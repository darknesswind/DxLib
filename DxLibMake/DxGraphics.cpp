// ----------------------------------------------------------------------------
// 
// 		ＤＸLibrary		绘制Program
// 
// 				Ver 3.11f
// 
// ----------------------------------------------------------------------------

// ＤＸLibrary 生成时使用的定义
#define __DX_MAKE

// インクルード----------------------------------------------------------------
#include "DxGraphics.h"
#include "DxLib.h"
#include "DxStatic.h"
#include "DxFile.h"
#include "DxSound.h"
#include "DxGraphicsBase.h"
#include "DxGraphicsAPI.h"
#include "DxMask.h"
#include "DxMemImg.h"
#include "DxMath.h"
#include "DxFont.h"
#include "DxLog.h"
#include "DxASyncLoad.h"
#include "DxPixelShader.h"
#include "DxVertexShader.h"
#include "DxUseCLib.h"

#include "DxModel.h"

#include "DxBaseImage.h"
#include "DxMovie.h"
#include "DxInput.h"
#include "DxBaseFunc.h"
#include "DxSystem.h"
#include "DxMemory.h"

#ifdef __WINDOWS__
#include "Windows/DxWindow.h"
#endif // __WINDOWS__


namespace DxLib
{

// 宏定义 -----------------------------------------------------------------

// シャドウマップの初期深度補正値
#define DEFAULT_SHADOWMAP_ADJUST_DEPTH		( 0.002f )
#define DEFAULT_SHADOWMAP_GRADATION_RANGE	( 0.0007f )
#define DEFAULT_SHADOWMAP_BLUR_PARAM		( 0 )

// RGB値を輝度最大のRGB値に変換するためのボリュームテクスチャのサイズ
#define RGBTOVMAXRGB_TEX_SIZE	(128)

// テクスチャピクセルフォーマットのビットデプスインデックス定義
#define TEX_BITDEPTH_16				(0)
#define TEX_BITDEPTH_32 			(1)
#define PIXELBYTE( x )				( x == TEX_BITDEPTH_16 ? 2 : 4 )

// パレットがある画像の有効性チェック
#define PALETTEIMAGECHK( HAND, MEMIMG )														\
{																							\
	IMAGEDATA2 *Image2 ;																	\
																							\
	if( GRAPHCHK( ( HAND ), Image2 ) )														\
		return -1 ;																			\
	if( Image2->Orig->FormatDesc.TextureFlag ) return -1 ;									\
	MEMIMG = &Image2->Soft.MemImg;															\
	if( MEMIMG->Base->UsePalette == 0 ) return -1;											\
}


// グラフィックハンドルの有効性チェック
#define GRAPHCHKFULL( HAND, GPOINT )			HANDLECHKFULL(       DX_HANDLETYPE_GRAPH, HAND, *( ( HANDLEINFO ** )&GPOINT ) )
#define GRAPHCHKFULL_ASYNC( HAND, GPOINT )		HANDLECHKFULL_ASYNC( DX_HANDLETYPE_GRAPH, HAND, *( ( HANDLEINFO ** )&GPOINT ) )
#define GRAPHCHK( HAND, GPOINT )				HANDLECHK(           DX_HANDLETYPE_GRAPH, HAND, *( ( HANDLEINFO ** )&GPOINT ) )
#define GRAPHCHK_ASYNC( HAND, GPOINT )			HANDLECHK_ASYNC(     DX_HANDLETYPE_GRAPH, HAND, *( ( HANDLEINFO ** )&GPOINT ) )

// シャドウマップハンドルの有効性チェック
#define SHADOWMAPCHK( HAND, SPOINT )			HANDLECHK(       DX_HANDLETYPE_SHADOWMAP, HAND, *( ( HANDLEINFO ** )&SPOINT ) )
#define SHADOWMAPCHK_ASYNC( HAND, SPOINT )		HANDLECHK_ASYNC( DX_HANDLETYPE_SHADOWMAP, HAND, *( ( HANDLEINFO ** )&SPOINT ) )

// シェーダーハンドルの有効性チェック
#define SHADERCHK( HAND, SPOINT )				HANDLECHK(       DX_HANDLETYPE_SHADER, HAND, *( ( HANDLEINFO ** )&SPOINT ) )
#define SHADERCHK_ASYNC( HAND, SPOINT )			HANDLECHK_ASYNC( DX_HANDLETYPE_SHADER, HAND, *( ( HANDLEINFO ** )&SPOINT ) )

// 頂点バッファハンドルの有効性チェック
#define VERTEXBUFFERCHK( HAND, SPOINT )			HANDLECHK(       DX_HANDLETYPE_VERTEX_BUFFER, HAND, *( ( HANDLEINFO ** )&SPOINT ) )
#define VERTEXBUFFERCHK_ASYNC( HAND, SPOINT )	HANDLECHK_ASYNC( DX_HANDLETYPE_VERTEX_BUFFER, HAND, *( ( HANDLEINFO ** )&SPOINT ) )

// インデックスバッファハンドルの有効性チェック
#define INDEXBUFFERCHK( HAND, SPOINT )			HANDLECHK(       DX_HANDLETYPE_INDEX_BUFFER, HAND, *( ( HANDLEINFO ** )&SPOINT ) )
#define INDEXBUFFERCHK_ASYNC( HAND, SPOINT )	HANDLECHK_ASYNC( DX_HANDLETYPE_INDEX_BUFFER, HAND, *( ( HANDLEINFO ** )&SPOINT ) )

// DrawPreparation を呼ぶ定型文
#define DRAWPREP_TEX( ORIG, TEX, FLAG )											\
	if( (ORIG)->FormatDesc.AlphaChFlag   ) FLAG |= DRAWPREP_TEXALPHACH ;		\
	if( (ORIG)->FormatDesc.AlphaTestFlag ) FLAG |= DRAWPREP_TEXALPHATEST ;		\
	if( GRH.DrawPrepAlwaysFlag != FALSE ||										\
		GRH.DrawPrepTexture    != (TEX) ||										\
		GRH.DrawPrepParamFlag  != FLAG )										\
		DrawPreparation( (TEX), FLAG ) ;										\
	if( GRH.UseAlphaChDrawShader )												\
	{																			\
		AlphaChDraw_Pre( &GRH.DrawRect ) ;										\
	}

#define DRAWPREP_NOTEX( FLAG )													\
	if( GRH.DrawPrepAlwaysFlag != FALSE ||										\
		GRH.DrawPrepTexture    != NULL ||										\
		GRH.DrawPrepParamFlag  != FLAG )										\
		DrawPreparation( NULL, FLAG ) ;											\
	if( GRH.UseAlphaChDrawShader )												\
	{																			\
		AlphaChDraw_Pre( &GRH.DrawRect ) ;										\
	}

// FVFの変更
#define SETFVF( type )	\
	if( GRH.SetFVF != ( type ) )\
	{\
		GraphicsDevice_SetFVF( ( type ) ) ;\
		GRH.SetFVF = ( type ) ;\
		GRH.SetVD = NULL;\
	}

// プリミティブの数を算出
#define GETPRIMNUM( primtype, vertnum )	\
	( ( (primtype) == D_D3DPT_TRIANGLELIST  ) ? (vertnum) / 3 :\
    ( ( (primtype) == D_D3DPT_LINELIST      ) ? (vertnum) / 2 :\
	( ( (primtype) == D_D3DPT_TRIANGLEFAN   ) ? (vertnum) - 2 :\
	( ( (primtype) == D_D3DPT_TRIANGLESTRIP ) ? (vertnum) - 2 :\
	( ( (primtype) == D_D3DPT_LINESTRIP     ) ? (vertnum) - 1 :\
	( ( (primtype) == D_D3DPT_POINTLIST     ) ? (vertnum)     : 0 ) ) ) ) ) )

#define RENDERVERTEX( NextUse3DVertex )	\
	{\
/*		if( GRH.Vertex3DNum != 0 )\
		{\
			SETFVF( VERTEXFVF_3D )\
			SetTransformToWorldHardware( &GlobalIdentMatrix ) ;\
			GraphicsDevice_DrawPrimitiveUP(\
				D_D3DPT_TRIANGLELIST,\
				GRH.Vertex3DNum / 3,\
				GRH.Tex3DVertexBuffer,\
				sizeof( VERTEX_3D ) ) ;\
			SetTransformToWorldHardware( &GBASE.WorldMatrix ) ;\
			GRH.Vertex3DNum = 0 ;\
			GRH.Vertex3DBufferNextAddress = GRH.Tex3DVertexBuffer ;\
		}*/\
\
		if( GRH.VertexNum != 0 )\
		{\
			SETFVF( D3DDev_VertexType[ GRH.Use3DVertex ][ GRH.VertexType ] )\
			if( GRH.Use3DVertex )\
			{\
				SetTransformToWorldHardware( &GlobalIdentMatrix ) ;\
			}\
			GraphicsDevice_DrawPrimitiveUP(\
				GRH.PrimitiveType,\
				GETPRIMNUM( GRH.PrimitiveType, GRH.VertexNum ),\
				GRH.VertexBufferPoint[ GRH.Use3DVertex ][ GRH.VertexType ],\
				D3DDev_VertexSize[ GRH.Use3DVertex ][ GRH.VertexType ] ) ;\
			if( GRH.Use3DVertex )\
			{\
				SetTransformToWorldHardware( &GBASE.WorldMatrix ) ;\
			}\
		}\
		GRH.VertexNum = 0 ;\
		GRH.VertexBufferNextAddress = GRH.VertexBufferPoint[ NextUse3DVertex ][ GRH.VertexType ] ;\
	}

#define GETVERTEX_QUAD( p )		\
	if(\
		  GRH.Use3DVertex != 0 ||\
		  GRH.PrimitiveType != D_D3DPT_TRIANGLELIST ||\
		  GRH.VertexNum + 6 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 0 )\
		GRH.Use3DVertex = 0 ;\
		GRH.PrimitiveType = D_D3DPT_TRIANGLELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define GETVERTEX_BILLBOARD( p )		\
	if(\
		  GRH.Use3DVertex != 1 ||\
		  GRH.PrimitiveType != D_D3DPT_TRIANGLELIST ||\
		  GRH.VertexNum + 6 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 1 )\
		GRH.Use3DVertex = 1 ;\
		GRH.PrimitiveType = D_D3DPT_TRIANGLELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define GETVERTEX_TRIANGLE( p )		\
	if(\
		  GRH.Use3DVertex != 0 ||\
		  GRH.PrimitiveType != D_D3DPT_TRIANGLELIST ||\
		  GRH.VertexNum + 3 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 0 )\
		GRH.Use3DVertex = 0 ;\
		GRH.PrimitiveType = D_D3DPT_TRIANGLELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define GETVERTEX_TRIANGLE3D( p )		\
	if(\
		  GRH.Use3DVertex != 1 ||\
		  GRH.PrimitiveType != D_D3DPT_TRIANGLELIST ||\
		  GRH.VertexNum + 3 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 1 )\
		GRH.Use3DVertex = 1 ;\
		GRH.PrimitiveType = D_D3DPT_TRIANGLELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define GETVERTEX_LINEBOX( p )		\
	if(\
		  GRH.Use3DVertex != 0 ||\
		  GRH.PrimitiveType != D_D3DPT_TRIANGLELIST ||\
		  GRH.VertexNum + 24 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 0 )\
		GRH.Use3DVertex = 0 ;\
		GRH.PrimitiveType = D_D3DPT_TRIANGLELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define GETVERTEX_LINETRIANGLE( p )		\
	if(\
		  GRH.Use3DVertex != 0 ||\
		  GRH.PrimitiveType != D_D3DPT_LINELIST ||\
		  GRH.VertexNum + 6 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 0 )\
		GRH.Use3DVertex = 0 ;\
		GRH.PrimitiveType = D_D3DPT_LINELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define GETVERTEX_LINETRIANGLE3D( p )		\
	if(\
		  GRH.Use3DVertex != 1 ||\
		  GRH.PrimitiveType != D_D3DPT_LINELIST ||\
		  GRH.VertexNum + 6 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 1 )\
		GRH.Use3DVertex = 1 ;\
		GRH.PrimitiveType = D_D3DPT_LINELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define GETVERTEX_LINE( p )		\
	if(\
		  GRH.Use3DVertex == 1 ||\
		  GRH.PrimitiveType != D_D3DPT_LINELIST ||\
		  GRH.VertexNum + 2 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 0 )\
		GRH.Use3DVertex = 0 ;\
		GRH.PrimitiveType = D_D3DPT_LINELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;


#define GETVERTEX_LINE3D( p )		\
	if(\
		  GRH.Use3DVertex != 1 ||\
		  GRH.PrimitiveType != D_D3DPT_LINELIST ||\
		  GRH.VertexNum + 2 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 1 )\
		GRH.Use3DVertex = 1 ;\
		GRH.PrimitiveType = D_D3DPT_LINELIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;


#define GETVERTEX_POINT( p )		\
	if(\
		  GRH.Use3DVertex != 0 ||\
		  GRH.PrimitiveType != D_D3DPT_POINTLIST ||\
		  GRH.VertexNum + 1 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 0 )\
		GRH.Use3DVertex = 0 ;\
		GRH.PrimitiveType = D_D3DPT_POINTLIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define GETVERTEX_POINT3D( p )		\
	if(\
		  GRH.Use3DVertex != 1 ||\
		  GRH.PrimitiveType != D_D3DPT_POINTLIST ||\
		  GRH.VertexNum + 1 >= D3DDev_VertexBuffer_MaxVertexNum[ GRH.Use3DVertex ][ GRH.VertexType ] /* ←本来は > だけど、GeForce 9800 GT の不具合対応のため >= にした */\
	  )\
	{\
		RENDERVERTEX( 1 )\
		GRH.Use3DVertex = 1 ;\
		GRH.PrimitiveType = D_D3DPT_POINTLIST ;\
	}\
	*((DWORD_PTR *)&p) = (DWORD_PTR)GRH.VertexBufferNextAddress ;

#define ADD4VERTEX_POINT		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_2D ) ;	\
		GRH.VertexNum ++ ;

#define ADD4VERTEX_POINT3D		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_3D ) ;	\
		GRH.VertexNum ++ ;
/*
#define ADD4VERTEX_LINEBOX			\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_2D ) * 8 ;	\
		GRH.VertexNum += 8 ;
*/
#define ADD4VERTEX_LINEBOX			\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_2D ) * 24 ;	\
		GRH.VertexNum += 24 ;

#define ADD4VERTEX_LINETRIANGLE		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_2D ) * 6 ;	\
		GRH.VertexNum += 6 ;

#define ADD4VERTEX_LINETRIANGLE3D		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_3D ) * 6 ;	\
		GRH.VertexNum += 6 ;

#define ADD4VERTEX_LINE			\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_2D ) * 2 ;	\
		GRH.VertexNum += 2 ;

#define ADD4VERTEX_LINE3D		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_3D ) * 2 ;	\
		GRH.VertexNum += 2 ;

#define ADD4VERTEX_NOTEX		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_2D ) * 6 ;	\
		GRH.VertexNum += 6 ;

#define ADD4VERTEX_TEX			\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_2D ) * 6 ;	\
		GRH.VertexNum += 6 ;

#define ADD4VERTEX_BLENDTEX		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_BLENDTEX_2D ) * 6 ;	\
		GRH.VertexNum += 6 ;

#define ADD3VERTEX_NOTEX		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_2D ) * 3 ;	\
		GRH.VertexNum += 3 ;

#define ADD3VERTEX_NOTEX3D		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_NOTEX_3D ) * 3 ;	\
		GRH.VertexNum += 3 ;

#define ADD4VERTEX_BILLBOARD		\
		GRH.VertexBufferNextAddress += sizeof( VERTEX_3D ) * 6 ;	\
		GRH.VertexNum += 6 ;

// テクスチャーの分割有効時の最大サイズと最小サイズ
#define MAX_TEXTURE_SIZE			(2048)
#define MIN_TEXTURE_SIZE			(1)

// テクスチャー分割を行う最小サイズ
#define DIVTEXTURE_MINSIZE			(32)

// デバイスからの最大・最小のテクスチャサイズを取得
// できなかった時に設定するサイズ
#define DEFAULT_MAXTEXTURE_SIZE		(256)
#define DEFAULT_MINTEXTURE_SIZE		(8)

// 非管理テクスチャへのデータ転送用システムメモリ配置テクスチャの同じフォーマットの最大数
#define SYSMEMTEXTURE_ONE_FORMAT_NUM	(16)

// 非管理テクスチャへのデータ転送用システムメモリ配置サーフェスの同じフォーマットの最大数
#define SYSMEMSURFACE_ONE_FORMAT_NUM	(16)

// 頂点バッファに格納できる頂点の最大数のテーブル[ 0:２Ｄ頂点  1:３Ｄ頂点 ]
static const int D3DDev_VertexBuffer_MaxVertexNum[ 2 ][ VERTEXTYPE_NUM ] =
{
	D3DDEV_NOTEX_VERTMAXNUM,
	D3DDEV_TEX_VERTMAXNUM, 
	D3DDEV_BLENDTEX_VERTMAXNUM,

	D3DDEV_NOTEX_3D_VERTMAXNUM,
	D3DDEV_TEX_3D_VERTMAXNUM, 
} ;

// 頂点構造の定義のテーブル[ 0:２Ｄ頂点  1:３Ｄ頂点 ]
static const DWORD D3DDev_VertexType[ 2 ][ VERTEXTYPE_NUM ] =
{
	VERTEXFVF_NOTEX_2D,
	VERTEXFVF_2D,
	VERTEXFVF_BLENDTEX_2D,

	VERTEXFVF_NOTEX_3D,
	VERTEXFVF_3D
} ;

// 頂点のサイズのテーブル[ 0:２Ｄ頂点  1:３Ｄ頂点 ]
static const int D3DDev_VertexSize[ 2 ][ VERTEXTYPE_NUM ] =
{
	sizeof( VERTEX_NOTEX_2D ),
	sizeof( VERTEX_2D ),
	sizeof( VERTEX_BLENDTEX_2D ),

	sizeof( VERTEX_NOTEX_3D ),
	sizeof( VERTEX_3D ),
} ;

static MATRIX GlobalIdentMatrix =
{
	1.0f, 0.0f, 0.0f, 0.0f,
	0.0f, 1.0f, 0.0f, 0.0f,
	0.0f, 0.0f, 1.0f, 0.0f,
	0.0f, 0.0f, 0.0f, 1.0f
} ;

// 8x8 の tgaテクスチャ
static BYTE WhiteTga8x8TextureFileImage[ 84 ] = 
{
	0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00,
	0x20, 0x08, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF,
	0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF,
	0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0x87, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x54, 0x52, 0x55, 0x45, 0x56, 0x49, 0x53, 0x49, 0x4F, 0x4E, 0x2D, 0x58, 0x46, 0x49,
	0x4C, 0x45, 0x2E, 0x00
} ;

// シェーダーバイナリ配列
extern BYTE DxShaderCodeBin_Model[] ;
extern BYTE DxShaderCodeBin_Filter[] ;
extern BYTE DxShaderCodeBin_Base[] ;
extern BYTE DxShaderCodeBin_RgbaMix[] ;

// 结构体声明 -----------------------------------------------------------------

// ライブラリが事前に用意するシェーダーコード関数用のライブラリの設定情報を一時的に退避するために使う構造体
struct LIBSHADER_DRAWPARAMTEMP
{
	DX_DIRECT3DSURFACE9 *TargetSurface[ DX_RENDERTARGET_COUNT ] ;
	DX_DIRECT3DSURFACE9 *DepthStencilSurfaece ;
	int BlendMode, BlendParam ;
	int AlphaTestMode, AlphaTestParam ;
	int UseZBufferFlag3D ;
	int DrawMode ;
	int FogEnable ;
	int LightEnable ;

	int UserSetVertexShaderHandle ;
	int UserSetPixelShaderHandle ;
	int UserSetTextureGraphHandle[ 8 ] ;
	int TextureNum ;
} ;

// 数据定义 -----------------------------------------------------------------

GRAPHICSMANAGE2 GraphicsManage2 ;

// 函数声明 -------------------------------------------------------------------

extern int CreateSubBackBufferSurface() ;										// ScreenCopy や GetDrawScreen を実現するために使用するテンポラリバッファの作成( 0:成功  -1:失敗 )

static int ShaderCodeSetup() ;													// シェーダーコードのセットアップを行う
static int ShaderCodeTerminate() ;												// シェーダーコードの後始末を行う
static int MemLoadShaderCode( const char *ShaderName, bool IsVertexShader ) ;	// 指定名の事前用意シェーダーを読み込む

static int DeleteDeviceLostDeleteGraph( void ) ;								// デバイスロスト発生時に削除するフラグが立っているグラフィックを削除する
static int SetupSubBackBuffer() ;												// サブバックバッファを使用する準備を行う( 0:成功  -1:失敗 )
static int ListUpTexSize( int Size, short *SizeList, int NotDivFlag, int Pow2Flag, int MaxTextureSize ) ;		// 指定のテクスチャーサイズを上手く分割する
static int InitializeDerivationGraphHandle( int GrHandle, int SrcX, int SrcY, int Width, int Height, int SrcGrHandle, int ASyncThread = FALSE ) ;			// 指定部分だけを抜き出したグラフィックハンドルを初期化する
static int InitializeGraphDrawInfo( int GrHandle, int ASyncThread = FALSE ) ;			// グラフィックハンドルの描画情報を初期化する
static int CreateOrigTexture( IMAGEDATA2_ORIG *Orig, int ASyncThread = FALSE ) ;		// オリジナル画像情報中のテクスチャを作成する( 0:成功  -1:失敗 )
static int ReleaseOrigTexture( IMAGEDATA2_ORIG *Orig ) ;						// オリジナル画像情報中のテクスチャを解放する
static int CreateOrigZBuffer( IMAGEDATA2_ORIG *Orig ) ;							// オリジナル画像情報中のＺバッファを作成する
static int ReleaseOrigZBuffer( IMAGEDATA2_ORIG *Orig ) ;						// オリジナル画像情報中のＺバッファを開放する
static int CreateDirect3DVertexBufferObject( VERTEXBUFFERHANDLEDATA *VertexBuffer ) ;	// 頂点バッファハンドル用の Direct3DVertexBuffer9 オブジェクトを作成する
static int ReleaseDirect3DVertexBufferObject( VERTEXBUFFERHANDLEDATA *VertexBuffer ) ;	// 頂点バッファハンドル用の Direct3DVertexBuffer9 オブジェクトを解放する
static int CreateDirect3DIndexBufferObject( INDEXBUFFERHANDLEDATA *IndexBuffer ) ;		// インデックスバッファハンドル用の Direct3DIndexBuffer9 オブジェクトを作成する
static int ReleaseDirect3DIndexBufferObject( INDEXBUFFERHANDLEDATA *IndexBuffer ) ;		// インデックスバッファハンドル用の Direct3DIndexBuffer9 オブジェクトを解放する
static int ReleaseOrigDirectXObjectAll() ;										// グラフィックハンドルが持つすべての DirectX オブジェクトを解放する
static int AllocOrigDirectXObjectAll() ;										// グラフィックハンドルが持つすべての DirectX オブジェクトを取得する
static  D_D3DVERTEXELEMENT9	MakeVertexElement9( BYTE Stream, BYTE Offset, BYTE Type, BYTE Method, BYTE Usage, BYTE UsageIndex ) ;
static int CheckMultiSampleParam( D_D3DFORMAT Format, D_D3DMULTISAMPLE_TYPE *Samples, DWORD *Quality, int SamplesFailedBreak, int ASyncThread = FALSE ) ;	// マルチサンプルレンダリングのサンプル数とクオリティをチェック
static int GetSysMemTexture( int CubeMap, int Width, int Height, int MipMapCount, D_D3DFORMAT Format, int ASyncThread ) ;			// 管理テクスチャへの転送用のシステムメモリテクスチャを取得する
static int GetSysMemSurface( int Width, int Height, D_D3DFORMAT Format, int ASyncThread ) ;												// 管理テクスチャへの転送用のシステムメモリサーフェスを取得する
static int GetSysMemTextureFromOrig( IMAGEDATA2_ORIG *Orig, IMAGEDATA2_ORIG_HARD_TEX *OrigTex, int ASyncThread = FALSE ) ;				// IMAGEDATA2_ORIG と IMAGEDATA2_ORIG_HARD_TEX の情報を元に GetSysMemTexture を使用する
static int CreateSysMemTextureDirect3D9Texture( IMAGEDATA2_SYSMEMTEXTURE *MemTex ) ;					// 構造体のデータを元に転送用のシステムメモリテクスチャを作成する
static int CreateSysMemSurfaceDirect3D9Surface( IMAGEDATA2_SYSMEMSURFACE *MemSurface ) ;				// 構造体のデータを元に転送用のシステムメモリサーフェスを作成する
static int ReleaseSysMemTexture( int Index, int ASyncThread = FALSE ) ;					// 管理テクスチャへの転送用のシステムメモリテクスチャを解放する
static int ReleaseSysMemSurface( int Index, int ASyncThread = FALSE ) ;					// 管理テクスチャへの転送用のシステムメモリサーフェスを解放する
static int ReleaseSysMemTextureAll( int IsNotUseOnly = FALSE ) ;						// 管理テクスチャへの転送用のシステムメモリテクスチャをすべて解放する
static int ReleaseSysMemSurfaceAll( int IsNotUseOnly = FALSE ) ;						// 管理テクスチャへの転送用のシステムメモリサーフェスをすべて解放する
static int UpdateDrawTexture( IMAGEDATA2_ORIG_HARD_TEX *OrigTex, int TargetSurface ) ;	// 描画先用テクスチャと描画用テクスチャが分かれている場合に、描画用テクスチャに描画先用テクスチャの内容を反映する
static int CheckMultiSampleDrawValidGraph( int GrHandle ) ;								// ＭＳＡＡを使用する描画可能画像かどうかを調べる( TRUE:MSAA画像  FALSE:MSAA画像ではない )
static int SetupFormatDesc( IMAGEFORMATDESC *Format, SETUP_GRAPHHANDLE_GPARAM *GParam, int Width, int Height, int AlphaValidFlag, int UsePaletteFlag, int BaseFormat, int MipMapCount ) ; // グラフィックハンドルに画像データを転送するための関数
static int RefreshAlphaChDrawMode( void ) ;												// 描画先に正しいα値を書き込むかどうかのフラグを更新する
static int RefreshShadowMapMatrix( SHADOWMAPDATA *ShadowMap ) ;							// シャドウマップへのレンダリングで使用する行列の情報を更新する

static int BltBmpOrBaseImageToGraph3(
	const COLORDATA	*BmpColorData,
	      HBITMAP	RgbBmp,
	      HBITMAP	AlphaBmp,
	const RECT		*SrcRect,
	      int		DestX,
	      int		DestY,
	      int		GrHandle,
	      int		BmpFlag,
	const BASEIMAGE	*RgbImage,
	const BASEIMAGE	*AlphaImage,
	      int		RedIsAlphaFlag = FALSE,
	      int		UseTransColorConvAlpha = TRUE,
	      int		TargetOrig = FALSE,
	      int		ASyncThread = FALSE
) ;
static int BltBmpOrBaseImageToGraph3_MipMapBlt(
	IMAGEDATA2_ORIG			*Orig,
	const RECT				*SrcRect,
	const RECT				*DestRect,
	int						UseSysMemSurface,
	DX_DIRECT3DBASETEXTURE9	*UseTex,
	int						TexWidth,
	int						TexHeight,
	const BASEIMAGE			*RgbImage,
	const BASEIMAGE			*AlphaImage,
	const COLORDATA			*DestColor,
	int						RedIsAlphaFlag,
	int						UseTransColorConvAlpha,
	int						ASyncThread = FALSE
) ;
static int BltBmpOrBaseImageToGraph3_NoMipMapBlt(
	IMAGEDATA2_ORIG			*Orig,
	const RECT				*SrcRect,
	const RECT				*DestRect,
	int						UseSysMemSurface,
	DX_DIRECT3DBASETEXTURE9	*UseTex,
	int						TexWidth,
	int						TexHeight,
	int						TexUseWidth,
	int						TexUseHeight,
	const BASEIMAGE			*RgbImage,
	const BASEIMAGE			*AlphaImage,
	const COLORDATA			*DestColor,
	int						RedIsAlphaFlag,
	int						UseTransColorConvAlpha,
	int						ASyncThread = FALSE
) ;

#ifndef DX_NON_MOVIE

static void UpdateGraphMovie( MOVIEGRAPH *Movie, DWORD_PTR GrHandle ) ;				// ムービー画像を更新する

#endif


// 描画可能画像やバックバッファから指定領域のグラフィックを取得する
extern	int GetDrawScreenGraphBase( int TargetScreen, int TargetScreenSurface, int x1, int y1, int x2, int y2, int destX, int destY, int GrHandle ) ;

// ソフトウエアレンダリング制御系関数
static int	InitializeSoftware() ;							// ソフトウエアレンダリングの初期化を行う
static int	TerminateSoftware() ;							// ソフトウエアレンダリングの後始末を行う

// ハードウエアアクセラレータ制御系関数
			static int  InitializeHardware() ;														// ハードウエアアクセラレータ関係の初期化
			static int	ReInitializeHardware() ;													// 一時的にハードウエアを破棄した際に、破棄前の状態を作り出すための関数
			static int  SetBaseHardwareState() ;													// Ｄｉｒｅｃｔ３ＤＤｅｖｉｃｅ基本設定
			static int  RefreshBlendStateHardware( DIRECT3DBLENDINFO *pUserInfo = NULL, int TextureStageIsTextureAndTextureCoordOnlyFlag = FALSE, int TextureIsGraphHandleFlag = TRUE ) ;	// ブレンド設定を更新(Direct3D に反映)する
			static int  SetDrawModeHardware( int DrawMode ) ;										// 描画モードのセット
			static int  SetMaxAnisotropyHardware( int MaxAnisotropy ) ;								// 最大異方性のセット
			static int  SetDrawBlendModeHardware( int BlendMode, int AlphaTestValidFlag, int AlphaChannelValidFlag ) ;	// 描画ブレンドモードの設定
			static int	SetIgnoreDrawGraphColorHardware( int EnableFlag ) ;							// 描画時の画像の色を無視するかどうかを設定する
			static int  SetDrawAlphaTestHardware( int TestMode, int TestParam ) ;					// アルファテストの設定
//			static int  SetRenderTargetHardware( DX_DIRECT3DSURFACE9 * TargetSurface, int TargetIndex = 0 ) ;	// 描画対象の変更
			static int  SetUseZBufferHardware( int Flag ) ;											// Ｚバッファの有効無効のセット
			static int  SetWriteZBufferHardware( int Flag ) ;										// Ｚバッファの書き込みの有無をセット
			static int  SetZBufferCmpTypeHardware( int CmpType ) ;									// Ｚ値の比較タイプをセット
			static int  SetZBiasHardware( int Bias ) ;												// Ｚバイアスをセット
			static int	SetFillModeHardware( int FillMode ) ;										// フィルモードをセット
__inline	static int  SetTextureHardware( DX_DIRECT3DTEXTURE9 *RenderTexture ) ;					// テクスチャをセットする 
__inline	static int  SetBlendTextureHardware( DX_DIRECT3DTEXTURE9 *BlendTexture, int TexWidth = -1, int TexHeight = -1 ) ;	// ブレンドするテクスチャをセットする 
__inline	static int  SetBlendTextureParamHardware( int BlendType, int *Param ) ;					// ブレンドするテクスチャのパラメータをセットする
			static int  SetUseDiffuseAlphaColorFlagHardware( int UseFlag ) ;						// ディフューズカラーのα値を使用するかどうかフラグをセットする
			static int  SetUseDiffuseRGBColorFlagHardware( int UseFlag ) ;							// ディフューズカラーのＲＧＢ値を使用するかどうかフラグをセットする
			static void RefreshRenderStateHardware() ;												// 描画設定をリフレッシュ
			static int  SetTransformToWorldHardware( const MATRIX *Matrix ) ;						// ワールド変換用行列をセットする
			static int  SetTransformToViewHardware( const MATRIX *Matrix ) ;						// ビュー変換用行列をセットする
			static int  SetTransformToProjectionHardware( const MATRIX *Matrix ) ;					// 投影変換用行列をセットする
			static int  SetLightHardware( int LightNumber, LIGHT *Light ) ;							// ライトのセット
			static int  SetLightEnableHardware( int LightNumber, int EnableState ) ;				// ライトの有効、無効を変更
			static int  SetMaterialHardware( MATERIAL *Material ) ;									// マテリアルのセット
			static int	SetUseSpecularHardware( int UseFlag ) ;										// スペキュラを使用するかどうかをセット
			static int	SetMaterialUseVertexDiffuseColorHardware( int UseFlag ) ;					// 頂点のディフューズカラーをマテリアルのディフューズカラーとして使用するかどうかを設定する
			static int	SetMaterialUseVertexSpecularColorHardware( int UseFlag ) ;					// 頂点のスペキュラカラーをマテリアルのスペキュラカラーとして使用するかどうかを設定する
			static int  SetUseCullingHardware( int State ) ;										// カリングの有無をセット 
			static int  SetAmbientColorHardware( int Color ) ;										// アンビエントカラーのセット
			static int  SetShadeModeHardware( int ShadeMode ) ;										// シェーディングモードのセット
			static int  SetTextureAddressHardware( int AddressMode, int Stage = -1 ) ;				// テクスチャーのアドレッシングモードをセットする
			static int  SetTextureAddressUHardware( int AddressMode, int Stage = -1 ) ;				// テクスチャーのアドレッシングモードをセットする
			static int  SetTextureAddressVHardware( int AddressMode, int Stage = -1 ) ;				// テクスチャーのアドレッシングモードをセットする
			static int  SetTextureAddressWHardware( int AddressMode, int Stage = -1 ) ;				// テクスチャーのアドレッシングモードをセットする
			static int	SetTextureAddressTransformMatrixHardware( int Use, MATRIX *Matrix, int Stage = -1 ) ;	// テクスチャ座標変換行列をセットする
			static int	SetFogEnableHardware( int Flag ) ;											// フォグを有効にするかどうかを設定する( TRUE:有効  FALSE:無効 )
			static int	SetFogModeHardware( int Mode /* DX_FOGMODE_NONE 等 */ ) ;					// フォグモードを設定する
			static int	SetFogColorHardware( DWORD Color ) ;										// フォグカラーを変更する
			static int	SetFogStartEndHardware( float Start, float End ) ;							// フォグが始まる距離と終了する距離を設定する( 0.0f ～ 1.0f )
			static int	SetFogDensityHardware( float Density ) ;									// フォグの密度を設定する( 0.0f ～ 1.0f )
			static int  SetUseLightFlagHardware( int LightFlag ) ;									// ライトの有無フラグをセットする
			static int  SetPlaneVertexHardware( VERTEX_2D *GraphVert, int xnum, int ynum ) ;		// ２次元配列的に配置された頂点データを頂点バッファに追加する
			static int  SetViewportHardware( D_D3DVIEWPORT9 *Viewport ) ;							// ビューポートをセットする
			extern int	SetViewportHardwareEasy( int x1, int y1, int x2, int y2 ) ;					// ビューポートをセットする( 簡易版 )
			static int	SetScissorRectHardware( RECT *Rect ) ;										// シザー矩形を設定する
			static int	SetScissorTestEnableHardware( int Enable ) ;								// シザー矩形を有効にするかどうかを設定
			static int	SetEdgeFontDrawFlagHardware( int EdgeFontFlag ) ;							// 縁付きフォント描画を行うかどうかを設定
            //extern int	RenderVertexHardware() ;													// 頂点バッファに溜まった頂点データをレンダリングする
			static void FASTCALL DrawPreparation( DX_DIRECT3DTEXTURE9 *Texture = NULL, int ParamFlag = 0 ) ;	// 描画準備を行う
			static void RefreshAmbientAndEmissiveParam() ;											// アンビエントライトとエミッシブカラーを掛け合わせたパラメータを更新する
			static void RefreshUseShaderIndex() ;													// 使用するシェーダーのインデックスの値を更新する

__inline	static DWORD GetDiffuseColor( void )															// 現在のディフューズカラーを得る
			{
				return  ( GBASE.DrawBright.Red   << 16 ) |
						( GBASE.DrawBright.Green << 8  ) |
						( GBASE.DrawBright.Blue        ) |
						( ( ( GBASE.BlendMode != DX_BLENDMODE_NOBLEND || GBASE.UseNoBlendModeParam ) ? GBASE.BlendParam : 255 ) << 24 ) ;
			}
__inline static int CheckBlendGraphSize( IMAGEDATA2 *GraphData ) ;											// ブレンド画像との大きさチェック
__inline static void _VectorTransformToBillboard( VECTOR *Vector, VECTOR *Position ) ;						// ビルボード用の行列計算

static void DefaultRestoreGraphFunction( void ) ;		// デフォルトのグラフィック復旧関数

#ifndef DX_NON_FILTER

// 事前用意のシェーダー用
static void LibShader_PushBaseDrawParam( LIBSHADER_DRAWPARAMTEMP *DrawParamTemp ) ;
static void LibShader_PopBaseDrawParam( LIBSHADER_DRAWPARAMTEMP *DrawParamTemp ) ;
static void LibShader_PushShaderParam( LIBSHADER_DRAWPARAMTEMP *DrawParamTemp, int TextureNum ) ;
static void LibShader_PopShaderParam( LIBSHADER_DRAWPARAMTEMP *DrawParamTemp ) ;

struct GRAPHFILTER_INFO
{
	int IsBlend ;
	int FilterOrBlendType ;
	int SrcGrHandle ;
	int BlendGrHandle ;
	int DestGrHandle ;
	float BlendRatio ;
	int Pass ;
	int SrcX1 ;
	int SrcY1 ;
	int SrcX2 ;
	int SrcY2 ;
	int BlendX ;
	int BlendY ;
	int BlendPosEnable ;
	int DestX ;
	int DestY ;

	int DestWidth ;
	int DestHeight ;
	BASEIMAGE SrcImage ;
	BASEIMAGE BlendImage ;
	BASEIMAGE DestImage ;
} ;
static int	GraphFilterDestGraphSetup( GRAPHFILTER_INFO *Info, int PassNum, int UseWorkScreen, int *UseSrcGrHandle, int *UseDestGrHandle ) ;
static int	GraphFilterDestGraphUpdate( GRAPHFILTER_INFO *Info, int UseWorkScreen, int UseDestGrHandle, int FilterResult ) ;
static int	GraphFilter_BasePolygonDraw( GRAPHFILTER_INFO *Info, int ScaleDivNum = 1 ) ;
static int	GraphFilter_GetSoftImage( int GrHandle, BASEIMAGE *BaseImage, RECT *GetRect = NULL ) ;
static int	GraphFilter_SoftImageSetup( GRAPHFILTER_INFO *Info, int DestDiscard = TRUE, int DestWidth = -1, int DestHeight = -1 ) ;
static int	GraphFilter_SoftImageTerminate( GRAPHFILTER_INFO *Info ) ;

static int GraphFilterPassNum_Table[DX_GRAPH_FILTER_NUM] =
{
		1,		// DX_GRAPH_FILTER_MONO
		2,		// DX_GRAPH_FILTER_GAUSS
		1,		// DX_GRAPH_FILTER_DOWN_SCALE
		1,		// DX_GRAPH_FILTER_BRIGHT_CLIP
		2,		// DX_GRAPH_FILTER_HSB
		1,		// DX_GRAPH_FILTER_INVERT
		1,		// DX_GRAPH_FILTER_LEVEL
		1,		// DX_GRAPH_FILTER_TWO_COLOR
		1,		// DX_GRAPH_FILTER_GRADIENT_MAP
		1,		// DX_GRAPH_FILTER_PREMUL_ALPHA
		1,		// DX_GRAPH_FILTER_INTERP_ALPHA
};
static int GraphFilterUseWorkScreen_Table[DX_GRAPH_FILTER_NUM] =
{
		0,		// DX_GRAPH_FILTER_MONO
		1,		// DX_GRAPH_FILTER_GAUSS
		0,		// DX_GRAPH_FILTER_DOWN_SCALE
		0,		// DX_GRAPH_FILTER_BRIGHT_CLIP
		0,		// DX_GRAPH_FILTER_HSB
		0,		// DX_GRAPH_FILTER_INVERT
		0,		// DX_GRAPH_FILTER_LEVEL
		0,		// DX_GRAPH_FILTER_TWOCOLOR
		0,		// DX_GRAPH_FILTER_GRADIENT_MAP
		0,		// DX_GRAPH_FILTER_PREMUL_ALPHA
		0,		// DX_GRAPH_FILTER_INTERP_ALPHA
};
static int	GraphFilter_Mono(        GRAPHFILTER_INFO *Info, float Cb, float Cr ) ;
static int	GraphFilter_Gauss(       GRAPHFILTER_INFO *Info, int PixelWidth, float Param ) ;
static int	GraphFilter_Down_Scale(  GRAPHFILTER_INFO *Info, int DivNum ) ;
static int	GraphFilter_Bright_Clip( GRAPHFILTER_INFO *Info, int CmpType, float CmpParam, int ClipFillFlag, COLOR_F *ClipFillColor ) ;
static int	GraphFilter_HSB(         GRAPHFILTER_INFO *Info, int HueType, float Hue, float Saturation, float Bright ) ;
static int	GraphFilter_Invert(      GRAPHFILTER_INFO *Info ) ;
static int	GraphFilter_Level(       GRAPHFILTER_INFO *Info, float Min, float Max, float Gamma, float AfterMin, float AfterMax ) ;
static int	GraphFilter_TwoColor(    GRAPHFILTER_INFO *Info, float Threshold, COLOR_F *LowColor, COLOR_F *HighColor ) ;
static int	GraphFilter_GradientMap( GRAPHFILTER_INFO *Info, int MapGrHandle, int Reverse ) ;
static int	GraphFilter_PremulAlpha( GRAPHFILTER_INFO *Info ) ;
static int	GraphFilter_InterpAlpha( GRAPHFILTER_INFO *Info ) ;

static int GraphBlendPassNum_Table[DX_GRAPH_BLEND_NUM] =
{
		1,		// DX_GRAPH_BLEND_NORMAL
		1,		// DX_GRAPH_BLEND_RGBA_SELECT_MIX
		1,		// DX_GRAPH_BLEND_MULTIPLE
		1,		// DX_GRAPH_BLEND_DIFFERENCE
		1,		// DX_GRAPH_BLEND_ADD
		1,		// DX_GRAPH_BLEND_SCREEN
		1,		// DX_GRAPH_BLEND_OVERLAY
		1,		// DX_GRAPH_BLEND_DODGE
		1,		// DX_GRAPH_BLEND_BURN
		1,		// DX_GRAPH_BLEND_DARKEN
		1,		// DX_GRAPH_BLEND_LIGHTEN
		1,		// DX_GRAPH_BLEND_SOFTLIGHT
		1,		// DX_GRAPH_BLEND_HARDLIGHT
		1,		// DX_GRAPH_BLEND_EXCLUSION
		1,		// DX_GRAPH_BLEND_NORMAL_ALPHACH
		1,		// DX_GRAPH_BLEND_ADD_ALPHACH
		1,		// DX_GRAPH_BLEND_MULTIPLE_A_ONLY
};
static int GraphBlendUseWorkScreen_Table[DX_GRAPH_BLEND_NUM] =
{
		0,		// DX_GRAPH_BLEND_NORMAL
		0,		// DX_GRAPH_BLEND_RGBA_SELECT_MIX
		0,		// DX_GRAPH_BLEND_MULTIPLE
		0,		// DX_GRAPH_BLEND_DIFFERENCE
		0,		// DX_GRAPH_BLEND_ADD
		0,		// DX_GRAPH_BLEND_SCREEN
		0,		// DX_GRAPH_BLEND_OVERLAY
		0,		// DX_GRAPH_BLEND_DODGE
		0,		// DX_GRAPH_BLEND_BURN
		0,		// DX_GRAPH_BLEND_DARKEN
		0,		// DX_GRAPH_BLEND_LIGHTEN
		0,		// DX_GRAPH_BLEND_SOFTLIGHT
		0,		// DX_GRAPH_BLEND_HARDLIGHT
		0,		// DX_GRAPH_BLEND_EXCLUSION
		0,		// DX_GRAPH_BLEND_NORMAL_ALPHACH
		0,		// DX_GRAPH_BLEND_ADD_ALPHACH
		0,		// DX_GRAPH_BLEND_MULTIPLE_A_ONLY
};
static int	GraphBlend_Basic(           GRAPHFILTER_INFO *Info ) ;
static int	GraphBlend_RGBA_Select_Mix( GRAPHFILTER_INFO *Info, int SelectR, int SelectG, int SelectB, int SelectA ) ;

#endif // DX_NON_FILTER

static int	GetCircle_ThicknessDrawPosition( int x, int y, int r, int Thickness, short ( *CirclePos )[ 5 ] ) ;			// 線の幅付き円の描画用頂点を取得する関数
static int	GetOval_ThicknessDrawPosition( int x, int y, int rx, int ry, int Thickness, short ( *CirclePos )[ 5 ] ) ;	// 線の幅付き楕円の描画用頂点を取得する関数

// 分岐が必要な描画系関数
static int	DrawBillboard3DHardware( VECTOR Pos, float cx, float cy, float Size, float Angle, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int TurnFlag, int DrawFlag = TRUE, RECT *DrawArea = NULL ) ;	// ハードウエアアクセラレータ使用版 DrawBillboard3DHardware
static int	DrawModiBillboard3DHardware( VECTOR Pos, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int DrawFlag = TRUE, RECT *DrawArea = NULL ) ;	// ハードウエアアクセラレータ使用版 DrawModiBillboard3DHardware
static int  DrawGraphHardware( int x, int y, float xf, float yf, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int IntFlag ) ;							// ハードウエアアクセラレータ使用版 DrawGraph
static int  DrawExtendGraphHardware( int x1, int y1, int x2, int y2, float x1f, float y1f, float x2f, float y2f, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int IntFlag ) ;		// ハードウエアアクセラレータ使用版 DrawExtendGraph
static int  DrawRotaGraphHardware( int x, int y, float xf, float yf, double ExRate, double Angle, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int TurnFlag, int IntFlag ) ;	// ハードウエアアクセラレータ使用版 DrawRotaGraph
static int  DrawModiGraphBase( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int GrHandle, int TransFlag, bool SimpleDrawFlag ) ;
static int	DrawModiGraphFBase( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, int GrHandle, int TransFlag, bool SimpleDrawFlag ) ;
static int  DrawModiGraphHardware( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, bool SimpleDrawFlag ) ;	// ハードウエアアクセラレータ使用版 DrawModiGraph
static int  DrawModiGraphFHardware( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, bool SimpleDrawFlag ) ;	// ハードウエアアクセラレータ使用版 DrawModiGraphF
static void DrawModiTexHardware( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, IMAGEDATA2_HARD_DRAW *DrawTex, bool SimpleDrawFlag ) ;		// テクスチャを変形して描画する
static int  DrawFillBoxHardware( int x1, int y1, int x2, int y2, int Color ) ;																// ハードウエアアクセラレータ使用版 DrawFillBox
static int  DrawLineBoxHardware( int x1, int y1, int x2, int y2, int Color ) ;																// ハードウエアアクセラレータ使用版 DrawLineBox
static int	DrawChipMapHardware( int Sx, int Sy, int XNum, int YNum, const int *MapData, int MapDataPitch, int ChipTypeNum, const int *ChipGrHandle, int TransFlag ) ;	// ハードウエアアクセラレータ使用版 DrawChipMap
static int	DrawTileHardware( int x1, int y1, int x2, int y2, int Tx, int Ty, double ExtRate, double Angle, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag ) ;	// ハードウエアアクセラレータ使用版 DrawTile
static int	DrawPrimitiveHardware( const VERTEX_3D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawIndexedPrimitiveHardware( const VERTEX_3D *Vertex, int VertexNum, const WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawPrimitiveLightHardware( const VERTEX3D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawIndexedPrimitiveLightHardware( const VERTEX3D *Vertex, int VertexNum, const WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawPrimitiveLight_UseVertexBufferHardware( VERTEXBUFFERHANDLEDATA *VertexBuffer, int PrimitiveType, int StartVertex, int UseVertexNum, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawIndexedPrimitiveLight_UseVertexBufferHardware( VERTEXBUFFERHANDLEDATA *VertexBuffer, INDEXBUFFERHANDLEDATA *IndexBuffer, int PrimitiveType, int BaseVertex, int StartVertex, int UseVertexNum, int StartIndex, int UseIndexNum, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawPrimitive2DHardware( VERTEX_2D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag, int BillboardFlag, int Is3D, int TurnFlag, int TextureNo ) ;
static int	DrawIndexedPrimitive2DHardware( VERTEX_2D *Vertex, int VertexNum, WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawPrimitive2DUserHardware( const VERTEX2D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag, int Is3D, int TurnFlag, int TextureNo ) ;
static int	DrawPrimitive2DUserHardware_Billboard( VERTEX2D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag, int Is3D, int TurnFlag, int TextureNo ) ;
static int	DrawIndexedPrimitive2DUserHardware( const VERTEX2D *Vertex, int VertexNum, const WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawLineHardware( int x1, int y1, int x2, int y2, int Color ) ;																			// ハードウエアアクセラレータ使用版 DrawLine
static int	DrawLine3DHardware( VECTOR Pos1, VECTOR Pos2, int Color, int DrawFlag = TRUE, RECT *DrawArea = NULL ) ;									// ハードウエアアクセラレータ使用版 DrawLine3D
static int	DrawCircle_ThicknessHardware( int x, int y, int r, int Color, int Thickness ) ;															// ハードウエアアクセラレータ使用版 DrawCircle( 太さ指定あり )
static int	DrawOval_ThicknessHardware( int x, int y, int rx, int ry, int Color, int Thickness ) ;													// ハードウエアアクセラレータ使用版 DrawOval( 太さ指定あり )
static int	DrawCircleHardware( int x, int y, int r, int Color, int FillFlag ) ;																	// ハードウエアアクセラレータ使用版 DrawCircle
static int	DrawOvalHardware( int x, int y, int rx, int ry, int Color, int FillFlag ) ;																// ハードウエアアクセラレータ使用版 DrawOval
static int	DrawTriangleHardware( int x1, int y1, int x2, int y2, int x3, int y3, int Color, int FillFlag ) ;										// ハードウエアアクセラレータ使用版 DrawTriangle
static int	DrawTriangle3DHardware( VECTOR Pos1, VECTOR Pos2, VECTOR Pos3, int Color, int FillFlag, int DrawFlag = TRUE, RECT *DrawArea = NULL ) ;	// ハードウエアアクセラレータ使用版 DrawTriangle3D
static int	DrawQuadrangleHardware( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int Color, int FillFlag ) ;						// ハードウエアアクセラレータ使用版 DrawQuadrangle
static int	DrawPixelHardware( int x, int y, int Color ) ;																							// ハードウエアアクセラレータ使用版 DrawPixel
static int	DrawPixel3DHardware( VECTOR Pos, int Color, int DrawFlag = TRUE, RECT *DrawArea = NULL ) ;												// ハードウエアアクセラレータ使用版 DrawPixel3D
static int	DrawPixelSetHardware( const POINTDATA *PointData, int Num ) ;																					// ハードウエアアクセラレータ使用版 DrawPixelSet
static int	DrawLineSetHardware( const LINEDATA *LineData, int Num ) ;																					// ハードウエアアクセラレータ使用版 DrawLineSet

static int  DrawGraphSoftware( int x, int y, IMAGEDATA2 *Image2, int TransFlag ) ;									// ソフトウエアレンダリング版 DrawGraph
static int  DrawExtendGraphSoftware( int x1, int y1, int x2, int y2, IMAGEDATA2 *Image2, int TransFlag ) ;		// ソフトウエアレンダリング版 DrawExtendGraph
static int  DrawRotaGraphSoftware( float x, float y, double ExRate, double Angle, IMAGEDATA2 *Image2, int TransFlag, int TurnFlag ) ;	// ソフトウエアレンダリング版 DrawRotaGraph
static int	DrawPolySoftware( DX_POINTDATA *p, IMAGEDATA2 *Image2, int TransFlag, int Color ) ;
static int  DrawModiGraphSoftware( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, IMAGEDATA2 *Image2, int TransFlag ) ;	// ソフトウエアレンダリング版 DrawModiGraph
static int  DrawModiGraphFSoftware( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, IMAGEDATA2 *Image2, int TransFlag ) ;	// ソフトウエアレンダリング版 DrawModiGraphF
static int  DrawFillBoxSoftware( int x1, int y1, int x2, int y2, int Color ) ;																// ソフトウエアレンダリング版 DrawFillBox
static int  DrawLineBoxSoftware( int x1, int y1, int x2, int y2, int Color ) ;																// ソフトウエアレンダリング版 DrawLineBox
static int	DrawChipMapSoftware( int Sx, int Sy, int XNum, int YNum, const int *MapData, int MapDataPitch, int ChipTypeNum, const int *ChipGrHandle, int TransFlag ) ;	// ソフトウエアレンダリング版 DrawChipMap
static int	DrawTileSoftware( int x1, int y1, int x2, int y2, int Tx, int Ty, double ExtRate, double Angle, IMAGEDATA2 *Image2, int TransFlag ) ;	// ソフトウエアレンダリング版 DrawTile
static int	DrawPrimitiveSoftware( VERTEX_3D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawIndexedPrimitiveSoftware( VERTEX_3D *Vertex, int VertexNum, WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawPrimitive2DSoftware( VERTEX_2D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawIndexedPrimitive2DSoftware( VERTEX_2D *Vertex, int VertexNum, WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag ) ;
static int	DrawLineSoftware( int x1, int y1, int x2, int y2, int Color ) ;																	// ソフトウエアレンダリング版 DrawLine
static int	DrawCircle_ThicknessSoftware( int x, int y, int r, int Color, int Thickness ) ;													// ソフトウエアレンダリング版 DrawCircle( 太さ指定あり )
static int	DrawOval_ThicknessSoftware( int x, int y, int rx, int ry, int Color, int Thickness ) ;											// ソフトウエアレンダリング版 DrawOval( 太さ指定あり )
static int	DrawCircleSoftware( int x, int y, int r, int Color, int FillFlag ) ;															// ソフトウエアレンダリング版 DrawCircle
static int	DrawOvalSoftware( int x, int y, int rx, int ry, int Color, int FillFlag ) ;														// ソフトウエアレンダリング版 DrawOval
static int	DrawTriangleSoftware( int x1, int y1, int x2, int y2, int x3, int y3, int Color, int FillFlag ) ;								// ソフトウエアレンダリング版 DrawTriangle
static int	DrawQuadrangleSoftware( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int Color, int FillFlag ) ;				// ソフトウエアレンダリング版 DrawQuadrangle
static int	DrawPixelSoftware( int x, int y, int Color ) ;																					// ソフトウエアレンダリング版 DrawPixel
static int	DrawPixelSetSoftware( const POINTDATA *PointData, int Num ) ;																			// ソフトウエアレンダリング版 DrawPixelSet
static int	DrawLineSetSoftware( const LINEDATA *LineData, int Num ) ;																			// ソフトウエアレンダリング版 DrawLineSet


// Program -----------------------------------------------------------------

// ビルボード用の行列計算
__inline static void _VectorTransformToBillboard( VECTOR *Vector, VECTOR *Position )
{
	VECTOR invec = *Vector ;
	Vector->x = invec.x * GBASE.BillboardMatrix.m[0][0] + invec.y * GBASE.BillboardMatrix.m[1][0] + Position->x ;
	Vector->y = invec.x * GBASE.BillboardMatrix.m[0][1] + invec.y * GBASE.BillboardMatrix.m[1][1] + Position->y ;
	Vector->z = invec.x * GBASE.BillboardMatrix.m[0][2] + invec.y * GBASE.BillboardMatrix.m[1][2] + Position->z ;
}

// ブレンド画像との大きさチェック
__inline static int CheckBlendGraphSize( IMAGEDATA2 *GraphData )
{
	IMAGEDATA2 *BlendData ;

	if( GRAPHCHK( GBASE.BlendGraph, BlendData ) )
		return -1 ;

	// ブレンド画像よりも大きかったらアウト
	return ( ( BlendData->Width  - GraphData->Width  ) |
		     ( BlendData->Height - GraphData->Height ) ) & 0x80000000 ? -1 : 0 ;
}

static int BltBmpOrBaseImageToGraph3_MipMapBlt(
	IMAGEDATA2_ORIG			*Orig,
	const RECT				*SrcRect,
	const RECT				*DestRect,
	int						UseSysMemSurface,
	DX_DIRECT3DBASETEXTURE9	*UseTex,
	int						TexWidth,
	int						TexHeight,
	const BASEIMAGE			*RgbImage,
	const BASEIMAGE			*AlphaImage,
	const COLORDATA			*DestColor,
	int						RedIsAlphaFlag,
	int						UseTransColorConvAlpha,
	int						ASyncThread
)
{
	int AlphaImageSize, ImageSize, ImageW, ImageH, ImagePitch ;
	void *Image1, *Image2, *ImageD, *ImageS, *ImageBuffer ;
	int ImageDW, ImageDH, ImageSW, ImageSH ;
	int ImageNum ;
	RECT DestRectT, SrcRectT ;
	D_D3DLOCKED_RECT LockRect ;
	POINT DestPoint ;
	int UseSysMemSurfaceIndex ;
	DX_DIRECT3DSURFACE9 *DestSurface ;
	DX_DIRECT3DSURFACE9 *UseSurface ;
	int TempTexWidth ;
	int TempTexHeight ;
	int i, j, ts ;
	HRESULT hr ;

	DestPoint.x = 0 ;
	DestPoint.y = 0 ;

	ImageNum = Orig->FormatDesc.CubeMapTextureFlag ? CUBEMAP_SURFACE_NUM : 1 ;

	// 転送先がテクスチャ全体で、且つDXTフォーマットで転送先もDXTフォーマットの場合は単純なメモリ転送を行う
	if( DestRect->left == 0 && DestRect->right  == TexWidth  &&
		DestRect->top  == 0 && DestRect->bottom == TexHeight &&
		RgbImage->MipMapCount >= Orig->Hard.MipMapCount &&
		( ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT1 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT1 ) ||
		  ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT2 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT2 ) ||
		  ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT3 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT3 ) ||
		  ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT4 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT4 ) ||
		  ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT5 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT5 ) ) )
	{
		if( Orig->FormatDesc.CubeMapTextureFlag )
		{
			ImageBuffer = RgbImage->GraphData ;
			for( i = 0 ; i < CUBEMAP_SURFACE_NUM ; i ++ )
			{
				TempTexWidth = TexWidth ;
				TempTexHeight = TexHeight ;
				ImageSize = RgbImage->Width * RgbImage->Height * RgbImage->ColorData.ColorBitDepth / 8 ;
				for( j = 0 ; j < Orig->Hard.MipMapCount ; j ++ )
				{
					// テクスチャをロック
					if( UseSysMemSurface == FALSE )
					{
						hr = GraphicsCubeTexture_LockRect_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, &LockRect, NULL, 0, ASyncThread ) ;
					}
					else
					{
						for(;;)
						{
							UseSysMemSurfaceIndex = GetSysMemSurface( TempTexWidth, TempTexHeight, GRH.TextureFormat[ Orig->ColorFormat ], ASyncThread ) ;
							if( UseSysMemSurfaceIndex != -1 ) break ;
							if( NS_ProcessMessage() != 0 ) break ;
							Thread_Sleep( 1 ) ;
						}
						if( UseSysMemSurfaceIndex == -1 )
						{
							return -1 ;
						}
						UseSurface = GRH.SysMemSurface[ UseSysMemSurfaceIndex ].MemSurface ;

						hr = GraphicsSurface_LockRect_ASync( UseSurface, &LockRect, NULL, D_D3DLOCK_DISCARD, ASyncThread ) ;
					}
					if( hr != D_D3D_OK )
					{
						DXST_ERRORLOG_ADD( _T( "キューブマップミップマップテクスチャのロックに失敗しました\n" ) ) ;
						return -1 ;
					}

					// テクスチャに転送
					_MEMCPY( LockRect.pBits, ImageBuffer, ImageSize ) ;

					// ロック解除
					if( UseSysMemSurface == FALSE )
					{
						GraphicsCubeTexture_UnlockRect_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, ASyncThread ) ;
					}
					else
					{
						GraphicsSurface_UnlockRect_ASync( UseSurface, ASyncThread ) ;

						GraphicsCubeTexture_GetCubeMapSurface_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, &DestSurface, ASyncThread ) ;

						GraphicsDevice_UpdateSurface_ASync( UseSurface, NULL, DestSurface, NULL, ASyncThread ) ; 

						Graphics_ObjectRelease_ASync( DestSurface, ASyncThread ) ;

						ReleaseSysMemSurface( UseSysMemSurfaceIndex, ASyncThread ) ;
						UseSysMemSurfaceIndex = -1 ;
					}

					// 転送元アドレスを進める
					ImageBuffer = ( BYTE * )ImageBuffer + ImageSize ;
					ImageSize /= 4 ;
					if( ImageSize < 8 )
						ImageSize = 8 ;

					TempTexWidth >>= 1 ;
					TempTexHeight >>= 1 ;
					if( TempTexWidth < 1 )
					{
						TempTexWidth = 1 ;
					}
					if( TempTexHeight < 1 )
					{
						TempTexHeight = 1 ;
					}
				}
			}
		}
		else
		{
			TempTexWidth = TexWidth ;
			TempTexHeight = TexHeight ;
			ImageSize = RgbImage->Width * RgbImage->Height * RgbImage->ColorData.ColorBitDepth / 8 ;
			ImageBuffer = RgbImage->GraphData ;
			for( j = 0 ; j < Orig->Hard.MipMapCount ; j ++ )
			{
				// テクスチャをロック
				if( UseSysMemSurface == FALSE )
				{
					hr = GraphicsTexture_LockRect_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, &LockRect, NULL, 0, ASyncThread ) ;
				}
				else
				{
					for(;;)
					{
						UseSysMemSurfaceIndex = GetSysMemSurface( TempTexWidth, TempTexHeight, GRH.TextureFormat[ Orig->ColorFormat ], ASyncThread ) ;
						if( UseSysMemSurfaceIndex != -1 ) break ;
						if( NS_ProcessMessage() != 0 ) break ;
						Thread_Sleep( 1 ) ;
					}
					if( UseSysMemSurfaceIndex == -1 )
					{
						return -1 ;
					}
					UseSurface = GRH.SysMemSurface[ UseSysMemSurfaceIndex ].MemSurface ;

					hr = GraphicsSurface_LockRect_ASync( UseSurface, &LockRect, NULL, D_D3DLOCK_DISCARD, ASyncThread ) ;
				}
				if( hr != D_D3D_OK )
				{
					DXST_ERRORLOG_ADD( _T( "ミップマップテクスチャのロックに失敗しました\n" ) ) ;
					return -1 ;
				}

				// テクスチャに転送
				_MEMCPY( LockRect.pBits, ImageBuffer, ImageSize ) ;

				// ロック解除
				if( UseSysMemSurface == FALSE )
				{
					GraphicsTexture_UnlockRect_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, ASyncThread ) ;
				}
				else
				{
					GraphicsSurface_UnlockRect_ASync( UseSurface, ASyncThread ) ;

					GraphicsTexture_GetSurfaceLevel_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, &DestSurface, ASyncThread ) ;

					GraphicsDevice_UpdateSurface_ASync( UseSurface, NULL, DestSurface, NULL, ASyncThread ) ; 

					Graphics_ObjectRelease_ASync( DestSurface, ASyncThread ) ;

					ReleaseSysMemSurface( UseSysMemSurfaceIndex, ASyncThread ) ;
					UseSysMemSurfaceIndex = -1 ;
				}

				// 転送元アドレスを進める
				ImageBuffer = ( BYTE * )ImageBuffer + ImageSize ;
				ImageSize /= 4 ;
				if( ImageSize < 8 )
					ImageSize = 8 ;

				TempTexWidth >>= 1 ;
				TempTexHeight >>= 1 ;
				if( TempTexWidth < 1 )
				{
					TempTexWidth = 1 ;
				}
				if( TempTexHeight < 1 )
				{
					TempTexHeight = 1 ;
				}
			}
		}
	}
	else
	{
		// 転送先が標準フォーマットではない場合は転送できない
		if( GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT1 &&
			GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT2 &&
			GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT3 &&
			GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT4 &&
			GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT5 )
		{
			// 転送元にミップマップ情報がある場合と無い場合で処理を分岐
			if( RgbImage->MipMapCount >= Orig->Hard.MipMapCount )
			{
				// ある場合

				ImageBuffer = RgbImage->GraphData ;
				if( Orig->FormatDesc.CubeMapTextureFlag )
				{
					for( i = 0 ; i < CUBEMAP_SURFACE_NUM ; i ++ )
					{
						TempTexWidth = TexWidth ;
						TempTexHeight = TexHeight ;
						ImageSize = RgbImage->Width * RgbImage->Height * RgbImage->ColorData.PixelByte ;
						for( j = 0 ; j < Orig->Hard.MipMapCount ; j ++ )
						{
							// テクスチャをロック
							if( UseSysMemSurface == FALSE )
							{
								hr = GraphicsCubeTexture_LockRect_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, &LockRect, NULL, 0, ASyncThread ) ;
							}
							else
							{
								for(;;)
								{
									UseSysMemSurfaceIndex = GetSysMemSurface( TempTexWidth, TempTexHeight, GRH.TextureFormat[ Orig->ColorFormat ], ASyncThread ) ;
									if( UseSysMemSurfaceIndex != -1 ) break ;
									if( NS_ProcessMessage() != 0 ) break ;
									Thread_Sleep( 1 ) ;
								}
								if( UseSysMemSurfaceIndex == -1 )
								{
									return -1 ;
								}
								UseSurface = GRH.SysMemSurface[ UseSysMemSurfaceIndex ].MemSurface ;

								hr = GraphicsSurface_LockRect_ASync( UseSurface, &LockRect, NULL, D_D3DLOCK_DISCARD, ASyncThread ) ;
							}
							if( hr != D_D3D_OK )
							{
								DXST_ERRORLOG_ADD( _T( "ミップマップテクスチャのロックに失敗しました\n" ) ) ;
								return -1 ;
							}

							// テクスチャに転送
							_MEMCPY( LockRect.pBits, ImageBuffer, ImageSize ) ;

							// ロック解除
							if( UseSysMemSurface == FALSE )
							{
								GraphicsCubeTexture_UnlockRect_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, ASyncThread ) ;
							}
							else
							{
								GraphicsSurface_UnlockRect_ASync( UseSurface, ASyncThread ) ;

								GraphicsCubeTexture_GetCubeMapSurface_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, &DestSurface, ASyncThread ) ;

								GraphicsDevice_UpdateSurface_ASync( UseSurface, NULL, DestSurface, NULL, ASyncThread ) ; 

								Graphics_ObjectRelease_ASync( DestSurface, ASyncThread ) ;

								ReleaseSysMemSurface( UseSysMemSurfaceIndex, ASyncThread ) ;
								UseSysMemSurfaceIndex = -1 ;
							}

							// 転送元アドレスを進める
							ImageBuffer = ( BYTE * )ImageBuffer + ImageSize ;
							ImageSize /= 4 ;

							TempTexWidth >>= 1 ;
							TempTexHeight >>= 1 ;
							if( TempTexWidth < 1 )
							{
								TempTexWidth = 1 ;
							}
							if( TempTexHeight < 1 )
							{
								TempTexHeight = 1 ;
							}
						}
					}
				}
				else
				{
					TempTexWidth = TexWidth ;
					TempTexHeight = TexHeight ;
					ImageSize = RgbImage->Width * RgbImage->Height * RgbImage->ColorData.PixelByte ;
					for( j = 0 ; j < Orig->Hard.MipMapCount ; j ++ )
					{
						// テクスチャをロック
						if( UseSysMemSurface == FALSE )
						{
							hr = GraphicsTexture_LockRect_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, &LockRect, NULL, 0, ASyncThread ) ;
						}
						else
						{
							for(;;)
							{
								UseSysMemSurfaceIndex = GetSysMemSurface( TempTexWidth, TempTexHeight, GRH.TextureFormat[ Orig->ColorFormat ], ASyncThread ) ;
								if( UseSysMemSurfaceIndex != -1 ) break ;
								if( NS_ProcessMessage() != 0 ) break ;
								Thread_Sleep( 1 ) ;
							}
							if( UseSysMemSurfaceIndex == -1 )
							{
								return -1 ;
							}
							UseSurface = GRH.SysMemSurface[ UseSysMemSurfaceIndex ].MemSurface ;

							hr = GraphicsSurface_LockRect_ASync( UseSurface, &LockRect, NULL, D_D3DLOCK_DISCARD, ASyncThread ) ;
						}
						if( hr != D_D3D_OK )
						{
							DXST_ERRORLOG_ADD( _T( "ミップマップテクスチャのロックに失敗しました\n" ) ) ;
							return -1 ;
						}

						// テクスチャに転送
						_MEMCPY( LockRect.pBits, ImageBuffer, ImageSize ) ;

						// ロック解除
						if( UseSysMemSurface == FALSE )
						{
							GraphicsTexture_UnlockRect_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, ASyncThread ) ;
						}
						else
						{
							GraphicsSurface_UnlockRect_ASync( UseSurface, ASyncThread ) ;

							GraphicsTexture_GetSurfaceLevel_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, &DestSurface, ASyncThread ) ;

							GraphicsDevice_UpdateSurface_ASync( UseSurface, NULL, DestSurface, NULL, ASyncThread ) ; 

							Graphics_ObjectRelease_ASync( DestSurface, ASyncThread ) ;

							ReleaseSysMemSurface( UseSysMemSurfaceIndex, ASyncThread ) ;
							UseSysMemSurfaceIndex = -1 ;
						}

						// 転送元アドレスを進める
						ImageBuffer = ( BYTE * )ImageBuffer + ImageSize ;
						ImageSize /= 4 ;

						TempTexWidth >>= 1 ;
						TempTexHeight >>= 1 ;
						if( TempTexWidth < 1 )
						{
							TempTexWidth = 1 ;
						}
						if( TempTexHeight < 1 )
						{
							TempTexHeight = 1 ;
						}
					}
				}
			}
			else
			{
				// 無い場合

				// 一時バッファに格納
				ts = DestRect->right  - DestRect->left ;
				for( ImageW = 1 ; ImageW < ts ; ImageW <<= 1 ){}
				ts = DestRect->bottom - DestRect->top  ;
				for( ImageH = 1 ; ImageH < ts ; ImageH <<= 1 ){}
				ImagePitch = DestColor->PixelByte * ImageW ;
				ImageSize = ImagePitch * ImageH ;
				ImageBuffer = DXALLOC( ImageSize * 2 ) ;
				Image1 = ImageBuffer ;
				Image2 = ( BYTE * )Image1 + ImageSize ;
				if( ImageBuffer == NULL )
				{
					DXST_ERRORLOG_ADD( _T( "テクスチャへ転送する画像を一時的に格納するメモリ領域の確保に失敗しました\n" ) ) ;
					return -1 ;
				}

				ImageSize      = RgbImage->Pitch   * RgbImage->Height ;
				AlphaImageSize = AlphaImage->Pitch * AlphaImage->Height ;
				for( i = 0 ; i < ImageNum ; i ++ )
				{
					// ミップマップの深さだけ繰り返し
					ImageSW = ImageW ;
					ImageSH = ImageH ;
					ImageDW = ImageW ;
					ImageDH = ImageH ;
					TempTexWidth = TexWidth ;
					TempTexHeight = TexHeight ;
					for( j = 0 ; j < Orig->Hard.MipMapCount ; j ++ )
					{
						// 縮小画像の作成
						if( j == 0 )
						{
							// level0 の時は等倍の出力フォーマット画像を作成する
							NS_GraphColorMatchBltVer2(
											   Image1,        ImagePitch,              DestColor,
								( BYTE * )RgbImage->GraphData   + ImageSize * i,      RgbImage->Pitch,   &RgbImage->ColorData,
								( BYTE * )AlphaImage->GraphData + AlphaImageSize * i, AlphaImage->Pitch, &AlphaImage->ColorData,
								DestPoint, SrcRect, FALSE,
								UseTransColorConvAlpha && ( DestColor->AlphaWidth != 0 && AlphaImage->GraphData == NULL ), Orig->TransCode,
								BASEIM.ImageShavedMode, FALSE,
								RedIsAlphaFlag, FALSE,
								FALSE ) ;
							ImageD = Image1 ;
						}
						else
						{
							if( j & 1 )
							{
								ImageS = Image1 ;
								ImageD = Image2 ;
							}
							else
							{
								ImageS = Image2 ;
								ImageD = Image1 ;
							}

							GraphHalfScaleBlt( DestColor, ImageD, ImagePitch, ImageS, ImagePitch, 0, 0, 0, 0, ImageSW, ImageSH ) ;
						}

						// 転送先のロック
						DestRectT.left   = DestRect->left   >> j ;
						DestRectT.right  = DestRect->right  >> j ;
						DestRectT.top    = DestRect->top    >> j ;
						DestRectT.bottom = DestRect->bottom >> j ;
						if( DestRectT.right  == DestRectT.left ) DestRectT.right  = DestRectT.left + 1 ;
						if( DestRectT.bottom == DestRectT.top  ) DestRectT.bottom = DestRectT.top  + 1 ;
						if( UseSysMemSurface == FALSE )
						{
							if( Orig->FormatDesc.CubeMapTextureFlag )
							{
								if( GraphicsCubeTexture_LockRect_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, &LockRect, &DestRectT, 0, ASyncThread ) != D_D3D_OK )
								{
									DXFREE( ImageBuffer ) ;
									ImageBuffer = NULL ;
									DXST_ERRORLOG_ADD( _T( "キューブマップミップマップテクスチャのロックに失敗しました\n" ) ) ;
									return -1 ;
								}
							}
							else
							{
								if( GraphicsTexture_LockRect_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, &LockRect, &DestRectT, 0, ASyncThread ) != D_D3D_OK )
								{
									DXFREE( ImageBuffer ) ;
									ImageBuffer = NULL ;
									DXST_ERRORLOG_ADD( _T( "ミップマップテクスチャのロックに失敗しました\n" ) ) ;
									return -1 ;
								}
							}
						}
						else
						{
							for(;;)
							{
								UseSysMemSurfaceIndex = GetSysMemSurface( TempTexWidth, TempTexHeight, GRH.TextureFormat[ Orig->ColorFormat ], ASyncThread ) ;
								if( UseSysMemSurfaceIndex != -1 ) break ;
								if( NS_ProcessMessage() != 0 ) break ;
								Thread_Sleep( 1 ) ;
							}
							if( UseSysMemSurfaceIndex == -1 )
							{
								DXFREE( ImageBuffer ) ;
								ImageBuffer = NULL ;
								DXST_ERRORLOG_ADD( _T( "ミップマップテクスチャ用のメモリサーフェスの取得に失敗しました\n" ) ) ;
								return -1 ;
							}
							UseSurface = GRH.SysMemSurface[ UseSysMemSurfaceIndex ].MemSurface ;

							if( GraphicsSurface_LockRect_ASync( UseSurface, &LockRect, &DestRectT, D_D3DLOCK_DISCARD, ASyncThread ) != D_D3D_OK )
							{
								DXFREE( ImageBuffer ) ;
								ImageBuffer = NULL ;
								DXST_ERRORLOG_ADD( _T( "ミップマップテクスチャのロックに失敗しました\n" ) ) ;
								return -1 ;
							}
						}

						// テクスチャに転送
						SrcRectT.left   = 0 ;
						SrcRectT.top    = 0 ;
						SrcRectT.right  = ImageDW ;
						SrcRectT.bottom = ImageDH ;
						NS_GraphColorMatchBltVer2(
							LockRect.pBits, LockRect.Pitch,  DestColor,
									ImageD,     ImagePitch,  DestColor,
									  NULL,              0,       NULL,
							DestPoint, &SrcRectT, FALSE,
							FALSE, 0, 0, FALSE, FALSE, FALSE, FALSE ) ;

						// ロック解除
						if( UseSysMemSurface == FALSE )
						{
							if( Orig->FormatDesc.CubeMapTextureFlag )
							{
								GraphicsCubeTexture_UnlockRect_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, ASyncThread ) ;
							}
							else
							{
								GraphicsTexture_UnlockRect_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, ASyncThread ) ;
							}
						}
						else
						{
							DX_DIRECT3DSURFACE9 *DestSurface ;
							POINT DestSurfacePoint ;

							GraphicsSurface_UnlockRect_ASync( UseSurface, ASyncThread ) ;

							if( Orig->FormatDesc.CubeMapTextureFlag )
							{
								GraphicsCubeTexture_GetCubeMapSurface_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, j, &DestSurface, ASyncThread ) ;
							}
							else
							{
								GraphicsTexture_GetSurfaceLevel_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, j, &DestSurface, ASyncThread ) ;
							}

							DestSurfacePoint.x = DestRectT.left ;
							DestSurfacePoint.y = DestRectT.top ;
							GraphicsDevice_UpdateSurface_ASync( UseSurface, &DestRectT, DestSurface, &DestSurfacePoint, ASyncThread ) ; 

							Graphics_ObjectRelease_ASync( DestSurface, ASyncThread ) ;

							ReleaseSysMemSurface( UseSysMemSurfaceIndex, ASyncThread ) ;
							UseSysMemSurfaceIndex = -1 ;
						}

						// 次のイメージのサイズをセット
						ImageSW = ImageDW ;
						ImageSH = ImageDH ;
						ImageDW >>= 1 ;
						ImageDH >>= 1 ;
						if( ImageDW == 0 ) ImageDW = 1 ;
						if( ImageDH == 0 ) ImageDH = 1 ;

						TempTexWidth >>= 1 ;
						TempTexHeight >>= 1 ;
						if( TempTexWidth < 1 )
						{
							TempTexWidth = 1 ;
						}
						if( TempTexHeight < 1 )
						{
							TempTexHeight = 1 ;
						}
					}
				}

				// メモリの解放
				DXFREE( ImageBuffer ) ;
			}
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "DXTフォーマットのテクスチャに標準形式のイメージを転送することはできません\n" ) ) ;
		}
	}

	// 正常終了
	return 0 ;
}

static int BltBmpOrBaseImageToGraph3_NoMipMapBlt(
	IMAGEDATA2_ORIG			*Orig,
	const RECT				*SrcRect,
	const RECT				*DestRect,
	int						UseSysMemSurface,
	DX_DIRECT3DBASETEXTURE9	*UseTex,
	int						TexWidth,
	int						TexHeight,
	int						TexUseWidth,
	int						TexUseHeight,
	const BASEIMAGE			*RgbImage,
	const BASEIMAGE			*AlphaImage,
	const COLORDATA			*DestColor,
	int						RedIsAlphaFlag,
	int						UseTransColorConvAlpha,
	int						ASyncThread
)
{
	int k ;
	int i ;
	int hr ;
	POINT DestPoint ;
	RECT DestRectT ;
	int H ;
	BYTE *DestAddr ;
	BYTE *SrcRgbAddr ;
	BYTE *SrcAlphaAddr ;
	D_D3DLOCKED_RECT LockRect ;
	int RightLineFillFlag ;
	int BottomLineFillFlag ;
	int ImageNum ;
	DWORD ImageSize ;
	DWORD AlphaImageSize ;
	int UseSysMemSurfaceIndex ;
	DX_DIRECT3DSURFACE9 *UseSurface ;

	DestPoint.x = 0 ;
	DestPoint.y = 0 ;

	RightLineFillFlag = FALSE ;
	BottomLineFillFlag = FALSE ;
	DestRectT = *DestRect ;
	if( TexUseWidth  < TexWidth  && TexUseWidth  == DestRectT.right )
	{
		RightLineFillFlag = TRUE ;
		DestRectT.right ++ ;
	}
	if( TexUseHeight < TexHeight && TexUseHeight == DestRectT.bottom )
	{
		BottomLineFillFlag = TRUE ;
		DestRectT.bottom ++ ;
	}

	ImageNum = Orig->FormatDesc.CubeMapTextureFlag ? CUBEMAP_SURFACE_NUM : 1 ;

//	DXST_ERRORLOGFMT_ADD(( _T( "SrcRect l:%d t:%d r:%d b:%d  DestRect l:%d t:%d r:%d b:%d" ),
//	SrcRect->left, SrcRect->top, SrcRect->right, SrcRect->bottom,
//	DestRectT.left, DestRectT.top, DestRectT.right, DestRectT.bottom )) ;

	for( i = 0 ; i < ImageNum ; i ++ )
	{
		// 転送先のロック
		if( UseSysMemSurface == FALSE )
		{
			if( Orig->FormatDesc.CubeMapTextureFlag )
			{
				hr = GraphicsCubeTexture_LockRect_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, 0, &LockRect, &DestRectT, 0, ASyncThread ) ;
			}
			else
			{
				hr = GraphicsTexture_LockRect_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, 0, &LockRect, &DestRectT, 0, ASyncThread ) ;
			}
			UseSysMemSurfaceIndex = -1 ;
		}
		else
		{
			for(;;)
			{
				UseSysMemSurfaceIndex = GetSysMemSurface( TexWidth, TexHeight, GRH.TextureFormat[ Orig->ColorFormat ], ASyncThread ) ;
				if( UseSysMemSurfaceIndex != -1 ) break ;
				if( NS_ProcessMessage() != 0 ) break ;
				Thread_Sleep( 1 ) ;
			}
			if( UseSysMemSurfaceIndex == -1 )
			{
				return -1 ;
			}
			UseSurface = GRH.SysMemSurface[ UseSysMemSurfaceIndex ].MemSurface ;

			hr = GraphicsSurface_LockRect_ASync( UseSurface, &LockRect, &DestRectT, D_D3DLOCK_DISCARD, ASyncThread ) ;
		}
		if( hr != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "テクスチャのロックに失敗しました\n" ) ) ;
			return -1  ;
		}

		// 転送処理

		// 転送先がテクスチャ全体で、且つDXTフォーマットで転送先もDXTフォーマットの場合は単純なメモリ転送を行う
		if( DestRect->left == 0 && DestRect->right  == TexWidth  &&
			DestRect->top  == 0 && DestRect->bottom == TexHeight &&
			( ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT1 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT1 ) ||
			  ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT2 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT2 ) ||
			  ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT3 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT3 ) ||
			  ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT4 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT4 ) ||
			  ( RgbImage->ColorData.Format == DX_BASEIMAGE_FORMAT_DXT5 && GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_DXT5 ) ) )
		{
			ImageSize = RgbImage->Width * RgbImage->Height * RgbImage->ColorData.ColorBitDepth / 8 ;
			_MEMCPY( LockRect.pBits, ( BYTE * )RgbImage->GraphData + ImageSize * i, ImageSize ) ;
		}
		else
		{
			// 転送先が標準フォーマットではない場合は転送できない
			if( GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT1 &&
				GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT2 &&
				GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT3 &&
				GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT4 &&
				GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT5 )
			{
				ImageSize      = RgbImage->Pitch   * RgbImage->Height ;
				AlphaImageSize = AlphaImage->Pitch * AlphaImage->Height ;

				SrcRgbAddr   = ( BYTE * )RgbImage->GraphData   + i * ImageSize ;
				SrcAlphaAddr = ( BYTE * )AlphaImage->GraphData + i * AlphaImageSize ;
				NS_GraphColorMatchBltVer2(
					LockRect.pBits, LockRect.Pitch,    DestColor,
					SrcRgbAddr,     RgbImage->Pitch,   &RgbImage->ColorData,
					SrcAlphaAddr,   AlphaImage->Pitch, &AlphaImage->ColorData,
					DestPoint, SrcRect, FALSE,
					UseTransColorConvAlpha && ( DestColor->AlphaWidth != 0 && AlphaImage->GraphData == NULL ), Orig->TransCode,
					BASEIM.ImageShavedMode, FALSE,
					RedIsAlphaFlag, FALSE,
					FALSE ) ;

				if( BottomLineFillFlag )
				{
					_MEMCPY( ( BYTE * )LockRect.pBits + ( TexUseHeight - DestRect->top     ) * LockRect.Pitch,
							 ( BYTE * )LockRect.pBits + ( TexUseHeight - DestRect->top - 1 ) * LockRect.Pitch,
							 DestColor->PixelByte * ( SrcRect->right - SrcRect->left ) ) ;
				}
				if( RightLineFillFlag )
				{
					H = SrcRect->bottom - SrcRect->top ;
					DestAddr = ( BYTE * )LockRect.pBits + ( TexUseWidth - DestRect->left ) * DestColor->PixelByte ;
					switch( DestColor->PixelByte )
					{
					case 2 :
						for( k = 0 ; k < H ; k ++, DestAddr += LockRect.Pitch )
						{
							*( ( WORD * )DestAddr ) = *( ( WORD * )DestAddr - 1 ) ;
						}
						break ;

					case 4 :
						for( k = 0 ; k < H ; k ++, DestAddr += LockRect.Pitch )
						{
							*( ( DWORD * )DestAddr ) = *( ( DWORD * )DestAddr - 1 ) ;
						}
						break ;
					}
				}
				if( BottomLineFillFlag && RightLineFillFlag )
				{
					DestAddr = ( BYTE * )LockRect.pBits + ( TexUseHeight - DestRect->top ) * LockRect.Pitch + ( TexUseWidth - DestRect->left ) * DestColor->PixelByte ;
					switch( DestColor->PixelByte )
					{
					case 2 : *( ( WORD  * )DestAddr ) = *( ( WORD  * )( DestAddr - LockRect.Pitch ) - 1 ) ; break ;
					case 4 : *( ( DWORD * )DestAddr ) = *( ( DWORD * )( DestAddr - LockRect.Pitch ) - 1 ) ;	break ;
					}
				}
			}
			else
			{
				DXST_ERRORLOG_ADD( _T( "DXTフォーマットのテクスチャに標準形式のイメージを転送することはできません\n" ) ) ;
			}
		}

		// ロック解除
		if( UseSysMemSurface == FALSE )
		{
			if( Orig->FormatDesc.CubeMapTextureFlag )
			{
				GraphicsCubeTexture_UnlockRect_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, 0, ASyncThread ) ;
			}
			else
			{
				GraphicsTexture_UnlockRect_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, 0, ASyncThread ) ;
			}
		}
		else
		{
			DX_DIRECT3DSURFACE9 *DestSurface ;
			POINT DestSurfacePoint ;

			GraphicsSurface_UnlockRect_ASync( UseSurface, ASyncThread ) ;

			if( Orig->FormatDesc.CubeMapTextureFlag )
			{
				GraphicsCubeTexture_GetCubeMapSurface_ASync( ( DX_DIRECT3DCUBETEXTURE9 * )UseTex, ( D_D3DCUBEMAP_FACES )i, 0, &DestSurface, ASyncThread ) ;
			}
			else
			{
				GraphicsTexture_GetSurfaceLevel_ASync( ( DX_DIRECT3DTEXTURE9 * )UseTex, 0, &DestSurface, ASyncThread ) ;
			}

			DestSurfacePoint.x = DestRectT.left ;
			DestSurfacePoint.y = DestRectT.top ;
			GraphicsDevice_UpdateSurface_ASync( UseSurface, &DestRectT, DestSurface, &DestSurfacePoint, ASyncThread ) ; 

			Graphics_ObjectRelease_ASync( DestSurface, ASyncThread ) ;

			ReleaseSysMemSurface( UseSysMemSurfaceIndex, ASyncThread ) ;
			UseSysMemSurfaceIndex = -1 ;
		}
	}

	// 正常終了
	return 0 ;
}

// デフォルトのグラフィック復旧関数
static void DefaultRestoreGraphFunction( void )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *FileBackImage2 ;
	IMAGEDATA2 *MemBackImage2 ;
	int i ;
	int ImageDataArea ;
	BASEIMAGE FileRgbImage ;
	BASEIMAGE FileAlphaImage ;
	int FileRgbLoad ;
	int FileAlphaLoad ;
	BASEIMAGE MemRgbImage ;
	BASEIMAGE MemAlphaImage ;
	int MemRgbLoad ;
	int MemAlphaLoad ;
	int LoadHr ;

	DXST_ERRORLOG_ADD( _T( "グラフィックを復帰します\n" ) ) ;

	// すべてのグラフィックを検証
	ImageDataArea = HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMax ;
	FileBackImage2 = NULL ;
	FileRgbLoad = FALSE ;
	FileAlphaLoad = FALSE ;
	MemBackImage2 = NULL ;
	MemRgbLoad = FALSE ;
	MemAlphaLoad = FALSE ;
	if( HandleManageArray[ DX_HANDLETYPE_GRAPH ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMin ; i <= ImageDataArea ; i ++ )
		{
			Image2 = ( IMAGEDATA2 * )HandleManageArray[ DX_HANDLETYPE_GRAPH ].Handle[ i ] ;
			if( Image2 == NULL || Image2->ReadBase == NULL ) continue ;

			// ファイルから読み込んだ場合はファイルから画像を復元する
			if( Image2->ReadBase->FileName )
			{
				// 一つ前のグラフィックとパスとファイルが同じ場合は読み込みをしない
				if( FileBackImage2 == NULL ||
					FileRgbLoad == FALSE ||
					FileBackImage2->ReadBase->FileName == NULL ||
					_TSTRCMP( Image2->ReadBase->FileName, FileBackImage2->ReadBase->FileName ) != 0 ||
					Image2->ReadBase->ReverseFlag != FileBackImage2->ReadBase->ReverseFlag )
				{
					// BASEIMAGE の後始末
					if( FileRgbLoad == TRUE )
					{
						NS_ReleaseGraphImage( &FileRgbImage ) ;
						FileRgbLoad = FALSE ;
					}
					if( FileAlphaLoad == TRUE )
					{
						NS_ReleaseGraphImage( &FileAlphaImage ) ;
						FileAlphaLoad = FALSE ;
					}

					// 画像をファイルからロードした場合は画像をロードする
		//			DXST_ERRORLOGFMT_ADD(( _T( "i:%d フルパス:%s がロードできませんでした" ), i, Image2->FilePath )) ;
		//			DXST_ERRORLOGFMT_ADD(( _T( "ファイル:%s をロードします" ), Image2->FilePath->String )) ;
		//			DXST_ERRORLOGFMT_ADD(( _T( "反転フラグ:%d  ファイル:%s をロードします" ), Image2->ReadBase->ReverseFlag, Image2->ReadBase->FileName )) ;
					LoadHr = NS_CreateGraphImage_plus_Alpha(
								Image2->ReadBase->FileName,
								NULL,
								0,
								LOADIMAGE_TYPE_FILE, 
								NULL,
								0,
								LOADIMAGE_TYPE_FILE,
								&FileRgbImage,
								&FileAlphaImage,
								Image2->ReadBase->ReverseFlag ) ;
					if( LoadHr == -1 )
					{
						DXST_ERRORLOGFMT_ADD(( _T( "ファイル:%s がロードできませんでした" ), Image2->ReadBase->FileName )) ;
						goto R1 ;
					}

					FileRgbLoad = TRUE ;
					if( LoadHr == 0 ) FileAlphaLoad = TRUE ;
				}

				// グラフィックの転送
		//		DXST_ERRORLOGFMT_ADD(( _T( "UseFileX:%d UseFileY:%d" ), Image2->UseFileX, Image2->UseFileY )) ;
				BltBmpOrGraphImageToGraphBase(
					NULL,
					NULL,
					NULL,
					FALSE,
					&FileRgbImage,
					FileAlphaLoad == TRUE ? &FileAlphaImage : NULL,
					Image2->UseBaseX,
					Image2->UseBaseY,
					Image2->HandleInfo.Handle,
					GBASE.NotUseTransColor ? FALSE : TRUE
				) ;
		R1 :
				FileBackImage2 = Image2 ;
			}
			else
			// メモリから読み込んだ場合はメモリから画像を復元する
			if( Image2->ReadBase->MemImage )
			{
				// 一つ前のグラフィックとメモリアドレスが同じ場合は読み込みをしない
				if( MemBackImage2 == NULL ||
					MemRgbLoad == FALSE ||
					Image2->ReadBase->MemImage != MemBackImage2->ReadBase->MemImage ||
					Image2->ReadBase->AlphaMemImage != MemBackImage2->ReadBase->AlphaMemImage ||
					Image2->ReadBase->ReverseFlag != MemBackImage2->ReadBase->ReverseFlag )
				{
					// BASEIMAGE の後始末
					if( MemRgbLoad == TRUE )
					{
						NS_ReleaseGraphImage( &MemRgbImage ) ;
						MemRgbLoad = FALSE ;
					}
					if( MemAlphaLoad == TRUE )
					{
						NS_ReleaseGraphImage( &MemAlphaImage ) ;
						MemAlphaLoad = FALSE ;
					}

					// 画像をメモリからロードした場合は画像をロードする
					LoadHr = NS_CreateGraphImage_plus_Alpha(
								NULL,
								Image2->ReadBase->MemImage,
								Image2->ReadBase->MemImageSize,
								LOADIMAGE_TYPE_MEM,
								Image2->ReadBase->AlphaMemImage,
								Image2->ReadBase->AlphaMemImageSize,
								LOADIMAGE_TYPE_MEM,
								&MemRgbImage,
								&MemAlphaImage,
								Image2->ReadBase->ReverseFlag ) ;
					if( LoadHr == -1 )
					{
						DXST_ERRORLOGFMT_ADD(( _T( "メモリからの画像データのローができませんでした" ) )) ;
						goto R2 ;
					}

					MemRgbLoad = TRUE ;
					if( LoadHr == 0 ) MemAlphaLoad = TRUE ;
				}

				// グラフィックの転送
				BltBmpOrGraphImageToGraphBase( 
					NULL,
					NULL,
					NULL,
					FALSE,
					&MemRgbImage,
					MemAlphaLoad == TRUE ? &MemAlphaImage : NULL,
					Image2->UseBaseX,
					Image2->UseBaseY,
					Image2->HandleInfo.Handle,
					GBASE.NotUseTransColor ? FALSE : TRUE
				) ;
		R2 :
				MemBackImage2 = Image2 ;
			}
			else
			// BaseImage から読み込んだ場合は BaseImage から画像を復元する
			if( Image2->ReadBase->BaseImage )
			{
				// グラフィックの転送
				BltBmpOrGraphImageToGraphBase( 
					NULL,
					NULL,
					NULL,
					FALSE,
					Image2->ReadBase->BaseImage,
					Image2->ReadBase->AlphaBaseImage,
					Image2->UseBaseX,
					Image2->UseBaseY,
					Image2->HandleInfo.Handle,
					GBASE.NotUseTransColor ? FALSE : TRUE
				) ;
			}
		}
	}

	// GraphImage の後始末
	if( FileRgbLoad == TRUE )
	{
		NS_ReleaseGraphImage( &FileRgbImage ) ;
		FileRgbLoad = FALSE ;
	}
	if( FileAlphaLoad == TRUE )
	{
		NS_ReleaseGraphImage( &FileAlphaImage ) ;
		FileAlphaLoad = FALSE ;
	}
	if( MemRgbLoad == TRUE )
	{
		NS_ReleaseGraphImage( &MemRgbImage ) ;
		MemRgbLoad = FALSE ;
	}
	if( MemAlphaLoad == TRUE )
	{
		NS_ReleaseGraphImage( &MemAlphaImage ) ;
		MemAlphaLoad = FALSE ;
	}

	DXST_ERRORLOG_ADD( _T( "グラフィックの復帰が完了しました\n" ) ) ;
}

// グラフィックハンドルに画像データを転送するための関数
static int BltBmpOrBaseImageToGraph3(
	const COLORDATA	*BmpColorData,
	HBITMAP		RgbBmp,
	HBITMAP		AlphaBmp,
	const RECT	*SrcRect,
	int			DestX,
	int			DestY,
	int			GrHandle,
	int			BmpFlag,
	const BASEIMAGE	*RgbImage,
	const BASEIMAGE	*AlphaImage,
	int			RedIsAlphaFlag,
	int			UseTransColorConvAlpha,
	int			TargetOrig,
	int			ASyncThread
)
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_ORIG *Orig ;
	IMAGEDATA2_ORIG_HARD_TEX *OrigTex ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	int i, j, Width, Height ;
	int ImageNum ;
	int UseSysMemTex = -1 ;
	POINT DestPoint ;
	RECT DestRect, MovRect ;
	COLORDATA *DestColor ;
#ifdef __WINDOWS__
	BITMAP Bmp ;
#endif // __WINDOWS__
	BASEIMAGE TempBaseRGB, TempBaseAlpha = { 0 } ;
	int RequiredReleaseBaseRGB = FALSE ;
	int RequiredReleaseBaseAlpha = FALSE ;
	D_D3DLOCKED_RECT LockRect ;
	DX_DIRECT3DBASETEXTURE9 *UseTex ;
	DX_DIRECT3DSURFACE9 *SMSurface[ CUBEMAP_SURFACE_NUM ] = { 0 } ;

	if( GRA2.InitializeFlag == FALSE ) return -1 ;

	// エラー判定
	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
			return -1 ;
	}
	else
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
	}
	Orig = Image2->Orig ;

	// 頂点を描画しておく
	RenderVertexHardware( ASyncThread ) ;

	// 転送幅を計算しておく
	Width = SrcRect->right - SrcRect->left ;
	Height = SrcRect->bottom - SrcRect->top ;
	if( Width <= 0 || Height <= 0 ) return 0 ;

	// 転送元の情報をセット
	TempBaseAlpha.GraphData = NULL ;
	RequiredReleaseBaseRGB = FALSE ;
	RequiredReleaseBaseAlpha = FALSE ;
	if( BmpFlag )
	{
#ifdef __WINDOWS__
		// Bitmap の場合
		GetObject( RgbBmp, sizeof( BITMAP ), ( void * )&Bmp ) ;
		TempBaseRGB.GraphData = Bmp.bmBits ;
		TempBaseRGB.Width = Bmp.bmWidth ;
		TempBaseRGB.Height = Bmp.bmHeight ;
		TempBaseRGB.Pitch = Bmp.bmWidthBytes ;
		TempBaseRGB.Pitch = ( TempBaseRGB.Pitch + 3 ) / 4 * 4 ;
		TempBaseRGB.ColorData = *BmpColorData ;
		TempBaseRGB.MipMapCount = 0 ;
		TempBaseRGB.GraphDataCount = 0 ;

		if( AlphaBmp )
		{
			GetObject( AlphaBmp, sizeof( BITMAP ), ( void * )&Bmp ) ;
			TempBaseAlpha.GraphData = Bmp.bmBits ;
			TempBaseAlpha.Width = Bmp.bmWidth ;
			TempBaseAlpha.Height = Bmp.bmHeight ;
			TempBaseAlpha.Pitch = Bmp.bmWidthBytes ;
			TempBaseAlpha.Pitch = ( TempBaseAlpha.Pitch + 3 ) / 4 * 4 ;
			TempBaseAlpha.ColorData = *BmpColorData ;
			TempBaseAlpha.MipMapCount = 0 ;
			TempBaseAlpha.GraphDataCount = 0 ;
		}
#else // __WINDOWS__
		return -1 ;
#endif // __WINDOWS__
	}
	else
	{
		// BASEIMAGE の場合
		TempBaseRGB.GraphData = RgbImage->GraphData ;
		TempBaseRGB.Width = RgbImage->Width ;
		TempBaseRGB.Height = RgbImage->Height ;
		TempBaseRGB.Pitch = RgbImage->Pitch ;
		TempBaseRGB.ColorData = RgbImage->ColorData ;
		TempBaseRGB.MipMapCount = RgbImage->MipMapCount ;
		TempBaseRGB.GraphDataCount = RgbImage->GraphDataCount ;

		if( AlphaImage )
		{
			TempBaseAlpha.GraphData = AlphaImage->GraphData ;
			TempBaseAlpha.Width = AlphaImage->Width ;
			TempBaseAlpha.Height = AlphaImage->Height ;
			TempBaseAlpha.Pitch = AlphaImage->Pitch ;
			TempBaseAlpha.ColorData = AlphaImage->ColorData ;
			TempBaseAlpha.MipMapCount = AlphaImage->MipMapCount ;
			TempBaseAlpha.GraphDataCount = AlphaImage->GraphDataCount ;
		}
	}

	// 転送元がキューブマップで転送先がキューブマップではない場合はエラー
	if( ( TempBaseRGB.GraphDataCount != 0 ) != ( Orig->FormatDesc.CubeMapTextureFlag != 0 ) )
		return -1 ;

	// イメージの数をセット
	ImageNum = TempBaseRGB.GraphDataCount == 0 ? 1 : TempBaseRGB.GraphDataCount ;

	// BASEIMAGE が DXT で、転送先が DXT では無い場合はここで標準フォーマットに変換する
	{
		int Flag1 = FALSE ;
		int Flag2 = FALSE ;
		int Hr1 = 0, Hr2 = 0 ;

		if( Orig->FormatDesc.TextureFlag )
		{
			if( ( TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT1 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT1 ) ||
				( TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT2 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT2 ) ||
				( TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT3 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT3 ) ||
				( TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT4 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT4 ) ||
				( TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT5 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT5 ) )
			{
				Flag1 = TRUE ;
			}

			if( TempBaseAlpha.GraphData != NULL )
			{
				if( ( TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT1 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT1 ) ||
					( TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT2 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT2 ) ||
					( TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT3 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT3 ) ||
					( TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT4 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT4 ) ||
					( TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT5 && GRH.TextureFormat[ Orig->ColorFormat ] != D_D3DFMT_DXT5 ) )
				{
					Flag2 = TRUE ;
				}
			}
		}
		else
		{
			if( TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT1 ||
				TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT2 ||
				TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT3 ||
				TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT4 ||
				TempBaseRGB.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT5 )
			{
				Flag1 = TRUE ;
			}

			if( TempBaseAlpha.GraphData != NULL )
			{
				if( TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT1 ||
					TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT2 ||
					TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT3 ||
					TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT4 ||
					TempBaseAlpha.ColorData.Format == DX_BASEIMAGE_FORMAT_DXT5 )
				{
					Flag2 = TRUE ;
				}
			}
		}

		if( Flag1 == TRUE )
		{
			Hr1 = ConvertNormalFormatBaseImage( &TempBaseRGB ) ;
			if( Hr1 == 0 )
			{
				RequiredReleaseBaseRGB = TRUE ;
			}
		}

		if( Flag2 == TRUE )
		{
			Hr2 = ConvertNormalFormatBaseImage( &TempBaseAlpha ) ;
			if( Hr2 == 0 )
			{
				RequiredReleaseBaseAlpha = TRUE ;
			}
		}

		if( Hr1 < 0 || Hr2 < 0 )
		{
			DXST_ERRORLOG_ADD( _T( "標準イメージ用のメモリ確保に失敗しました\n" ) ) ;
			goto ERR ;
		}
	}

	// テクスチャかどうかで処理を分岐
	if( Orig->FormatDesc.TextureFlag )
	{
		// テクスチャの場合

		// 描画を終わらせておく
//		RenderVertexHardware() ;
//		EndScene() ;
		if( GraphicsDevice_IsValid() == 0 )
			goto ERR ;

		// テクスチャのカラー情報を取得する
		DestColor = GetD3DFormatColorData( GRH.TextureFormat[ Orig->ColorFormat ] ) ;

		// 転送位置のセット
		DestPoint.x = 0 ;
		DestPoint.y = 0 ;

		// 描画可能画像の場合は転送する画像情報と同じ大きさのシステムメモリサーフェスに内容を転送する
		if( Orig->FormatDesc.DrawValidFlag )
		{
			for( i = 0 ; i < ImageNum ; i ++ )
			{
				if( GraphicsDevice_CreateOffscreenPlainSurface_ASync( Width, Height, GRH.TextureFormat[ Orig->ColorFormat ], D_D3DPOOL_SYSTEMMEM, &SMSurface[ i ], NULL, ASyncThread ) != D_D3D_OK )
				{
					DXST_ERRORLOG_ADD( _T( "画像転送用のシステムメモリテクスチャの作成に失敗しました\n" ) ) ;
					goto ERR ;
				}

				// システムメモリサーフェスをロック
				GraphicsSurface_LockRect_ASync( SMSurface[ i ], &LockRect, NULL, D_D3DLOCK_DISCARD, ASyncThread ) ;

				// 内容を転送
				MovRect.left   = 0 ;
				MovRect.top    = 0 ;
				MovRect.right  = Width ;
				MovRect.bottom = Height ;
				NS_GraphColorMatchBltVer2(
					LockRect.pBits,                                                                LockRect.Pitch,                DestColor,
					( BYTE * )TempBaseRGB.GraphData   + TempBaseRGB.Pitch   * TempBaseRGB.Height   * i,   TempBaseRGB.Pitch,   &TempBaseRGB.ColorData,
					( BYTE * )TempBaseAlpha.GraphData + TempBaseAlpha.Pitch * TempBaseAlpha.Height * i, TempBaseAlpha.Pitch, &TempBaseAlpha.ColorData,
					DestPoint, &MovRect, FALSE,
					UseTransColorConvAlpha && ( DestColor->AlphaWidth != 0 && TempBaseAlpha.GraphData == NULL ), Orig->TransCode,
					BASEIM.ImageShavedMode, FALSE,
					RedIsAlphaFlag, FALSE,
					FALSE ) ;

				// システムメモリサーフェスのロックを解除
				GraphicsSurface_UnlockRect_ASync( SMSurface[ i ], ASyncThread ) ;
			}
		}

		// 転送対象がオリジナル画像に対してかどうかで処理を分岐
		if( TargetOrig == TRUE )
		{
			// オリジナル画像に対しての場合

			// テクスチャの数だけ繰り返し
			OrigTex = Orig->Hard.Tex ;
			for( i = 0 ; i < Orig->Hard.TexNum ; i ++, OrigTex ++ )
			{
				// 範囲外だったら何もしない
				if( OrigTex->OrigPosX >= DestX + Width  ||
					OrigTex->OrigPosY >= DestY + Height ||
					DestX >= OrigTex->OrigPosX + OrigTex->UseWidth ||
					DestY >= OrigTex->OrigPosY + OrigTex->UseHeight ) continue ;

				// ロックする転送範囲と転送する範囲の確定
				if( OrigTex->OrigPosX > DestX )
				{
					DestRect.left = 0 ;
					MovRect.left = OrigTex->OrigPosX - DestX ;
				}
				else
				{
					DestRect.left = DestX - OrigTex->OrigPosX ;
					MovRect.left = 0 ;
				}

				if( OrigTex->OrigPosX + OrigTex->UseWidth < DestX + Width )
				{
					DestRect.right = OrigTex->UseWidth ;
					MovRect.right = ( OrigTex->OrigPosX + OrigTex->UseWidth ) - DestX ;
				}
				else
				{
					DestRect.right = ( DestX + Width ) - OrigTex->OrigPosX ;
					MovRect.right = Width ;
				}

				if( OrigTex->OrigPosY > DestY )
				{
					DestRect.top = 0 ;
					MovRect.top = OrigTex->OrigPosY - DestY ;
				}
				else
				{
					DestRect.top = DestY - OrigTex->OrigPosY ;
					MovRect.top = 0 ;
				}

				if( OrigTex->OrigPosY + OrigTex->UseHeight < DestY + Height )
				{
					DestRect.bottom = OrigTex->UseHeight ;
					MovRect.bottom = ( OrigTex->OrigPosY + OrigTex->UseHeight ) - DestY ;
				}
				else
				{
					DestRect.bottom = ( DestY + Height ) - OrigTex->OrigPosY ;
					MovRect.bottom = Height ;
				}

				// 元画像の転送領域値を加算
				MovRect.left   += SrcRect->left ;
				MovRect.top    += SrcRect->top ;
				MovRect.right  += SrcRect->left ;
				MovRect.bottom += SrcRect->top ;

				// 描画可能画像かどうかで処理を分岐
				if( Orig->FormatDesc.DrawValidFlag == TRUE )
				{
					// 描画可能画像の場合

					// 内容を転送
					DestPoint.x = DestRect.left ;
					DestPoint.y = DestRect.top ;
					for( j = 0 ; j < ImageNum ; j ++ )
					{
						GraphicsDevice_UpdateSurface_ASync(
							SMSurface[ j ],			&MovRect,
							OrigTex->Surface[ j ],	&DestPoint, ASyncThread ) ;
					}
					if( OrigTex->RenderTargetSurface )
					{
						GraphicsDevice_UpdateSurface_ASync(
							SMSurface[ 0 ],					&MovRect,
							OrigTex->RenderTargetSurface,	&DestPoint, ASyncThread ) ;
					}
				}
				else
				{
					int FullUpdate ;

					// 描画不可能画像の場合

					// 全体転送かどうかを調べる
					if( DestRect.right  - DestRect.left == OrigTex->TexWidth &&
						DestRect.bottom - DestRect.top  == OrigTex->TexHeight )
					{
						FullUpdate = TRUE ;
					}
					else
					{
						FullUpdate = FALSE ;
					}

					// 使用するテクスチャのセット
					//UseTex = Orig->FormatDesc.UseManagedTextureFlag == FALSE ? OrigTex->MemTexture : OrigTex->Texture ;
					if( FullUpdate && Orig->FormatDesc.UseManagedTextureFlag == FALSE )
					{
						for(;;)
						{
							UseSysMemTex = GetSysMemTextureFromOrig( Orig, OrigTex, ASyncThread ) ;
							if( UseSysMemTex != -1 ) break ;
							if( NS_ProcessMessage() != 0 ) break ;
							Thread_Sleep( 1 ) ;
						}
						if( UseSysMemTex == -1 )
						{
							goto ERR ;
						}
						UseTex = GRH.SysMemTexture[ UseSysMemTex ].MemTexture ;
					}
					else
					{
						UseSysMemTex = -1 ;
						UseTex = OrigTex->Texture ;
					}

					// ミップマップかどうかで処理を分岐
					if( Orig->Hard.MipMapCount > 1 )
					{
						if( BltBmpOrBaseImageToGraph3_MipMapBlt(
								Orig,
								&MovRect,
								&DestRect,
								FullUpdate == FALSE && Orig->FormatDesc.UseManagedTextureFlag == FALSE,
								UseTex,
								OrigTex->TexWidth,
								OrigTex->TexHeight,
								&TempBaseRGB,
								&TempBaseAlpha,
								DestColor,
								RedIsAlphaFlag,
								UseTransColorConvAlpha,
								ASyncThread ) < 0 )
							goto ERR ;
					}
					else
					{
						if( BltBmpOrBaseImageToGraph3_NoMipMapBlt(
								Orig,
								&MovRect,
								&DestRect,
								FullUpdate == FALSE && Orig->FormatDesc.UseManagedTextureFlag == FALSE,
								UseTex,
								OrigTex->TexWidth,
								OrigTex->TexHeight,
								OrigTex->UseWidth,
								OrigTex->UseHeight,
								&TempBaseRGB,
								&TempBaseAlpha,
								DestColor,
								RedIsAlphaFlag,
								UseTransColorConvAlpha,
								ASyncThread ) < 0 )
							goto ERR ;
					}

					// 管理テクスチャではない場合はここで転送用のシステムメモリテクスチャを解放する
					if( FullUpdate && Orig->FormatDesc.UseManagedTextureFlag == FALSE )
					{
						if( Orig->FormatDesc.CubeMapTextureFlag )
						{
							GraphicsDevice_UpdateTexture_ASync( UseTex, OrigTex->CubeTexture, ASyncThread ) ;
						}
						else
						{
							GraphicsDevice_UpdateTexture_ASync( UseTex, OrigTex->Texture, ASyncThread ) ;
						}
						ReleaseSysMemTexture( UseSysMemTex, ASyncThread ) ;
						UseSysMemTex = -1 ;
					}
				}
			}
		}
		else
		{
			// オリジナル画像に対してではない場合

			// 描画情報の数だけ繰り返し
			DrawTex = Image2->Hard.Draw ;
			DestPoint.x = 0 ;
			DestPoint.y = 0 ;
			for( i = 0 ; i < Image2->Hard.DrawNum ; i ++, DrawTex ++ )
			{
				// 範囲外だったら何もしない
				if( DrawTex->DrawPosX >= DestX + Width ||
					DrawTex->DrawPosY >= DestY + Height ||
					DestX >= DrawTex->DrawPosX + DrawTex->Width ||
					DestY >= DrawTex->DrawPosY + DrawTex->Height ) continue ;

				// ロックする転送範囲と転送する範囲の確定
				if( DrawTex->DrawPosX > DestX )
				{
					DestRect.left = 0 ;
					MovRect.left = DrawTex->DrawPosX - DestX ;
				}
				else
				{
					DestRect.left = DestX - DrawTex->DrawPosX ;
					MovRect.left = 0 ;
				}

				if( DrawTex->DrawPosX + DrawTex->Width < DestX + Width )
				{
					DestRect.right = DrawTex->Width ;
					MovRect.right = ( DrawTex->DrawPosX + DrawTex->Width ) - DestX ;
				}
				else
				{
					DestRect.right = ( DestX + Width ) - DrawTex->DrawPosX ;
					MovRect.right = Width ;
				}

				if( DrawTex->DrawPosY > DestY )
				{
					DestRect.top = 0 ;
					MovRect.top = DrawTex->DrawPosY - DestY ;
				}
				else
				{
					DestRect.top = DestY - DrawTex->DrawPosY ;
					MovRect.top = 0 ;
				}

				if( DrawTex->DrawPosY + DrawTex->Height < DestY + Height )
				{
					DestRect.bottom = DrawTex->Height ;
					MovRect.bottom = ( DrawTex->DrawPosY + DrawTex->Height ) - DestY ;
				}
				else
				{
					DestRect.bottom = ( DestY + Height ) - DrawTex->DrawPosY ;
					MovRect.bottom = Height ;
				}

				// テクスチャの指定領域値を加算
				DestRect.left   += DrawTex->UsePosX ;
				DestRect.top    += DrawTex->UsePosY ;
				DestRect.right  += DrawTex->UsePosX ;
				DestRect.bottom += DrawTex->UsePosY ;

				// 元画像の転送領域値を加算
				MovRect.left   += SrcRect->left ;
				MovRect.top    += SrcRect->top ;
				MovRect.right  += SrcRect->left ;
				MovRect.bottom += SrcRect->top ;

				// 描画可能画像かどうかで処理を分岐
				if( Orig->FormatDesc.DrawValidFlag == TRUE )
				{
					// 描画可能画像の場合

					// 内容を転送
					DestPoint.x = DestRect.left ;
					DestPoint.y = DestRect.top ;
					for( j = 0 ; j < ImageNum ; j ++ )
					{
						if( GraphicsDevice_UpdateSurface_ASync(
								SMSurface[ j ],             &MovRect,
								DrawTex->Tex->Surface[ j ], &DestPoint, ASyncThread ) != D_D3D_OK )
						{
							DXST_ERRORLOG_ADD( _T( "描画可能テクスチャへの画像の転送に失敗しました\n" ) ) ;
							goto ERR ;
						}
					}
				}
				else
				{
					int FullUpdate ;

					// 描画不可能画像の場合

					// 全体転送かどうかを調べる
					if( DestRect.right  - DestRect.left == DrawTex->Tex->TexWidth &&
						DestRect.bottom - DestRect.top  == DrawTex->Tex->TexHeight )
					{
						FullUpdate = TRUE ;
					}
					else
					{
						FullUpdate = FALSE ;
					}

					// 使用するテクスチャのセット
					//UseTex = Orig->FormatDesc.UseManagedTextureFlag == FALSE ? DrawTex->Tex->MemTexture : DrawTex->Tex->Texture ;
					if( FullUpdate && Orig->FormatDesc.UseManagedTextureFlag == FALSE )
					{
						for(;;)
						{
							UseSysMemTex = GetSysMemTextureFromOrig( Orig, DrawTex->Tex, ASyncThread ) ;
							if( UseSysMemTex != -1 ) break ;
							if( NS_ProcessMessage() != 0 ) break ;
							Thread_Sleep( 1 ) ;
						}
						if( UseSysMemTex == -1 )
						{
							goto ERR ;
						}
						UseTex = GRH.SysMemTexture[ UseSysMemTex ].MemTexture ;
					}
					else
					{
						UseTex = DrawTex->Tex->Texture ;
						UseSysMemTex = -1 ;
					}

					// ミップマップかどうかで処理を分岐
					if( Orig->Hard.MipMapCount > 1 )
					{
						if( BltBmpOrBaseImageToGraph3_MipMapBlt(
								Orig,
								&MovRect,
								&DestRect,
								FullUpdate == FALSE && Orig->FormatDesc.UseManagedTextureFlag == FALSE,
								UseTex,
								DrawTex->Tex->TexWidth,
								DrawTex->Tex->TexHeight,
								&TempBaseRGB,
								&TempBaseAlpha,
								DestColor,
								RedIsAlphaFlag,
								UseTransColorConvAlpha,
								ASyncThread ) < 0 )
							goto ERR ;
					}
					else
					{
						if( BltBmpOrBaseImageToGraph3_NoMipMapBlt(
								Orig,
								&MovRect,
								&DestRect,
								FullUpdate == FALSE && Orig->FormatDesc.UseManagedTextureFlag == FALSE,
								UseTex,
								DrawTex->Tex->TexWidth,
								DrawTex->Tex->TexHeight,
								DrawTex->Tex->UseWidth,
								DrawTex->Tex->UseHeight,
								&TempBaseRGB,
								&TempBaseAlpha,
								DestColor,
								RedIsAlphaFlag,
								UseTransColorConvAlpha,
								ASyncThread ) < 0 )
							goto ERR ;
					}

					// 管理テクスチャではない場合はここで転送用のシステムメモリテクスチャを解放する
					if( FullUpdate && Orig->FormatDesc.UseManagedTextureFlag == FALSE )
					{
						if( Orig->FormatDesc.CubeMapTextureFlag )
						{
							GraphicsDevice_UpdateTexture_ASync( UseTex, DrawTex->Tex->CubeTexture, ASyncThread ) ;
						}
						else
						{
							GraphicsDevice_UpdateTexture_ASync( UseTex, DrawTex->Tex->Texture, ASyncThread ) ;
						}
						ReleaseSysMemTexture( UseSysMemTex, ASyncThread ) ;
						UseSysMemTex = -1 ;
					}
				}
			}
		}
	}
	else
	{
		// テクスチャではない場合

		// MEMIMG の転送処理関数を使うための準備を行う

		// オリジナル画像が対象かどうかで処理を分岐
		if( TargetOrig == TRUE )
		{
			// オリジナル画像が対象の場合

			// サイズの補正
			if( DestX + Width  > ( int )Orig->Soft.MemImg.Width  ) Width  = Orig->Soft.MemImg.Width  - DestX ;
			if( DestY + Height > ( int )Orig->Soft.MemImg.Height ) Height = Orig->Soft.MemImg.Height - DestY ;
			if( Width <= 0 || Height <= 0 )
				goto ERR ;

			// 画像の転送
			BltBaseImageToMemImg(
				&TempBaseRGB, TempBaseAlpha.GraphData == NULL ? NULL : &TempBaseAlpha, &Orig->Soft.MemImg,
				SrcRect->left, SrcRect->top,
				Width, Height,
				DestX, DestY, UseTransColorConvAlpha ) ;
		}
		else
		{
			// オリジナル画像が対象ではない場合

			// サイズの補正
			if( DestX + Width  > Image2->Width  ) Width  = Image2->Width  - DestX ;
			if( DestY + Height > Image2->Height ) Height = Image2->Height - DestY ;
			if( Width <= 0 || Height <= 0 ) 
				goto ERR ;

			// 画像の転送
			BltBaseImageToMemImg(
				&TempBaseRGB, TempBaseAlpha.GraphData == NULL ? NULL : &TempBaseAlpha, &Orig->Soft.MemImg,
				SrcRect->left, SrcRect->top,
				Width, Height,
				Image2->UseOrigX + DestX, Image2->UseOrigY + DestY, UseTransColorConvAlpha ) ;
		}

		// パレット画像の場合は透過色コードを調整
		if( Orig->FormatDesc.UsePaletteFlag == TRUE && Orig->Soft.MemImg.Base->Palette )
		{
			int i ;
			DWORD TransCode ;

			// 透過色の取得
			TransCode = NS_GetColor3( 
					GetMemImgColorData( Orig->FormatDesc.ColorBitDepth == 16 ? 0 : 1, Orig->FormatDesc.AlphaChFlag, FALSE ),
					( GBASE.TransColor >> 16 ) & 0xff,
					( GBASE.TransColor >> 8  ) & 0xff,
					( GBASE.TransColor >> 0  ) & 0xff,
					0xff ) ;

			// 指定のカラーがパレットの中にあったらそれを透過色にする
			if( Orig->Soft.MemImg.Base->ColorType == 1 )
			{
				TransCode &= 0xffffff;
				for( i = 0 ; i < 256 ; i ++ )
					if( ( Orig->Soft.MemImg.Base->Palette[i] & 0xffffff ) == TransCode ) break ;
			}
			else
			{
				TransCode &= 0xffff;
				for( i = 0 ; i < 256 ; i ++ )
					if( ((WORD *)Orig->Soft.MemImg.Base->Palette)[i] == TransCode ) break ;
			}
			if( i == 256 ) i = 0 ;
			Orig->Soft.MemImg.Base->TransColor = i ;
		}
	}

	if( RequiredReleaseBaseRGB )
	{
		ReleaseBaseImage( &TempBaseRGB ) ;
	}

	if( RequiredReleaseBaseAlpha )
	{
		ReleaseBaseImage( &TempBaseAlpha ) ;
	}

	for( i = 0 ; i < CUBEMAP_SURFACE_NUM ; i ++ )
	{
		if( SMSurface[ i ] != NULL )
		{
			Graphics_ObjectRelease_ASync( SMSurface[ i ], ASyncThread ) ;
			SMSurface[ i ] = NULL ;
		}
	}

	if( UseSysMemTex != -1 )
	{
		ReleaseSysMemTexture( UseSysMemTex, ASyncThread ) ;
		UseSysMemTex = -1 ;
	}

	// 終了
	return 0 ;

	// エラー終了
ERR :

	if( RequiredReleaseBaseRGB )
	{
		ReleaseBaseImage( &TempBaseRGB ) ;
	}

	if( RequiredReleaseBaseAlpha )
	{
		ReleaseBaseImage( &TempBaseAlpha ) ;
	}

	for( i = 0 ; i < CUBEMAP_SURFACE_NUM ; i ++ )
	{
		if( SMSurface[ i ] != NULL )
		{
			Graphics_ObjectRelease_ASync( SMSurface[ i ], ASyncThread ) ;
			SMSurface[ i ] = NULL ;
		}
	}

	if( UseSysMemTex != -1 )
	{
		ReleaseSysMemTexture( UseSysMemTex, ASyncThread ) ;
		UseSysMemTex = -1 ;
	}

	return -1 ;
}



// ソフトウエアレンダリングの初期化を行う
static int InitializeSoftware()
{
	// メイン画面用 MEMIMG の作成
	if( MakeMemImgScreen( &GRS.MainBufferMemImg, GRA2.MainScreenSizeX, GRA2.MainScreenSizeY,
							GRA2.MainScreenColorBitDepth == 16 ? 0 : 1 ) < 0 )
		return DxLib_Error( DXSTRING( _T( "プライマリサーフェス用の MEMIMG の作成に失敗しました\n" ) ) ) ;

	// フォントの半透明描画用アルファつき画像の作成
	_MEMSET( &GRS.FontScreenMemImgAlpha, 0, sizeof( MEMIMG ) ) ;
	_MEMSET( &GRS.FontScreenMemImgNormal, 0, sizeof( MEMIMG ) ) ;
	InitializeMemImg(
		&GRS.FontScreenMemImgNormal,
		GRA2.MainScreenSizeX,
		GRA2.MainScreenSizeY,
		-1,
		0,
		GRA2.MainScreenColorBitDepth == 16 ? 0 : 1,
		FALSE, FALSE, FALSE, NULL ) ;
	InitializeMemImg(
		&GRS.FontScreenMemImgAlpha,
		GRA2.MainScreenSizeX,
		GRA2.MainScreenSizeY,
		-1,
		0,
		GRA2.MainScreenColorBitDepth == 16 ? 0 : 1,
		FALSE, TRUE, FALSE, NULL ) ;

	// バッファのクリア
	ClearMemImg( &GRS.MainBufferMemImg, NULL, NS_GetColor3( GRS.MainBufferMemImg.Base->ColorDataP, GRA2.BackgroundRed, GRA2.BackgroundGreen, GRA2.BackgroundBlue, 0 ) ) ;

	// 描画対象のセット
	GRS.TargetMemImg = &GRS.MainBufferMemImg ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリングの後始末を行う
static int	TerminateSoftware()
{
	// メインバッファの解放
	TerminateMemImg( &GRS.MainBufferMemImg ) ;

	// フォントの半透明描画用アルファつき画像の解放
	TerminateMemImg( &GRS.FontScreenMemImgNormal ) ;
	TerminateMemImg( &GRS.FontScreenMemImgAlpha ) ;

	// 終了
	return 0 ;
}












// ビギンシーンを行う
extern void BeginScene( void )
{
	if( Graphics_IsValid() == 0 || GRH.BeginSceneFlag == TRUE ) return ;

	GraphicsDevice_BeginScene() ;
	GRH.BeginSceneFlag = TRUE ;

	GRH.DrawPrepFormat    = NULL ;
	GRH.DrawPrepTexture   = NULL ;
	GRH.DrawPrepParamFlag = 0 ;
}

// エンドシーンを行う
extern void EndScene( void )
{
	if( Graphics_IsValid() == 0 || GRH.BeginSceneFlag == FALSE ) return ;

	GraphicsDevice_EndScene() ;
	GRH.BeginSceneFlag = FALSE ;
}

// フォーマット情報をセットアップする
static int SetupFormatDesc( 
	IMAGEFORMATDESC *Format,
	SETUP_GRAPHHANDLE_GPARAM *GParam,
	int Width,
	int Height,
	int AlphaValidFlag,
	int UsePaletteFlag,
	int BaseFormat,
	int MipMapCount
)
{
	// フォーマット情報を初期化
	_MEMSET( Format, 0, sizeof( *Format ) ) ;

	// テクスチャフォーマットかどうかをセット
	Format->TextureFlag = ( unsigned char )GRA2.ValidHardWare ;

	// DirectX が管理するテクスチャにしないかどうかをセット
	Format->UseManagedTextureFlag = ( unsigned char )GParam->UseManagedTextureFlag ;

	// キューブマップかどうかをセット
	Format->CubeMapTextureFlag = ( unsigned char )GParam->CubeMapTextureCreateFlag ;

	// 基本フォーマットのセット
	Format->BaseFormat = ( unsigned char )BaseFormat ;

	// ミップマップの数を保存
	if( MipMapCount != -1 )
	{
		Format->MipMapCount = ( unsigned char )MipMapCount ;
	}
	else
	{
		if( GParam->MipMapCount == -1 )
		{
			int tx, ty ;

			tx = Width ;
			ty = Height ;
			Format->MipMapCount = 1 ;
			for(;;)
			{
				if( tx == 1 && ty == 1 ) break ;
				Format->MipMapCount ++ ;
				tx /= 2 ;
				ty /= 2 ;
				if( tx == 0 ) tx = 1 ;
				if( ty == 0 ) ty = 1 ;
			}
		}
		else
		{
			Format->MipMapCount = GParam->MipMapCount == 0 ? 1 : ( unsigned char )GParam->MipMapCount ;
		}
	}

	// 描画可能画像かどうかで処理を分岐
	if( GParam->DrawValidImageCreateFlag == TRUE )
	{
		// 描画可能な場合はアルファテスト、ブレンドグラフィックは無しで、
		// アルファチャンネルが着くかどうかは GBASE.DrawValidAlphaImageCreateFlag の値に従う
		// 基本フォーマットは強制的に DX_BASEIMAGE_FORMAT_NORMAL
		Format->DrawValidFlag = TRUE ;
		Format->AlphaChFlag = ( unsigned char )GParam->DrawValidAlphaImageCreateFlag ;
		Format->AlphaTestFlag = FALSE ;		// 描画可能な場合はアルファテストは無し
		Format->BlendGraphFlag = FALSE ;		// 描画可能な場合はブレンド画像も無し
		Format->UseManagedTextureFlag = FALSE ;
		Format->MipMapCount = 1 ;
		Format->MSSamples = ( unsigned char )GParam->DrawValidMSSamples ;
		Format->MSQuality = ( unsigned char )GParam->DrawValidMSQuality ;
	}
	else
	{
		// 描画可能指定が無い場合はアルファチャンネルを付けるかどうかは引数に
		// アルファテストを付けるかどうかは GBASE.AlphaTestImageCreateFlag に
		// ブレンド画像にするかどうかは GBASE.BlendImageCreateFlag に従う
		Format->DrawValidFlag = FALSE ;
		Format->AlphaChFlag = ( unsigned char )AlphaValidFlag ;
		Format->AlphaTestFlag = ( unsigned char )GParam->AlphaTestImageCreateFlag ;
		Format->BlendGraphFlag = ( unsigned char )GParam->BlendImageCreateFlag ;
	}

	// テクスチャかどうかで処理を分岐
	if( Format->TextureFlag == TRUE )
	{
		// テクスチャの場合

		// カラービット深度の決定
		Format->ColorBitDepth = ( unsigned char )( GParam->CreateImageColorBitDepth == 0 ? ( AlphaValidFlag == TRUE ? 32 : GRA2.MainScreenColorBitDepth ) : GParam->CreateImageColorBitDepth ) ;
		Format->ChannelNum = 0 ;
		Format->ChannelBitDepth = 0 ;
		Format->FloatTypeFlag = FALSE ;
		Format->SystemMemFlag = FALSE ;

		// アルファチャンネルありの場合はアルファテストは無し
		if( Format->AlphaChFlag )
			Format->AlphaTestFlag = FALSE ;

		// ブレンド画像の場合はフォーマットは固定される
		if( Format->BlendGraphFlag == TRUE )
		{
			Format->ColorBitDepth = 32 ;
			Format->AlphaTestFlag = FALSE ;
			Format->AlphaChFlag   = TRUE ;
			Format->DrawValidFlag = FALSE ;
		}
		else
		// 描画可能画像の場合はチャンネル数とチャンネル辺りのビット数、浮動小数点型かどうかを設定する
		if( GParam->DrawValidImageCreateFlag == TRUE )
		{
			Format->ChannelNum      = ( unsigned char )GParam->CreateDrawValidGraphChannelNum ;
			Format->ChannelBitDepth = ( unsigned char )GParam->CreateImageChannelBitDepth ;
			Format->FloatTypeFlag   = ( unsigned char )GParam->DrawValidFloatTypeGraphCreateFlag ;
		}
	}
	else
	{
		// テクスチャではない場合
		Format->BaseFormat = DX_BASEIMAGE_FORMAT_NORMAL ;
		Format->ColorBitDepth = ( unsigned char )( GParam->CreateImageColorBitDepth == 0 ? GRA2.MainScreenColorBitDepth : GParam->CreateImageColorBitDepth ) ;
		Format->ChannelNum = 0 ;
		Format->ChannelBitDepth = 0 ;
		Format->FloatTypeFlag = FALSE ;
		Format->SystemMemFlag = TRUE ;
		Format->CubeMapTextureFlag = FALSE ;
		Format->UsePaletteFlag = ( unsigned char )UsePaletteFlag ;
		Format->UseManagedTextureFlag = FALSE ;		// DirectX の管理も無し
		Format->AlphaTestFlag = FALSE ;				// アルファテストは無し
		Format->DrawValidFlag = Format->BlendGraphFlag ? FALSE : TRUE ;	// 普通の画像の場合はブレンド画像ではなければ描画可能
		Format->MipMapCount = 0 ;
	}

	// 正常終了
	return 0 ;
}

// 描画先に正しいα値を書き込むかどうかのフラグを更新する
static	int RefreshAlphaChDrawMode( void )
{
	IMAGEDATA2 *Image2 ;
	int i ;
	int NextFlag ;

	NextFlag = FALSE ;

	// ０番以外にも描画先が設定されていた場合は通常モード
	for( i = 1 ; i < DX_RENDERTARGET_COUNT ; i ++ )
	{
		if( GBASE.TargetScreen[ i ] != 0 )
			goto END ;
	}

	// 描画先が通常画面の場合は何もしない
	if( GBASE.TargetScreen[ 0 ] == DX_SCREEN_BACK ||
		GBASE.TargetScreen[ 0 ] == DX_SCREEN_FRONT ||
		GBASE.TargetScreen[ 0 ] == DX_SCREEN_WORK ||
		GBASE.TargetScreen[ 0 ] == DX_SCREEN_TEMPFRONT )
		goto END ;

	// 描画先となっている画像が無効の場合は何もしない
	if( GRAPHCHKFULL( GBASE.TargetScreen[ 0 ], Image2 ) )
		goto END ;

	// 描画先の画像にαチャンネルが無い場合も何もしない
	if( Image2->Orig->FormatDesc.AlphaChFlag == FALSE )
		goto END ;
	
	// テクスチャではない場合は何もしない
	if( Image2->Orig->FormatDesc.TextureFlag == FALSE )
		goto END ;

	// ここに来たということは正確なαチャンネルの計算を行うということ
	NextFlag = TRUE ;

END :

	// テクスチャの保存
	if( NextFlag == TRUE )
	{
		IMAGEDATA2 *WorkImage2 ;
		int WorkTextureHandle ;

		WorkTextureHandle = GetWorkTexture( Image2->Orig->FormatDesc.FloatTypeFlag, Image2->Width, Image2->Height, 0 ) ;
		if( GRAPHCHK( WorkTextureHandle, WorkImage2 ) )
			return -1 ;

		GRH.RenderTargetTexture          = WorkImage2->Orig->Hard.Tex[ 0 ].Texture ;
		GRH.RenderTargetSurface          =     Image2->Orig->Hard.Tex[ 0 ].Surface[ 0 ] ;
		GRH.RenderTargetCopySurface      = WorkImage2->Orig->Hard.Tex[ 0 ].Surface[ 0 ] ;
		GRH.RenderTargetTextureInvWidth  = 1.0f / WorkImage2->Orig->Hard.Tex[ 0 ].TexWidth ;
		GRH.RenderTargetTextureInvHeight = 1.0f / WorkImage2->Orig->Hard.Tex[ 0 ].TexHeight ;
	}
	else
	{
		GRH.RenderTargetTexture = FALSE ;
	}

	// 以前とフラグの状態が異なる場合のみブレンドモードの更新も行う
	if( NextFlag != GBASE.AlphaChDrawMode )
	{
		// フラグの保存
		GBASE.AlphaChDrawMode = NextFlag ;
		GRH.ChangeBlendParamFlag = TRUE ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}

	// 終了
	return 0 ;
}

// グラフィックハンドルを初期化する
extern int SetupGraphHandle_UseGParam(
	SETUP_GRAPHHANDLE_GPARAM *GParam,
	int GrHandle,
	int Width,
	int Height,
	int /*TextureFlag*/,
	int AlphaValidFlag,
	int UsePaletteFlag,
	int BaseFormat,
	int MipMapCount,
	int ASyncThread
) 
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_ORIG *Orig ;
	int IsTex ;
	int DivXNum, DivYNum, DivNum ;
	short TexSizeX[ 256 ], TexSizeY[ 256 ] ;
	short TexPosX[ 256 ], TexPosY[ 256 ] ;
	short XList[ 32 ], YList[ 32 ] ;
	int XPos, YPos ;
	int AllocSize ;
	int i, j ;
	IMAGEDATA2_ORIG_HARD_TEX *OrigTex ;
	IMAGEFORMATDESC Format ;

	// アドレスの取得
	if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
		return -1 ;

	// テクスチャかどうかを決定する
//	IsTex = TextureFlag &&						// 関数の引数でテクスチャ作成指定があり
//	        GBASE.TextureImageCreateFlag &&		// グローバル設定でもテクスチャ作成指定があり
//			GRA2.ValidHardWare ;				// 且つ３Ｄ描画機能を備えている場合、テクスチャ
	IsTex = GRA2.ValidHardWare ;

	// フォーマット情報をセットする
	SetupFormatDesc( &Format, GParam, Width, Height, AlphaValidFlag, UsePaletteFlag, BaseFormat, MipMapCount ) ;

	// テクスチャの場合は何分割になるか調べる
	if( IsTex )
	{
		// 作成するテクスチャのサイズをリストアップ
//		DivXNum = ListUpTexSize( Width,  XList, Format.DrawValidFlag | Format.BlendGraphFlag | GParam->NotUseDivFlag, Format.DrawValidFlag == FALSE, GParam->UserMaxTextureSize ) ;
//		DivYNum = ListUpTexSize( Height, YList, Format.DrawValidFlag | Format.BlendGraphFlag | GParam->NotUseDivFlag, Format.DrawValidFlag == FALSE, GParam->UserMaxTextureSize ) ;
		// 分割する方がデメリットが大きくなってきたので、基本的に最大テクスチャーサイズに収まる限りは１枚で済ますように処理を変更
		DivXNum = ListUpTexSize( Width,  XList, TRUE, Format.DrawValidFlag == FALSE, GParam->UserMaxTextureSize ) ;
		DivYNum = ListUpTexSize( Height, YList, TRUE, Format.DrawValidFlag == FALSE, GParam->UserMaxTextureSize ) ;

		// 分割数をセット
		DivNum = DivXNum * DivYNum ;

		// 位置とサイズをセットする
		YPos = 0 ;
		for( i = 0 ; i < DivYNum ; i ++ )
		{
			XPos = 0 ;
			for( j = 0 ; j < DivXNum ; j ++ )
			{
				TexPosX[ i * DivXNum + j ] = ( short )XPos ;
				TexPosY[ i * DivXNum + j ] = ( short )YPos ;

				TexSizeX[ i * DivXNum + j ] = XList[ j ] ;
				TexSizeY[ i * DivXNum + j ] = YList[ i ] ;

				XPos += XList[ j ] ;
			}
			YPos += YList[ i ] ;
		}

		// ハードウェア制限に応じてテクスチャを正方形にする
		if( GRH.DeviceCaps.TextureCaps & D_D3DPTEXTURECAPS_SQUAREONLY )
		{
			int Size, DNum, MotoDivNum ;
			int PosX, PosY ;

			MotoDivNum = DivXNum * DivYNum ;
			for( i = 0 ; i < MotoDivNum ; i ++ )
			{
				if( TexSizeX[ i ] != TexSizeY[ i ] )
				{
					if( TexSizeX[ i ] < TexSizeY[ i ] )
					{
						Size = TexSizeX[ i ] ;
						DNum = TexSizeY[ i ] / TexSizeX[ i ] ;
						TexSizeY[ i ] = ( short )Size ;
						PosX = TexPosX[ i ] ;
						PosY = TexPosY[ i ] ;
						for( j = 0 ; j < DNum - 1 ; j ++ )
						{
							TexSizeX[ DivNum + j ] = ( short )Size ;
							TexSizeY[ DivNum + j ] = ( short )Size ;
							TexPosX[ DivNum + j ] = ( short )PosX ;
							TexPosY[ DivNum + j ] = ( short )( PosY + Size * ( j + 1 ) ) ;
						}
						DivNum += DNum - 1 ;
					}
					else
					{
						Size = TexSizeY[ i ] ;
						DNum = TexSizeX[ i ] / TexSizeY[ i ] ;
						TexSizeX[ i ] = ( short )Size ;
						PosX = TexPosX[ i ] ;
						PosY = TexPosY[ i ] ;
						for( j = 0 ; j < DNum - 1 ; j ++ )
						{
							TexSizeY[ DivNum + j ] = ( short )Size ;
							TexSizeX[ DivNum + j ] = ( short )Size ;
							TexPosY[ DivNum + j ] = ( short )PosY ;
							TexPosX[ DivNum + j ] = ( short )( PosX + Size * ( j + 1 ) ) ;
						}
						DivNum += DNum - 1 ;
					}
				}
			}
		}
	}

	// 確保メモリの確定
	AllocSize = sizeof( IMAGEDATA2_ORIG ) - ( ( sizeof( IMAGEDATA2_ORIG_SOFT ) > sizeof( IMAGEDATA2_ORIG_HARD ) ? sizeof( IMAGEDATA2_ORIG_SOFT ) : sizeof( IMAGEDATA2_ORIG_HARD ) ) ) ;
	if( IsTex )
	{
		AllocSize += sizeof( IMAGEDATA2_ORIG_HARD ) + ( DivNum - 4 ) * sizeof( IMAGEDATA2_ORIG_HARD_TEX ) ;
	}
	else
	{
		AllocSize += sizeof( IMAGEDATA2_ORIG_SOFT ) ;
	}

	// オリジナル画像情報構造体用のメモリの確保
	Image2->Orig = ( IMAGEDATA2_ORIG * )DXCALLOC( AllocSize ) ;
	if( Image2->Orig == NULL )
	{
		DXST_ERRORLOG_ADD( _T( "グラフィックのオリジナル画像データ保存用メモリの確保に失敗しました\n" ) ) ;
		goto ERR ;
	}
	Orig = Image2->Orig ;

	// フォーマットをセット
	Orig->FormatDesc = Format ;

	// 透過色をセット
	Orig->TransCode = GParam->TransColor ;

	// 幅と高さを保存
	Image2->UseOrigX = 0 ;
	Image2->UseOrigY = 0 ;
	Image2->Width = Width ;
	Image2->Height = Height ;
	Image2->Orig->Width = Width ;
	Image2->Orig->Height = Height ;

	// 参照数を初期化
	Image2->Orig->RefCount = 1 ;

	// オリジナル画像情報の初期化
	if( Orig->FormatDesc.TextureFlag )
	{
		// テクスチャの場合

		// フォーマットの決定
		Orig->ColorFormat = NS_GetTexFormatIndex( &Orig->FormatDesc ) ;

		// テクスチャ分割数に合わせてテクスチャ情報リスト用のメモリを確保する
		Orig->Hard.TexNum = DivNum ;

		// ミップマップの数をセット
//		Orig->Hard.MipMap = Orig->FormatDesc.DrawValidFlag ? FALSE : GRH.MipMapFlag ;
		if( Orig->ColorFormat == DX_GRAPHICSIMAGE_FORMAT_3D_DXT1 ||
			Orig->ColorFormat == DX_GRAPHICSIMAGE_FORMAT_3D_DXT2 ||
			Orig->ColorFormat == DX_GRAPHICSIMAGE_FORMAT_3D_DXT3 ||
			Orig->ColorFormat == DX_GRAPHICSIMAGE_FORMAT_3D_DXT4 ||
			Orig->ColorFormat == DX_GRAPHICSIMAGE_FORMAT_3D_DXT5 )
		{
			Orig->Hard.MipMapCount = 1 ;
		}
		else
		{
			Orig->Hard.MipMapCount = Format.MipMapCount ;
		}

		// 決定したテクスチャーサイズでテクスチャー情報を初期化する
		OrigTex = Orig->Hard.Tex ;
		for( i = 0 ; i < DivNum ; i ++, OrigTex ++ )
		{
			OrigTex->UseWidth  = Orig->Width  - TexPosX[ i ] ;
			OrigTex->UseHeight = Orig->Height - TexPosY[ i ] ;
			if( OrigTex->UseWidth  > TexSizeX[ i ] ) OrigTex->UseWidth  = TexSizeX[ i ] ; 
			if( OrigTex->UseHeight > TexSizeY[ i ] ) OrigTex->UseHeight = TexSizeY[ i ] ;

			OrigTex->OrigPosX = TexPosX[ i ] ;
			OrigTex->OrigPosY = TexPosY[ i ] ;

			OrigTex->TexWidth  = TexSizeX[ i ] ;
			OrigTex->TexHeight = TexSizeY[ i ] ;
		}

/*
		// 描画可能で解像度がバックバッファ以上の場合は専用のＺバッファを持つ
		if( Orig->FormatDesc.DrawValidFlag &&
			( Orig->Hard.Tex[ 0 ].TexWidth  > GRA2.MainScreenSizeX ||
			  Orig->Hard.Tex[ 0 ].TexHeight > GRA2.MainScreenSizeY ) )
		{
			Orig->ZBufferFlag = TRUE ;
		}
*/
		// 描画可能な場合でＺバッファを作成しないフラグが立っていない場合はＺバッファを持つ
		if( Orig->FormatDesc.DrawValidFlag && GParam->DrawValidGraphCreateZBufferFlag )
		{
			Orig->ZBufferFlag = TRUE ;
			switch( GParam->CreateDrawValidGraphZBufferBitDepth )
			{
			default :
			case 16 : Orig->ZBufferBitDepthIndex = ZBUFFER_FORMAT_16BIT ; break ;
			case 24 : Orig->ZBufferBitDepthIndex = ZBUFFER_FORMAT_24BIT ; break ;
			case 32 : Orig->ZBufferBitDepthIndex = ZBUFFER_FORMAT_32BIT ; break ;
			}
		}

		// IDirect3DTexture9 の作成
		if( CreateOrigTexture( Orig, ASyncThread ) == -1 )
			goto ERR ;
	}
	else
	{
		// テクスチャではない場合

		// ブレンド用画像の場合とそれ以外で処理を分岐
		if( Orig->FormatDesc.BlendGraphFlag == TRUE )
		{
			// イメージの作成
			if( InitializeMemImg( &Orig->Soft.MemImg, Orig->Width, Orig->Height, -1, 0, 2, FALSE, FALSE, FALSE ) < 0 )
			{
				DXST_ERRORLOG_ADD( _T( "ブレンド画像用メモリイメージの作成に失敗しました\n" ) ) ;
				goto ERR ;
			}
		}
		else
		{
			DWORD TransColor ;

			// ピクセルフォーマットのインデックスをセット
			if( Orig->FormatDesc.ColorBitDepth == 16 )
			{
				if( Orig->FormatDesc.AlphaChFlag )	Orig->ColorFormat = DX_GRAPHICSIMAGE_FORMAT_X8A8R5G6B5 ;
				else								Orig->ColorFormat = DX_GRAPHICSIMAGE_FORMAT_R5G6B5 ;
			}
			else
			{
				if( Orig->FormatDesc.AlphaChFlag )	Orig->ColorFormat = DX_GRAPHICSIMAGE_FORMAT_A8R8G8B8 ;
				else								Orig->ColorFormat = DX_GRAPHICSIMAGE_FORMAT_X8R8G8B8 ;
			}
			
			if( Orig->FormatDesc.UsePaletteFlag == TRUE )
			{
				TransColor = 0xffff ;
			}
			else
			{
				TransColor = NS_GetColor3( 
						GetMemImgColorData( Orig->FormatDesc.ColorBitDepth == 16 ? 0 : 1, Orig->FormatDesc.AlphaChFlag, FALSE ),
						( GBASE.TransColor >> 16 ) & 0xff,
						( GBASE.TransColor >> 8  ) & 0xff,
						( GBASE.TransColor >> 0  ) & 0xff,
						0xff ) ;
			}

			// イメージの作成
			if( InitializeMemImg(
					&Orig->Soft.MemImg,
					Orig->Width,
					Orig->Height,
					-1,
					TransColor,
					Orig->FormatDesc.ColorBitDepth == 16 ? 0 : 1,
					Orig->FormatDesc.UsePaletteFlag,
					Orig->FormatDesc.AlphaChFlag,
					FALSE
				) < 0 )
			{
				DXST_ERRORLOG_ADD( _T( "メモリイメージの作成に失敗しました\n" ) ) ;
				goto ERR ;
			}
		}
	}

	// 描画情報の初期化
	if( InitializeGraphDrawInfo( GrHandle, ASyncThread ) < 0 )
		goto ERR ;

	// 終了
	return 0 ;

	// エラー終了
ERR :
	NS_DeleteGraph( GrHandle ) ;

	return -1 ;
}

// 指定部分だけを抜き出したグラフィックハンドルを初期化する
static int InitializeDerivationGraphHandle( int GrHandle, int SrcX, int SrcY, int Width, int Height, int SrcGrHandle, int ASyncThread )
{
	IMAGEDATA2 *Image2, *SrcImage2 ;
	IMAGEDATA2_ORIG *Orig ;

	// アドレスの取得
	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( GrHandle, Image2 ) ||
			GRAPHCHK_ASYNC( SrcGrHandle, SrcImage2 ) )
			return -1 ;
	}
	else
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;

		if( GRAPHCHK( SrcGrHandle, SrcImage2 ) )
			return -1 ;
	}
	Orig = SrcImage2->Orig ;

	// オリジナル画像の参照数をインクリメントする
	Image2->Orig = Orig ;
	Orig->RefCount ++ ;

	// ファイルの情報をコピーする
	SetGraphName( GrHandle, NULL, FALSE, SrcGrHandle, ASyncThread ) ;
	Image2->UseBaseX = SrcImage2->UseBaseX + SrcX ;
	Image2->UseBaseY = SrcImage2->UseBaseY + SrcY ;

	// オリジナル画像中の参照座標をセット
	Image2->UseOrigX = SrcImage2->UseOrigX + SrcX ;
	Image2->UseOrigY = SrcImage2->UseOrigY + SrcY ;

	// サイズを保存
	Image2->Width = Width ;
	Image2->Height = Height ;

	//描画情報の初期化
	InitializeGraphDrawInfo( GrHandle, ASyncThread ) ;

	// 終了
	return 0 ;
}

// グラフィックハンドルの描画情報を初期化する
static int InitializeGraphDrawInfo( int GrHandle, int ASyncThread )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_ORIG *Orig ;
	IMAGEDATA2_ORIG_HARD_TEX *OrigTex ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	int i, Num, Size, Handle ;
	bool List[ 256 ] ;
	double d ;

	// アドレスの取得
	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
			return -1 ;
	}
	else
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
	}
	Orig = Image2->Orig ;
	Handle = Image2->HandleInfo.Handle ;

	// 基本確保メモリの算出
	Size = sizeof( IMAGEDATA2 ) - ( ( sizeof( IMAGEDATA2_SOFT ) > sizeof( IMAGEDATA2_HARD ) ? sizeof( IMAGEDATA2_SOFT ) : sizeof( IMAGEDATA2_HARD ) ) ) ;

	// テクスチャかどうかで処理を分岐
	if( Orig->FormatDesc.TextureFlag )
	{
		// テクスチャの場合

		// 頂点タイプ計算に使用する値の準備
		d = ( double )Image2->Height / ( double )Image2->Width ;

		// 元画像から被る部分の数を数える
		OrigTex = Orig->Hard.Tex ;
		Num = 0 ;
		for( i = 0 ; i < Orig->Hard.TexNum ; i ++, OrigTex ++ )
		{
			if(
				(
				  (
				    OrigTex->OrigPosX <= Image2->UseOrigX  &&
					OrigTex->OrigPosX + OrigTex->UseWidth  > Image2->UseOrigX
				  ) ||
				  (
				    Image2->UseOrigX  <= OrigTex->OrigPosX &&
					Image2->UseOrigX  + Image2->Width      > OrigTex->OrigPosX
				  )
				) &&
				(
				  (
				    OrigTex->OrigPosY <= Image2->UseOrigY  &&
					OrigTex->OrigPosY + OrigTex->UseHeight > Image2->UseOrigY
				  ) ||
				  (
				    Image2->UseOrigY  <= OrigTex->OrigPosY &&
					Image2->UseOrigY  + Image2->Height     > OrigTex->OrigPosY
				  )
				)
			  )
			{
				Num ++ ;
				List[ i ] = true ;
			}
			else
			{
				List[ i ] = false ;
			}
		}

		// 被る部分が０の場合はエラー
		if( Num == 0 )
		{
			DXST_ERRORLOG_ADD( _T( "テクスチャ描画情報の作成に失敗しました\n" ) ) ;
			return -1 ;
		}

		// 描画情報を格納するメモリ領域が足りない場合は再確保
		if( Num > 4 )
		{
			if( ReallocHandle( Handle, Size + sizeof( IMAGEDATA2_HARD ) + ( Num - 4 ) * sizeof( IMAGEDATA2_HARD_DRAW ) ) < 0 )
			{
				DXST_ERRORLOG_ADD( _T( "画像描画情報格納用メモリの確保に失敗しました\n" ) ) ;
				return -1 ;
			}
			Image2 = ( IMAGEDATA2 * )GetHandleInfo( Handle ) ;
			Orig = Image2->Orig ;
		}

		Image2->Hard.DrawNum = Num ;

		// 描画情報をセットする
		OrigTex = Orig->Hard.Tex ;
		DrawTex = Image2->Hard.Draw ;
		Num = 0 ;
		for( i = 0 ; i < Orig->Hard.TexNum ; i ++, OrigTex ++ )
		{
			if( List[ i ] == false ) continue ;

			// 使用するオリジナル画像テクスチャ情報のアドレスをセット
			DrawTex->Tex = OrigTex ;

			// オリジナル画像テクスチャ中のどの部分を使用するか、などの情報をセット
			{
				if( OrigTex->OrigPosX > Image2->UseOrigX )
				{
					DrawTex->DrawPosX = OrigTex->OrigPosX - Image2->UseOrigX ;
					DrawTex->UsePosX  = 0 ;

					if( OrigTex->OrigPosX + OrigTex->UseWidth > Image2->UseOrigX + Image2->Width )
					{
						DrawTex->Width = Image2->UseOrigX + Image2->Width - OrigTex->OrigPosX ;
					}
					else
					{
						DrawTex->Width = OrigTex->UseWidth ;
					}
				}
				else
				{
					DrawTex->DrawPosX = 0 ;
					DrawTex->UsePosX  = Image2->UseOrigX - OrigTex->OrigPosX ;

					if( OrigTex->OrigPosX + OrigTex->UseWidth > Image2->UseOrigX + Image2->Width )
					{
						DrawTex->Width = Image2->Width ;
					}
					else
					{
						DrawTex->Width = OrigTex->OrigPosX + OrigTex->UseWidth - Image2->UseOrigX ;
					}
				}

				if( OrigTex->OrigPosY > Image2->UseOrigY )
				{
					DrawTex->DrawPosY = OrigTex->OrigPosY - Image2->UseOrigY ;
					DrawTex->UsePosY  = 0 ;

					if( OrigTex->OrigPosY + OrigTex->UseHeight > Image2->UseOrigY + Image2->Height )
					{
						DrawTex->Height = Image2->UseOrigY + Image2->Height - OrigTex->OrigPosY ;
					}
					else
					{
						DrawTex->Height = OrigTex->UseHeight ;
					}
				}
				else
				{
					DrawTex->DrawPosY = 0 ;
					DrawTex->UsePosY  = Image2->UseOrigY - OrigTex->OrigPosY ;

					if( OrigTex->OrigPosY + OrigTex->UseHeight > Image2->UseOrigY + Image2->Height )
					{
						DrawTex->Height = Image2->Height ;
					}
					else
					{
						DrawTex->Height = OrigTex->OrigPosY + OrigTex->UseHeight - Image2->UseOrigY ;
					}
				}
			}

			// 算出した使用域情報から頂点データに使用する値の割り出し
			DrawTex->Vertex[ 0 ].x = ( float )DrawTex->DrawPosX ;
			DrawTex->Vertex[ 1 ].x = ( float )( DrawTex->DrawPosX + DrawTex->Width ) ;
			DrawTex->Vertex[ 2 ].x = ( float )DrawTex->DrawPosX ;
			DrawTex->Vertex[ 3 ].x = ( float )( DrawTex->DrawPosX + DrawTex->Width ) ;

			DrawTex->Vertex[ 0 ].y = ( float )DrawTex->DrawPosY ;
			DrawTex->Vertex[ 1 ].y = ( float )DrawTex->DrawPosY ;
			DrawTex->Vertex[ 2 ].y = ( float )( DrawTex->DrawPosY + DrawTex->Height ) ;
			DrawTex->Vertex[ 3 ].y = ( float )( DrawTex->DrawPosY + DrawTex->Height ) ;

			DrawTex->Vertex[ 0 ].u = ( float )DrawTex->UsePosX / ( float )OrigTex->TexWidth ;
			DrawTex->Vertex[ 1 ].u = ( float )( DrawTex->UsePosX + DrawTex->Width ) / ( float )OrigTex->TexWidth ;
			DrawTex->Vertex[ 2 ].u = ( float )DrawTex->UsePosX / ( float )OrigTex->TexWidth ;
			DrawTex->Vertex[ 3 ].u = ( float )( DrawTex->UsePosX + DrawTex->Width ) / ( float )OrigTex->TexWidth ;

			DrawTex->Vertex[ 0 ].v = ( float )DrawTex->UsePosY / ( float )OrigTex->TexHeight ;
			DrawTex->Vertex[ 1 ].v = ( float )DrawTex->UsePosY / ( float )OrigTex->TexHeight ;
			DrawTex->Vertex[ 2 ].v = ( float )( DrawTex->UsePosY + DrawTex->Height ) / ( float )OrigTex->TexHeight ;
			DrawTex->Vertex[ 3 ].v = ( float )( DrawTex->UsePosY + DrawTex->Height ) / ( float )OrigTex->TexHeight ;

			// 頂点タイプのセット
			DrawTex->VertType[ 0 ] = DrawTex->Vertex[ 0 ].y <= Image2->Height - ( d * DrawTex->Vertex[ 0 ].x ) ;
			DrawTex->VertType[ 1 ] = DrawTex->Vertex[ 1 ].y <= Image2->Height - ( d * DrawTex->Vertex[ 1 ].x ) ;
			DrawTex->VertType[ 2 ] = DrawTex->Vertex[ 2 ].y <= Image2->Height - ( d * DrawTex->Vertex[ 2 ].x ) ;
			DrawTex->VertType[ 3 ] = DrawTex->Vertex[ 3 ].y <= Image2->Height - ( d * DrawTex->Vertex[ 3 ].x ) ;

			DrawTex ++ ;
		}
	}
	else
	{
		// テクスチャではない場合

		// 描画用 MEMIMG の準備
		DerivationMemImg( &Image2->Soft.MemImg, &Orig->Soft.MemImg, Image2->UseOrigX, Image2->UseOrigY, Image2->Width, Image2->Height ) ;
	}

	// 終了
	return 0 ;
}





// オリジナル画像情報中のテクスチャを作成する( 0:成功  -1:失敗 )
static int CreateOrigTexture( IMAGEDATA2_ORIG *Orig, int ASyncThread )
{
	int i, j ;
	IMAGEDATA2_ORIG_HARD_TEX *OrigTex ;

	// Direct3DDevice が無効だったらエラー
	if( GraphicsDevice_IsValid() == 0 )
		return -1 ;

	// ハードウエアを使用する画像ではない場合は何もせずに終了
	if( Orig->FormatDesc.TextureFlag == FALSE ) return 0 ;

	// 指定のフォーマットが作成できない場合は失敗
	if( GRH.TextureFormat[ Orig->ColorFormat ] == D_D3DFMT_UNKNOWN )
	{
		DXST_ERRORLOG_ADD( _T( "指定のフォーマットで作成できるテクスチャフォーマットがありませんでした\n" ) ) ;
		return -1 ;
	}

	// テクスチャの場合はテクスチャの数だけテクスチャを作成
	OrigTex = Orig->Hard.Tex ;
	for( i = 0 ; i < Orig->Hard.TexNum ; i ++, OrigTex ++ )
	{
		// 既にテクスチャが作成されていたらスキップ
//		if( OrigTex->Texture != NULL ) continue ;

		// Direct3D9Ex を使用している場合は管理属性を使用しない( できない )
		if( Graphics_IsExObject() != 0 )
			Orig->FormatDesc.UseManagedTextureFlag = FALSE ;

		// レンダリングターゲットサーフェスの作成
		if( Orig->FormatDesc.DrawValidFlag )
		{
			// キューブマップでは別途レンダーターゲットは作成しない
			if( Orig->FormatDesc.CubeMapTextureFlag == FALSE )
			{
				D_D3DMULTISAMPLE_TYPE Samples = D_D3DMULTISAMPLE_NONE ;
				DWORD Quality = 0 ;

				if( Orig->FormatDesc.MSSamples != 0 )
				{
					Samples = ( D_D3DMULTISAMPLE_TYPE )Orig->FormatDesc.MSSamples ;
					Quality = ( DWORD )Orig->FormatDesc.MSQuality ;
					CheckMultiSampleParam( GRH.TextureFormat[ Orig->ColorFormat ], &Samples, &Quality, FALSE, ASyncThread ) ;
				}

				if( Orig->FormatDesc.MSSamples != 0 && OrigTex->RenderTargetSurface == NULL )
				{
					// レンダリングターゲットサーフェスの作成
					if( GraphicsDevice_CreateRenderTarget_ASync(
						OrigTex->TexWidth,							// 幅
						OrigTex->TexHeight,							// 高さ
						GRH.TextureFormat[ Orig->ColorFormat ],		// フォーマット
						Samples,									// マルチサンプリングタイプ
						Quality,									// マルチサンプリングクオリティ
						FALSE,										// ロックはできない
						&OrigTex->RenderTargetSurface,				// DX_DIRECT3DSURFACE9 のポインタを受け取るアドレス
						NULL,										// 絶対 NULL
						ASyncThread
						) != D_D3D_OK )
					{
						DXST_ERRORLOG_ADD( _T( "書き込み専用サーフェスの作成に失敗しました\n" ) ) ;
						return -1 ;
					}
				}

				if( ( GRH.FSAAMultiSampleType == D_D3DMULTISAMPLE_NONE && Orig->FormatDesc.MSSamples != 0 ) ||
					( GRH.FSAAMultiSampleType != D_D3DMULTISAMPLE_NONE && Orig->FormatDesc.MSSamples == 0 ) ||
					Orig->ZBufferFlag  )
				{
					if( OrigTex->ZBuffer != NULL )
					{
						Graphics_ObjectRelease( OrigTex->ZBuffer ) ;
						OrigTex->ZBuffer = NULL ;
					}

					// レンダリングターゲット深度バッファの作成
					if( GraphicsDevice_CreateDepthStencilSurface_ASync(
						OrigTex->TexWidth,									// 幅
						OrigTex->TexHeight,									// 高さ
						GRH.ZBufferFormat[ Orig->ZBufferBitDepthIndex ],	// フォーマット
						Samples,											// マルチサンプリングタイプ
						Quality,											// マルチサンプリングクオリティ
						FALSE,												// ロックはできない
						&OrigTex->ZBuffer,									// DX_DIRECT3DSURFACE9 のポインタを受け取るアドレス
						NULL,												// 絶対 NULL
						ASyncThread
						) != D_D3D_OK )
					{
						DXST_ERRORLOG_ADD( _T( "書き込み専用マルチサンプル深度サーフェスの作成に失敗しました\n" ) ) ;
						return -1 ;
					}
				}
				else
				if( OrigTex->ZBuffer != NULL )
				{
					Graphics_ObjectRelease( OrigTex->ZBuffer ) ;
					OrigTex->ZBuffer = NULL ;
				}
			}
		}

		// ビデオメモリテクスチャの作成
		if( Orig->FormatDesc.CubeMapTextureFlag )
		{
			if( OrigTex->CubeTexture == NULL )
			{
				if( GraphicsDevice_CreateCubeTexture_ASync(
					OrigTex->TexWidth,																													// エッジサイズ
					Orig->Hard.MipMapCount,																												// MipMap レベル
					Orig->FormatDesc.DrawValidFlag ? D_D3DUSAGE_RENDERTARGET : 0,																		// フラグ
					GRH.TextureFormat[ Orig->ColorFormat ],																								// フォーマット
					Orig->FormatDesc.UseManagedTextureFlag == FALSE || Orig->FormatDesc.DrawValidFlag ? D_D3DPOOL_DEFAULT : D_D3DPOOL_MANAGED,			// テクスチャを DirectX が管理するかどうか
					&OrigTex->CubeTexture,																												// DX_DIRECT3DTEXTURE9 のポインタを受け取るアドレス
					NULL,																																// 絶対 NULL
					ASyncThread
					) != D_D3D_OK )
				{
					DXST_ERRORLOG_ADD( _T( "キューブマップテクスチャの作成に失敗しました\n" ) ) ;
					return -1 ;
				}
			}
		}
		else
		{
			if( OrigTex->Texture == NULL )
			{
				if( GraphicsDevice_CreateTexture_ASync(
					OrigTex->TexWidth,																													// 幅
					OrigTex->TexHeight,																													// 高さ
					Orig->Hard.MipMapCount,																												// MipMap レベル
					Orig->FormatDesc.DrawValidFlag ? D_D3DUSAGE_RENDERTARGET : 0,																		// フラグ
					GRH.TextureFormat[ Orig->ColorFormat ],																								// フォーマット
					Orig->FormatDesc.UseManagedTextureFlag == FALSE || Orig->FormatDesc.DrawValidFlag ? D_D3DPOOL_DEFAULT : D_D3DPOOL_MANAGED,			// テクスチャを DirectX が管理するかどうか
					&OrigTex->Texture,																													// DX_DIRECT3DTEXTURE9 のポインタを受け取るアドレス
					NULL,																																// 絶対 NULL
					ASyncThread
					) != D_D3D_OK )
				{
					DXST_ERRORLOG_ADD( _T( "テクスチャの作成に失敗しました\n" ) ) ;
					return -1 ;
				}
			}
		}

		// 描画可能テクスチャではなく、且つ管理テクスチャではない場合はシステムメモリテクスチャを作成
		/*if( ( Orig->FormatDesc.DrawValidFlag == FALSE && Orig->FormatDesc.UseManagedTextureFlag == FALSE ) && OrigTex->MemTexture == NULL )
		{
			if( GraphicsDevice_CreateTexture(
				OrigTex->TexWidth,							// 幅
				OrigTex->TexHeight,							// 高さ
				Orig->Hard.MipMapCount,						// MipMap レベル
				D_D3DUSAGE_DYNAMIC,							// フラグ
				GRH.TextureFormat[ Orig->ColorFormat ],		// フォーマット
				D_D3DPOOL_SYSTEMMEM,						// テクスチャを DirectX が管理するかどうか
				&OrigTex->MemTexture,						// DX_DIRECT3DTEXTURE9 のポインタを受け取るアドレス
				NULL										// 絶対 NULL
				) != D_D3D_OK )
			{
				Graphics_ObjectRelease( OrigTex->Texture ) ;
				OrigTex->Texture = NULL ;

				DXST_ERRORLOG_ADD( _T( "メモリテクスチャの作成に失敗しました\n" ) ) ;
				return -1 ;
			}
		}*/

		// サーフェスのアドレスも取得する
		if( Orig->FormatDesc.CubeMapTextureFlag )
		{
			for( j = 0 ; j < CUBEMAP_SURFACE_NUM ; j ++ )
			{
				if( OrigTex->Surface[ j ] == NULL )
				{
					if( GraphicsCubeTexture_GetCubeMapSurface_ASync( OrigTex->CubeTexture, ( D_D3DCUBEMAP_FACES )j, 0, &OrigTex->Surface[ j ], ASyncThread ) != D_D3D_OK )
					{
						DXST_ERRORLOG_ADD( _T( "キューブテクスチャのサーフェスアドレスの取得に失敗しました\n" ) ) ;
						return -1 ;
					}
				}
			}
		}
		else
		{
			if( OrigTex->Surface[ 0 ] == NULL )
			{
				if( GraphicsTexture_GetSurfaceLevel_ASync( OrigTex->Texture, 0, &OrigTex->Surface[ 0 ], ASyncThread ) != D_D3D_OK )
				{
					DXST_ERRORLOG_ADD( _T( "テクスチャのサーフェスアドレスの取得に失敗しました\n" ) ) ;
					return -1 ;
				}
			}
		}

		// ついでに真っ黒に塗りつぶす
		{
//			int j, MipCount, h ;
//			D_D3DLOCKED_RECT LockRect ;

			if( Orig->FormatDesc.DrawValidFlag )
			{
				for( j = 0 ; j < CUBEMAP_SURFACE_NUM ; j ++ )
				{
					if( OrigTex->Surface[ j ] != NULL )
					{
						GraphicsDevice_ColorFill_ASync( OrigTex->Surface[ j ], NULL, 0x00000000, ASyncThread ) ;
					}
				}
			}
/*
			else
			// DXTフォーマットの場合はクリアしない
			if( Orig->ColorFormat != DX_GRAPHICSIMAGE_FORMAT_3D_DXT1 &&
				Orig->ColorFormat != DX_GRAPHICSIMAGE_FORMAT_3D_DXT2 &&
				Orig->ColorFormat != DX_GRAPHICSIMAGE_FORMAT_3D_DXT3 &&
				Orig->ColorFormat != DX_GRAPHICSIMAGE_FORMAT_3D_DXT4 &&
				Orig->ColorFormat != DX_GRAPHICSIMAGE_FORMAT_3D_DXT5 )
			{
				DX_DIRECT3DTEXTURE9 *UseTex ;

				UseTex = Orig->FormatDesc.UseManagedTextureFlag == FALSE ? OrigTex->MemTexture : OrigTex->Texture ;
				h = OrigTex->TexHeight ;
				if( Orig->Hard.MipMapCount > 1 )
				{
					MipCount = Orig->Hard.MipMapCount ;
					for( j = 0 ; j < MipCount ; j ++, h >>= 1 )
					{
						if( UseTex->LockRect( j, &LockRect, NULL, 0 ) == D_D3D_OK )
						{
							_MEMSET( LockRect.pBits, 0, LockRect.Pitch * h ) ;

							UseTex->UnlockRect( j ) ;
						}
					}
				}
				else
				{
					if( UseTex->LockRect( 0, &LockRect, NULL, 0 ) == D_D3D_OK )
					{
						_MEMSET( LockRect.pBits, 0, LockRect.Pitch * h ) ;

						UseTex->UnlockRect( 0 ) ;
					}
				}

				if( Orig->FormatDesc.UseManagedTextureFlag == FALSE )
				{
					GraphicsDevice_UpdateTexture( OrigTex->MemTexture, OrigTex->Texture ) ;
				}
			}
*/
		}
	}

	// 終了
	return 0 ;
}

// オリジナル画像情報中のテクスチャを解放する
static int ReleaseOrigTexture( IMAGEDATA2_ORIG *Orig )
{
	int i ;
	int j ;
	IMAGEDATA2_ORIG_HARD_TEX *OrigTex ;

	// ハードウエアを使用する画像ではない場合は何もせずに終了
	if( Orig->FormatDesc.TextureFlag == FALSE ) return 0 ;

	// テクスチャの場合はテクスチャの数だけテクスチャを作成
	OrigTex = Orig->Hard.Tex ;
	for( i = 0 ; i < Orig->Hard.TexNum ; i ++, OrigTex ++ )
	{
		// サーフェスの解放
		for( j = 0 ; j < CUBEMAP_SURFACE_NUM ; j ++ )
		{
			if( OrigTex->Surface[ j ] )
			{
				Graphics_ObjectRelease( OrigTex->Surface[ j ] ) ;
				OrigTex->Surface[ j ] = NULL ;
			}
		}
		if( OrigTex->RenderTargetSurface )
		{
			Graphics_ObjectRelease( OrigTex->RenderTargetSurface ) ;
			OrigTex->RenderTargetSurface = NULL ;
		}
		if( OrigTex->ZBuffer )
		{
			Graphics_ObjectRelease( OrigTex->ZBuffer ) ;
			OrigTex->ZBuffer = NULL ;
		}

		// テクスチャの解放
		if( OrigTex->Texture )
		{
			Graphics_ObjectRelease( OrigTex->Texture ) ;
			OrigTex->Texture = NULL ;
		}
		
		/*if( OrigTex->MemTexture )
		{
			Graphics_ObjectRelease( OrigTex->MemTexture ) ;
			OrigTex->MemTexture = NULL ;
		}*/
	}

	// 終了
	return 0 ;
}

#if 0
// オリジナル画像情報中のＺバッファを作成する
static int CreateOrigZBuffer( IMAGEDATA2_ORIG *Orig )
{
	int i ;
	IMAGEDATA2_ORIG_HARD_TEX *OrigTex ;

	// 描画可能画像ではない場合は何もしない
	if( Orig->FormatDesc.DrawValidFlag == FALSE ) return 0 ;

	// テクスチャかどうかで処理を分岐
	if( Orig->FormatDesc.TextureFlag == TRUE )
	{
		// テクスチャの場合

		OrigTex = Orig->Hard.Tex ;
		for( i = 0 ; i < Orig->Hard.TexNum ; i ++, OrigTex ++ )
		{
			// Ｚバッファが既に作成されている場合は何もしない
			if( OrigTex->ZBuffer != NULL ) continue ;

			// テクスチャの作成
			if( GraphicsDevice_CreateDepthStencilSurface(
				OrigTex->TexWidth,																	// 幅
				OrigTex->TexHeight,																	// 高さ
				D_D3DFMT_D16,																		// フォーマット
				GRH.MultiSampleType,																// マルチサンプリングタイプ
				GRH.MultiSampleQuality,																// マルチサンプルクオリティ
				TRUE,																				// 自動 Release フラグ
				&OrigTex->ZBuffer,																	// DX_DIRECT3DSURFACE9 のポインタを受け取るアドレス
				NULL																				// 絶対 NULL
				) != D_D3D_OK )
			{
				DXST_ERRORLOG_ADD( _T( "Ｚバッファサーフェスの作成に失敗しました\n" ) ) ;
				return -1 ;
			}
		}
	}
	else
	{
		// テクスチャではない場合

		// 既にＺバッファ用の MEMIMG が作成されている場合は何もしない
		if( Orig->Soft.ZBuffer == NULL )
		{
			// Ｚバッファサーフェス用MEMIMG を格納するメモリ領域の確保
			Orig->Soft.ZBuffer = ( MEMIMG * )DXCALLOC( sizeof( MEMIMG ) ) ;
			if( Orig->Soft.ZBuffer == NULL )
			{
				DXST_ERRORLOG_ADD( _T( "Ｚバッファ用MEMIMGを格納するメモリ領域の確保に失敗しました\n" ) ) ;
				return -1 ;
			}

			// Ｚバッファサーフェス用の MEMIMG を初期化
			if( MakeMemImgZBuffer( Orig->Soft.ZBuffer, Orig->Width, Orig->Height ) == -1 )
			{
				DXST_ERRORLOG_ADD( _T( "Ｚバッファ用MEMIMGの初期化に失敗しました\n" ) ) ;
				return -1 ;
			}
		}
	}

	// 終了
	return 0 ;
}

// オリジナル画像情報中のＺバッファを開放する
static int ReleaseOrigZBuffer( IMAGEDATA2_ORIG *Orig )
{
	int i ;
	IMAGEDATA2_ORIG_HARD_TEX *OrigTex ;

	// 描画可能画像ではない場合は何もしない
	if( Orig->FormatDesc.DrawValidFlag == FALSE ) return 0 ;

	// テクスチャかどうかで処理を分岐
	if( Orig->FormatDesc.TextureFlag == TRUE )
	{
		// テクスチャの場合

		OrigTex = Orig->Hard.Tex ;
		for( i = 0 ; i < Orig->Hard.TexNum ; i ++, OrigTex ++ )
		{
			// Ｚバッファの解放
			if( OrigTex->ZBuffer != NULL )
			{
				Graphics_ObjectRelease( OrigTex->ZBuffer ) ;
				OrigTex->ZBuffer = NULL ;
			}
		}
	}
	else
	{
		// テクスチャではない場合

		// 既にＺバッファ用の MEMIMG が解放されていた場合は何もしない
		if( Orig->Soft.ZBuffer != NULL )
		{
			// Ｚバッファ用 MEMIMG の後始末
			TerminateMemImg( Orig->Soft.ZBuffer ) ;

			// Ｚバッファ用 MEMIMG 自体の解放
			DXFREE( Orig->Soft.ZBuffer ) ;
			Orig->Soft.ZBuffer = NULL ;
		}
	}

	// 終了
	return 0 ;
}
#endif

// 頂点バッファハンドル用の Direct3DVertexBuffer9 オブジェクトを作成する
static int CreateDirect3DVertexBufferObject( VERTEXBUFFERHANDLEDATA *VertexBuffer )
{
	int FVF ;
	int Result ;

	// 対応していないタイプの場合はエラー
	FVF = VERTEXFVF_3D_LIGHT ;
	switch( VertexBuffer->Type )
	{
	case DX_VERTEX_TYPE_NORMAL_3D :
		FVF = VERTEXFVF_3D_LIGHT ;
		break ;
	}

	// 頂点処理をハードウエアで処理する場合のみ Direct3D9VertexBuffer を作成する
	if( GRH.VertexHardwareProcess || GRH.ValidVertexShader )
	{
		// 頂点バッファを作成する
		Result = GraphicsDevice_CreateVertexBuffer_ASync( 
				VertexBuffer->UnitSize * VertexBuffer->Num,
				D_D3DUSAGE_WRITEONLY,
				FVF,
				D_D3DPOOL_DEFAULT,
				&VertexBuffer->Direct3DBuffer ) ;
		if( Result < 0 )
		{
			DXST_ERRORLOG_ADD( _T( "頂点バッファの作成に失敗しました\n" ) ) ;
			return -1 ;
		}

		// データを復帰する
		NS_SetVertexBufferData( 0, VertexBuffer->Buffer, VertexBuffer->Num, VertexBuffer->HandleInfo.Handle ) ; 
	}

	// 終了
	return 0 ;
}

// 頂点バッファハンドル用の Direct3DVertexBuffer9 オブジェクトを解放する
static int ReleaseDirect3DVertexBufferObject( VERTEXBUFFERHANDLEDATA *VertexBuffer )
{
	if( VertexBuffer->Direct3DBuffer != NULL )
	{
		Graphics_ObjectRelease( VertexBuffer->Direct3DBuffer ) ;
		VertexBuffer->Direct3DBuffer = NULL ;
	}

	// 終了
	return 0 ;
}

// インデックスバッファハンドル用の Direct3DIndexBuffer9 オブジェクトを作成する
static int CreateDirect3DIndexBufferObject( INDEXBUFFERHANDLEDATA *IndexBuffer )
{
	D_D3DFORMAT Format ;

	// 対応していないタイプの場合はエラー
	Format = D_D3DFMT_INDEX16 ;
	switch( IndexBuffer->Type )
	{
	case DX_INDEX_TYPE_16BIT :
		Format = D_D3DFMT_INDEX16 ;
		break ;

	case DX_INDEX_TYPE_32BIT :
		Format = D_D3DFMT_INDEX32 ;
		break ;
	}

	// 頂点処理をハードウエアで処理する場合のみ Direct3D9IndexBuffer を作成する
	if( GRH.VertexHardwareProcess || GRH.ValidVertexShader )
	{
		// インデックスバッファを作成する
		if( GraphicsDevice_CreateIndexBuffer_ASync( 
				IndexBuffer->UnitSize * IndexBuffer->Num,
				D_D3DUSAGE_WRITEONLY,
				Format,
				D_D3DPOOL_DEFAULT,
				&IndexBuffer->Direct3DBuffer
			) < 0 )
		{
			DXST_ERRORLOG_ADD( _T( "インデックスバッファの作成に失敗しました\n" ) ) ;
			return -1 ;
		}

		// データを復帰する
		NS_SetIndexBufferData( 0, IndexBuffer->Buffer, IndexBuffer->Num, IndexBuffer->HandleInfo.Handle ) ; 
	}

	// 終了
	return 0 ;
}

// インデックスバッファハンドル用の Direct3DIndexBuffer9 オブジェクトを解放する
static int ReleaseDirect3DIndexBufferObject( INDEXBUFFERHANDLEDATA *IndexBuffer )
{
	if( IndexBuffer->Direct3DBuffer != NULL )
	{
		Graphics_ObjectRelease( IndexBuffer->Direct3DBuffer ) ;
		IndexBuffer->Direct3DBuffer = NULL ;
	}

	// 終了
	return 0 ;
}


// グラフィックハンドルが持つすべての DirectX オブジェクトを解放する
static int ReleaseOrigDirectXObjectAll()
{
	int i ;
	SHADERHANDLEDATA *Shader ;
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	INDEXBUFFERHANDLEDATA *IndexBuffer ;
	IMAGEDATA2_SYSMEMTEXTURE *MemTex ;
	IMAGEDATA2_SYSMEMSURFACE *MemSurface ;
	IMAGEDATA2 *Image2 ;
	SHADOWMAPDATA *ShadowMap ;

	MemTex = GRH.SysMemTexture ;
	for( i = 0 ; i < GRH.SysMemTextureInitNum ; MemTex ++ )
	{
		if( MemTex->InitializeFlag == FALSE )
			continue ;

		i ++ ;

		if( MemTex->MemTexture != NULL )
		{
			Graphics_ObjectRelease( MemTex->MemTexture ) ;
			MemTex->MemTexture = NULL ;
		}
	}

	MemSurface = GRH.SysMemSurface ;
	for( i = 0 ; i < GRH.SysMemSurfaceInitNum ; MemSurface ++ )
	{
		if( MemSurface->InitializeFlag == FALSE )
			continue ;

		i ++ ;

		if( MemSurface->MemSurface != NULL )
		{
			Graphics_ObjectRelease( MemSurface->MemSurface ) ;
			MemSurface->MemSurface = NULL ;
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_GRAPH ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMax ; i ++ )
		{
			Image2 = ( IMAGEDATA2 * )HandleManageArray[ DX_HANDLETYPE_GRAPH ].Handle[ i ] ;

			if( Image2 == NULL ) continue ;
			if( Image2->Orig == NULL ) continue ;
			ReleaseOrigTexture( Image2->Orig ) ;

#ifndef DX_NON_MOVIE
			if( Image2->MovieHandle != -1 )
			{
				ReleaseMovieSurface( Image2->MovieHandle ) ;
			}
#endif
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_SHADOWMAP ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_SHADOWMAP ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_SHADOWMAP ].AreaMax ; i ++ )
		{
			ShadowMap = ( SHADOWMAPDATA * )HandleManageArray[ DX_HANDLETYPE_SHADOWMAP ].Handle[ i ] ;

			if( ShadowMap == NULL ) continue ;
			ReleaseShadowMapTexture( ShadowMap  ) ;
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_VERTEX_BUFFER ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_VERTEX_BUFFER ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_VERTEX_BUFFER ].AreaMax ; i ++ )
		{
			VertexBuffer = ( VERTEXBUFFERHANDLEDATA * )HandleManageArray[ DX_HANDLETYPE_VERTEX_BUFFER ].Handle[ i ] ;
			if( VertexBuffer == NULL ) continue ;
			ReleaseDirect3DVertexBufferObject( VertexBuffer ) ;
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_INDEX_BUFFER ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_INDEX_BUFFER ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_INDEX_BUFFER ].AreaMax ; i ++ )
		{
			IndexBuffer = ( INDEXBUFFERHANDLEDATA * )HandleManageArray[ DX_HANDLETYPE_INDEX_BUFFER ].Handle[ i ] ;
			if( IndexBuffer == NULL ) continue ;
			ReleaseDirect3DIndexBufferObject( IndexBuffer ) ;
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_SHADER ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_SHADER ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_SHADER ].AreaMax ; i ++ )
		{
			Shader = ( SHADERHANDLEDATA * )HandleManageArray[ DX_HANDLETYPE_SHADER ].Handle[ i ] ;
			if( Shader == NULL ) continue ;
			if( Shader->IsVertexShader )
			{
				if( Shader->VertexShader )
				{
					Graphics_ObjectRelease( Shader->VertexShader ) ;
					Shader->VertexShader = NULL ;
				}
			}
			else
			{
				if( Shader->PixelShader )
				{
					Graphics_ObjectRelease( Shader->PixelShader ) ;
					Shader->PixelShader = NULL ;
				}
			}
		}
	}

	// 終了
	return 0 ;
}

// グラフィックハンドルが持つすべての DirectX オブジェクトを取得する
static int AllocOrigDirectXObjectAll()
{
	int i ;
	SHADERHANDLEDATA *Shader ;
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	INDEXBUFFERHANDLEDATA *IndexBuffer ;
	IMAGEDATA2_SYSMEMTEXTURE *MemTex ;
	IMAGEDATA2_SYSMEMSURFACE *MemSurface ;
	IMAGEDATA2 *Image2 ;
	SHADOWMAPDATA *ShadowMap ;

	MemTex = GRH.SysMemTexture ;
	for( i = 0 ; i < GRH.SysMemTextureInitNum ; MemTex ++ )
	{
		if( MemTex->InitializeFlag == FALSE )
			continue ;

		i ++ ;

		CreateSysMemTextureDirect3D9Texture( MemTex ) ;
	}

	MemSurface = GRH.SysMemSurface ;
	for( i = 0 ; i < GRH.SysMemSurfaceInitNum ; MemSurface ++ )
	{
		if( MemSurface->InitializeFlag == FALSE )
			continue ;

		i ++ ;

		CreateSysMemSurfaceDirect3D9Surface( MemSurface ) ;
	}

	if( HandleManageArray[ DX_HANDLETYPE_GRAPH ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMax ; i ++ )
		{
			Image2 = ( IMAGEDATA2 * )HandleManageArray[ DX_HANDLETYPE_GRAPH ].Handle[ i ] ;

			if( Image2 == NULL ) continue ;
			if( Image2->Orig == NULL ) continue ;
			CreateOrigTexture( Image2->Orig ) ;
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_SHADOWMAP ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_SHADOWMAP ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_SHADOWMAP ].AreaMax ; i ++ )
		{
			ShadowMap = ( SHADOWMAPDATA * )HandleManageArray[ DX_HANDLETYPE_SHADOWMAP ].Handle[ i ] ;

			if( ShadowMap == NULL ) continue ;
			CreateShadowMapTexture( ShadowMap ) ;
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_VERTEX_BUFFER ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_VERTEX_BUFFER ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_VERTEX_BUFFER ].AreaMax ; i ++ )
		{
			VertexBuffer = ( VERTEXBUFFERHANDLEDATA * )HandleManageArray[ DX_HANDLETYPE_VERTEX_BUFFER ].Handle[ i ] ;
			if( VertexBuffer == NULL ) continue ;
			CreateDirect3DVertexBufferObject( VertexBuffer ) ;
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_INDEX_BUFFER ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_INDEX_BUFFER ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_INDEX_BUFFER ].AreaMax ; i ++ )
		{
			IndexBuffer = ( INDEXBUFFERHANDLEDATA * )HandleManageArray[ DX_HANDLETYPE_INDEX_BUFFER ].Handle[ i ] ;
			if( IndexBuffer == NULL ) continue ;
			CreateDirect3DIndexBufferObject( IndexBuffer ) ;
		}
	}

	if( HandleManageArray[ DX_HANDLETYPE_SHADER ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_SHADER ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_SHADER ].AreaMax ; i ++ )
		{
			Shader = ( SHADERHANDLEDATA * )HandleManageArray[ DX_HANDLETYPE_SHADER ].Handle[ i ] ;
			if( Shader == NULL ) continue ;
			if( Shader->IsVertexShader )
			{
				GraphicsDevice_CreateVertexShader( ( DWORD * )Shader->FunctionCode, &Shader->VertexShader ) ;
			}
			else
			{
				GraphicsDevice_CreatePixelShader( ( DWORD * )Shader->FunctionCode, &Shader->PixelShader ) ;
			}
		}
	}

	// 終了
	return 0 ;
}


static  D_D3DVERTEXELEMENT9	MakeVertexElement9( BYTE Stream, BYTE Offset, BYTE Type, BYTE Method, BYTE Usage, BYTE UsageIndex )
{
	D_D3DVERTEXELEMENT9 Result = { Stream, Offset, Type, Method, Usage, UsageIndex } ;
	return Result ;
}


// 設定に基づいて使用するＺバッファをセットする
extern int SetupUseZBuffer( void )
{
	IMAGEDATA2 *TargetScreenImage2 = NULL ;
	IMAGEDATA2 *TargetZBufferImage2 = NULL ;
	SHADOWMAPDATA *TargetShadowMap = NULL ;

	// シャドウマップかどうかをチェック
	if( !SHADOWMAPCHK( GBASE.TargetScreen[ 0 ], TargetShadowMap ) )
	{
		// シャドウマップの場合は専用のＺバッファを使用する
		GraphicsDevice_SetDepthStencilSurface( TargetShadowMap->ZBufferSurface ) ;
	}
	else
	{
		// 描画先の画像情報の取得
		GRAPHCHKFULL( GBASE.TargetScreen[ 0 ], TargetScreenImage2 ) ;

		// 使用するＺバッファの画像情報の取得
		GRAPHCHKFULL( GBASE.TargetZBuffer, TargetZBufferImage2 ) ;

		// マスクサーフェスが存在していて且つ有効な場合はマスクサーフェスのＺバッファを使用する
#ifndef DX_NON_MASK
		if( MASKD.MaskValidFlag && MASKD.MaskScreenSurface )
		{
			GraphicsDevice_SetDepthStencilSurface( GRH.ZBufferSurface ) ;
		}
		else
#endif
		// 描画可能画像が描画先かどうかで処理を分岐
		if( TargetScreenImage2 )
		{
			// 描画先Ｚバッファがあって、且つ描画先以上のサイズを持つ場合は描画先Ｚバッファを使用する
			if( TargetZBufferImage2 != NULL &&
				TargetZBufferImage2->Width >= TargetScreenImage2->Width &&
				TargetZBufferImage2->Height >= TargetScreenImage2->Height )
			{
				GraphicsDevice_SetDepthStencilSurface( TargetZBufferImage2->Hard.Draw[ 0 ].Tex->ZBuffer ) ;
			}
			else
			// 描画可能画像のＺバッファがある場合はそのＺバッファを使用する
			if( TargetScreenImage2->Hard.Draw[ 0 ].Tex->ZBuffer )
			{
				GraphicsDevice_SetDepthStencilSurface( TargetScreenImage2->Hard.Draw[ 0 ].Tex->ZBuffer ) ;
			}
			else
			// 描画先がデフォルトのＺバッファよりも大きかったらＺバッファを外す
			if( TargetScreenImage2->Width  > GRH.ZBufferSizeX || 
				TargetScreenImage2->Height > GRH.ZBufferSizeY )
			{
				GraphicsDevice_SetDepthStencilSurface( NULL ) ;
			}
			else
			{
				// デフォルトのＺバッファを使用する
				GraphicsDevice_SetDepthStencilSurface( GRH.ZBufferSurface ) ;
			}
		}
		else
		{
			// 描画先Ｚバッファがあって、且つ描画先以上のサイズを持つ場合は描画先Ｚバッファを使用する
			if( TargetZBufferImage2 != NULL &&
				TargetZBufferImage2->Width  >= GBASE.DrawSizeX &&
				TargetZBufferImage2->Height >= GBASE.DrawSizeY )
			{
				GraphicsDevice_SetDepthStencilSurface( TargetZBufferImage2->Hard.Draw[ 0 ].Tex->ZBuffer ) ;
			}
			else
			{
				// それ以外の場合デフォルトのＺバッファを使用する
				GraphicsDevice_SetDepthStencilSurface( GRH.ZBufferSurface ) ;
			}
		}
	}

	// 終了
	return 0 ;
}


// 指定のマルチサンプル数で使用できる最大クオリティ値を取得する
extern int NS_GetMultiSampleQuality( int Samples )
{
	IMAGEFORMATDESC Format ;
	SETUP_GRAPHHANDLE_GPARAM GParam ;
	int FormatIndex ;
	D_D3DFORMAT D3DFormat ;
	DWORD Quality ;

	if( Samples > 16 )
		Samples = 16 ;

	if( Graphics_IsValid() == 0 )
		return -1 ;

	// 現在の設定のフォーマットをセットアップする
	InitSetupGraphHandleGParam( &GParam ) ; 
	GParam.DrawValidImageCreateFlag = TRUE ;
	GParam.CubeMapTextureCreateFlag = FALSE ;
	SetupFormatDesc( &Format, &GParam, 256, 256, GParam.AlphaChannelImageCreateFlag, FALSE, DX_BASEIMAGE_FORMAT_NORMAL, -1 ) ;

	// フォーマットインデックスを得る
	FormatIndex = NS_GetTexFormatIndex( &Format ) ;

	// Direct3D でのフォーマットを取得
	D3DFormat = GRH.TextureFormat[ FormatIndex ] ;
	if( D3DFormat == D_D3DFMT_UNKNOWN )
		return -1 ;

	// 設定できるクオリティを取得
	Quality = 10000 ;
	if( CheckMultiSampleParam( D3DFormat, ( D_D3DMULTISAMPLE_TYPE * )&Samples, &Quality, TRUE ) < 0 )
		return -1 ;

	// クオリティを返す
	return Quality ;
}

#ifndef DX_NON_ASYNCLOAD

// マルチサンプルレンダリングのサンプル数とクオリティをチェックする非同期読み込み処理用コールバック関数
static int CheckMultiSampleParamASyncCallback( ASYNCLOAD_MAINTHREAD_REQUESTINFO *Info )
{
	return CheckMultiSampleParam( 
						( D_D3DFORMAT )Info->Data[ 0 ],
						( D_D3DMULTISAMPLE_TYPE * )Info->Data[ 1 ],
						( DWORD * )Info->Data[ 2 ],
						( int )Info->Data[ 3 ],
						FALSE 
					) ;
}

#endif // DX_NON_ASYNCLOAD

// マルチサンプルレンダリングのサンプル数とクオリティをチェック
static int CheckMultiSampleParam( D_D3DFORMAT Format, D_D3DMULTISAMPLE_TYPE *Samples, DWORD *Quality, int SamplesFailedBreak, int ASyncThread )
{
#ifndef DX_NON_ASYNCLOAD
	if( ASyncThread == TRUE )
	{
		ASYNCLOAD_MAINTHREAD_REQUESTINFO AInfo ;

		AInfo.Function = CheckMultiSampleParamASyncCallback ;
		AInfo.Data[ 0 ] = ( DWORD_PTR )Format ;
		AInfo.Data[ 1 ] = ( DWORD_PTR )Samples ;
		AInfo.Data[ 2 ] = ( DWORD_PTR )Quality ;
		AInfo.Data[ 3 ] = ( DWORD_PTR )SamplesFailedBreak ;
		return AddASyncLoadRequestMainThreadInfo( &AInfo ) ;
	}
#endif // DX_NON_ASYNCLOAD

	return Graphics_CheckMultiSampleParam( Format, Samples, Quality, SamplesFailedBreak ) ;
}

// IMAGEDATA2_ORIG と IMAGEDATA2_ORIG_HARD_TEX の情報を元に GetSysMemTexture を使用する
static int GetSysMemTextureFromOrig( IMAGEDATA2_ORIG *Orig, IMAGEDATA2_ORIG_HARD_TEX *OrigTex, int ASyncThread )
{
	return GetSysMemTexture( Orig->FormatDesc.CubeMapTextureFlag, OrigTex->TexWidth, OrigTex->TexHeight, Orig->Hard.MipMapCount, GRH.TextureFormat[ Orig->ColorFormat ], ASyncThread ) ; 
}


#ifndef DX_NON_ASYNCLOAD

static int GetSysMemTextureASyncCallback( ASYNCLOAD_MAINTHREAD_REQUESTINFO *Info )
{
	return GetSysMemTexture(
				( int )Info->Data[ 0 ],
				( int )Info->Data[ 1 ],
				( int )Info->Data[ 2 ],
				( int )Info->Data[ 3 ],
				( D_D3DFORMAT )Info->Data[ 4 ],
				FALSE ) ;
}

#endif // DX_NON_ASYNCLOAD

// 管理テクスチャへの転送用のシステムメモリテクスチャを取得する
static int GetSysMemTexture( int CubeMap, int Width, int Height, int MipMapCount, D_D3DFORMAT Format, int ASyncThread )
{
#ifndef DX_NON_ASYNCLOAD
	if( ASyncThread )
	{
		ASYNCLOAD_MAINTHREAD_REQUESTINFO AInfo ;

		AInfo.Function = GetSysMemTextureASyncCallback ;
		AInfo.Data[ 0 ] = ( DWORD_PTR )CubeMap ;
		AInfo.Data[ 1 ] = ( DWORD_PTR )Width ;
		AInfo.Data[ 2 ] = ( DWORD_PTR )Height ;
		AInfo.Data[ 3 ] = ( DWORD_PTR )MipMapCount ;
		AInfo.Data[ 4 ] = ( DWORD_PTR )Format ;
		return AddASyncLoadRequestMainThreadInfo( &AInfo ) ;
	}
#endif // DX_NON_ASYNCLOAD

	int i, j ;
	IMAGEDATA2_SYSMEMTEXTURE *MemTex ;
	IMAGEDATA2_SYSMEMTEXTURE *NewMemTex ;

	// 既に適合するテクスチャで未使用のものが無いか調べる
	MemTex = GRH.SysMemTexture ;
	NewMemTex = NULL ;
	j = 0 ;
	for( i = 0 ; i < GRH.SysMemTextureInitNum ; MemTex ++ )
	{
		if( MemTex->InitializeFlag == FALSE )
		{
			if( NewMemTex == NULL )
			{
				NewMemTex = MemTex ;
			}
			continue ;
		}

		i ++ ;

		if( MemTex->CubeMap     != ( unsigned char )CubeMap ||
			MemTex->Width       != ( short )        Width ||
			MemTex->Height      != ( short )        Height ||
			MemTex->MipMapCount != ( unsigned char )MipMapCount ||
			MemTex->Format      !=                  Format )
			continue ;

		j ++ ;

		if( MemTex->UseFlag == TRUE )
		{
			// 同じフォーマットのテクスチャが規定数使用中だったらエラー
			if( j == SYSMEMTEXTURE_ONE_FORMAT_NUM )
				return -1 ;
			continue ;
		}

		MemTex->UseCount ++ ;
		MemTex->UseFlag = TRUE ;
		return ( int )( MemTex - GRH.SysMemTexture ) ; 
	}

	// 適合するテクスチャが無く、すべてのテクスチャが初期化済みの場合は未使用中で使用頻度の低いテクスチャを解放する
	if( GRH.SysMemTextureInitNum == SYSMEMTEXTURE_NUM )
	{
		unsigned int MinUseCount ;

		MinUseCount = 0xffffffff ;
		MemTex = GRH.SysMemTexture ;
		NewMemTex = NULL ;
		for( i = 0 ; i < SYSMEMTEXTURE_NUM ; i ++, MemTex ++ )
		{
			if( MemTex->UseFlag == FALSE &&
				MemTex->UseCount <= MinUseCount )
			{
				MinUseCount = MemTex->UseCount ;
				NewMemTex = MemTex ;
			}
		}

		// すべてが使用中の場合はエラー
		if( NewMemTex == NULL )
		{
			return -1 ;
		}

		// 既存のデータを解放
		Graphics_ObjectRelease( NewMemTex->MemTexture ) ;
		NewMemTex->MemTexture = NULL ;

		NewMemTex->InitializeFlag = FALSE ;
		NewMemTex->UseCount = 0 ;
		NewMemTex->UseFlag = FALSE ;

		// 初期化データを減らす
		GRH.SysMemTextureInitNum -- ;
	}
	else
	{
		if( NewMemTex == NULL )
		{
			NewMemTex = MemTex ;
		}
	}

	// データの初期化
	NewMemTex->CubeMap = ( unsigned char )CubeMap ;
	NewMemTex->MipMapCount = ( unsigned char )MipMapCount ;
	NewMemTex->Width = ( short )Width ;
	NewMemTex->Height = ( short )Height ;
	NewMemTex->Format = Format ;
	NewMemTex->UseCount = 1 ;

	// テクスチャの作成
	if( CreateSysMemTextureDirect3D9Texture( NewMemTex ) < 0 )
	{
		// 使用されていないシステムメモリテクスチャを解放して、再度作成を試みる
		ReleaseSysMemTextureAll( TRUE ) ;
		if( CreateSysMemTextureDirect3D9Texture( NewMemTex ) < 0 )
		{
			return -1 ;
		}
	}

	// 初期化フラグと使用中フラグを立てる
	NewMemTex->InitializeFlag = TRUE ;
	NewMemTex->UseFlag = TRUE ;

	// 初期化データの追加
	GRH.SysMemTextureInitNum ++ ;

	return ( int )( NewMemTex - GRH.SysMemTexture ) ;
}



#ifndef DX_NON_ASYNCLOAD

static int GetSysMemSurfaceASyncCallback( ASYNCLOAD_MAINTHREAD_REQUESTINFO *Info )
{
	return GetSysMemSurface(
				( int )Info->Data[ 0 ],
				( int )Info->Data[ 1 ],
				( D_D3DFORMAT )Info->Data[ 2 ],
				FALSE ) ;
}

#endif // DX_NON_ASYNCLOAD

// 管理テクスチャへの転送用のシステムメモリテクスチャを取得する
static int GetSysMemSurface( int Width, int Height, D_D3DFORMAT Format, int ASyncThread )
{
#ifndef DX_NON_ASYNCLOAD
	if( ASyncThread )
	{
		ASYNCLOAD_MAINTHREAD_REQUESTINFO AInfo ;

		AInfo.Function = GetSysMemSurfaceASyncCallback ;
		AInfo.Data[ 0 ] = ( DWORD_PTR )Width ;
		AInfo.Data[ 1 ] = ( DWORD_PTR )Height ;
		AInfo.Data[ 2 ] = ( DWORD_PTR )Format ;
		return AddASyncLoadRequestMainThreadInfo( &AInfo ) ;
	}
#endif // DX_NON_ASYNCLOAD

	int i, j ;
	IMAGEDATA2_SYSMEMSURFACE *MemSurface ;
	IMAGEDATA2_SYSMEMSURFACE *NewMemSurface ;

	// 既に適合するテクスチャで未使用のものが無いか調べる
	MemSurface = GRH.SysMemSurface ;
	NewMemSurface = NULL ;
	j = 0 ;
	for( i = 0 ; i < GRH.SysMemSurfaceInitNum ; MemSurface ++ )
	{
		if( MemSurface->InitializeFlag == FALSE )
		{
			if( NewMemSurface == NULL )
			{
				NewMemSurface = MemSurface ;
			}
			continue ;
		}

		i ++ ;

		if( MemSurface->Width       != ( short )Width ||
			MemSurface->Height      != ( short )Height ||
			MemSurface->Format      !=          Format )
			continue ;

		j ++ ;

		if( MemSurface->UseFlag == TRUE )
		{
			// 同じフォーマットのテクスチャが規定数使用中だったらエラー
			if( j == SYSMEMSURFACE_ONE_FORMAT_NUM )
				return -1 ;
			continue ;
		}

		MemSurface->UseCount ++ ;
		MemSurface->UseFlag = TRUE ;
		return ( int )( MemSurface - GRH.SysMemSurface ) ; 
	}

	// 適合するテクスチャが無く、すべてのテクスチャが初期化済みの場合は未使用中で使用頻度の低いテクスチャを解放する
	if( GRH.SysMemSurfaceInitNum == SYSMEMSURFACE_NUM )
	{
		unsigned int MinUseCount ;

		MinUseCount = 0xffffffff ;
		MemSurface = GRH.SysMemSurface ;
		NewMemSurface = NULL ;
		for( i = 0 ; i < SYSMEMSURFACE_NUM ; i ++, MemSurface ++ )
		{
			if( MemSurface->UseFlag == FALSE &&
				MemSurface->UseCount <= MinUseCount )
			{
				MinUseCount = MemSurface->UseCount ;
				NewMemSurface = MemSurface ;
			}
		}

		// すべてが使用中の場合はエラー
		if( NewMemSurface == NULL )
		{
			return -1 ;
		}

		// 既存のデータを解放
		Graphics_ObjectRelease( NewMemSurface->MemSurface ) ;
		NewMemSurface->MemSurface = NULL ;

		NewMemSurface->InitializeFlag = FALSE ;
		NewMemSurface->UseCount = 0 ;
		NewMemSurface->UseFlag = FALSE ;

		// 初期化データを減らす
		GRH.SysMemSurfaceInitNum -- ;
	}
	else
	{
		if( NewMemSurface == NULL )
		{
			NewMemSurface = MemSurface ;
		}
	}

	// データの初期化
	NewMemSurface->Width = ( short )Width ;
	NewMemSurface->Height = ( short )Height ;
	NewMemSurface->Format = Format ;
	NewMemSurface->UseCount = 1 ;

	// テクスチャの作成
	if( CreateSysMemSurfaceDirect3D9Surface( NewMemSurface ) < 0 )
	{
		// 使用されていないシステムメモリテクスチャを解放して、再度作成を試みる
		ReleaseSysMemSurfaceAll( TRUE ) ;
		if( CreateSysMemSurfaceDirect3D9Surface( NewMemSurface ) < 0 )
		{
			return -1 ;
		}
	}

	// 初期化フラグと使用中フラグを立てる
	NewMemSurface->InitializeFlag = TRUE ;
	NewMemSurface->UseFlag = TRUE ;

	// 初期化データの追加
	GRH.SysMemSurfaceInitNum ++ ;

	return ( int )( NewMemSurface - GRH.SysMemSurface ) ;
}


// 構造体のデータを元に転送用のシステムメモリテクスチャを作成する
static int CreateSysMemTextureDirect3D9Texture( IMAGEDATA2_SYSMEMTEXTURE *MemTex )
{
	long Result ;

	if( MemTex->CubeMap != 0 )
	{
		Result = GraphicsDevice_CreateCubeTexture(
			MemTex->Width,											// 幅
			MemTex->MipMapCount,									// MipMap レベル
			D_D3DUSAGE_DYNAMIC,										// フラグ
			MemTex->Format,											// フォーマット
			D_D3DPOOL_SYSTEMMEM,									// テクスチャを DirectX が管理するかどうか
			( DX_DIRECT3DCUBETEXTURE9 ** )&MemTex->MemTexture,		// DX_DIRECT3DCUBETEXTURE9 のポインタを受け取るアドレス
			NULL													// 絶対 NULL
		) ;
		if( Result != D_D3D_OK )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "メモリキューブマップテクスチャの作成に失敗しました  エラーコード:0x%08x SizeX:%d SizeY:%d Format:%d 総メモリ確保数:%d 総確保メモリサイズ:%dByte(%dKByte)" ),
				Result, MemTex->Width, MemTex->Height, GRH.TextureFormat[ MemTex->Format ], NS_DxGetAllocNum(), NS_DxGetAllocSize(), NS_DxGetAllocSize() )) ;
			return -1 ;
		}
	}
	else
	{
		Result = GraphicsDevice_CreateTexture(
			MemTex->Width,									// 幅
			MemTex->Height,									// 高さ
			MemTex->MipMapCount,							// MipMap レベル
			D_D3DUSAGE_DYNAMIC,								// フラグ
			MemTex->Format,									// フォーマット
			D_D3DPOOL_SYSTEMMEM,							// テクスチャを DirectX が管理するかどうか
			( DX_DIRECT3DTEXTURE9 ** )&MemTex->MemTexture,	// DX_DIRECT3DTEXTURE9 のポインタを受け取るアドレス
			NULL											// 絶対 NULL
		) ;
		if( Result != D_D3D_OK )
		{
			static bool OutPutLog = false ;

			DXST_ERRORLOGFMT_ADD(( _T( "メモリテクスチャの作成に失敗しました  エラーコード:0x%08x SizeX:%d SizeY:%d Format:%d 総メモリ確保数:%d 総確保メモリサイズ:%dByte(%dKByte)" ),
				Result, MemTex->Width, MemTex->Height, GRH.TextureFormat[ MemTex->Format ], NS_DxGetAllocNum(), NS_DxGetAllocSize(), NS_DxGetAllocSize() )) ;

			if( OutPutLog == false )
			{
				OutPutLog = true ;

				DXST_ERRORLOGFMT_ADD(( _T( "メモリテクスチャの作成に失敗しました  エラーコード:0x%08x SizeX:%d SizeY:%d Format:%d 総メモリ確保数:%d 総確保メモリサイズ:%dByte(%dKByte)" ),
					Result, MemTex->Width, MemTex->Height, GRH.TextureFormat[ MemTex->Format ], NS_DxGetAllocNum(), NS_DxGetAllocSize(), NS_DxGetAllocSize() )) ;
				DXST_ERRORLOGFMT_ADD(( _T( "非管理テクスチャへのデータ転送用システムメモリ配置テクスチャの数：%d" ), GRH.SysMemTextureInitNum )) ;

				int i, j ;
				MemTex = GRH.SysMemTexture ;
				j = 0 ;
				for( i = 0 ; i < GRH.SysMemTextureInitNum ; j ++ , MemTex ++ )
				{
					if( MemTex->InitializeFlag == FALSE )
					{
						continue ;
					}
					i++ ;
					DXST_ERRORLOGFMT_ADD(( _T( "No%d. UseFlag:%d UseCount:%d CubeMap:%d SizeX:%d SizeY:%d MipMapCount:%d Format:%d" ),
						j, MemTex->UseFlag, MemTex->UseCount, MemTex->CubeMap, MemTex->Width, MemTex->Height, MemTex->MipMapCount, MemTex->Format )) ;
				}
			}
			return -1 ;
		}
	}

	// 正常終了
	return 0 ;
}


// 構造体のデータを元に転送用のシステムメモリサーフェスを作成する
static int CreateSysMemSurfaceDirect3D9Surface( IMAGEDATA2_SYSMEMSURFACE *MemSurface )
{
	long Result ;

	Result = GraphicsDevice_CreateOffscreenPlainSurface(
		MemSurface->Width,									// 幅
		MemSurface->Height,									// 高さ
		MemSurface->Format,									// フォーマット
		D_D3DPOOL_SYSTEMMEM,								// テクスチャを DirectX が管理するかどうか
		( DX_DIRECT3DSURFACE9 ** )&MemSurface->MemSurface,	// DX_DIRECT3DSURFACE9 のポインタを受け取るアドレス
		NULL												// 絶対 NULL
	) ;
	if( Result != D_D3D_OK )
	{
		static bool OutPutLog = false ;

		DXST_ERRORLOGFMT_ADD(( _T( "メモリサーフェスの作成に失敗しました  エラーコード:0x%08x SizeX:%d SizeY:%d Format:%d 総メモリ確保数:%d 総確保メモリサイズ:%dByte(%dKByte)" ),
			Result, MemSurface->Width, MemSurface->Height, GRH.TextureFormat[ MemSurface->Format ], NS_DxGetAllocNum(), NS_DxGetAllocSize(), NS_DxGetAllocSize() )) ;

		if( OutPutLog == false )
		{
			OutPutLog = true ;

			DXST_ERRORLOGFMT_ADD(( _T( "メモリサーフェスの作成に失敗しました  エラーコード:0x%08x SizeX:%d SizeY:%d Format:%d 総メモリ確保数:%d 総確保メモリサイズ:%dByte(%dKByte)" ),
				Result, MemSurface->Width, MemSurface->Height, GRH.TextureFormat[ MemSurface->Format ], NS_DxGetAllocNum(), NS_DxGetAllocSize(), NS_DxGetAllocSize() )) ;
			DXST_ERRORLOGFMT_ADD(( _T( "非管理テクスチャへのデータ転送用システムメモリ配置サーフェスの数：%d" ), GRH.SysMemTextureInitNum )) ;

			int i, j ;
			MemSurface = GRH.SysMemSurface ;
			j = 0 ;
			for( i = 0 ; i < GRH.SysMemSurfaceInitNum ; j ++ , MemSurface ++ )
			{
				if( MemSurface->InitializeFlag == FALSE )
				{
					continue ;
				}
				i++ ;
				DXST_ERRORLOGFMT_ADD(( _T( "No%d. UseFlag:%d UseCount:%d SizeX:%d SizeY:%d Format:%d" ),
					j, MemSurface->UseFlag, MemSurface->UseCount, MemSurface->Width, MemSurface->Height, MemSurface->Format )) ;
			}
		}
		return -1 ;
	}

	// 正常終了
	return 0 ;
}


#ifndef DX_NON_ASYNCLOAD

static int ReleaseSysMemTextureASyncCallback( ASYNCLOAD_MAINTHREAD_REQUESTINFO *Info )
{
	return ReleaseSysMemTexture(
				( int )Info->Data[ 0 ],
				FALSE ) ;
}

#endif // DX_NON_ASYNCLOAD

// 管理テクスチャへの転送用のシステムメモリテクスチャの取得を解放する
static int ReleaseSysMemTexture( int Index, int ASyncThread )
{
#ifndef DX_NON_ASYNCLOAD
	if( ASyncThread )
	{
		ASYNCLOAD_MAINTHREAD_REQUESTINFO AInfo ;

		AInfo.Function = ReleaseSysMemTextureASyncCallback ;
		AInfo.Data[ 0 ] = ( DWORD_PTR )Index ;
		return AddASyncLoadRequestMainThreadInfo( &AInfo ) ;
	}
#endif // DX_NON_ASYNCLOAD

	IMAGEDATA2_SYSMEMTEXTURE *MemTex ;

	MemTex = &GRH.SysMemTexture[ Index ] ;

	if( MemTex->InitializeFlag == FALSE ||
		MemTex->UseFlag == FALSE )
		return 0 ;

	MemTex->UseFlag = FALSE ;
	MemTex->UseTime = NS_GetNowCount() ;

	// 終了
	return 0 ;
}


#ifndef DX_NON_ASYNCLOAD

static int ReleaseSysMemSurfaceASyncCallback( ASYNCLOAD_MAINTHREAD_REQUESTINFO *Info )
{
	return ReleaseSysMemSurface(
				( int )Info->Data[ 0 ],
				FALSE ) ;
}

#endif // DX_NON_ASYNCLOAD

// 管理テクスチャへの転送用のシステムメモリサーフェスの取得を解放する
static int ReleaseSysMemSurface( int Index, int ASyncThread )
{
#ifndef DX_NON_ASYNCLOAD
	if( ASyncThread )
	{
		ASYNCLOAD_MAINTHREAD_REQUESTINFO AInfo ;

		AInfo.Function = ReleaseSysMemSurfaceASyncCallback ;
		AInfo.Data[ 0 ] = ( DWORD_PTR )Index ;
		return AddASyncLoadRequestMainThreadInfo( &AInfo ) ;
	}
#endif // DX_NON_ASYNCLOAD

	IMAGEDATA2_SYSMEMSURFACE *MemSurface ;

	MemSurface = &GRH.SysMemSurface[ Index ] ;

	if( MemSurface->InitializeFlag == FALSE ||
		MemSurface->UseFlag == FALSE )
		return 0 ;

	MemSurface->UseFlag = FALSE ;
	MemSurface->UseTime = NS_GetNowCount() ;

	// 終了
	return 0 ;
}


// 管理テクスチャへの転送用のシステムメモリテクスチャをすべて解放する
static int ReleaseSysMemTextureAll( int IsNotUseOnly )
{
	int i ;
	int ReleaseCount ;
	IMAGEDATA2_SYSMEMTEXTURE *MemTex ;

	ReleaseCount = 0 ;
	MemTex = GRH.SysMemTexture ;
	for( i = 0 ; i < GRH.SysMemTextureInitNum ; MemTex ++ )
	{
		if( MemTex->InitializeFlag == FALSE )
		{
			continue ;
		}

		i ++ ;

		if( IsNotUseOnly && MemTex->UseFlag )
		{
			continue ;
		}

		if( MemTex->MemTexture != NULL )
		{
			Graphics_ObjectRelease( MemTex->MemTexture ) ;
			MemTex->MemTexture = NULL ;
		}

		MemTex->InitializeFlag = FALSE ;
		MemTex->UseCount = 0 ;
		MemTex->UseFlag = FALSE ;

		ReleaseCount ++ ;
	}
	GRH.SysMemTextureInitNum -= ReleaseCount ;

	// 終了
	return 0 ;
}

// 管理テクスチャへの転送用のシステムメモリサーフェスをすべて解放する
static int ReleaseSysMemSurfaceAll( int IsNotUseOnly )
{
	int i ;
	int ReleaseCount ;
	IMAGEDATA2_SYSMEMSURFACE *MemSurface ;

	ReleaseCount = 0 ;
	MemSurface = GRH.SysMemSurface ;
	for( i = 0 ; i < GRH.SysMemSurfaceInitNum ; MemSurface ++ )
	{
		if( MemSurface->InitializeFlag == FALSE )
		{
			continue ;
		}

		i ++ ;

		if( IsNotUseOnly && MemSurface->UseFlag )
		{
			continue ;
		}

		if( MemSurface->MemSurface != NULL )
		{
			Graphics_ObjectRelease( MemSurface->MemSurface ) ;
			MemSurface->MemSurface = NULL ;
		}

		MemSurface->InitializeFlag = FALSE ;
		MemSurface->UseCount = 0 ;
		MemSurface->UseFlag = FALSE ;

		ReleaseCount ++ ;
	}
	GRH.SysMemSurfaceInitNum -= ReleaseCount ;

	// 終了
	return 0 ;
}


// 管理テクスチャへの転送用のシステムメモリテクスチャの定期処理を行う
extern int SysMemTextureProcess( void )
{
	int i ;
	int ReleaseCount ;
	IMAGEDATA2_SYSMEMTEXTURE *MemTex ;
	int NowTime ;

	// メインスレッド以外から呼ばれた場合は何もしない
	if( CheckMainThread() == FALSE )
	{
		return -1 ;
	}

	NowTime = NS_GetNowCount() ;

	MemTex = GRH.SysMemTexture ;
	ReleaseCount = 0 ;
	for( i = 0 ; i < GRH.SysMemTextureInitNum ; MemTex ++ )
	{
		if( MemTex->InitializeFlag == FALSE )
		{
			continue ;
		}

		i ++ ;

		// 最後に使用してから２秒以上経過していたら解放する
		if( MemTex->UseFlag || NowTime - MemTex->UseTime < 2000 )
		{
			continue ;
		}

		if( MemTex->MemTexture != NULL )
		{
			Graphics_ObjectRelease( MemTex->MemTexture ) ;
			MemTex->MemTexture = NULL ;
		}

		MemTex->InitializeFlag = FALSE ;
		MemTex->UseCount = 0 ;
		MemTex->UseFlag = FALSE ;

		ReleaseCount ++ ;
	}
	GRH.SysMemTextureInitNum -= ReleaseCount ;

	// 終了
	return 0 ;
}


// 管理テクスチャへの転送用のシステムメモリサーフェスの定期処理を行う
extern int SysMemSurfaceProcess( void )
{
	int i ;
	int ReleaseCount ;
	IMAGEDATA2_SYSMEMSURFACE *MemSurface ;
	int NowTime ;

	// メインスレッド以外から呼ばれた場合は何もしない
	if( CheckMainThread() == FALSE )
	{
		return -1 ;
	}

	NowTime = NS_GetNowCount() ;

	MemSurface = GRH.SysMemSurface ;
	ReleaseCount = 0 ;
	for( i = 0 ; i < GRH.SysMemSurfaceInitNum ; MemSurface ++ )
	{
		if( MemSurface->InitializeFlag == FALSE )
		{
			continue ;
		}

		i ++ ;

		// 最後に使用してから２秒以上経過していたら解放する
		if( MemSurface->UseFlag || NowTime - MemSurface->UseTime < 2000 )
		{
			continue ;
		}

		if( MemSurface->MemSurface != NULL )
		{
			Graphics_ObjectRelease( MemSurface->MemSurface ) ;
			MemSurface->MemSurface = NULL ;
		}

		MemSurface->InitializeFlag = FALSE ;
		MemSurface->UseCount = 0 ;
		MemSurface->UseFlag = FALSE ;

		ReleaseCount ++ ;
	}
	GRH.SysMemSurfaceInitNum -= ReleaseCount ;

	// 終了
	return 0 ;
}



// 描画先用テクスチャと描画用テクスチャが分かれている場合に、描画用テクスチャに描画先用テクスチャの内容を反映する
static int UpdateDrawTexture( IMAGEDATA2_ORIG_HARD_TEX *OrigTex, int TargetSurface )
{
	GraphicsDevice_StretchRect(
		OrigTex->RenderTargetSurface,
		NULL,
		OrigTex->Surface[ TargetSurface ],
		NULL,
		D_D3DTEXF_NONE ) ;

	// 終了
	return 0 ;
}

// ＭＳＡＡを使用する描画可能画像かどうかを調べる( TRUE:MSAA画像  FALSE:MSAA画像ではない )
static int CheckMultiSampleDrawValidGraph( int GrHandle )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHKFULL( GrHandle, Image2 ) )
		return FALSE ;

	if( Image2->Orig->FormatDesc.TextureFlag == FALSE )
		return FALSE ;

	return Image2->Orig->FormatDesc.MSSamples != 0 ? TRUE : FALSE ;
}



#ifndef DX_NON_MOVIE

// ムービー画像を更新する
static void UpdateGraphMovie( MOVIEGRAPH *Movie, DWORD_PTR GrHandle )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_ORIG *Orig ;

	if( GRAPHCHK( ( LONG_PTR )GrHandle, Image2 ) )
		return;
	Orig = Image2->Orig ;

	// テクスチャかどうかで処理を分岐
	if( Image2->Orig->FormatDesc.TextureFlag )
	{
		// テクスチャの場合

	//	D_DDSURFACEDESC2 SrcDesc ;
		BASEIMAGE MovieImage, AlphaImage ;
		RECT SrcRect ;
#ifndef DX_NON_OGGTHEORA
		DX_DIRECT3DSURFACE9 *YUY2Image ;
#endif

		// ムービーイメージの構築
#ifndef DX_NON_OGGTHEORA
		// Ogg Theora を使用している場合はここで更新処理
		if( Movie->TheoraFlag )
		{
			if( Movie->RightAlpha == TRUE || TheoraDecode_GetYUVImage( Movie->TheoraHandle ) == NULL )
			{
				if( TheoraDecode_SetupImage( Movie->TheoraHandle, 1, 0 ) == 0 )
				{
					return ;
				}
			}
			else
			{
				if( TheoraDecode_SetupImage( Movie->TheoraHandle, 0, 1 ) == 0 )
				{
					return ;
				}
			}
		}

		// Theora を使用していて、且つ YUY2 フォーマットを使用しているかで処理を分岐
		if( Movie->TheoraFlag && Movie->RightAlpha == FALSE && ( YUY2Image = ( DX_DIRECT3DSURFACE9 * )TheoraDecode_GetYUVImage( Movie->TheoraHandle ) ) )
		{
			if( GraphicsDevice_IsValid() != 0 )
			{
				RECT Rect ;
				DX_DIRECT3DSURFACE9 *Surface ;

				// ビットマップデータを分割されているテクスチャーに貼り付ける
				SETRECT( Rect, 0, 0, Image2->Orig->Hard.Tex[ 0 ].UseWidth, Image2->Orig->Hard.Tex[ 0 ].UseHeight ) ;

				// グラフィックの転送
				if( GraphicsTexture_GetSurfaceLevel( Image2->Orig->Hard.Tex[ 0 ].Texture, 0, &Surface ) == D_D3D_OK )
				{
					HRESULT hr ;
					hr = GraphicsDevice_StretchRect( YUY2Image, &Rect, Surface, &Rect, D_D3DTEXF_NONE ) ;
					Graphics_ObjectRelease( Surface ) ;
				}
			}
		}
		else
#endif
		{
			// ムービーのイメージ情報を作成する
			MovieImage = *Movie->UseNowImage ;
			
			// 右側半分がアルファ情報の場合はアルファ情報を転送する準備をする
			if( Movie->RightAlpha )
			{
				MovieImage.Width /= 2;
				AlphaImage = MovieImage;
				AlphaImage.GraphData = (BYTE *)MovieImage.GraphData + MovieImage.Width * MovieImage.ColorData.PixelByte ;
			}

			// 転送元矩形をセット
			SETRECT( SrcRect, Image2->UseOrigX, Image2->UseOrigY, Image2->UseOrigX + Image2->Width, Image2->UseOrigY + Image2->Height ) ;

			// 分割されているテクスチャーに貼り付ける
			BltBmpOrBaseImageToGraph3(
				NULL,
				NULL,
				NULL,
				&SrcRect,
				0,
				0,
				( int )GrHandle,
				FALSE,
				&MovieImage,
				Movie->RightAlpha ? &AlphaImage : NULL,
				FALSE,
				FALSE,
				FALSE ) ;
		}
	}
	else
	{
		// テクスチャでは無い場合
		MEMIMG *MemImg ;

		MemImg = &Image2->Soft.MemImg ;

#ifndef DX_NON_OGGTHEORA
		// Ogg Theora を使用している場合はここで更新
		if( Movie->TheoraFlag )
		{
			if( TheoraDecode_SetupImage( Movie->TheoraHandle, 1, 0 ) == 0 )
				return ;
		}
#endif

		// ピクセルフォーマットが違うか、右側半分をアルファ情報として扱う場合はカラーマッチング転送を行う
		if( Movie->SurfaceMode == DX_MOVIESURFACE_FULLCOLOR ||
			MemImg->Base->ColorDataP->ColorBitDepth != Movie->UseNowImage->ColorData.ColorBitDepth ||
			Movie->RightAlpha == 1 )
		{
			// 右半分がアルファ情報ではない場合は簡易転送
			if( Movie->RightAlpha == 0 )
			{
				BltBaseImageToMemImg(
					Movie->UseNowImage,
					NULL,
					MemImg,
					0,
					0,
					Image2->Width,
					Image2->Height,
					0,
					0,
					FALSE ) ;
			}
			else
			{
				// 右半分がアルファ情報の場合は通常転送
				BASEIMAGE MovieImage, AlphaImage;
				RECT SrcRect ;

				SETRECT( SrcRect, 0, 0, Image2->Width, Image2->Height ) ;
				MovieImage.ColorData	= Movie->UseNowImage->ColorData ;
				MovieImage.GraphData	= Movie->UseNowImage->GraphData ;
				MovieImage.Pitch		= Movie->UseNowImage->Pitch ;
				MovieImage.Width		= Movie->UseNowImage->Width / 2;
				MovieImage.Height		= Movie->UseNowImage->Height ;

				AlphaImage = MovieImage;
				AlphaImage.GraphData = (BYTE *)MovieImage.GraphData + MovieImage.Width * MovieImage.ColorData.PixelByte ;

				// グラフィックの転送
				BltBaseImageToMemImg(
					&MovieImage,
					&AlphaImage,
					MemImg,
					0,
					0,
					Image2->Width,
					Image2->Height,
					0,
					0,
					FALSE ) ;
			}
		}
		else
		{
			// 高速転送処理プログラム
			void *DestP, *SrcP ;
			int SrcAddPitch, DestAddPitch ;
			int DwMoveSetNum, NokoriMoveSetNum ;
			int MoveLineByte, ColorBitDepth ;
			int PixelByte ;
			int BltHeight ;

			// 転送するライン数をセット
			BltHeight = Movie->Height ;

			// 色ビット数をセット
			ColorBitDepth = NS_GetColorBitDepth() ;

			// １ドット当たりのバイト数取得
			PixelByte = ColorBitDepth / 8 ;

			// １ライン当たりの転送サイズをセット
			MoveLineByte = Movie->Width * PixelByte ;

			// 転送元、先アドレスセット
			DestP = MemImg->UseImage ;
			SrcP = Movie->UseNowImage->GraphData ;

			// １ライン転送後、次の転送元アドレスまでのバイト数計算
			DestAddPitch = MemImg->Base->Pitch - MoveLineByte ;
			SrcAddPitch = Movie->UseNowImage->Pitch - MoveLineByte ;

			// ４バイト転送何回、その後あまる転送分が何ピクセル分あるか算出
			DwMoveSetNum = MoveLineByte / 4 ;
			NokoriMoveSetNum = ( MoveLineByte - DwMoveSetNum * 4 ) / PixelByte ;

			// 転送処理
#ifndef DX_NON_INLINE_ASM
			_asm{
				PUSHF
				CLD
				MOV		EDI, DestP
				MOV		ESI, SrcP
				MOV		EAX, DestAddPitch
				MOV		EBX, SrcAddPitch
				MOV		EDX, BltHeight
				CMP		ColorBitDepth, 8
				JZ		CB8
				CMP		ColorBitDepth, 16
				JZ		CB16


			CB32:
				MOV		ECX, DwMoveSetNum
				REP		MOVSD
				ADD		EDI, DestAddPitch
				ADD		ESI, SrcAddPitch
				DEC		EDX
				JNZ		CB32
				JMP		END_


			CB16:
				MOV		ECX, DwMoveSetNum
				TEST	ECX, 0xffffffff
				JZ		B161
				REP		MOVSD
			B161:
				MOV		ECX, NokoriMoveSetNum
				TEST	ECX, 0xffffffff
				JZ		B162
				REP		MOVSW
			B162:
				ADD		EDI, DestAddPitch
				ADD		ESI, SrcAddPitch
				DEC		EDX
				JNZ		CB16
				JMP		END_


			CB8:
				MOV		ECX, DwMoveSetNum
				TEST	ECX, 0xffffffff
				JZ		B81
				REP		MOVSD
			B81:
				MOV		ECX, NokoriMoveSetNum
				TEST	ECX, 0xffffffff
				JZ		B82
				REP		MOVSB
			B82:
				ADD		EDI, DestAddPitch
				ADD		ESI, SrcAddPitch
				DEC		EDX
				JNZ		CB8
				JMP		END_

			END_:
				POPF
			}
#else
			int i, j ;
			BYTE *DestBP, *SrcBP ;

			DestBP = ( BYTE * )DestP ;
			SrcBP = ( BYTE * )SrcP ;
			switch( ColorBitDepth )
			{
			case 8 :
				for( i = BltHeight ; i > 0 ; i -- )
				{
					for( j = DwMoveSetNum ; j > 0 ; j --, DestBP += 4, SrcBP += 4 )
					{
						*( ( DWORD * )DestBP ) = *( ( DWORD * )SrcBP ) ;
					}
					for( j = NokoriMoveSetNum ; j > 0 ; j --, DestBP ++, SrcBP ++ )
					{
						*DestBP = *SrcBP ;
					}
					DestBP += DestAddPitch ;
					SrcBP += SrcAddPitch ;
				}
				break ;

			case 16 :
				for( i = BltHeight ; i > 0 ; i -- )
				{
					for( j = DwMoveSetNum ; j > 0 ; j --, DestBP += 4, SrcBP += 4 )
					{
						*( ( DWORD * )DestBP ) = *( ( DWORD * )SrcBP ) ;
					}
					for( j = NokoriMoveSetNum ; j > 0 ; j --, DestBP += 2, SrcBP += 2 )
					{
						*( ( WORD * )DestBP ) = *( ( WORD * )SrcBP ) ;
					}
					DestBP += DestAddPitch ;
					SrcBP += SrcAddPitch ;
				}
				break ;

			case 32 :
				for( i = BltHeight ; i > 0 ; i -- )
				{
					for( j = DwMoveSetNum ; j > 0 ; j --, DestBP += 4, SrcBP += 4 )
					{
						*( ( DWORD * )DestBP ) = *( ( DWORD * )SrcBP ) ;
					}
					DestBP += DestAddPitch ;
					SrcBP += SrcAddPitch ;
				}
				break ;
			}
#endif
		}
	}
}

#endif

// D3DFORMAT のフォーマットに合わせたカラーフォーマット情報を取得する
extern COLORDATA *GetD3DFormatColorData( D_D3DFORMAT Format )
{
	static int InitializeFlag = FALSE ;
	static COLORDATA R8G8B8_ColorData,   A8R8G8B8_ColorData,    X8R8G8B8_ColorData ;
	static COLORDATA R5G6B5_ColorData,   X1R5G5B5_ColorData,    A1R5G5B5_ColorData ;
	static COLORDATA A4R4G4B4_ColorData, R3G3B2_ColorData,      A8R3G3B2_ColorData ;
	static COLORDATA X4R4G4B4_ColorData, A2B10G10R10_ColorData, A8B8G8R8_ColorData ;
	static COLORDATA X8B8G8R8_ColorData, A2R10G10B10_ColorData ;
	static COLORDATA A16B16G16R16I_ColorData ;
	static COLORDATA A16B16G16R16F_ColorData ;
	static COLORDATA A32B32G32R32F_ColorData ;
	static COLORDATA ONE_I8_ColorData ;
	static COLORDATA ONE_I16_ColorData ;
	static COLORDATA ONE_F16_ColorData ;
	static COLORDATA ONE_F32_ColorData ;
	static COLORDATA TWO_I8_ColorData ;
	static COLORDATA TWO_I16_ColorData ;
	static COLORDATA TWO_F16_ColorData ;
	static COLORDATA TWO_F32_ColorData ;

	if( InitializeFlag == FALSE )
	{
		InitializeFlag = TRUE ;
		NS_CreateColorData( &R8G8B8_ColorData,         24, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000 ) ;
		NS_CreateColorData( &A8R8G8B8_ColorData,       32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &X8R8G8B8_ColorData,       32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000 ) ;
		NS_CreateColorData( &R5G6B5_ColorData,         16, 0x0000f800, 0x000007e0, 0x0000001f, 0x00000000 ) ;
		NS_CreateColorData( &X1R5G5B5_ColorData,       16, 0x00007c00, 0x000003e0, 0x0000001f, 0x00000000 ) ;
		NS_CreateColorData( &A1R5G5B5_ColorData,       16, 0x00007c00, 0x000003e0, 0x0000001f, 0x00008000 ) ;
		NS_CreateColorData( &A4R4G4B4_ColorData,       16, 0x00000f00, 0x000000f0, 0x0000000f, 0x0000f000 ) ;
		NS_CreateColorData( &R3G3B2_ColorData,          8, 0x000000e0, 0x0000001c, 0x00000003, 0x00000000 ) ;
		NS_CreateColorData( &A8R3G3B2_ColorData,       16, 0x000000e0, 0x0000001c, 0x00000003, 0x0000ff00 ) ;
		NS_CreateColorData( &X4R4G4B4_ColorData,       16, 0x00000f00, 0x000000f0, 0x0000000f, 0x00000000 ) ;
		NS_CreateColorData( &A2B10G10R10_ColorData,    32, 0x000003ff, 0x000ffc00, 0x3ff00000, 0xc0000000 ) ;
		NS_CreateColorData( &A8B8G8R8_ColorData,       32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0xff000000 ) ;
		NS_CreateColorData( &X8B8G8R8_ColorData,       32, 0x000000ff, 0x0000ff00, 0x00ff0000, 0x00000000 ) ;
		NS_CreateColorData( &A2R10G10B10_ColorData,    32, 0x3ff00000, 0x000ffc00, 0x000003ff, 0xc0000000 ) ;
		NS_CreateColorData( &A16B16G16R16I_ColorData,   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 4, 16, FALSE ) ;
		NS_CreateColorData( &A16B16G16R16F_ColorData,   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 4, 16,  TRUE ) ;
		NS_CreateColorData( &A32B32G32R32F_ColorData,   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 4, 32,  TRUE ) ;
		NS_CreateColorData( &ONE_I8_ColorData,	        0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 1,  8, FALSE ) ;
		NS_CreateColorData( &ONE_I16_ColorData,	        0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 1, 16, FALSE ) ;
		NS_CreateColorData( &ONE_F16_ColorData,	        0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 1, 16,  TRUE ) ;
		NS_CreateColorData( &ONE_F32_ColorData,	        0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 1, 32,  TRUE ) ;
		NS_CreateColorData( &TWO_I8_ColorData,	        0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 2,  8, FALSE ) ;
		NS_CreateColorData( &TWO_I16_ColorData,	        0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 2, 16, FALSE ) ;
		NS_CreateColorData( &TWO_F16_ColorData,	        0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 2, 16,  TRUE ) ;
		NS_CreateColorData( &TWO_F32_ColorData,	        0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 2, 32,  TRUE ) ;
	}

	switch( Format )
	{
	case D_D3DFMT_R8G8B8 :        return &R8G8B8_ColorData ;
	case D_D3DFMT_A8R8G8B8 :      return &A8R8G8B8_ColorData ;
	case D_D3DFMT_X8R8G8B8 :      return &X8R8G8B8_ColorData ;
	case D_D3DFMT_R5G6B5 :        return &R5G6B5_ColorData ;
	case D_D3DFMT_X1R5G5B5 :      return &X1R5G5B5_ColorData ;
	case D_D3DFMT_A1R5G5B5 :      return &A1R5G5B5_ColorData ;
	case D_D3DFMT_A4R4G4B4 :      return &A4R4G4B4_ColorData ;
	case D_D3DFMT_R3G3B2 :        return &R3G3B2_ColorData ;
	case D_D3DFMT_A8R3G3B2 :      return &A8R3G3B2_ColorData ;
	case D_D3DFMT_X4R4G4B4 :      return &X4R4G4B4_ColorData ;
	case D_D3DFMT_A2B10G10R10 :   return &A2B10G10R10_ColorData ;
	case D_D3DFMT_A8B8G8R8 :      return &A8B8G8R8_ColorData ;
	case D_D3DFMT_X8B8G8R8 :      return &X8B8G8R8_ColorData ;
	case D_D3DFMT_A2R10G10B10 :   return &A2R10G10B10_ColorData ;
	case D_D3DFMT_A16B16G16R16 :  return &A16B16G16R16I_ColorData ;
	case D_D3DFMT_A16B16G16R16F : return &A16B16G16R16F_ColorData ;
	case D_D3DFMT_A32B32G32R32F : return &A32B32G32R32F_ColorData ;
	case D_D3DFMT_L8 :            return &ONE_I8_ColorData ;
	case D_D3DFMT_L16 :           return &ONE_I16_ColorData ;
	case D_D3DFMT_R16F :          return &ONE_F16_ColorData ;
	case D_D3DFMT_R32F :          return &ONE_F32_ColorData ;
	case D_D3DFMT_V8U8 :          return &TWO_I8_ColorData ;
	case D_D3DFMT_G16R16 :        return &TWO_I16_ColorData ;
	case D_D3DFMT_G16R16F :       return &TWO_F16_ColorData ;
	case D_D3DFMT_G32R32F :       return &TWO_F32_ColorData ;
	}
	return NULL ;
}

extern int AllocCommonBuffer( int Index, DWORD Size )
{
	if( Index >= COMMON_BUFFER_NUM || Index < 0 )
	{
		return -1 ;
	}

	if( GRH.CommonBufferSize[ Index ] >= Size )
	{
		return 0 ;
	}

	GRH.CommonBuffer[ Index ] = DXALLOC( Size ) ;
	if( GRH.CommonBuffer[ Index ] == NULL )
	{
		return -1 ;
	}
	GRH.CommonBufferSize[ Index ] = Size ;

	return 0 ;
}

extern int TerminateCommonBuffer( void ) 
{
	int i ;

	for( i = 0 ; i < COMMON_BUFFER_NUM ; i ++ )
	{
		if( GRH.CommonBuffer[ i ] != NULL )
		{
			DXFREE( GRH.CommonBuffer[ i ] ) ;
			GRH.CommonBuffer[ i ] = 0 ;
		}

		GRH.CommonBufferSize[ i ] = 0 ;
	}

	return 0 ;
}

// 新しいグラフィックハンドルを確保する
extern int AddGraphHandle( void )
{
	return AddHandle( DX_HANDLETYPE_GRAPH );
}

// グラフィックハンドルの初期化
extern int InitializeGraphHandle( HANDLEINFO *HandleInfo )
{
	IMAGEDATA2 *Image2 = ( IMAGEDATA2 * )HandleInfo ;

#ifndef DX_NON_MOVIE
	// ムービーハンドルは無し
	Image2->MovieHandle = -1 ;
#endif

	// 終了
	return 0 ;
}

// グラフィックハンドルの後始末
extern int TerminateGraphHandle( HANDLEINFO *HandleInfo )
{
	IMAGEDATA2 *Image2 = ( IMAGEDATA2 * )HandleInfo ;
	int i ;

	// ムービーグラフィックだった場合その後始末を行う
#ifndef DX_NON_MOVIE
	CloseMovie( Image2->MovieHandle ) ;
#endif

	// 描画先になっていたら描画先を表画面にする
	for( i = 0 ; i < GRH.RenderTargetNum ; i ++ )
	{
		if( GBASE.TargetScreen[ i ] == Image2->HandleInfo.Handle )
		{
			NS_SetRenderTargetToShader( i, i == 0 ? DX_SCREEN_FRONT : -1 ) ;
		}
	}

	// 描画先Ｚバッファになっていたら描画先を裏画面にする
	if( GBASE.TargetZBuffer == Image2->HandleInfo.Handle )
	{
		NS_SetDrawZBuffer( DX_SCREEN_BACK ) ;
	}

	// オリジナルデータがある場合はオリジナルデータの解放処理を行う
	if( Image2->Orig )
	{
		// テクスチャかどうかで処理を分岐
		if( Image2->Orig->FormatDesc.TextureFlag )
		{
			// テクスチャの場合
		}
		else
		{
			// テクスチャでは無い場合

			// 描画用 MEMIMG の後始末
			TerminateMemImg( &Image2->Soft.MemImg ) ;
		}

		// オリジナルデータの参照数をデクリメント
		Image2->Orig->RefCount -- ;

		// ０になったらオリジナルデータの解放処理を行う
		if( Image2->Orig->RefCount == 0 )
		{
			// Ｚバッファを解放する
			//ReleaseOrigZBuffer( Image2->Orig ) ;

			// テクスチャかどうかで処理を分岐
			if( Image2->Orig->FormatDesc.TextureFlag )
			{
				// テクスチャの場合

				// テクスチャオブジェクトの解放
				ReleaseOrigTexture( Image2->Orig ) ;
			}
			else
			{
				// テクスチャでは無い場合

				// MEMIMG を解放する
				TerminateMemImg( &Image2->Orig->Soft.MemImg ) ;
			}

			// オリジナル画像データ用に確保したメモリ領域を開放
			DXFREE( Image2->Orig ) ;
		}

		Image2->Orig = NULL ;
	}

	// フルカラーイメージがある場合は解放
	if( Image2->FullColorImage != NULL )
	{
		DXFREE( Image2->FullColorImage ) ;
		Image2->FullColorImage = NULL ;
	}

	// ロックイメージがある場合は解放
	if( Image2->LockImage != NULL )
	{
		DXFREE( Image2->LockImage ) ;
		Image2->LockImage = NULL ;
	}

	// ファイル名保存用にメモリを確保していた場合は解放
	SetGraphBaseInfo( Image2->HandleInfo.Handle, NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, NULL, NULL, FALSE, -1, FALSE ) ;

	// 解放時に立てるフラグへのポインタが有効である場合は立てる
	if( Image2->LostFlag != NULL )
		*Image2->LostFlag = TRUE ;

	// 終了
	return 0 ;
}

// シャドウマップハンドルの初期化
extern int InitializeShadowMapHandle( HANDLEINFO *HandleInfo )
{
	SHADOWMAPDATA *ShadowMap = ( SHADOWMAPDATA * )HandleInfo ;

	ShadowMap->BaseSizeX = -1 ;
	ShadowMap->BaseSizeY = -1 ;

	ShadowMap->AdjustDepth = DEFAULT_SHADOWMAP_ADJUST_DEPTH ;
	ShadowMap->BlurParam = DEFAULT_SHADOWMAP_BLUR_PARAM ;
	ShadowMap->GradationParam = DEFAULT_SHADOWMAP_GRADATION_RANGE ;

	ShadowMap->LightMatrix.m[ 3 ][ 3 ] = 1.0f ;
	ShadowMap->ShadowMapProjectionMatrix.m[ 3 ][ 3 ] = 1.0f ;

	// 初期ライト方向の設定
	NS_SetShadowMapLightDirection( HandleInfo->Handle, VGet( 0.0f, -1.0f, 0.0f ) ) ;

	// 終了
	return 0 ;
}

// シャドウマップハンドルの後始末
extern int TerminateShadowMapHandle( HANDLEINFO *HandleInfo )
{
	SHADOWMAPDATA *ShadowMap = ( SHADOWMAPDATA * )HandleInfo ;
	int i ;

	// 描画で使用するシャドウマップに設定されていたら解除
	for( i = 0 ; i < MAX_USE_SHADOWMAP_NUM ; i ++ )
	{
		if( GBASE.ShadowMap[ i ] == HandleInfo->Handle )
		{
			NS_SetDrawUseShadowMap( i, -1 ) ;
		}
	}

	// シャドウマップの描画準備が行われていたら解除する
	if( ShadowMap->DrawSetupFlag )
	{
		NS_ShadowMap_DrawEnd() ;
	}

	// サーフェスやテクスチャを解放
	ReleaseShadowMapTexture( ShadowMap ) ;

	// 解放時に立てるフラグへのポインタが有効である場合は立てる
	if( ShadowMap->LostFlag != NULL )
		*ShadowMap->LostFlag = TRUE ;

	// 終了
	return 0 ;
}

// 新しいシャドウマップハンドルを確保する
extern int AddShadowMapHandle( void )
{
	return AddHandle( DX_HANDLETYPE_SHADOWMAP );
}

// シャドウマップハンドルのセットアップを行う
extern int SetupShadowMapHandle_UseGParam( SETUP_SHADOWMAPHANDLE_GPARAM *GParam, int SmHandle, int SizeX, int SizeY, int TexFormat_Float, int TexFormat_BitDepth, int ASyncThread )
{
	SHADOWMAPDATA *ShadowMap ;

	// アドレスの取得
	if( SHADOWMAPCHK_ASYNC( SmHandle, ShadowMap ) )
		return -1 ;

	// パラメータの保存
	ShadowMap->TexFormat_Float = TexFormat_Float ;
	ShadowMap->TexFormat_BitDepth = TexFormat_BitDepth ;
	ShadowMap->BaseSizeX = SizeX ;
	ShadowMap->BaseSizeY = SizeY ;

	// テクスチャの作成
	if( CreateShadowMapTexture( ShadowMap ) == -1 )
	{
		goto ERR ;
	}

	// 終了
	return 0 ;

	// エラー終了
ERR :
	NS_DeleteGraph( SmHandle ) ;

	return -1 ;
}

// シャドウマップデータに必要なテクスチャを作成する
extern int CreateShadowMapTexture( SHADOWMAPDATA *ShadowMap, int ASyncThread )
{
	// フォーマットの決定
	if( ShadowMap->TexFormat_Float )
	{
		if( ShadowMap->TexFormat_BitDepth == 16 )
		{
			ShadowMap->ColorFormat = /*DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F16*/DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F16 ;
			ShadowMap->ZBufferFormat = ZBUFFER_FORMAT_16BIT ;
		}
		else
		{
			ShadowMap->ColorFormat = /*DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F32*/DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32 ;
			ShadowMap->ZBufferFormat = ZBUFFER_FORMAT_32BIT ;
		}
	}
	else
	{
		if( ShadowMap->TexFormat_BitDepth == 16 )
		{
			ShadowMap->ColorFormat = /*DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I16*/ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I16 ;
			ShadowMap->ZBufferFormat = ZBUFFER_FORMAT_16BIT ;
		}
		else
		{
			ShadowMap->ColorFormat = DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32 ;
			ShadowMap->ZBufferFormat = ZBUFFER_FORMAT_32BIT ;
		}
	}

	// 決定したフォーマットが作成できない場合は失敗
	if( GRH.TextureFormat[ ShadowMap->ColorFormat ] == D_D3DFMT_UNKNOWN )
	{
		DXST_ERRORLOG_ADD( _T( "シャドウマップデータ用のフォーマットで作成できるテクスチャフォーマットがありませんでした\n" ) ) ;
		return -1 ;
	}

	// レンダリングターゲット深度バッファの作成
	if( ShadowMap->ZBufferSurface == NULL )
	{
		if( GraphicsDevice_CreateDepthStencilSurface_ASync(
			ShadowMap->BaseSizeX,					// 幅
			ShadowMap->BaseSizeY,					// 高さ
			GRH.ZBufferFormat[ ShadowMap->ZBufferFormat ],		// フォーマット
			D_D3DMULTISAMPLE_NONE,					// マルチサンプリングタイプ
			0,										// マルチサンプリングクオリティ
			FALSE,									// ロックはできない
			&ShadowMap->ZBufferSurface,				// DX_DIRECT3DSURFACE9 のポインタを受け取るアドレス
			NULL,									// 絶対 NULL
			ASyncThread
			) != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "シャドウマップ用深度サーフェスの作成に失敗しました\n" ) ) ;
			return -1 ;
		}
	}

	// レンダーターゲットにできるテクスチャの作成
	if( ShadowMap->Texture == NULL )
	{
		if( GraphicsDevice_CreateTexture_ASync(
			ShadowMap->BaseSizeX,					// 幅
			ShadowMap->BaseSizeY,					// 高さ
			1,										// MipMap レベル
			D_D3DUSAGE_RENDERTARGET,				// フラグ
			GRH.TextureFormat[ ShadowMap->ColorFormat ],		// フォーマット
			D_D3DPOOL_DEFAULT,						// テクスチャを DirectX が管理するかどうか
			&ShadowMap->Texture,					// DX_DIRECT3DTEXTURE9 のポインタを受け取るアドレス
			NULL,									// 絶対 NULL
			ASyncThread
			) != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "シャドウマップ用テクスチャの作成に失敗しました\n" ) ) ;
			return -1 ;
		}

		// テクスチャのサーフェスを取得しておく
		if( GraphicsTexture_GetSurfaceLevel_ASync( ShadowMap->Texture, 0, &ShadowMap->Surface, ASyncThread ) != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "シャドウマップ用テクスチャのサーフェスアドレスの取得に失敗しました\n" ) ) ;
			return -1 ;
		}
	}

	// 終了
	return 0 ;
}

// シャドウマップデータに必要なテクスチャを解放する
extern int ReleaseShadowMapTexture( SHADOWMAPDATA *ShadowMap )
{
	if( ShadowMap->ZBufferSurface != NULL )
	{
		Graphics_ObjectRelease( ShadowMap->ZBufferSurface ) ;
		ShadowMap->ZBufferSurface = NULL ;
	}

	if( ShadowMap->Surface != NULL )
	{
		Graphics_ObjectRelease( ShadowMap->Surface ) ;
		ShadowMap->Surface = NULL ;
	}

	if( ShadowMap->Texture != NULL )
	{
		Graphics_ObjectRelease( ShadowMap->Texture ) ;
		ShadowMap->Texture = NULL ;
	}

	// 終了
	return 0 ;
}

// シャドウマップデータをハンドル値から取り出す
extern SHADOWMAPDATA *GetShadowMapData( int SmHandle, int ASyncThread )
{
	SHADOWMAPDATA *ShadowMap ;

	// エラー判定
	if( ASyncThread )
	{
		if( SHADOWMAPCHK_ASYNC( SmHandle, ShadowMap ) )
			return NULL ;
	}
	else
	{
		if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
			return NULL ;
	}

	return ShadowMap ;
}


// シャドウマップが想定するライトの方向を設定する
extern int NS_SetShadowMapLightDirection( int SmHandle, VECTOR Direction )
{
	VECTOR xvec ;
	VECTOR yvec ;
	VECTOR zvec ;
	SHADOWMAPDATA *ShadowMap ;

	// アドレスの取得
	if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
		return -1 ;

	// ライトベクトル方向に回転するための行列を作成
	zvec = VNorm( Direction ) ;
	yvec = VGet( 0.0f, 1.0f, 0.0f ) ;
	xvec = VCross( yvec, zvec ) ;
	if( VSquareSize( xvec ) <= 0.0000001f )
	{
		yvec = VGet( 1.0f, 0.0f, 0.0f ) ;
		xvec = VCross( yvec, zvec ) ;
	}
	yvec = VNorm( VCross( zvec, xvec ) ) ;
	xvec = VNorm( xvec ) ;
	ShadowMap->ShadowMapViewMatrix.m[ 0 ][ 0 ] = ShadowMap->LightMatrix.m[ 0 ][ 0 ] = xvec.x ;
	ShadowMap->ShadowMapViewMatrix.m[ 1 ][ 0 ] = ShadowMap->LightMatrix.m[ 1 ][ 0 ] = xvec.y ;
	ShadowMap->ShadowMapViewMatrix.m[ 2 ][ 0 ] = ShadowMap->LightMatrix.m[ 2 ][ 0 ] = xvec.z ;

	ShadowMap->ShadowMapViewMatrix.m[ 0 ][ 1 ] = ShadowMap->LightMatrix.m[ 0 ][ 1 ] = yvec.x ;
	ShadowMap->ShadowMapViewMatrix.m[ 1 ][ 1 ] = ShadowMap->LightMatrix.m[ 1 ][ 1 ] = yvec.y ;
	ShadowMap->ShadowMapViewMatrix.m[ 2 ][ 1 ] = ShadowMap->LightMatrix.m[ 2 ][ 1 ] = yvec.z ;

	ShadowMap->ShadowMapViewMatrix.m[ 0 ][ 2 ] = ShadowMap->LightMatrix.m[ 0 ][ 2 ] = zvec.x ;
	ShadowMap->ShadowMapViewMatrix.m[ 1 ][ 2 ] = ShadowMap->LightMatrix.m[ 1 ][ 2 ] = zvec.y ;
	ShadowMap->ShadowMapViewMatrix.m[ 2 ][ 2 ] = ShadowMap->LightMatrix.m[ 2 ][ 2 ] = zvec.z ;

	// ライトの方向を保存
	ShadowMap->LightDirection = Direction ;

	// もしシャドウマップへの描画準備済みの場合はシャドウマップへの描画に必要な行列を更新する
	if( ShadowMap->DrawSetupFlag )
	{
		// 行列の更新
		RefreshShadowMapMatrix( ShadowMap ) ;
	}

	// 終了
	return 0 ;
}

// シャドウマップへのレンダリングで使用する行列の情報を更新する
static int RefreshShadowMapMatrix( SHADOWMAPDATA *ShadowMap )
{
	VECTOR TempPos ;
	VECTOR MaxPos ;
	VECTOR MinPos ;
	VECTOR *SrcPos ;
	VECTOR EyePos ;
	VECTOR AreaSize ;
	int i ;

	// ライト始点からの最大座標と最小座標を割り出す
	SrcPos = ShadowMap->EnableDrawArea ? ShadowMap->DrawAreaViewClipPos : ShadowMap->DefaultViewClipPos ;
	MinPos.x =  100000000.0f ;
	MinPos.y =  100000000.0f ;
	MinPos.z =  100000000.0f ;
	MaxPos.x = -100000000.0f ;
	MaxPos.y = -100000000.0f ;
	MaxPos.z = -100000000.0f ;
	for( i = 0 ; i < 8 ; i ++, SrcPos ++ )
	{
		VectorTransformSR( &TempPos, SrcPos, &ShadowMap->LightMatrix ) ;

		if( MinPos.x > TempPos.x ) MinPos.x = TempPos.x ;
		if( MinPos.y > TempPos.y ) MinPos.y = TempPos.y ;
		if( MinPos.z > TempPos.z ) MinPos.z = TempPos.z ;

		if( MaxPos.x < TempPos.x ) MaxPos.x = TempPos.x ;
		if( MaxPos.y < TempPos.y ) MaxPos.y = TempPos.y ;
		if( MaxPos.z < TempPos.z ) MaxPos.z = TempPos.z ;
	}

	// シャドウマップ描画用ビュー行列の平行移動成分を設定
	EyePos.x = ( MaxPos.x + MinPos.x ) / 2.0f ;
	EyePos.y = ( MaxPos.y + MinPos.y ) / 2.0f ;
	EyePos.z = MinPos.z ;
	ShadowMap->ShadowMapViewMatrix.m[ 3 ][ 0 ] = -EyePos.x ;
	ShadowMap->ShadowMapViewMatrix.m[ 3 ][ 1 ] = -EyePos.y ;
	ShadowMap->ShadowMapViewMatrix.m[ 3 ][ 2 ] = -EyePos.z ;

	// シャドウマップ描画用の射影行列の拡大成分を設定
	AreaSize = VSub( MaxPos, MinPos ) ;
	ShadowMap->ShadowMapProjectionMatrix.m[ 0 ][ 0 ] = 2.0f / AreaSize.x ;
	ShadowMap->ShadowMapProjectionMatrix.m[ 1 ][ 1 ] = 2.0f / AreaSize.y ;
	ShadowMap->ShadowMapProjectionMatrix.m[ 2 ][ 2 ] = 1.0f / ( MaxPos.z - MinPos.z ) ;

	// ビュー行列と射影行列のセット
	NS_SetTransformToView( &ShadowMap->ShadowMapViewMatrix ) ;
	NS_SetTransformToProjection( &ShadowMap->ShadowMapProjectionMatrix ) ;

	// 終了
	return 0 ;
}

// シャドウマップへの描画の準備を行う
extern int NS_ShadowMap_DrawSetup( int SmHandle )
{
	int i ;
	SHADOWMAPDATA *ShadowMap ;

	// アドレスの取得
	if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
		return -1 ;

	// 描画で使用するシャドウマップに設定されていたら解除
	for( i = 0 ; i < MAX_USE_SHADOWMAP_NUM ; i ++ )
	{
		if( GBASE.ShadowMap[ i ] == SmHandle )
		{
			NS_SetDrawUseShadowMap( i, -1 ) ;
		}
	}

	// 既に描画準備が完了している場合は何もしない
	if( ShadowMap->DrawSetupFlag == TRUE )
		return -1 ;

	// 別のシャドウマップに対する描画準備が完了していたら、そちらの描画完了状態を解除する
	if( GRH.ShadowMapDraw == TRUE )
	{
		NS_ShadowMap_DrawEnd() ;
	}

	// 元々の描画対象を保存
	for( i = 0 ; i < DX_RENDERTARGET_COUNT ; i ++ )
	{
		ShadowMap->RenderTargetScreen[ i ]        = GBASE.TargetScreen[ i ] ;
		ShadowMap->RenderTargetScreenSurface[ i ] = GBASE.TargetScreenSurface[ i ] ;
	}

	// 現在の描画座標計算用の情報を保存
#ifndef DX_NON_MASK
	ShadowMap->RenderMaskUseFlag          = MASKD.MaskUseFlag ;
#endif

	ShadowMap->RenderCameraPosition       = GBASE.CameraPosition ;
	ShadowMap->RenderCameraTarget         = GBASE.CameraTarget ;
	ShadowMap->RenderCameraUp             = GBASE.CameraUp ;
	ShadowMap->RenderCameraHRotate        = GBASE.CameraHRotate ;
	ShadowMap->RenderCameraVRotate        = GBASE.CameraVRotate ;
	ShadowMap->RenderCameraTRotate        = GBASE.CameraTRotate ;
	ShadowMap->RenderCameraMatrix         = GBASE.CameraMatrix ;
	ShadowMap->RenderCameraScreenCenterX  = GBASE.CameraScreenCenterX ;
	ShadowMap->RenderCameraScreenCenterY  = GBASE.CameraScreenCenterY ;

	ShadowMap->RenderProjectionMatrixMode = GBASE.ProjectionMatrixMode ;
	ShadowMap->RenderProjNear             = GBASE.ProjNear ;
	ShadowMap->RenderProjFar              = GBASE.ProjFar ;
	ShadowMap->RenderProjDotAspect        = GBASE.ProjDotAspect ;
	ShadowMap->RenderProjFov              = GBASE.ProjFov ;
	ShadowMap->RenderProjSize             = GBASE.ProjSize ;
	ShadowMap->RenderProjMatrix           = GBASE.ProjMatrix ;

	// 描画範囲が設定されていない場合に使用する描画範囲を算出する
	{
		VECTOR AddXVecP ;
		VECTOR AddXVecM ;
		VECTOR AddYVecP ;
		VECTOR AddYVecM ;
		VECTOR AddZVecP ;
		VECTOR AddZVecM ;

		// 描画範囲に入れる領域は視錐台の後方２倍、左右・上下１．５倍、にする
		AddXVecP = VSub( NS_ConvScreenPosToWorldPos( VGet( GBASE.DrawAreaF.right,                0.0f, 1.0f ) ), NS_ConvScreenPosToWorldPos( VGet( GBASE.DrawAreaF.left,                   0.0f, 1.0f ) ) ) ;
		AddYVecP = VSub( NS_ConvScreenPosToWorldPos( VGet(                  0.0f, GBASE.DrawAreaF.top, 1.0f ) ), NS_ConvScreenPosToWorldPos( VGet(                 0.0f, GBASE.DrawAreaF.bottom, 1.0f ) ) ) ;
		AddZVecP = VSub( NS_ConvScreenPosToWorldPos( VGet(                  0.0f,                0.0f, 1.0f ) ), NS_ConvScreenPosToWorldPos( VGet(                 0.0f,                   0.0f, 0.0f ) ) ) ;
		AddXVecM = VScale( AddXVecP, -1.0f ) ;
		AddYVecM = VScale( AddYVecP, -1.0f ) ;
		AddZVecM = VScale( AddZVecP, -1.0f ) ;

		AddXVecP = VScale( AddXVecP, 0.5f ) ;
		AddXVecM = VScale( AddXVecM, 0.5f ) ;
		AddYVecP = VScale( AddYVecP, 0.5f ) ;
		AddYVecM = VScale( AddYVecM, 0.5f ) ;
	//	AddZVecP = VScale( AddZVecP, 0.5f ) ;
	//	AddZVecM = VScale( AddZVecM, 0.5f ) ;

		// ライトベクトル方向にビュークリップ座標を回転して、最大値と最小値を算出
		_MEMCPY( ShadowMap->DefaultViewClipPos, GBASE.ViewClipPos, sizeof( GBASE.ViewClipPos ) ) ;
		
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 0 ], &ShadowMap->DefaultViewClipPos[ 0 ], &AddZVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 1 ], &ShadowMap->DefaultViewClipPos[ 1 ], &AddZVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 2 ], &ShadowMap->DefaultViewClipPos[ 2 ], &AddZVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 3 ], &ShadowMap->DefaultViewClipPos[ 3 ], &AddZVecM ) ;
		
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 0 ], &ShadowMap->DefaultViewClipPos[ 0 ], &AddXVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 2 ], &ShadowMap->DefaultViewClipPos[ 2 ], &AddXVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 4 ], &ShadowMap->DefaultViewClipPos[ 4 ], &AddXVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 6 ], &ShadowMap->DefaultViewClipPos[ 6 ], &AddXVecM ) ;

		VectorAdd( &ShadowMap->DefaultViewClipPos[ 1 ], &ShadowMap->DefaultViewClipPos[ 1 ], &AddXVecP ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 3 ], &ShadowMap->DefaultViewClipPos[ 3 ], &AddXVecP ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 5 ], &ShadowMap->DefaultViewClipPos[ 5 ], &AddXVecP ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 7 ], &ShadowMap->DefaultViewClipPos[ 7 ], &AddXVecP ) ;
		
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 0 ], &ShadowMap->DefaultViewClipPos[ 0 ], &AddYVecP ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 1 ], &ShadowMap->DefaultViewClipPos[ 1 ], &AddYVecP ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 4 ], &ShadowMap->DefaultViewClipPos[ 4 ], &AddYVecP ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 5 ], &ShadowMap->DefaultViewClipPos[ 5 ], &AddYVecP ) ;

		VectorAdd( &ShadowMap->DefaultViewClipPos[ 2 ], &ShadowMap->DefaultViewClipPos[ 2 ], &AddYVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 3 ], &ShadowMap->DefaultViewClipPos[ 3 ], &AddYVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 6 ], &ShadowMap->DefaultViewClipPos[ 6 ], &AddYVecM ) ;
		VectorAdd( &ShadowMap->DefaultViewClipPos[ 7 ], &ShadowMap->DefaultViewClipPos[ 7 ], &AddYVecM ) ;
	}

#ifndef DX_NON_MASK
	// マスク画面を使用しない設定に変更
	NS_SetUseMaskScreenFlag( FALSE ) ;
#endif

	// 描画対象をシャドウマップに変更
	GRH.ShadowMapDrawSetupRequest = TRUE ;
	NS_SetDrawScreen( SmHandle ) ;
	for( i = 1 ; i < DX_RENDERTARGET_COUNT ; i ++ )
	{
		NS_SetRenderTargetToShader( i, -1 ) ;
	}

	// シャドウマップへのレンダリングに必要な行列のセットアップ
	RefreshShadowMapMatrix( ShadowMap ) ;

	// 描画準備をしてあるフラグを立てる
	ShadowMap->DrawSetupFlag = TRUE ;

	// 使用するシェーダーのインデックスを更新する
	RefreshUseShaderIndex() ;

	// 画面を最深度でクリア
	{
		int Red, Green, Blue, Enable ;

		Red   = GRA2.BackgroundRed ;
		Green = GRA2.BackgroundGreen ;
		Blue  = GRA2.BackgroundBlue ;
		Enable = GRA2.EnableBackgroundColor ;

		NS_SetBackgroundColor( 255,255,255 ) ;
		NS_ClearDrawScreen() ;

		GRA2.BackgroundRed = Red ;
		GRA2.BackgroundGreen = Green ;
		GRA2.BackgroundBlue = Blue ;
		GRA2.EnableBackgroundColor = Enable ;
	}

	// 終了
	return 0 ;
}

// シャドウマップへの描画を終了する
extern int NS_ShadowMap_DrawEnd( void )
{
	SHADOWMAPDATA *ShadowMap ;
	int i ;

	// 描画準備をしていない場合は何もしない
	if( GRH.ShadowMapDraw == FALSE )
		return -1 ;

	// アドレスの取得
	if( SHADOWMAPCHK( GRH.ShadowMapDrawHandle, ShadowMap ) )
	{
		GRH.ShadowMapDraw = FALSE ;
		return -1 ;
	}

	// 描画準備をしていない場合は何もしない
	if( ShadowMap->DrawSetupFlag == FALSE )
		return -1 ;

	// 描画準備完了済みフラグを倒す
	ShadowMap->DrawSetupFlag = FALSE ;

	// シャドウマップに対する描画であるかどうかのフラグを倒す
	GRH.ShadowMapDraw = FALSE ;
	GRH.ShadowMapDrawHandle = 0 ;

	// 描画先を元に戻す
	for( i = 0 ; i < DX_RENDERTARGET_COUNT ; i ++ )
	{
		NS_SetRenderTargetToShader( i, ShadowMap->RenderTargetScreen[ i ], ShadowMap->RenderTargetScreenSurface[ i ] ) ; 
	}

#ifndef DX_NON_MASK
	// マスク画面を使用する設定を元に戻す
	NS_SetUseMaskScreenFlag( ShadowMap->RenderMaskUseFlag ) ;
#endif

	// カメラ設定を元に戻す
	GBASE.CameraPosition      = ShadowMap->RenderCameraPosition ;
	GBASE.CameraTarget        = ShadowMap->RenderCameraTarget ;
	GBASE.CameraUp            = ShadowMap->RenderCameraUp ;
	GBASE.CameraHRotate       = ShadowMap->RenderCameraHRotate ;
	GBASE.CameraVRotate       = ShadowMap->RenderCameraVRotate ;
	GBASE.CameraTRotate       = ShadowMap->RenderCameraTRotate ;
	GBASE.CameraMatrix        = ShadowMap->RenderCameraMatrix ;
	NS_SetTransformToView( &ShadowMap->RenderCameraMatrix ) ;
	NS_SetCameraScreenCenter( ShadowMap->RenderCameraScreenCenterX, ShadowMap->RenderCameraScreenCenterY ) ;

	// 射影パラメータをリセット
	GBASE.ProjectionMatrixMode = ShadowMap->RenderProjectionMatrixMode ;
	GBASE.ProjNear             = ShadowMap->RenderProjNear ;
	GBASE.ProjFar              = ShadowMap->RenderProjFar ;
	GBASE.ProjDotAspect        = ShadowMap->RenderProjDotAspect ;
	GBASE.ProjFov              = ShadowMap->RenderProjFov ;
	GBASE.ProjSize             = ShadowMap->RenderProjSize ;
	GBASE.ProjMatrix           = ShadowMap->RenderProjMatrix ;
	_SetTransformToProjection( &GBASE.ProjMatrix ) ;

	// 使用するシェーダーのインデックスを更新する
	RefreshUseShaderIndex() ;

	// シャドウマップにブラーを掛ける
	if( ShadowMap->BlurParam > 0 )
	{
		NS_GraphFilter( ShadowMap->HandleInfo.Handle, DX_GRAPH_FILTER_GAUSS, 8, ShadowMap->BlurParam ) ;
	}

	// 終了
	return 0 ;
}

// 頂点シェーダーに設定するシャドウマップの情報を更新する
extern void RefreshShadowMapVSParam( void )
{
	SHADOWMAPDATA *ShadowMap ;
	float TranspMat[ 7 ][ 4 ] ;
	static float TranspMatDef[ 7 ][ 4 ] =
	{
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },

		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
		{ 0.0f, 0.0f, 0.0f, 0.0f },
	} ;
	int i ;

	for( i = 0 ; i < MAX_USE_SHADOWMAP_NUM ; i ++ )
	{
		// アドレスの取得
		if( SHADOWMAPCHK( GBASE.ShadowMap[ i ], ShadowMap ) )
		{
			SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_LIB, i == 0 ? DX_VS_CONSTF_SHADOWMAP1_LIGHT_VIEW_MAT : DX_VS_CONSTF_SHADOWMAP2_LIGHT_VIEW_MAT, TranspMatDef,      7, TRUE ) ;
		}
		else
		{
			// 行列のセット
			TranspMat[ 0 ][ 0 ] = ShadowMap->ShadowMapViewMatrix.m[ 0 ][ 0 ] ;
			TranspMat[ 0 ][ 1 ] = ShadowMap->ShadowMapViewMatrix.m[ 1 ][ 0 ] ;
			TranspMat[ 0 ][ 2 ] = ShadowMap->ShadowMapViewMatrix.m[ 2 ][ 0 ] ;
			TranspMat[ 0 ][ 3 ] = ShadowMap->ShadowMapViewMatrix.m[ 3 ][ 0 ] ;

			TranspMat[ 1 ][ 0 ] = ShadowMap->ShadowMapViewMatrix.m[ 0 ][ 1 ] ;
			TranspMat[ 1 ][ 1 ] = ShadowMap->ShadowMapViewMatrix.m[ 1 ][ 1 ] ;
			TranspMat[ 1 ][ 2 ] = ShadowMap->ShadowMapViewMatrix.m[ 2 ][ 1 ] ;
			TranspMat[ 1 ][ 3 ] = ShadowMap->ShadowMapViewMatrix.m[ 3 ][ 1 ] ;

			TranspMat[ 2 ][ 0 ] = ShadowMap->ShadowMapViewMatrix.m[ 0 ][ 2 ] ;
			TranspMat[ 2 ][ 1 ] = ShadowMap->ShadowMapViewMatrix.m[ 1 ][ 2 ] ;
			TranspMat[ 2 ][ 2 ] = ShadowMap->ShadowMapViewMatrix.m[ 2 ][ 2 ] ;
			TranspMat[ 2 ][ 3 ] = ShadowMap->ShadowMapViewMatrix.m[ 3 ][ 2 ] ;


			TranspMat[ 3 ][ 0 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 0 ][ 0 ] ;
			TranspMat[ 3 ][ 1 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 1 ][ 0 ] ;
			TranspMat[ 3 ][ 2 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 2 ][ 0 ] ;
			TranspMat[ 3 ][ 3 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 3 ][ 0 ] ;

			TranspMat[ 4 ][ 0 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 0 ][ 1 ] ;
			TranspMat[ 4 ][ 1 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 1 ][ 1 ] ;
			TranspMat[ 4 ][ 2 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 2 ][ 1 ] ;
			TranspMat[ 4 ][ 3 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 3 ][ 1 ] ;

			TranspMat[ 5 ][ 0 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 0 ][ 2 ] ;
			TranspMat[ 5 ][ 1 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 1 ][ 2 ] ;
			TranspMat[ 5 ][ 2 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 2 ][ 2 ] ;
			TranspMat[ 5 ][ 3 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 3 ][ 2 ] ;

			TranspMat[ 6 ][ 0 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 0 ][ 3 ] ;
			TranspMat[ 6 ][ 1 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 1 ][ 3 ] ;
			TranspMat[ 6 ][ 2 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 2 ][ 3 ] ;
			TranspMat[ 6 ][ 3 ] = ShadowMap->ShadowMapProjectionMatrix.m[ 3 ][ 3 ] ;

			SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_LIB, i == 0 ? DX_VS_CONSTF_SHADOWMAP1_LIGHT_VIEW_MAT : DX_VS_CONSTF_SHADOWMAP2_LIGHT_VIEW_MAT, TranspMat, 7, TRUE ) ;
		}
	}
}

// ピクセルシェーダーに設定するシャドウマップの情報を更新する
extern void RefreshShadowMapPSParam( void )
{
	SHADOWMAPDATA *ShadowMap ;
	float ShadowMapParam[ 2 ][ 2 ][ 4 ] ;
	LIGHT_HANDLE *pLH ;
	static int ConstAddressTable[ 6 ][ 2 ] =
	{
		{ 0, 2 },
		{ 0, 3 },
		{ 1, 0 },
		{ 1, 1 },
		{ 1, 2 },
		{ 1, 3 }
	} ;
	int CheckNum ;
	int i ;
	int j ;

	for( i = 0 ; i < MAX_USE_SHADOWMAP_NUM ; i ++ )
	{
		ShadowMapParam[ i ][ 0 ][ 2 ] = 1.0f ;
		ShadowMapParam[ i ][ 0 ][ 3 ] = 1.0f ;
		ShadowMapParam[ i ][ 1 ][ 0 ] = 1.0f ;
		ShadowMapParam[ i ][ 1 ][ 1 ] = 1.0f ;
		ShadowMapParam[ i ][ 1 ][ 2 ] = 1.0f ;
		ShadowMapParam[ i ][ 1 ][ 3 ] = 1.0f ;

		// アドレスの取得
		if( SHADOWMAPCHK( GBASE.ShadowMap[ i ], ShadowMap ) )
		{
			ShadowMapParam[ i ][ 0 ][ 0 ] = 1.0f ;
			ShadowMapParam[ i ][ 0 ][ 1 ] = 0.0f ;
		}
		else
		{
			ShadowMapParam[ i ][ 0 ][ 0 ] = ShadowMap->AdjustDepth ;
			ShadowMapParam[ i ][ 0 ][ 1 ] = ShadowMap->GradationParam ;

			CheckNum = GBASE.Light.EnableNum > DX_PS_CONSTB_LIGHT2_NUM ? DX_PS_CONSTB_LIGHT2_NUM : GBASE.Light.EnableNum ;
			for( j = 0 ; j < CheckNum ; j ++ )
			{
				pLH = GBASE.Light.Data[ GBASE.Light.EnableD3DIndex[ j ] ] ;
				if( pLH->ShadowMapSlotDisableFlag[ i ] == FALSE )
				{
					ShadowMapParam[ i ][ ConstAddressTable[ j ][ 0 ] ][ ConstAddressTable[ j ][ 1 ] ] = 0.0f ;
				}
			}
		}
	}

	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB, DX_PS_CONSTF_SHADOW1_DADJ_GRAD_ENBL0_1, ShadowMapParam, 4, TRUE ) ;
}

// 描画で使用するシャドウマップを指定する、スロットは０か１かを指定可能、SmHandle に -1 を渡すと指定のスロットのシャドウマップを解除
extern int NS_SetDrawUseShadowMap( int SlotIndex, int SmHandle )
{
	SHADOWMAPDATA *ShadowMap ;

	// スロットのインデックスが不正な場合はエラー
	if( SlotIndex < 0 || SlotIndex >= MAX_USE_SHADOWMAP_NUM )
		return -1 ;

	// ハンドル値がマイナスの値の場合は解除
	if( SmHandle < 0 )
	{
		// ハンドル値をリセット
		GBASE.ShadowMap[ SlotIndex ] = 0 ;
	}
	else
	{
		// アドレスの取得
		if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
			return -1 ;

		// ハンドル値の保存
		GBASE.ShadowMap[ SlotIndex ] = SmHandle ;
	}

	// 使用するシェーダーのインデックスを更新する
	RefreshUseShaderIndex() ;

	// シェーダーのパラメータに反映
	RefreshShadowMapVSParam() ;
	RefreshShadowMapPSParam() ;

	// 終了
	return 0 ;
}

// シャドウマップに描画する際の範囲を設定する( この関数で描画範囲を設定しない場合は視錐台を拡大した範囲が描画範囲となる )
extern int NS_SetShadowMapDrawArea( int SmHandle, VECTOR MinPosition, VECTOR MaxPosition )
{
	SHADOWMAPDATA *ShadowMap ;

	// エラー判定
	if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
		return -1 ;

	// 座標を保存
	if( MinPosition.x < MaxPosition.x )
	{
		ShadowMap->DrawAreaMinPosition.x = MinPosition.x ;
		ShadowMap->DrawAreaMaxPosition.x = MaxPosition.x ;
	}
	else
	{
		ShadowMap->DrawAreaMinPosition.x = MaxPosition.x ;
		ShadowMap->DrawAreaMaxPosition.x = MinPosition.x ;
	}

	if( MinPosition.y < MaxPosition.y )
	{
		ShadowMap->DrawAreaMinPosition.y = MinPosition.y ;
		ShadowMap->DrawAreaMaxPosition.y = MaxPosition.y ;
	}
	else
	{
		ShadowMap->DrawAreaMinPosition.y = MaxPosition.y ;
		ShadowMap->DrawAreaMaxPosition.y = MinPosition.y ;
	}

	if( MinPosition.z < MaxPosition.z )
	{
		ShadowMap->DrawAreaMinPosition.z = MinPosition.z ;
		ShadowMap->DrawAreaMaxPosition.z = MaxPosition.z ;
	}
	else
	{
		ShadowMap->DrawAreaMinPosition.z = MaxPosition.z ;
		ShadowMap->DrawAreaMaxPosition.z = MinPosition.z ;
	}

	// 幅が無い場合は無効
	if( ShadowMap->DrawAreaMaxPosition.x - ShadowMap->DrawAreaMinPosition.x < 0.00000001f ||
		ShadowMap->DrawAreaMaxPosition.y - ShadowMap->DrawAreaMinPosition.y < 0.00000001f ||
		ShadowMap->DrawAreaMaxPosition.z - ShadowMap->DrawAreaMinPosition.z < 0.00000001f )
	{
		return -1 ;
	}

	// フラグを有効に設定
	ShadowMap->EnableDrawArea = TRUE ;

	// シャドウマップに描画する範囲の座標を更新
	ShadowMap->DrawAreaViewClipPos[ 0 ].x = ShadowMap->DrawAreaMinPosition.x ;
	ShadowMap->DrawAreaViewClipPos[ 0 ].y = ShadowMap->DrawAreaMinPosition.y ;
	ShadowMap->DrawAreaViewClipPos[ 0 ].z = ShadowMap->DrawAreaMinPosition.z ;

	ShadowMap->DrawAreaViewClipPos[ 1 ].x = ShadowMap->DrawAreaMaxPosition.x ;
	ShadowMap->DrawAreaViewClipPos[ 1 ].y = ShadowMap->DrawAreaMinPosition.y ;
	ShadowMap->DrawAreaViewClipPos[ 1 ].z = ShadowMap->DrawAreaMinPosition.z ;

	ShadowMap->DrawAreaViewClipPos[ 2 ].x = ShadowMap->DrawAreaMinPosition.x ;
	ShadowMap->DrawAreaViewClipPos[ 2 ].y = ShadowMap->DrawAreaMaxPosition.y ;
	ShadowMap->DrawAreaViewClipPos[ 2 ].z = ShadowMap->DrawAreaMinPosition.z ;

	ShadowMap->DrawAreaViewClipPos[ 3 ].x = ShadowMap->DrawAreaMaxPosition.x ;
	ShadowMap->DrawAreaViewClipPos[ 3 ].y = ShadowMap->DrawAreaMaxPosition.y ;
	ShadowMap->DrawAreaViewClipPos[ 3 ].z = ShadowMap->DrawAreaMinPosition.z ;

	ShadowMap->DrawAreaViewClipPos[ 4 ].x = ShadowMap->DrawAreaMinPosition.x ;
	ShadowMap->DrawAreaViewClipPos[ 4 ].y = ShadowMap->DrawAreaMinPosition.y ;
	ShadowMap->DrawAreaViewClipPos[ 4 ].z = ShadowMap->DrawAreaMaxPosition.z ;

	ShadowMap->DrawAreaViewClipPos[ 5 ].x = ShadowMap->DrawAreaMaxPosition.x ;
	ShadowMap->DrawAreaViewClipPos[ 5 ].y = ShadowMap->DrawAreaMinPosition.y ;
	ShadowMap->DrawAreaViewClipPos[ 5 ].z = ShadowMap->DrawAreaMaxPosition.z ;

	ShadowMap->DrawAreaViewClipPos[ 6 ].x = ShadowMap->DrawAreaMinPosition.x ;
	ShadowMap->DrawAreaViewClipPos[ 6 ].y = ShadowMap->DrawAreaMaxPosition.y ;
	ShadowMap->DrawAreaViewClipPos[ 6 ].z = ShadowMap->DrawAreaMaxPosition.z ;

	ShadowMap->DrawAreaViewClipPos[ 7 ].x = ShadowMap->DrawAreaMaxPosition.x ;
	ShadowMap->DrawAreaViewClipPos[ 7 ].y = ShadowMap->DrawAreaMaxPosition.y ;
	ShadowMap->DrawAreaViewClipPos[ 7 ].z = ShadowMap->DrawAreaMaxPosition.z ;

	// もしシャドウマップへの描画準備済みの場合はシャドウマップへの描画に必要な行列を更新する
	if( ShadowMap->DrawSetupFlag )
	{
		// 行列の更新
		RefreshShadowMapMatrix( ShadowMap ) ;
	}

	// 終了
	return 0 ;
}

// SetShadowMapDrawArea の設定を解除する
extern int NS_ResetShadowMapDrawArea( int SmHandle )
{
	SHADOWMAPDATA *ShadowMap ;

	// エラー判定
	if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
		return -1 ;

	// 既に設定が解除されていたら何もしない
	if( ShadowMap->EnableDrawArea == FALSE )
	{
		return 0 ;
	}

	// フラグを倒す
	ShadowMap->EnableDrawArea = FALSE ;

	// もしシャドウマップへの描画準備済みの場合はシャドウマップへの描画に必要な行列を更新する
	if( ShadowMap->DrawSetupFlag )
	{
		// 行列の更新
		RefreshShadowMapMatrix( ShadowMap ) ;
	}

	// 終了
	return 0 ;
}

// シャドウマップを使用した描画時の補正深度を設定する
extern int NS_SetShadowMapAdjustDepth( int SmHandle, float Depth )
{
	SHADOWMAPDATA *ShadowMap ;
	int i ;

	// エラー判定
	if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
		return -1 ;

	// 補正値を保存する
	ShadowMap->AdjustDepth = Depth ;

	// 既にシャドウマップを使用中の場合は補正値を変更する
	for( i = 0 ; i < MAX_USE_SHADOWMAP_NUM ; i ++ )
	{
		if( GBASE.ShadowMap[ i ] == SmHandle )
		{
			RefreshShadowMapPSParam() ;
			break ;
		}
	}

	// 終了
	return 0 ;
}

// シャドウマップに適用するぼかし度合いを設定する
extern int NS_SetShadowMapBlurParam( int SmHandle, int Param )
{
	SHADOWMAPDATA *ShadowMap ;

	// エラー判定
	if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
		return -1 ;

	// 補正値を保存する
	ShadowMap->BlurParam = Param ;

	// 終了
	return 0 ;
}

// シャドウマップを使用した描画時の影をグラデーションさせる範囲を設定する
extern int NS_SetShadowMapGradationParam( int SmHandle, float Param )
{
	SHADOWMAPDATA *ShadowMap ;
	int i ;

	// エラー判定
	if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
		return -1 ;

	// グラデーションさせる範囲を保存する
	ShadowMap->GradationParam = Param ;

	// 既にシャドウマップを使用中の場合は補正値を変更する
	for( i = 0 ; i < MAX_USE_SHADOWMAP_NUM ; i ++ )
	{
		if( GBASE.ShadowMap[ i ] == SmHandle )
		{
			RefreshShadowMapPSParam() ;
			break ;
		}
	}

	// 終了
	return 0 ;
}

// シャドウマップを画面にテスト描画する
#define SETDRAWRECTCODE_DRAWSHADOWMAP\
	if( x1 < x2 ){ GRH.DrawRect.left = x1 ; GRH.DrawRect.right = x2; }\
	if( y1 < y2 ){ GRH.DrawRect.top = y1 ; GRH.DrawRect.bottom = y2; }\
\
	SETRECT( GRH.DrawRect, x1, y1, x2, y2 ) ;\
	DRAWRECT_DRAWAREA_CLIP

extern int NS_TestDrawShadowMap( int SmHandle, int x1, int y1, int x2, int y2 )
{
	SHADOWMAPDATA *ShadowMap ;
	VERTEX_2D DrawVert[ 6 ] ;
	int Ret, Flag ;

	CheckActiveState() ;

	// アドレスの取得
	if( SHADOWMAPCHK( SmHandle, ShadowMap ) )
		return -1 ;

	Ret = -1 ;
	Flag = GRA2.ValidHardWare ;

	DrawVert[ 0 ].rhw = 1.0f ;
	DrawVert[ 0 ].pos.z = GBASE.DrawZ ;
	DrawVert[ 0 ].color = 0xffffffff ;
	DrawVert[ 0 ].sc_u = 0.0f ;
	DrawVert[ 0 ].sc_v = 0.0f ;

	DrawVert[ 1 ] = DrawVert[ 0 ] ;
	DrawVert[ 2 ] = DrawVert[ 0 ] ;
	DrawVert[ 3 ] = DrawVert[ 0 ] ;

	DrawVert[ 0 ].pos.x = ( float )x1 - 0.5f ;
	DrawVert[ 0 ].pos.y = ( float )y1 - 0.5f ;
	DrawVert[ 0 ].u = 0.0f ;
	DrawVert[ 0 ].v = 0.0f ;

	DrawVert[ 1 ].pos.x = ( float )x2 - 0.5f ;
	DrawVert[ 1 ].pos.y = ( float )y1 - 0.5f ;
	DrawVert[ 1 ].u = 1.0f ;
	DrawVert[ 1 ].v = 0.0f ;

	DrawVert[ 2 ].pos.x = ( float )x1 - 0.5f ;
	DrawVert[ 2 ].pos.y = ( float )y2 - 0.5f ;
	DrawVert[ 2 ].u = 0.0f ;
	DrawVert[ 2 ].v = 1.0f ;

	DrawVert[ 3 ].pos.x = ( float )x2 - 0.5f ;
	DrawVert[ 3 ].pos.y = ( float )y2 - 0.5f ;
	DrawVert[ 3 ].u = 1.0f ;
	DrawVert[ 3 ].v = 1.0f ;

	DrawVert[ 4 ] = DrawVert[ 2 ] ;
	DrawVert[ 5 ] = DrawVert[ 1 ] ;

	DRAW_DEF(
		DrawPrimitive2DHardware( DrawVert, 6, DX_PRIMTYPE_TRIANGLELIST, ( IMAGEDATA2 * )SmHandle, FALSE, FALSE, FALSE, FALSE, 0 ),
		0,
		SETDRAWRECTCODE_DRAWSHADOWMAP,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}

// グラフィックのデータをインデックス値から取り出す
extern IMAGEDATA2 *GetGraphData2( int GrHandle, int ASyncThread )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
			return NULL ;
	}
	else
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return NULL ;
	}

	return Image2 ;
}




// Direct3DDevice9 オブジェクトの作成
extern int CreateDirect3D9DeviceObject()
{
	HRESULT hr ;
	const TCHAR *String = NULL ;
	int ErrorRet = -1 ;

	if( Graphics_IsValid() == 0 ) return -1 ;

	// 既に作成済みの場合は一度削除する
	GraphicsDevice_Release() ;
	GRH.BeginSceneFlag = FALSE ;

	// シェーダー２．０を使えない環境ではフルスクリーンアンチエイリアスを正常に使える可能性も低いので
	// シェーダー２．０を使えない環境ではフルスクリーンアンチエイリアスを無効にする
	if( NS_GetValidShaderVersion() < 200 )
	{
		GRH.FSAAMultiSampleType = D_D3DMULTISAMPLE_NONE ;
		GRH.FSAAMultiSampleQuality = 0 ;
	}

	// デバイスの作成
	if( Graphics_CreateDevice() < 0 )
	{
		// 失敗したら画面モードを変更して試す
		GRA2.MainScreenColorBitDepth = 32 ;
		SetMemImgDefaultColorType( GRA2.MainScreenColorBitDepth == 32 ? 1 : 0 ) ;
		if( Graphics_CreateDevice() < 0 )
		{
			SetMainScreenSize( 800, 600 ) ;
			if( Graphics_CreateDevice() < 0 )
			{
				SetMainScreenSize( 1024, 768 ) ;
				if( Graphics_CreateDevice() < 0 )
				{
					goto ERR ;
				}
			}
		}
	}

	// VSyncの前にSleepする時間を取得する
	GraphicsDevice_WaitVSyncInitialize() ;

	// 固定機能パイプラインに戻す
	GRH.SetVS = NULL ;
	GRH.SetVD = NULL ;
	GRH.SetPS = NULL ;
	GRH.SetFVF = 0 ;
	GRH.SetIB = NULL ;
	GRH.SetVB = NULL ;

	// バックバッファのアドレスを取得しておく
	hr = GraphicsDevice_GetBackBuffer( 0, 0, D_D3DBACKBUFFER_TYPE_MONO, &GRH.BackBufferSurface ) ;

	DXST_ERRORLOG_ADD( _T( "成功\n" ) ) ;

	// 成功した場合はデバイス情報を取得する
	GraphicsDevice_GetDeviceCaps( &GRH.DeviceCaps ) ;

	// 同時にレンダリングできるターゲットの数を保存
	GRH.RenderTargetNum = GRH.DeviceCaps.NumSimultaneousRTs ;
	if( GRH.RenderTargetNum > DX_RENDERTARGET_COUNT )
	{
		GRH.RenderTargetNum = DX_RENDERTARGET_COUNT ;
	}

	// テクスチャステージのテンポラリレジスタが使用できるかどうかを保存
	GRH.ValidTexTempRegFlag = ( GRH.DeviceCaps.PrimitiveMiscCaps & D_D3DPMISCCAPS_TSSARGTEMP ) != 0 ? TRUE : FALSE ;

	// シェーダーを使わない設定の場合は必ず無効
	if( GRH.NonUseVertexHardwareProcess )
	{
		GRH.ValidVertexShader = FALSE ;
		GRH.ValidPixelShader = FALSE ;
		GRH.ValidVertexShader_SM3 = FALSE ;
		GRH.ValidPixelShader_SM3 = FALSE ;
	}
	else
	{
		// 頂点シェーダーが使用可能かどうかを保存
		GRH.ValidVertexShader = /* GRH.VertexHardwareProcess && */ ( GRH.DeviceCaps.VertexShaderVersion & 0xffff ) >= 0x0200 ;

		// ピクセルシェーダーが使用可能かどうかを保存
		GRH.ValidPixelShader = /* GRH.VertexHardwareProcess && */ ( GRH.DeviceCaps.PixelShaderVersion & 0xffff ) >= 0x0200 ;

		// SM3.0の頂点シェーダーが使用可能かどうかを保存
		GRH.ValidVertexShader_SM3 = /* GRH.VertexHardwareProcess && */ ( GRH.DeviceCaps.VertexShaderVersion & 0xffff ) >= 0x0300 ;

		// SM3.0のピクセルシェーダーが使用可能かどうかを保存
		GRH.ValidPixelShader_SM3 = /* GRH.VertexHardwareProcess && */ ( GRH.DeviceCaps.PixelShaderVersion & 0xffff ) >= 0x0300 ;
	}

	// D3DBLENDOP_ADD 以外が使用できるかどうかを取得する
	GRH.ValidDestBlendOp = ( GRH.DeviceCaps.PrimitiveMiscCaps & D_D3DPMISCCAPS_BLENDOP ) == 0 ? FALSE : TRUE ;

	// テクスチャのサイズが２のｎ乗である必要があるかどうかを取得する
	GRH.TextureSizePow2 = ( GRH.DeviceCaps.TextureCaps & D_D3DPTEXTURECAPS_POW2 ) != 0 ? TRUE : FALSE ;

	// 条件付でテクスチャのサイズが２のｎ乗でなくても大丈夫かどうかを取得する
	GRH.TextureSizeNonPow2Conditional = ( GRH.DeviceCaps.TextureCaps & D_D3DPTEXTURECAPS_NONPOW2CONDITIONAL ) != 0 ? TRUE : FALSE ;

	// テクスチャサイズが設定されていない場合は設定する
	if( GRH.DeviceCaps.MaxTextureWidth  == 0 ) GRH.DeviceCaps.MaxTextureWidth  = DEFAULT_MAXTEXTURE_SIZE ;
	if( GRH.DeviceCaps.MaxTextureHeight == 0 ) GRH.DeviceCaps.MaxTextureHeight = DEFAULT_MAXTEXTURE_SIZE ;

	// サイズの小さいほうを最大サイズとする
	GRH.MaxTextureSize = GRH.DeviceCaps.MaxTextureWidth < GRH.DeviceCaps.MaxTextureHeight ? GRH.DeviceCaps.MaxTextureWidth : GRH.DeviceCaps.MaxTextureHeight ;

	// 一度に描画できる最大プリミティブ数を取得する
	GRH.MaxPrimitiveCount = GRH.DeviceCaps.MaxPrimitiveCount ;

	// 頂点カラーを使用するかどうかの値を初期化
	GRH.MaterialUseVertexDiffuseColor = 0xff ;
	GRH.MaterialUseVertexSpecularColor = 0xff ;

	// DrawPreparation を行うべきフラグを立てる
	GRH.DrawPrepAlwaysFlag = TRUE ;

	{
		D_D3DADAPTER_IDENTIFIER9 Iden ;

		Graphics_GetAdapterIdentifier( D_D3DADAPTER_DEFAULT, 0, &Iden ) ;
		DXST_ERRORLOGFMT_ADDA(( "Driver:%s  Description:%s", Iden.Driver, Iden.Description )) ;
	}

	// 各種フォーマットを調べる
	{
		D_D3DSURFACE_DESC SurfaceDesc ;

		// 画面のフォーマットの取得
		GraphicsSurface_GetDesc( GRH.BackBufferSurface, &SurfaceDesc ) ;
		GRH.ScreenFormat = SurfaceDesc.Format ;
		switch( GRH.ScreenFormat )
		{
		case D_D3DFMT_X8R8G8B8 : String = _T( "D3DFMT_X8R8G8B8" ) ; break ;
		case D_D3DFMT_R5G6B5 :   String = _T( "D3DFMT_R5G6B5" ) ;   break ;
		case D_D3DFMT_X1R5G5B5 : String = _T( "D3DFMT_X1R5G5B5" ) ; break ;
		default:
			DXST_ERRORLOGFMT_ADD(( _T( "バックバッファが対応していないフォーマット %d です" ), GRH.ScreenFormat )) ;
			break ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "画面のフォーマットは %s です" ), String )) ;

		// 16ビットＺバッファフォーマットの設定
		GRH.ZBufferFormat[ ZBUFFER_FORMAT_16BIT ] = D_D3DFMT_D16 ;
		String = _T( "D3DFMT_D16" ) ;
		DXST_ERRORLOGFMT_ADD(( _T( "16bit Zバッファフォーマットは %s です" ), String )) ;

		// 24ビットＺバッファフォーマットの選定
		if( Graphics_CheckDepthStencilMatch( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, GRH.ScreenFormat, D_D3DFMT_D24X8 ) == D_D3D_OK )
		{
			GRH.ZBufferFormat[ ZBUFFER_FORMAT_24BIT ] = D_D3DFMT_D24X8 ;
			String = _T( "D3DFMT_D24X8" ) ;
		}
		else
		if( Graphics_CheckDepthStencilMatch( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, GRH.ScreenFormat, D_D3DFMT_D32 ) == D_D3D_OK )
		{
			GRH.ZBufferFormat[ ZBUFFER_FORMAT_24BIT ] = D_D3DFMT_D32 ;
			String = _T( "D3DFMT_D32" ) ;
		}
		else
		{
			GRH.ZBufferFormat[ ZBUFFER_FORMAT_24BIT ] = D_D3DFMT_D16 ;
			String = _T( "D3DFMT_D16" ) ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "24bit Zバッファフォーマットは %s です" ), String )) ;

		// 32ビットＺバッファフォーマットの選定
		if( Graphics_CheckDepthStencilMatch( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, GRH.ScreenFormat, D_D3DFMT_D32 ) == D_D3D_OK )
		{
			GRH.ZBufferFormat[ ZBUFFER_FORMAT_32BIT ] = D_D3DFMT_D32 ;
			String = _T( "D3DFMT_D32" ) ;
		}
		else
		if( Graphics_CheckDepthStencilMatch( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, GRH.ScreenFormat, D_D3DFMT_D24X8 ) == D_D3D_OK )
		{
			GRH.ZBufferFormat[ ZBUFFER_FORMAT_32BIT ] = D_D3DFMT_D24X8 ;
			String = _T( "D3DFMT_D24X8" ) ;
		}
		else
		if( Graphics_CheckDepthStencilMatch( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, GRH.ScreenFormat, D_D3DFMT_D16 ) == D_D3D_OK )
		{
			GRH.ZBufferFormat[ ZBUFFER_FORMAT_32BIT ] = D_D3DFMT_D16 ;
			String = _T( "D3DFMT_D16" ) ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "32bit Zバッファフォーマットは %s です" ), String )) ;

		// 16ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_R5G6B5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_RGB16 ] = D_D3DFMT_R5G6B5 ;
			String = _T( "D3DFMT_R5G6B5" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_X1R5G5B5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_RGB16 ] = D_D3DFMT_X1R5G5B5 ;
			String = _T( "D3DFMT_X1R5G5B5" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる 16bit カラーフォーマットが見つかりませんでした\n" ) ) ;
			goto ERR ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "16bit カラーフォーマットは %s です" ), String )) ;

		// 32ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_X8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_RGB32 ] = D_D3DFMT_X8R8G8B8 ;
			String = _T( "D3DFMT_X8R8G8B8" ) ;
		}
		else
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_RGB32 ] = GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_RGB16 ] ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "32bit カラーフォーマットは %s です" ), String )) ;

		// アルファ付き 16ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A4R4G4B4 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB16 ] = D_D3DFMT_A4R4G4B4 ;
			String = _T( "D3DFMT_A4R4G4B4" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB16 ] = D_D3DFMT_A8R8G8B8 ;
			String = _T( "D3DFMT_A8R8G8B8" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できるアルファ付き 16bit カラーフォーマットが見つかりませんでした\n" ) ) ;
			goto ERR ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "アルファ付き 16bit カラーフォーマットは %s です" ), String )) ;

		// アルファ付き 32ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB32 ] = D_D3DFMT_A8R8G8B8 ;
			String = _T( "D3DFMT_A8R8G8B8" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A4R4G4B4 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB32 ] = D_D3DFMT_A4R4G4B4 ;
			String = _T( "D3DFMT_A4R4G4B4" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できるアルファ付き 32bit カラーフォーマットが見つかりませんでした\n" ) ) ;
			goto ERR ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "アルファ付き 32bit カラーフォーマットは %s です" ), String )) ;

		// アルファテスト用 16ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A1R5G5B5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB16 ] = D_D3DFMT_A1R5G5B5 ;
			String = _T( "D3DFMT_A1R5G5B5" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB16 ] = D_D3DFMT_A8R8G8B8 ;
			String = _T( "D3DFMT_A8R8G8B8" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A4R4G4B4 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB16 ] = D_D3DFMT_A4R4G4B4 ;
			String = _T( "D3DFMT_A4R4G4B4" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できるアルファテスト用 16bit カラーフォーマットが見つかりませんでした\n" ) ) ;
			goto ERR ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "アルファテスト用 16bit カラーフォーマットは %s です" ), String )) ;

		// アルファテスト用 32ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB32 ] = D_D3DFMT_A8R8G8B8 ;
			String = _T( "D3DFMT_A8R8G8B8" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A1R5G5B5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB32 ] = D_D3DFMT_A1R5G5B5 ;
			String = _T( "D3DFMT_A1R5G5B5" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_A4R4G4B4 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB32 ] = D_D3DFMT_A4R4G4B4 ;
			String = _T( "D3DFMT_A4R4G4B4" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できるアルファテスト用 32bit カラーフォーマットが見つかりませんでした\n" ) ) ;
			goto ERR ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "アルファテスト用 32bit カラーフォーマットは %s です" ), String )) ;

		// DXT1フォーマットのチェック
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_DXT1 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT1 ] = D_D3DFMT_DXT1 ;
			String = _T( "D3DFMT_DXT1 です" ) ;
		}
		else
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT1 ] = GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB16 ] ;
			String = _T( "使えません" ) ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "ＤＸＴ１テクスチャフォーマットは%s" ), String )) ;

		// DXT2フォーマットのチェック
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_DXT2 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT2 ] = D_D3DFMT_DXT2 ;
			String = _T( "D3DFMT_DXT2 です" ) ;
		}
		else
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT2 ] = GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB32 ] ;
			String = _T( "使えません" ) ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "ＤＸＴ２テクスチャフォーマットは%s" ), String )) ;

		// DXT3フォーマットのチェック
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_DXT3 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT3 ] = D_D3DFMT_DXT3 ;
			String = _T( "D3DFMT_DXT3 です" ) ;
		}
		else
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT3 ] = GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB32 ] ;
			String = _T( "使えません" ) ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "ＤＸＴ３テクスチャフォーマットは%s" ), String )) ;

		// DXT4フォーマットのチェック
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_DXT4 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT4 ] = D_D3DFMT_DXT4 ;
			String = _T( "D3DFMT_DXT4 です" ) ;
		}
		else
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT4 ] = GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB32 ] ;
			String = _T( "使えません" ) ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "ＤＸＴ４テクスチャフォーマットは%s" ), String )) ;

		// DXT5フォーマットのチェック
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, 0, D_D3DRTYPE_TEXTURE, D_D3DFMT_DXT5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT5 ] = D_D3DFMT_DXT5 ;
			String = _T( "D3DFMT_DXT5 です" ) ;
		}
		else
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT5 ] = GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB32 ] ;
			String = _T( "使えません" ) ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "ＤＸＴ５テクスチャフォーマットは%s" ), String )) ;

		// 描画可能 16ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, GRH.ScreenFormat == D_D3DFMT_R5G6B5 ? D_D3DFMT_R5G6B5 : D_D3DFMT_X1R5G5B5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB16 ] = GRH.ScreenFormat == D_D3DFMT_R5G6B5 ? D_D3DFMT_R5G6B5 : D_D3DFMT_X1R5G5B5 ;
			String = GRH.ScreenFormat == D_D3DFMT_R5G6B5 ? _T( "D3DFMT_R5G6B5" ) : _T( "D3DFMT_R5G5B5" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, GRH.ScreenFormat == D_D3DFMT_R5G6B5 ? D_D3DFMT_X1R5G5B5 : D_D3DFMT_R5G6B5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB16 ] = GRH.ScreenFormat == D_D3DFMT_R5G6B5 ? D_D3DFMT_X1R5G5B5 : D_D3DFMT_R5G6B5 ;
			String = GRH.ScreenFormat == D_D3DFMT_R5G6B5 ? _T( "D3DFMT_R5G5B5" ) : _T( "D3DFMT_R5G6B5" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_X8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB16 ] = D_D3DFMT_X8R8G8B8 ;
			String = _T( "D3DFMT_X8R8G8B8" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用 16bit カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB16 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB16 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用 16bit カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 32ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_X8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB32 ] = D_D3DFMT_X8R8G8B8 ;
			String = _T( "D3DFMT_X8R8G8B8" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_R5G6B5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB32 ] = D_D3DFMT_R5G6B5 ;
			String = _T( "D3DFMT_R5G6B5" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_X1R5G5B5 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB32 ] = D_D3DFMT_X1R5G5B5 ;
			String = _T( "D3DFMT_R5G5B5" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用 32bit カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB32 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB32 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用 32bit カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 アルファチャンネル付き 32 ビットカラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ALPHA_RGB32 ] = D_D3DFMT_A8R8G8B8 ;
			String = _T( "D3DFMT_A8R8G8B8" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A4R4G4B4 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ALPHA_RGB32 ] = D_D3DFMT_A4R4G4B4 ;
			String = _T( "D3DFMT_A4R4G4B4" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用アルファ付き 32bit カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ALPHA_RGB32 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ALPHA_RGB32 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用アルファ付き 32bit カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 ARGB整数16ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_I16 ] = D_D3DFMT_A16B16G16R16 ;
			String = _T( "D3DFMT_A16B16G16R16" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用ABGR整数16ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_I16 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_I16 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用ABGR整数16ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 ARGB浮動小数点16ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F16 ] = D_D3DFMT_A16B16G16R16F ;
			String = _T( "D3DFMT_A16B16G16R16F" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用ABGR浮動小数点16ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F16 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F16 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用ABGR浮動小数点16ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 ARGB浮動小数点32ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A32B32G32R32F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F32 ] = D_D3DFMT_A32B32G32R32F ;
			String = _T( "D3DFMT_A32B32G32R32F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F32 ] = D_D3DFMT_A16B16G16R16F ;
			String = _T( "D3DFMT_A16B16G16R16F" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用ABGR浮動小数点32ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F32 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F32 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用ABGR浮動小数点32ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 １チャンネル整数8ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_L8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I8 ] = D_D3DFMT_L8 ;
			String = _T( "D3DFMT_L8" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8L8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I8 ] = D_D3DFMT_A8L8 ;
			String = _T( "D3DFMT_A8L8" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I8 ] = D_D3DFMT_A8R8G8B8 ;
			String = _T( "D3DFMT_A8R8G8B8" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用１チャンネル整数8ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I8 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I8 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用１チャンネル整数8ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 １チャンネル整数16ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_L16 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I16 ] = D_D3DFMT_L16 ;
			String = _T( "D3DFMT_L16" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_G16R16 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I16 ] = D_D3DFMT_G16R16 ;
			String = _T( "D3DFMT_G16R16" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I16 ] = D_D3DFMT_A16B16G16R16 ;
			String = _T( "D3DFMT_A16B16G16R16" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用１チャンネル整数16ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I16 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I16 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用１チャンネル整数16ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 １チャンネル浮動小数点16ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F16 ] = D_D3DFMT_R16F ;
			String = _T( "D3DFMT_R16F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_G16R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F16 ] = D_D3DFMT_G16R16F ;
			String = _T( "D3DFMT_G16R16F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F16 ] = D_D3DFMT_A16B16G16R16F ;
			String = _T( "D3DFMT_A16B16G16R16F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A32B32G32R32F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F16 ] = D_D3DFMT_A32B32G32R32F ;
			String = _T( "D3DFMT_A32B32G32R32F" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用１チャンネル浮動小数点16ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F16 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F16 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用１チャンネル浮動小数点16ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 １チャンネル浮動小数点32ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_R32F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32 ] = D_D3DFMT_R32F ;
			String = _T( "D3DFMT_R32F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_G32R32F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32 ] = D_D3DFMT_G32R32F ;
			String = _T( "D3DFMT_G32R32F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A32B32G32R32F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32 ] = D_D3DFMT_A32B32G32R32F ;
			String = _T( "D3DFMT_A32B32G32R32F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32 ] = D_D3DFMT_A16B16G16R16F ;
			String = _T( "D3DFMT_A16B16G16R16F" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用１チャンネル浮動小数点32ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用１チャンネル浮動小数点32ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 ２チャンネル整数8ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8L8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I8 ] = D_D3DFMT_A8L8 ;
			String = _T( "D3DFMT_V8U8" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A8R8G8B8 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I8 ] = D_D3DFMT_A8R8G8B8 ;
			String = _T( "D3DFMT_A8B8G8R8" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用２チャンネル整数8ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I8 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I8 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用２チャンネル整数8ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 ２チャンネル整数16ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_G16R16 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I16 ] = D_D3DFMT_G16R16 ;
			String = _T( "D3DFMT_G16R16" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16 ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I16 ] = D_D3DFMT_A16B16G16R16 ;
			String = _T( "D3DFMT_A16B16G16R16" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用２チャンネル整数16ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I16 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I16 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用２チャンネル整数16ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 ２チャンネル浮動小数点16ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_G16R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F16 ] = D_D3DFMT_G16R16F ;
			String = _T( "D3DFMT_G16R16F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F16 ] = D_D3DFMT_A16B16G16R16F ;
			String = _T( "D3DFMT_A16B16G16R16F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A32B32G32R32F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F16 ] = D_D3DFMT_A32B32G32R32F ;
			String = _T( "D3DFMT_A32B32G32R32F" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用２チャンネル浮動小数点16ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F16 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F16 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用２チャンネル浮動小数点16ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// 描画可能 ２チャンネル浮動小数点32ビット型カラーフォーマットの選定
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_G32R32F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F32 ] = D_D3DFMT_G32R32F ;
			String = _T( "D3DFMT_G32R32F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A32B32G32R32F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F32 ] = D_D3DFMT_A32B32G32R32F ;
			String = _T( "D3DFMT_A32B32G32R32F" ) ;
		}
		else
		if( Graphics_CheckDeviceFormat( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, GRH.ScreenFormat, D_D3DUSAGE_RENDERTARGET, D_D3DRTYPE_TEXTURE, D_D3DFMT_A16B16G16R16F ) == D_D3D_OK )
		{
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F32 ] = D_D3DFMT_A16B16G16R16F ;
			String = _T( "D3DFMT_A16B16G16R16F" ) ;
		}
		else
		{
			DXST_ERRORLOG_ADD( _T( "使用できる描画用２チャンネル浮動小数点32ビット型カラーフォーマットがありませんでした\n" ) ) ;
			GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F32 ] = D_D3DFMT_UNKNOWN ;
		}

		if( GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F32 ] != D_D3DFMT_UNKNOWN )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "描画用２チャンネル浮動小数点32ビット型カラーフォーマットは %s です" ), String )) ;
		}

		// マスクカラーバッファ用フォーマットの選定
		GRH.MaskColorFormat = GRA2.MainScreenColorBitDepth == 32 ? GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB32 ] : GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB16 ] ;

		// マスクアルファフォーマットの選定
		GRH.MaskAlphaFormat = GRA2.MainScreenColorBitDepth == 32 ? GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB32 ] : GRH.TextureFormat[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB16 ] ;
	}

	// 情報出力
	{
		DXST_ERRORLOGFMT_ADD(( _T( "一度に描画できるプリミティブの最大数:%d" ), GRH.MaxPrimitiveCount )) ;
		DXST_ERRORLOGFMT_ADD(( _T( "対応している最大頂点インデックス:%d" ), GRH.DeviceCaps.MaxVertexIndex )) ;
		DXST_ERRORLOGFMT_ADD(( _T( "同時にレンダリングできるバッファの数:%d" ), GRH.RenderTargetNum )) ;
		DXST_ERRORLOGFMT_ADD(( _T( "最大テクスチャサイズ　幅:%d 高さ:%d" ), GRH.DeviceCaps.MaxTextureWidth, GRH.DeviceCaps.MaxTextureHeight )) ;
		DXST_ERRORLOGFMT_ADD(( _T( "テクスチャステージテンポラリレジスタ：%s" ), GRH.ValidTexTempRegFlag ? _T( "使用可" ) : _T( "使用不可" ) )) ;
		DXST_ERRORLOGFMT_ADD(( _T( "減算合成のハードウェア対応：%s" ), GRH.ValidDestBlendOp ? _T( "ネイティブ" ) : _T( "エミュレート" ) )) ;
		if( GRH.VertexHardwareProcess )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "ハードウェア頂点シェーダーバージョンコード：%x" ), GRH.DeviceCaps.VertexShaderVersion & 0xffff )) ;
			DXST_ERRORLOGFMT_ADD(( _T( "エミュレーション頂点シェーダーバージョンコード：エミュレーション無し" ) )) ;
		}
		else
		{
			DXST_ERRORLOGFMT_ADD(( _T( "ハードウェア頂点シェーダーバージョンコード：%x" ), GRH.NativeVertexShaderVersion & 0xffff )) ;
			DXST_ERRORLOGFMT_ADD(( _T( "エミュレーション頂点シェーダーバージョンコード：%x" ), GRH.DeviceCaps.VertexShaderVersion & 0xffff )) ;
		}
		DXST_ERRORLOGFMT_ADD(( _T( "ピクセルシェーダーバージョンコード：%x" ), GRH.DeviceCaps.PixelShaderVersion & 0xffff )) ;
	}

	// 描画先の情報を描画先をロックして読み取る場合と一時的な描画サーフェスを介して読み取る場合のどちらが高速かを調べる
	{
		DX_DIRECT3DSURFACE9 *RTSurface = NULL ;
		DX_DIRECT3DSURFACE9 *SMSurface = NULL ;
		DX_DIRECT3DSURFACE9 *DestSurface = NULL ;
		D_D3DLOCKED_RECT SrcLockedRect ;
		D_D3DLOCKED_RECT DestLockedRect ;
		RECT LockRect ;
		LONGLONG Time1 = 0, Time2 = 0;
		int Size, i, j ;
		COLORDATA *ColorData ;

		// 初期状態ではロックを使用しない、にしておく
		GRH.UseRenderTargetLock = FALSE ;

		// キャッシュなどの関係で先行する方が不利になる可能性があるため、３回同じことを繰り返す
		for( j = 0 ; j < 3 ; j ++ )
		{
			// チェック開始
			Time1 = -1 ;
			Time2 = -1 ;
			for(;;)
			{
				// テストに使用するサーフェスのサイズを決定
				Size = 256 ;
				while( Size > GRA2.MainScreenSizeX || Size > GRA2.MainScreenSizeY ) Size >>= 1 ;

				// 仮の出力先のサーフェスを作成する
				DestSurface = NULL ;
				if( GraphicsDevice_CreateOffscreenPlainSurface(
						Size, Size, GRH.ScreenFormat, D_D3DPOOL_SYSTEMMEM, &DestSurface, NULL ) != D_D3D_OK )
					break ;

				// ロックする矩形の作成
				LockRect.left   = 0 ;
				LockRect.top    = 0 ;
				LockRect.right  = Size ;
				LockRect.bottom = Size ;

				// カラーデータの取得
				ColorData = GetD3DFormatColorData( GRH.ScreenFormat ) ;

				// 仮の出力先のサーフェスをロック
				if( GraphicsSurface_LockRect( DestSurface, &DestLockedRect, &LockRect, D_D3DLOCK_READONLY ) != D_D3D_OK )
					break ;

				// 最初に直接ロックする場合を試みる
				{
					Time1 = NS_GetNowHiPerformanceCount() ;

					// 直接ロック
					if( GraphicsSurface_LockRect( GRH.BackBufferSurface, &SrcLockedRect, &LockRect, D_D3DLOCK_READONLY ) != D_D3D_OK )
						break ;

					// データを転送
					for( i = 0 ; i < Size ; i ++ )
						_MEMCPY(
							( BYTE * )DestLockedRect.pBits + DestLockedRect.Pitch * i,
							( BYTE * )SrcLockedRect.pBits + SrcLockedRect.Pitch * i,
							Size * ColorData->PixelByte ) ;

					// ロック解除
					GraphicsSurface_UnlockRect( GRH.BackBufferSurface ) ;

					Time1 = NS_GetNowHiPerformanceCount() - Time1 ;

				}

				// 一時的な描画先サーフェスを作成して読み取る場合を試みる
				{
					Time2 = GetNowHiPerformanceCount() ;

					// ロックサイズと同じ大きさの描画可能サーフェスの作成
					if( GraphicsDevice_CreateRenderTarget(
							Size, Size, GRH.ScreenFormat, D_D3DMULTISAMPLE_NONE, 0, FALSE, &RTSurface, NULL ) != D_D3D_OK )
						break ;

					// ロックサイズと同じ大きさのシステムメモリ上のオフスクリーンサーフェスの作成
					if( GraphicsDevice_CreateOffscreenPlainSurface(
							Size, Size, GRH.ScreenFormat, D_D3DPOOL_SYSTEMMEM, &SMSurface, NULL ) != D_D3D_OK )
						break ;

					// まず描画可能サーフェスに内容を転送する
					GraphicsDevice_StretchRect(
						GRH.BackBufferSurface, &LockRect,
						RTSurface,             &LockRect, D_D3DTEXF_NONE ) ;

					// その後システムメモリサーフェスに内容を転送する
					GraphicsDevice_GetRenderTargetData(
						RTSurface, SMSurface ) ;

					// システムメモリサーフェスをロック
					if( GraphicsSurface_LockRect( SMSurface, &SrcLockedRect, NULL, D_D3DLOCK_READONLY ) != D_D3D_OK )
						break ;

					// データを転送
					for( i = 0 ; i < Size ; i ++ )
						_MEMCPY(
							( BYTE * )DestLockedRect.pBits + DestLockedRect.Pitch * i,
							( BYTE * )SrcLockedRect.pBits + SrcLockedRect.Pitch * i,
							Size * ColorData->PixelByte ) ;

					// ロック解除
					GraphicsSurface_UnlockRect( SMSurface ) ;

					// 一時的なサーフェスを解放
					Graphics_ObjectRelease( RTSurface ) ;
					Graphics_ObjectRelease( SMSurface ) ;
					RTSurface = NULL ;
					SMSurface = NULL ;

					Time2 = GetNowHiPerformanceCount() - Time2 ;
				}

				break ;
			}
			if( SMSurface != NULL )
			{
				Graphics_ObjectRelease( SMSurface ) ;
				SMSurface = NULL ;
			}
			if( RTSurface != NULL )
			{
				Graphics_ObjectRelease( RTSurface ) ;
				RTSurface = NULL ;
			}
			if( DestSurface != NULL )
			{
				Graphics_ObjectRelease( DestSurface ) ;
				DestSurface = NULL ;
			}
		}

		if( Time2 == -1 || Time1 == -1 )
		{
			DXST_ERRORLOG_ADD( _T( "バックバッファロックはロックできません\n" ) ) ;
		}
		else
		{
			// 高速な方を使用する
			DXST_ERRORLOGFMT_ADD( ( _T( "バックバッファロック転送の時間:%dnsec  一時的な描画可能バッファを使用した転送の時間:%dnsec" ), ( int )Time1, ( int )Time2 ) ) ;
			if( Time1 < Time2 )
			{
				GRH.UseRenderTargetLock = TRUE ;
				DXST_ERRORLOG_ADD( _T( "バックバッファロックを使用します\n" ) ) ;
			}
			else
			{
				DXST_ERRORLOG_ADD( _T( "バックバッファロックを使用しません\n" ) ) ;
			}
		}
	}

	// 終了
	return 0 ;

	// エラー処理
ERR:
	return ErrorRet ;
}

// Direct3D9 のシェーダーのセットアップを行う( 0:成功  -1:失敗 )
extern int SetupDirect3D9Shader()
{
	// 既に作成されていたときのために削除処理を行う
	TerminateDirect3D9Shader() ;

	// シェーダーが使用できるか調べる
	GRH.UseShader = FALSE ;
	if( ( GRH.ValidVertexShader_SM3 && GRH.ValidPixelShader_SM3 ) ||
		( GRH.ValidVertexShader && GRH.ValidPixelShader ) )
	{
		GRH.UseShader = TRUE ;

		// シェーダーコードが展開されていない場合は展開
		if( GRA2.ShaderInitializeFlag == FALSE )
		{
			if( ShaderCodeSetup() == FALSE )
			{
				DXST_ERRORLOGFMT_ADD( ( _T( "シェーダーコードを展開するメモリ領域の確保に失敗しました\n" ) ) ) ;
				GRH.UseShader = FALSE ;
				goto ENDLABEL ;
			}
		}

#ifndef DX_NON_MODEL
		if( GRH.ValidVertexShader_SM3 && GRH.ValidPixelShader_SM3 )
		{
			// 頂点シェーダーを一個だけ作ってみる
			if( GraphicsDevice_CreateVertexShader(
					( DWORD * )GRA2.MV1_PixelLighting_VertexShaderAddress[ 0 ][ 0 ][ 0 ][ 0 ],
									  &GRH.MV1_PixelLighting_VertexShader[ 0 ][ 0 ][ 0 ][ 0 ] )
					!= D_D3D_OK )
			{
				DXST_ERRORLOGFMT_ADD( ( _T( "頂点シェーダーオブジェクトの作成に失敗しました\n" ) ) ) ;
				GRH.UseShader = FALSE ;
				goto ENDLABEL ;
			}

			if( GraphicsDevice_CreatePixelShader(
					( DWORD * )GRA2.MV1_PixelLighting_PixelShaderAddress[ 0 ][ 0 ][ 0 ][ 0 ][ GRA2.LightIndexList84[ 1 ][ 0 ][ 0 ][ 0 ][ 0 ][ 0 ] ][ 0 ],
									  &GRH.MV1_PixelLighting_PixelShader[ 0 ][ 0 ][ 0 ][ 0 ][ GRA2.LightIndexList84[ 1 ][ 0 ][ 0 ][ 0 ][ 0 ][ 0 ] ][ 0 ] )
					!= D_D3D_OK )
			{
				DXST_ERRORLOGFMT_ADD( ( _T( "ピクセルシェーダーオブジェクトの作成に失敗しました\n" ) ) ) ;
				GRH.UseShader = FALSE ;
				goto ENDLABEL ;
			}
		}

		if( GRH.ValidVertexShader && GRH.ValidPixelShader )
		{
			// 頂点シェーダーを一個だけ作ってみる
			if( GraphicsDevice_CreateVertexShader(
					( DWORD * )GRA2.MV1_LightingVertexShaderAddress[ 0 ][ 0 ][ 0 ][ 0 ][ 0 ][ GRA2.LightIndexList20[ 1 ][ 0 ][ 0 ] ][ 0 ],
									  &GRH.MV1_LightingVertexShader[ 0 ][ 0 ][ 0 ][ 0 ][ 0 ][ GRA2.LightIndexList20[ 1 ][ 0 ][ 0 ] ][ 0 ] )
					!= D_D3D_OK )
			{
				DXST_ERRORLOGFMT_ADD( ( _T( "頂点シェーダーオブジェクトの作成に失敗しました\n" ) ) ) ;
				GRH.UseShader = FALSE ;
				goto ENDLABEL ;
			}

			// ピクセルシェーダーも一個だけ作ってみる
			/*
			if( GraphicsDevice_CreatePixelShader(
					( DWORD * )GRA2.DefaultPixelShaderAddress[ 0 ][ 0 ][ 0 ][ 0 ][ 0 ][ 1 ][ 0 ][ 1 ][ 1 ][ 1 ][ 0 ][ 0 ][ 0 ],
									  &GRH.DefaultPixelShader[ 0 ][ 0 ][ 0 ][ 0 ][ 0 ][ 1 ][ 0 ][ 1 ][ 1 ][ 1 ][ 0 ][ 0 ][ 0 ] )
					!= D_D3D_OK )
			{
				DXST_ERRORLOGFMT_ADD( ( _T( "ピクセルシェーダーオブジェクトの作成に失敗しました\n" ) ) ) ;
				GRH.UseShader = FALSE ;
				goto ENDLABEL ;
			}
			*/
			if( GraphicsDevice_CreatePixelShader(
					( DWORD * )GRA2.MV1_LightingPixelShaderAddress[ 0 ][ 0 ][ 0 ][ 0 ][ 0 ][ GRA2.LightIndexList10[ 1 ][ 0 ][ 0 ] ][ 0 ],
									  &GRH.MV1_LightingPixelShader[ 0 ][ 0 ][ 0 ][ 0 ][ 0 ][ GRA2.LightIndexList10[ 1 ][ 0 ][ 0 ] ][ 0 ] )
					!= D_D3D_OK )
			{
				DXST_ERRORLOGFMT_ADD( ( _T( "ピクセルシェーダーオブジェクトの作成に失敗しました\n" ) ) ) ;
				GRH.UseShader = FALSE ;
				goto ENDLABEL ;
			}
		}
#endif // DX_NON_MODEL

		// 基本的な描画処理に使用するピクセルシェーダーを作成する
		{
			int i, j, k, l, m ;
			char FileName[ 64 ] ;
			int Addr, Size ;
			void *DataImage ;

			DataImage = DXA_GetFileImage( &GRA2.BaseShaderBinDxa ) ;

			// テクスチャなしシェーダーの作成
			_STRCPY( FileName, "ps_nonetex_type0_ach0.pso" ) ;
			for( i = 0 ; i < 7 ; i ++ )
			{
				FileName[ 15 ] = ( char )( '0' + i ) ;
				for( j = 0 ; j < 2 ; j ++ )
				{
					FileName[ 20 ] = ( char )( '0' + j ) ;

					if( DXA_GetFileInfo( &GRA2.BaseShaderBinDxa, FileName, &Addr, &Size ) == 0 )
					{
						if( GraphicsDevice_CreatePixelShader( ( DWORD * )( ( BYTE * )DataImage + Addr ), &GRH.BaseNoneTexPixelShader[ i ][ j ] ) != D_D3D_OK )
						{
							DXST_ERRORLOGFMT_ADD( ( _T( "基本シェーダーオブジェクトの作成に失敗しました\n" ) ) ) ;
							GRH.UseShader = FALSE ;
							goto ENDLABEL ;
						}
					}
				}
			}

			// テクスチャありシェーダーの作成
			_STRCPY( FileName, "ps_blend0_type0_igcolor0_igtalpha0_ach0.pso" ) ;
			for( i = 0 ; i < 4 ; i ++ )
			{
				FileName[ 8 ] = ( char )( '0' + i ) ;
				for( j = 0 ; j < 7 ; j ++ )
				{
					FileName[ 14 ] = ( char )( '0' + j ) ;
					for( k = 0 ; k < 2 ; k ++ )
					{
						FileName[ 23 ] =( char )(  '0' + k ) ;
						for( l = 0 ; l < 2 ; l ++ )
						{
							FileName[ 33 ] = ( char )( '0' + l ) ;
							for( m = 0 ; m < 2 ; m ++ )
							{
								FileName[ 38 ] = ( char )( '0' + m ) ;

								if( DXA_GetFileInfo( &GRA2.BaseShaderBinDxa, FileName, &Addr, &Size ) == 0 )
								{
									if( GraphicsDevice_CreatePixelShader( ( DWORD * )( ( BYTE * )DataImage + Addr ), &GRH.BaseUseTexPixelShader[ i ][ j ][ k ][ l ][ m ] ) != D_D3D_OK )
									{
										DXST_ERRORLOGFMT_ADD( ( _T( "基本シェーダーオブジェクトの作成に失敗しました\n" ) ) ) ;
										GRH.UseShader = FALSE ;
										goto ENDLABEL ;
									}
								}
							}
						}
					}
				}
			}

			// マスク処理用シェーダーの作成
			DXA_GetFileInfo( &GRA2.BaseShaderBinDxa, "ps_mask_blend.pso", &Addr, &Size ) ;
			if( GraphicsDevice_CreatePixelShader( ( DWORD * )( ( BYTE * )DataImage + Addr ), &GRH.MaskEffectPixelShader ) != D_D3D_OK )
			{
				DXST_ERRORLOGFMT_ADD( ( _T( "マスク処理用シェーダーオブジェクトの作成に失敗しました\n" ) ) ) ;
				GRH.UseShader = FALSE ;
				goto ENDLABEL ;
			}
		}
	}

ENDLABEL:

//	GRH.UseShader = FALSE ;

	if( GRH.UseShader == FALSE )
	{
		DXST_ERRORLOGFMT_ADD( ( _T( "プログラマブルシェーダーを使用しません\n" ) ) ) ;
	}
	else
	{
		DXST_ERRORLOGFMT_ADD( ( _T( "プログラマブルシェーダーを使用します\n" ) ) ) ;
	}

	// シェーダーの定数をセット
	static float ZeroOne[ 4 ]        = { 0.0f, 1.0f, 0.0f, 0.0f } ;
	static float ZeroHalfOneTwo[ 4 ] = { 0.0f, 0.5f, 1.0f, 2.0f } ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_LIB, DX_VS_CONSTF_ZERO_ONE,          ZeroOne,        1, TRUE ) ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB, DX_PS_CONSTF_ZERO_HALF_ONE_TWO, ZeroHalfOneTwo, 1, TRUE ) ;

	// 正常終了
	return 0 ;
}


// Direct3DVertexDeclaration9 オブジェクトの作成( 0:成功  -1:失敗 )
extern int CreateDirect3D9VertexDeclaration()
{
	// 既に作成されていたときのために削除処理を行う
	TerminateDirect3D9VertexDeclaration() ;

#ifndef DX_NON_MODEL
	{
		D_D3DVERTEXELEMENT9 *VE, VertElem[ 64 ] = 
		{
			{ 0, 0,   D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 },
			{ 0, 12,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDWEIGHT,  0 },
			{ 0, 28,  D_D3DDECLTYPE_UBYTE4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDINDICES, 0 },
			{ 0, 32,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 },
			{ 0, 44,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 },
			{ 0, 48,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 },
			{ 0, 52,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TEXCOORD,     0 },
			D_D3DDECL_END()
		} ;
		int offset, index ;
		int i, j, k, l ;

		// バンプマップ情報つきかどうかで２ループ
		for( i = 0 ; i < 2 ; i ++ )
		{
			// スキニングメッシュタイプによって３ループ
			for( j = 0 ; j < 3 ; j ++ )
			{
				if( i == 0 )
				{
					switch( j )
					{
					case 0 :
						// バンプマップ情報無し剛体メッシュ
						VertElem[ 0 ] = MakeVertexElement9( 0,  0,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 ) ;
						VertElem[ 1 ] = MakeVertexElement9( 0, 12,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 ) ;
						VertElem[ 2 ] = MakeVertexElement9( 0, 24,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 ) ;
						VertElem[ 3 ] = MakeVertexElement9( 0, 28,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 ) ;
						offset = 32 ;
						index = 4 ;
						break ;

					case 1 :
						// バンプマップ情報無し４ボーン内スキニングメッシュ
						VertElem[ 0 ] = MakeVertexElement9( 0,  0,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 ) ;
						VertElem[ 1 ] = MakeVertexElement9( 0, 12,  D_D3DDECLTYPE_UBYTE4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDINDICES, 0 ) ;
						VertElem[ 2 ] = MakeVertexElement9( 0, 16,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDWEIGHT,  0 ) ;
						VertElem[ 3 ] = MakeVertexElement9( 0, 32,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 ) ;
						VertElem[ 4 ] = MakeVertexElement9( 0, 44,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 ) ;
						VertElem[ 5 ] = MakeVertexElement9( 0, 48,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 ) ;
						offset = 52 ;
						index = 6 ;
						break ;

					case 2 :
						// バンプマップ情報無し８ボーン内スキニングメッシュ
						VertElem[ 0 ] = MakeVertexElement9( 0,  0,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 ) ;
						VertElem[ 1 ] = MakeVertexElement9( 0, 12,  D_D3DDECLTYPE_UBYTE4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDINDICES, 0 ) ;
						VertElem[ 2 ] = MakeVertexElement9( 0, 16,  D_D3DDECLTYPE_UBYTE4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDINDICES, 1 ) ;
						VertElem[ 3 ] = MakeVertexElement9( 0, 20,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDWEIGHT,  0 ) ;
						VertElem[ 4 ] = MakeVertexElement9( 0, 36,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDWEIGHT,  1 ) ;
						VertElem[ 5 ] = MakeVertexElement9( 0, 52,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 ) ;
						VertElem[ 6 ] = MakeVertexElement9( 0, 64,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 ) ;
						VertElem[ 7 ] = MakeVertexElement9( 0, 68,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 ) ;
						offset = 72 ;
						index = 8 ;
						break ;
					}
				}
				else
				{
					switch( j )
					{
					case 0 :
						// バンプマップ情報有り剛体メッシュ
						VertElem[ 0 ] = MakeVertexElement9( 0,  0,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 ) ;
						VertElem[ 1 ] = MakeVertexElement9( 0, 12,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TANGENT,      0 ) ;
						VertElem[ 2 ] = MakeVertexElement9( 0, 24,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BINORMAL,     0 ) ;
						VertElem[ 3 ] = MakeVertexElement9( 0, 36,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 ) ;
						VertElem[ 4 ] = MakeVertexElement9( 0, 48,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 ) ;
						VertElem[ 5 ] = MakeVertexElement9( 0, 52,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 ) ;
						offset = 56 ;
						index = 6 ;
						break ;

					case 1 :
						// バンプマップ情報有り４ボーン内スキニングメッシュ
						VertElem[ 0 ] = MakeVertexElement9( 0,  0,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 ) ;
						VertElem[ 1 ] = MakeVertexElement9( 0, 12,  D_D3DDECLTYPE_UBYTE4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDINDICES, 0 ) ;
						VertElem[ 2 ] = MakeVertexElement9( 0, 16,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDWEIGHT,  0 ) ;
						VertElem[ 3 ] = MakeVertexElement9( 0, 32,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TANGENT,      0 ) ;
						VertElem[ 4 ] = MakeVertexElement9( 0, 44,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BINORMAL,     0 ) ;
						VertElem[ 5 ] = MakeVertexElement9( 0, 56,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 ) ;
						VertElem[ 6 ] = MakeVertexElement9( 0, 68,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 ) ;
						VertElem[ 7 ] = MakeVertexElement9( 0, 72,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 ) ;
						offset = 76 ;
						index = 8 ;
						break ;

					case 2 :
						// バンプマップ情報有り８ボーン内スキニングメッシュ
						VertElem[ 0 ] = MakeVertexElement9( 0,  0,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 ) ;
						VertElem[ 1 ] = MakeVertexElement9( 0, 12,  D_D3DDECLTYPE_UBYTE4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDINDICES, 0 ) ;
						VertElem[ 2 ] = MakeVertexElement9( 0, 16,  D_D3DDECLTYPE_UBYTE4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDINDICES, 1 ) ;
						VertElem[ 3 ] = MakeVertexElement9( 0, 20,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDWEIGHT,  0 ) ;
						VertElem[ 4 ] = MakeVertexElement9( 0, 36,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BLENDWEIGHT,  1 ) ;
						VertElem[ 5 ] = MakeVertexElement9( 0, 52,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TANGENT,      0 ) ;
						VertElem[ 6 ] = MakeVertexElement9( 0, 64,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BINORMAL,     0 ) ;
						VertElem[ 7 ] = MakeVertexElement9( 0, 76,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 ) ;
						VertElem[ 8 ] = MakeVertexElement9( 0, 88,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 ) ;
						VertElem[ 9 ] = MakeVertexElement9( 0, 92,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 ) ;
						offset = 96 ;
						index = 10 ;
						break ;
					}
				}

				for( k = 0 ; k < 9 ; k ++ )
				{
					VE = &VertElem[ index ] ;
					for( l = 0 ; l < k ; l ++, VE ++ )
					{
						VE->Stream     = 0 ;
						VE->Offset     = ( WORD )( offset + sizeof( float ) * 4 * l ) ;
						VE->Type       = D_D3DDECLTYPE_FLOAT4 ;
						VE->Method     = D_D3DDECLMETHOD_DEFAULT ;
						VE->Usage      = D_D3DDECLUSAGE_TEXCOORD ;
						VE->UsageIndex = ( BYTE )l ;
					}
					VE->Stream     = 0xFF ;
					VE->Offset     = 0 ;
					VE->Type       = D_D3DDECLTYPE_UNUSED ;
					VE->Method     = 0 ;
					VE->Usage      = 0 ;
					VE->UsageIndex = 0 ;

					GraphicsDevice_CreateVertexDeclaration( VertElem, &GRH.DefaultVertexDeclaration[ i ][ j ][ k ] ) ;
				}
			}
		}
	}
#endif // DX_NON_MODEL

	// ユーザーシェーダーモードで使用する頂点データ形式を作成
	{
		D_D3DVERTEXELEMENT9 _VertElem[ 10 ] ;

		// DX_VERTEX_TYPE_NORMAL_3D ( VERTEX3D構造体形式 )
		_VertElem[ 0 ] = MakeVertexElement9( 0,     0,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 ) ;
		_VertElem[ 1 ] = MakeVertexElement9( 0,    12,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 ) ;
		_VertElem[ 2 ] = MakeVertexElement9( 0,    24,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 ) ;
		_VertElem[ 3 ] = MakeVertexElement9( 0,    28,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 ) ;
		_VertElem[ 4 ] = MakeVertexElement9( 0,    32,  D_D3DDECLTYPE_FLOAT2,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TEXCOORD,     0 ) ;
		_VertElem[ 5 ] = MakeVertexElement9( 0,    40,  D_D3DDECLTYPE_FLOAT2,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TEXCOORD,     1 ) ;
		_VertElem[ 6 ] = MakeVertexElement9( 0xff,  0,  D_D3DDECLTYPE_UNUSED,                         0,                       0,     0 ) ;
		GraphicsDevice_CreateVertexDeclaration( _VertElem, &GRH.UserShaderDeclaration[ DX_VERTEX_TYPE_NORMAL_3D ] ) ;

		// DX_VERTEX_TYPE_SHADER_3D ( VERTEX3DSHADER構造体形式 )
		_VertElem[ 0 ] = MakeVertexElement9( 0,     0,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     0 ) ;
		_VertElem[ 1 ] = MakeVertexElement9( 0,    12,  D_D3DDECLTYPE_FLOAT4,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_POSITION,     1 ) ;
		_VertElem[ 2 ] = MakeVertexElement9( 0,    28,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_NORMAL,       0 ) ;
		_VertElem[ 3 ] = MakeVertexElement9( 0,    40,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TANGENT,      0 ) ;
		_VertElem[ 4 ] = MakeVertexElement9( 0,    52,  D_D3DDECLTYPE_FLOAT3,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_BINORMAL,     0 ) ;
		_VertElem[ 5 ] = MakeVertexElement9( 0,    64,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        0 ) ;
		_VertElem[ 6 ] = MakeVertexElement9( 0,    68,  D_D3DDECLTYPE_D3DCOLOR, D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_COLOR,        1 ) ;
		_VertElem[ 7 ] = MakeVertexElement9( 0,    72,  D_D3DDECLTYPE_FLOAT2,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TEXCOORD,     0 ) ;
		_VertElem[ 8 ] = MakeVertexElement9( 0,    80,  D_D3DDECLTYPE_FLOAT2,   D_D3DDECLMETHOD_DEFAULT, D_D3DDECLUSAGE_TEXCOORD,     1 ) ;
		_VertElem[ 9 ] = MakeVertexElement9( 0xff,  0,  D_D3DDECLTYPE_UNUSED,                         0,                       0,     0 ) ;
		GraphicsDevice_CreateVertexDeclaration( _VertElem, &GRH.UserShaderDeclaration[ DX_VERTEX_TYPE_SHADER_3D ] ) ;
	}

	// 正常終了
	return 0 ;
}

__inline void RGBtoVMaxRGBI( int R, int G, int B, BYTE &RD, BYTE &GD, BYTE &BD )
{
	int h, s ;

	if( R + G + B == 0 )
	{
		RD = 255 ;
		GD = 255 ;
		BD = 255 ;
		return ;
	}

	if( R > 255 ) R = 255 ;
	if( G > 255 ) G = 255 ;
	if( B > 255 ) B = 255 ;

	if( R > G )
	{
		if( R > B )
		{
			if( G > B )
			{
				// R > G > B
				if( R == B )
				{
					RD = 255 ;
					GD = 255 ;
					BD = 255 ;
				}
				else
				{
					h = ( G - B ) * 255 / ( R - B ) ;
					s = ( R - B ) * 255 / R ;

					RD = 255 ;
					GD = ( BYTE )( 255 - ( 255 - h ) * s / 255 ) ;
					BD = ( BYTE )( 255 - s ) ;
				}
			}
			else
			{
				// R > B > G
				if( R == G )
				{
					RD = 255 ;
					GD = 255 ;
					BD = 255 ;
				}
				else
				{
					h = ( B - G ) * 255 / ( R - G ) ;
					s = ( R - G ) * 255 / R ;

					RD = 255 ;
					GD = ( BYTE )( 255 - s ) ;
					BD = ( BYTE )( 255 - ( 255 - h ) * s / 255 ) ;
				}
			}
		}
		else
		{
			// B > R > G
			if( B == G )
			{
				RD = 255 ;
				GD = 255 ;
				BD = 255 ;
			}
			else
			{
				h = ( R - G ) * 255 / ( B - G ) ;
				s = ( B - G ) * 255 / B ;

				RD = ( BYTE )( 255 - ( 255 - h ) * s / 255 ) ;
				GD = ( BYTE )( 255 - s ) ;
				BD = 255 ;
			}
		}
	}
	else
	{
		if( G > B )
		{
			if( R > B )
			{
				// G > R > B
				if( G == B )
				{
					RD = 255 ;
					GD = 255 ;
					BD = 255 ;
				}
				else
				{
					h = ( R - B ) * 255 / ( G - B ) ;
					s = ( G - B ) * 255 / G ;

					RD = ( BYTE )( 255 - ( 255 - h ) * s / 255 ) ;
					GD = 255 ;
					BD = ( BYTE )( 255 - s ) ;
				}
			}
			else
			{
				// G > B > R
				if( G == R )
				{
					RD = 255 ;
					GD = 255 ;
					BD = 255 ;
				}
				else
				{
					h = ( B - R ) * 255 / ( G - R ) ;
					s = ( G - R ) * 255 / G ;

					RD = ( BYTE )( 255 - s ) ;
					GD = 255 ;
					BD = ( BYTE )( 255 - ( 255 - h ) * s / 255 ) ;
				}
			}
		}
		else
		{
			// B > G > R
			if( B == R )
			{
				RD = 255 ;
				GD = 255 ;
				BD = 255 ;
			}
			else
			{
				h = ( G - R ) * 255 / ( B - R ) ;
				s = ( B - R ) * 255 / B ;

				RD = ( BYTE )( 255 - s ) ;
				GD = ( BYTE )( 255 - ( 255 - h ) * s / 255 ) ;
				BD = 255 ;
			}
		}
	}
}

#ifndef DX_NON_MODEL

// RGBカラーを輝度を最大にしたRGB値に変換するためのボリュームテクスチャを作成する( 0:成功  -1:失敗 )
extern int CreateRGBtoVMaxRGBVolumeTexture()
{
	DX_DIRECT3DVOLUMETEXTURE9 *TempMemTexture9 ;
	D_D3DLOCKED_BOX LockInfo ;
	D_D3DBOX LockBox ;
	int r, g, b ;
	BYTE *pDest ;
	HRESULT hr ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	GRH.RGBtoVMaxRGBVolumeTexture = NULL ;
	TempMemTexture9 = NULL ;

	// ボリュームテクスチャの作成
	hr = GraphicsDevice_CreateVolumeTexture(
		RGBTOVMAXRGB_TEX_SIZE,
		RGBTOVMAXRGB_TEX_SIZE,
		RGBTOVMAXRGB_TEX_SIZE,
		1,
		0,
		D_D3DFMT_X8R8G8B8,
		D_D3DPOOL_DEFAULT,
		&GRH.RGBtoVMaxRGBVolumeTexture,
		NULL ) ;
	if( hr != D_D3D_OK )
	{
		DXST_ERRORLOG_ADD( _T( "RGBカラーを輝度を最大にしたRGB値に変換するためのボリュームテクスチャの作成に失敗しました\n" ) ) ;
		goto ERR ;
	}

	// 転送用システムメモリボリュームテクスチャの作成
	if( GraphicsDevice_CreateVolumeTexture(
		RGBTOVMAXRGB_TEX_SIZE,
		RGBTOVMAXRGB_TEX_SIZE,
		RGBTOVMAXRGB_TEX_SIZE,
		1,
		0,
		D_D3DFMT_X8R8G8B8,
		D_D3DPOOL_SYSTEMMEM,
		&TempMemTexture9,
		NULL ) != D_D3D_OK )
	{
		DXST_ERRORLOG_ADD( _T( "RGBカラーを輝度を最大にしたRGB値に変換するための転送元用ボリュームテクスチャの作成に失敗しました\n" ) ) ;
		goto ERR ;
	}

	// システムメモリボリュームテクスチャのロック
	_MEMSET( &LockInfo, 0, sizeof( LockInfo ) ) ;
	LockBox.Left   = 0 ;
	LockBox.Top    = 0 ;
	LockBox.Front  = 0 ;
	LockBox.Right  = RGBTOVMAXRGB_TEX_SIZE ;
	LockBox.Bottom = RGBTOVMAXRGB_TEX_SIZE ;
	LockBox.Back   = RGBTOVMAXRGB_TEX_SIZE ;
	hr = TempMemTexture9->LockBox( 0, &LockInfo, &LockBox, 0 ) ;
	if( hr == D_D3D_OK )
	{
		// システムメモリボリュームテクスチャに変換情報を書き込む
		for( b = 0 ; b < RGBTOVMAXRGB_TEX_SIZE ; b ++ )
		{
			for( g = 0 ; g < RGBTOVMAXRGB_TEX_SIZE ; g ++ )
			{
				pDest = ( BYTE * )LockInfo.pBits + LockInfo.SlicePitch * b + LockInfo.RowPitch * g ;
				for( r = 0 ; r < RGBTOVMAXRGB_TEX_SIZE ; r ++, pDest += 4 )
				{
					RGBtoVMaxRGBI( r * 2, g * 2, b * 2, pDest[ 2 ], pDest[ 1 ], pDest[ 0 ] ) ;
					if( r < 8 && g < 8 && b < 8 )
					{
						pDest[ 0 ] = 255 ;
						pDest[ 1 ] = 255 ;
						pDest[ 2 ] = 255 ;
					}
					pDest[ 3 ] = 255 ;
				}
			}
		}
	}
	else
	{
		DXST_ERRORLOG_ADD( _T( "RGBカラーを輝度を最大にしたRGB値に変換するための転送元用ボリュームテクスチャのロックに失敗しました\n" ) ) ;
		goto ERR ;
	}

	// ロックの解除
	TempMemTexture9->UnlockBox( 0 ) ;

	// テクスチャの転送
	hr = GraphicsDevice_UpdateTexture( TempMemTexture9, GRH.RGBtoVMaxRGBVolumeTexture ) ;

	// システムメモリボリュームテクスチャの解放
	Graphics_ObjectRelease( TempMemTexture9 ) ;
	TempMemTexture9 = NULL ;

	// 終了
	return 0 ;

ERR :
	if( GRH.RGBtoVMaxRGBVolumeTexture )
	{
		Graphics_ObjectRelease( GRH.RGBtoVMaxRGBVolumeTexture ) ;
		GRH.RGBtoVMaxRGBVolumeTexture = NULL ;
	}

	if( TempMemTexture9 )
	{
		Graphics_ObjectRelease( TempMemTexture9 ) ;
		TempMemTexture9 = NULL ;
	}
	
	return -1 ;
}

#endif // DX_NON_MODEL

// Ｚバッファオブジェクトの作成( 0:成功  -1:失敗 )
extern int CreateDirect3D9ZBufferObject()
{
	HRESULT hr ;
	int w, h ;
	int depth ;
	int index ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 既に作成済みの場合は一度削除する
	if( GRH.ZBufferSurface )
	{
		Graphics_ObjectRelease( GRH.ZBufferSurface ) ;
		GRH.ZBufferSurface = NULL ;
	}

	DXST_ERRORLOG_ADD( _T( "Ｚバッファを作成します.... " ) ) ;

	// Ｚバッファのサイズを決定
	if( GRH.UserZBufferSizeSet == FALSE ||
		GRH.ZBufferSizeX == 0 ||
		GRH.ZBufferSizeY == 0 )
	{
		for( w = 1 ; w < GRA2.MainScreenSizeX ; w <<= 1 ){}
		for( h = 1 ; h < GRA2.MainScreenSizeY ; h <<= 1 ){}
		GRH.ZBufferSizeX = w ;
		GRH.ZBufferSizeY = h ;
	}
	else
	{
		w = GRH.ZBufferSizeX ;
		h = GRH.ZBufferSizeY ;
	}

	// Ｚバッファのビット深度を決定
	if( GRH.UserZBufferBitDepthSet == FALSE ||
		GRH.ZBufferBitDepth == 0  )
	{
		depth = DEFAULT_ZBUFFER_BITDEPTH ;
		GRH.ZBufferBitDepth = DEFAULT_ZBUFFER_BITDEPTH ;
	}
	else
	{
		depth = GRH.ZBufferBitDepth ;
	}
	switch( depth )
	{
	default :
	case 16 : index = ZBUFFER_FORMAT_16BIT ; break ;
	case 24 : index = ZBUFFER_FORMAT_24BIT ; break ;
	case 32 : index = ZBUFFER_FORMAT_32BIT ; break ;
	}

	// 作成
	hr = GraphicsDevice_CreateDepthStencilSurface( w, h, GRH.ZBufferFormat[ index ], GRH.FSAAMultiSampleType, GRH.FSAAMultiSampleQuality, TRUE, &GRH.ZBufferSurface, NULL ) ;
	if( FAILED( hr ) )
	{
		DXST_ERRORLOG_ADD( _T( "Ｚバッファの作成に失敗しました\n" ) ) ;
		return -1 ;
	}

	// デバイスにセット
	GraphicsDevice_SetDepthStencilSurface( GRH.ZBufferSurface ) ;

	// クリア
	GraphicsDevice_Clear( 0, NULL, D_D3DCLEAR_ZBUFFER, 0, 1.0f, 0 ) ;

	DXST_ERRORLOG_ADD( _T( "成功\n" ) ) ;

	// 終了
	return 0 ;
}

// ScreenCopy や GetDrawScreen を実現するために使用するテンポラリバッファの作成( 0:成功  -1:失敗 )
extern int CreateSubBackBufferSurface()
{
	HRESULT hr ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 既に作成されている場合は一度削除する
	if( GRH.SubBackBufferSurface )
	{
		Graphics_ObjectRelease( GRH.SubBackBufferSurface ) ;
		GRH.SubBackBufferSurface = NULL ;
	}

	// レンダリングターゲットの作成
	hr = GraphicsDevice_CreateRenderTarget( GRA2.MainScreenSizeX, GRA2.MainScreenSizeY, GRH.ScreenFormat, GRH.FSAAMultiSampleType, GRH.FSAAMultiSampleQuality, FALSE, &GRH.SubBackBufferSurface, NULL ) ;
	if( FAILED( hr ) )
	{
		DXST_ERRORLOG_ADD( _T( "サブバックバッファの作成に失敗しました\n" ) ) ;
		return -1 ;
	}

	// 終了
	return 0 ;
}

// Direct3DVertexDeclaration9 オブジェクトの削除( 0:成功  -1:失敗 )
extern int TerminateDirect3D9VertexDeclaration()
{
	int i ;

	if( GraphicsDevice_IsValid() == 0 )
		return 0 ;

	GraphicsDevice_SetVertexShader( NULL ) ;
	GraphicsDevice_SetPixelShader( NULL ) ;
	GRH.SetVS = NULL ;
	GRH.SetVD = NULL ;

#ifndef DX_NON_MODEL
	DX_DIRECT3DVERTEXDECLARATION9 **VD ;

	VD = ( DX_DIRECT3DVERTEXDECLARATION9 ** )GRH.DefaultVertexDeclaration ;
	for( i = 0 ; i < sizeof( GRH.DefaultVertexDeclaration ) / sizeof( DX_DIRECT3DVERTEXDECLARATION9 * ) ; i ++ )
	{
		if( VD[ i ] )
		{
			Graphics_ObjectRelease( VD[ i ] ) ;
			VD[ i ] = NULL ;
		}
	}

#endif // DX_NON_MODEL

	// ユーザーシェーダーモード用の頂点宣言の解放
	for( i = 0 ; i < DX_VERTEX_TYPE_NUM ; i ++ )
	{
		if( GRH.UserShaderDeclaration[ i ] )
		{
			Graphics_ObjectRelease( GRH.UserShaderDeclaration[ i ] ) ;
			GRH.UserShaderDeclaration[ i ] = NULL ;
		}
	}

	// 正常終了
	return 0 ;
}

// Direct3D9 のシェーダーの後始末をする( 0:成功  -1:失敗 )
extern int TerminateDirect3D9Shader()
{
	if( GraphicsDevice_IsValid() == 0 )
		return 0 ;

	GraphicsDevice_SetVertexShader( NULL ) ;
	GraphicsDevice_SetPixelShader( NULL ) ;
	GRH.SetVS = NULL ;
	GRH.SetVD = NULL ;

	int i ;
	DX_DIRECT3DVERTEXSHADER9 **VS = NULL ;
	DX_DIRECT3DPIXELSHADER9 **PS = NULL ;

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )GRH.BaseNoneTexPixelShader ;
	for( i = 0 ; i < sizeof( GRH.BaseNoneTexPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )GRH.BaseUseTexPixelShader ;
	for( i = 0 ; i < sizeof( GRH.BaseUseTexPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	if( GRH.MaskEffectPixelShader )
	{
		Graphics_ObjectRelease( GRH.MaskEffectPixelShader ) ;
		GRH.MaskEffectPixelShader = NULL ;
	}

#ifndef DX_NON_MODEL

	VS = ( DX_DIRECT3DVERTEXSHADER9 ** )GRH.MV1_PixelLighting_VertexShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_PixelLighting_VertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++ )
	{
		if( VS[ i ] )
		{
			Graphics_ObjectRelease( VS[ i ] ) ;
			VS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )GRH.MV1_PixelLighting_ToonPixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_PixelLighting_ToonPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )GRH.MV1_PixelLighting_PixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_PixelLighting_PixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}








	VS = ( DX_DIRECT3DVERTEXSHADER9 ** )GRH.MV1_ToonOutLineVertexShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_ToonOutLineVertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++ )
	{
		if( VS[ i ] )
		{
			Graphics_ObjectRelease( VS[ i ] ) ;
			VS[ i ] = NULL ;
		}
	}

	VS = ( DX_DIRECT3DVERTEXSHADER9 ** )GRH.MV1_ShadowMapVertexShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_ShadowMapVertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++ )
	{
		if( VS[ i ] )
		{
			Graphics_ObjectRelease( VS[ i ] ) ;
			VS[ i ] = NULL ;
		}
	}

	VS = ( DX_DIRECT3DVERTEXSHADER9 ** )GRH.MV1_NoLightingVertexShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_NoLightingVertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++ )
	{
		if( VS[ i ] )
		{
			Graphics_ObjectRelease( VS[ i ] ) ;
			VS[ i ] = NULL ;
		}
	}

	VS = ( DX_DIRECT3DVERTEXSHADER9 ** )GRH.MV1_LightingVertexShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_LightingVertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++ )
	{
		if( VS[ i ] )
		{
			Graphics_ObjectRelease( VS[ i ] ) ;
			VS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )&GRH.MV1_ToonOutLinePixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_ToonOutLinePixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )&GRH.MV1_ShadowMapToonPixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_ShadowMapToonPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )&GRH.MV1_ShadowMapPixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_ShadowMapPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )GRH.MV1_ToonNoLightingPixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_ToonNoLightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )GRH.MV1_NoLightingPixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_NoLightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )GRH.MV1_ToonLightingPixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_ToonLightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

	PS = ( DX_DIRECT3DPIXELSHADER9 ** )GRH.MV1_LightingPixelShader ;
	for( i = 0 ; i < sizeof( GRH.MV1_LightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++ )
	{
		if( PS[ i ] )
		{
			Graphics_ObjectRelease( PS[ i ] ) ;
			PS[ i ] = NULL ;
		}
	}

#endif // DX_NON_MODEL

	// 正常終了
	return 0 ;
}

// シェーダーコードの後始末を行う
static int ShaderCodeTerminate()
{
	// すでに後始末されていたら何もしない
	if( GRA2.ShaderInitializeFlag == FALSE )
		return TRUE ;

	// 基本シェーダー用ＤＸＡの後始末
	DXA_Terminate( &GRA2.BaseShaderBinDxa ) ;


	// 解凍したシェーダーを格納していたメモリの解放
	if( GRA2.BaseShaderBinDxaImage != NULL )
	{
		DXFREE( GRA2.BaseShaderBinDxaImage ) ;
		GRA2.BaseShaderBinDxaImage = NULL ;
	}

#ifndef DX_NON_MODEL
	if( GRA2.ModelShaderPackImage )
	{
		DXFREE( GRA2.ModelShaderPackImage ) ;
		GRA2.ModelShaderPackImage = NULL ;
	}
#endif // DX_NON_MODEL

#ifndef DX_NON_FILTER

	// フィルターシェーダー用ＤＸＡの後始末
	DXA_Terminate( &GRA2.FilterShaderBinDxa ) ;

	if( GRA2.RGBAMixS_ShaderPackImage )
	{
		DXFREE( GRA2.RGBAMixS_ShaderPackImage ) ;
		GRA2.RGBAMixS_ShaderPackImage = NULL ;
	}
	if( GRA2.FilterShaderBinDxaImage )
	{
		DXFREE( GRA2.FilterShaderBinDxaImage ) ;
		GRA2.FilterShaderBinDxaImage = NULL ;
	}

#endif // DX_NON_FILTER

	// 初期化フラグを倒す
	GRA2.ShaderInitializeFlag = FALSE ;

	// 正常終了
	return TRUE ;
}

// シェーダーコードをメモリに展開する
static int ShaderCodeSetup()
{
	int Size = 0, Addr = 0, i = 0 ;
	void **AddrBuf = NULL ;
	BYTE *ShaderAddr = NULL ;
	WORD *SizeBuf = NULL ;
	short *SizeDest = NULL ;

	// すでに初期化されていたら何もしない
	if( GRA2.ShaderInitializeFlag == TRUE )
		return TRUE ;

#ifndef DX_NON_FILTER
	GRA2.FilterShaderBinDxaImage = NULL ;
	GRA2.RGBAMixS_ShaderPackImage = NULL ;
#endif // DX_NON_FILTER

#ifndef DX_NON_MODEL
	GRA2.ModelShaderPackImage = NULL ;
#endif // DX_NON_MODEL

	GRA2.BaseShaderBinDxaImage = NULL ;

	// 基本シェーダーオブジェクトファイルＤＸＡを圧縮したデータを解凍する
	{
		Size = DXA_Decode( DxShaderCodeBin_Base, NULL ) ;
		GRA2.BaseShaderBinDxaImage = DXALLOC( Size ) ;
		if( GRA2.BaseShaderBinDxaImage == NULL )
			goto ERR ;

		DXA_Decode( DxShaderCodeBin_Base, GRA2.BaseShaderBinDxaImage ) ;

		// ＤＸＡファイルをオープンする
		DXA_Initialize( &GRA2.BaseShaderBinDxa ) ;
		if( DXA_OpenArchiveFromMem( &GRA2.BaseShaderBinDxa, GRA2.BaseShaderBinDxaImage, Size, FALSE, FALSE ) != 0 )
			goto ERR ;
	}

#ifndef DX_NON_FILTER

	// RGBAMixシェーダーパック圧縮ファイルを展開する
	{
		Size = DXA_Decode( DxShaderCodeBin_Filter, NULL ) ;
		GRA2.RGBAMixS_ShaderPackImage = DXALLOC( Size ) ;
		if( GRA2.RGBAMixS_ShaderPackImage == NULL )
			goto ERR ;

		DXA_Decode( DxShaderCodeBin_Filter, GRA2.RGBAMixS_ShaderPackImage ) ;

		// アドレスリストのセット
		Addr = 0 ;
		SizeBuf = ( WORD * )GRA2.RGBAMixS_ShaderPackImage ;
		ShaderAddr = ( BYTE * )GRA2.RGBAMixS_ShaderPackImage + sizeof( WORD ) * 256 ;
		AddrBuf = ( void ** )GRA2.RGBAMixS_ShaderAddress ;
		SizeDest = ( short * )GRA2.RGBAMixS_ShaderSize ;
		for( i = 0 ; i < 256 ; i ++, SizeBuf ++, AddrBuf ++, SizeDest ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
			*SizeDest = *SizeBuf ;
		}
	}

	// フィルターシェーダーオブジェクトファイルＤＸＡを圧縮したデータを解凍する
	{
		Size = DXA_Decode( DxShaderCodeBin_Filter, NULL ) ;
		GRA2.FilterShaderBinDxaImage = DXALLOC( Size ) ;
		if( GRA2.FilterShaderBinDxaImage == NULL )
			goto ERR ;

		DXA_Decode( DxShaderCodeBin_Filter, GRA2.FilterShaderBinDxaImage ) ;

		// ＤＸＡファイルをオープンする
		DXA_Initialize( &GRA2.FilterShaderBinDxa ) ;
		if( DXA_OpenArchiveFromMem( &GRA2.FilterShaderBinDxa, GRA2.FilterShaderBinDxaImage, Size, FALSE, FALSE ) != 0 )
			goto ERR ;
	}

#endif // DX_NON_FILTER

#ifndef DX_NON_MODEL
	// ３Ｄモデル用シェーダーパック圧縮ファイルを展開する
	{
		// ライトインデックスリストの構築
		{
			int l0, l1, l2, l3, l4, l5, ind ;

			ind = 0 ;
			for( l0 = 0 ; l0 < 4 ; l0 ++ )
			{
				for( l1 = 0 ; l1 <= l0 ; l1 ++ )
				{
					for( l2 = 0 ; l2 <= l1 ; l2 ++ )
					{
						for( l3 = 0 ; l3 <= l2 ; l3 ++ )
						{
							for( l4 = 0 ; l4 <= l3 ; l4 ++ )
							{
								for( l5 = 0 ; l5 <= l4 ; l5 ++ )
								{
									GRA2.LightIndexList84[ l0 ][ l1 ][ l2 ][ l3 ][ l4 ][ l5 ] = ind ;
									ind ++ ;
								}
							}
						}
					}
				}
			}

			ind = 0 ;
			for( l0 = 0 ; l0 < 4 ; l0 ++ )
			{
				for( l1 = 0 ; l1 <= l0 ; l1 ++ )
				{
					for( l2 = 0 ; l2 <= l1 ; l2 ++ )
					{
						GRA2.LightIndexList20[ l0 ][ l1 ][ l2 ] = ind ;
						ind ++ ;
					}
				}
			}

			ind = 0 ;
			for( l0 = 0 ; l0 < 3 ; l0 ++ )
			{
				for( l1 = 0 ; l1 <= l0 ; l1 ++ )
				{
					for( l2 = 0 ; l2 <= l1 ; l2 ++ )
					{
						GRA2.LightIndexList10[ l0 ][ l1 ][ l2 ] = ind ;
						ind ++ ;
					}
				}
			}
		}

		Size = DXA_Decode( DxShaderCodeBin_Model, NULL ) ;
		GRA2.ModelShaderPackImage = DXCALLOC( Size ) ;
		if( GRA2.ModelShaderPackImage == NULL )
			goto ERR ;

		DXA_Decode( DxShaderCodeBin_Model, GRA2.ModelShaderPackImage ) ;

		// アドレスリストのセット
		Addr = 0 ;
		SizeBuf = ( WORD * )GRA2.ModelShaderPackImage ;
		ShaderAddr = ( BYTE * )GRA2.ModelShaderPackImage +
			sizeof( WORD ) * (
				sizeof( GRH.MV1_PixelLighting_VertexShader          ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) +
				sizeof( GRH.MV1_PixelLighting_ToonPixelShader       ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) +
				sizeof( GRH.MV1_PixelLighting_PixelShader           ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) +

				sizeof( GRH.MV1_ToonOutLineVertexShader   ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) +
				sizeof( GRH.MV1_ShadowMapVertexShader     ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) +
				sizeof( GRH.MV1_NoLightingVertexShader    ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) +
				sizeof( GRH.MV1_LightingVertexShader      ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) +
				sizeof( GRH.MV1_ToonOutLinePixelShader    ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) +
				sizeof( GRH.MV1_ShadowMapToonPixelShader  ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) +
				sizeof( GRH.MV1_ShadowMapPixelShader      ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) +
				sizeof( GRH.MV1_ToonNoLightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) +
				sizeof( GRH.MV1_NoLightingPixelShader     ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) +
				sizeof( GRH.MV1_ToonLightingPixelShader   ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) +
				sizeof( GRH.MV1_LightingPixelShader       ) / sizeof( DX_DIRECT3DPIXELSHADER9  * ) ) ;

		AddrBuf = ( void ** )GRA2.MV1_PixelLighting_VertexShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_PixelLighting_VertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_PixelLighting_ToonPixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_PixelLighting_ToonPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_PixelLighting_PixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_PixelLighting_PixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}








		AddrBuf = ( void ** )GRA2.MV1_ToonOutLineVertexShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_ToonOutLineVertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_ShadowMapVertexShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_ShadowMapVertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_NoLightingVertexShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_NoLightingVertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_LightingVertexShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_LightingVertexShader ) / sizeof( DX_DIRECT3DVERTEXSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}




		AddrBuf = ( void ** )&GRA2.MV1_ToonOutLinePixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_ToonOutLinePixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )&GRA2.MV1_ShadowMapToonPixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_ShadowMapToonPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )&GRA2.MV1_ShadowMapPixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_ShadowMapPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_ToonNoLightingPixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_ToonNoLightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_NoLightingPixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_NoLightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_ToonLightingPixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_ToonLightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}

		AddrBuf = ( void ** )GRA2.MV1_LightingPixelShaderAddress ;
		for( i = 0 ; i < sizeof( GRH.MV1_LightingPixelShader ) / sizeof( DX_DIRECT3DPIXELSHADER9 * ) ; i ++, SizeBuf ++, AddrBuf ++ )
		{
			if( *SizeBuf != 0 )
			{
				*AddrBuf = ( void * )ShaderAddr ;
				ShaderAddr += *SizeBuf ;
			}
		}





	}
#endif // DX_NON_MODEL

	GRA2.ShaderInitializeFlag = TRUE ;

	// 正常終了
	return TRUE ;

ERR :
	if( GRA2.BaseShaderBinDxaImage != NULL )
	{
		DXFREE( GRA2.BaseShaderBinDxaImage ) ;
		GRA2.BaseShaderBinDxaImage = NULL ;
	}

#ifndef DX_NON_FILTER
	if( GRA2.FilterShaderBinDxaImage != NULL )
	{
		DXFREE( GRA2.FilterShaderBinDxaImage ) ;
		GRA2.FilterShaderBinDxaImage = NULL ;
	}

	if( GRA2.RGBAMixS_ShaderPackImage != NULL )
	{
		DXFREE( GRA2.RGBAMixS_ShaderPackImage ) ;
		GRA2.RGBAMixS_ShaderPackImage = NULL ;
	}
#endif // DX_NON_FILTER

#ifndef DX_NON_MODEL
	if( GRA2.ModelShaderPackImage != NULL )
	{
		DXFREE( GRA2.ModelShaderPackImage ) ;
		GRA2.ModelShaderPackImage = NULL ;
	}
#endif // DX_NON_MODEL

	return FALSE ;
}

#ifndef DX_NON_FILTER

// 指定名の事前用意シェーダーを読み込む
static int MemLoadShaderCode( const char *ShaderName, bool IsVertexShader )
{
	int Addr, Size ;
	BYTE *FileImage ;
	int Ret ;

	if( GRA2.ShaderInitializeFlag == FALSE ) return -1 ;

	if( DXA_GetFileInfo( &GRA2.FilterShaderBinDxa, ShaderName, &Addr, &Size ) < 0 ) return -1 ;

	FileImage = ( BYTE * )DXA_GetFileImage( &GRA2.FilterShaderBinDxa ) + Addr ;

	Ret = CreateShader_UseGParam( IsVertexShader, FileImage, Size, FALSE, FALSE ) ;

	return Ret ;
}

#endif // DX_NON_FILTER


// ハードウエアアクセラレータ関係の初期化
static int InitializeHardware()
{
	int i ;

#ifndef DX_NON_FILTER
	// シェーダーハンドル値をリセットする
	_MEMSET( &GRH.ShaderCode, 0xff, sizeof( GRH.ShaderCode ) ) ;
#endif // DX_NON_FILTER

	// 頂点バッファ内の固定値をセットする
	{
		VERTEX_NOTEX_2D    *vertNoTex ;
		VERTEX_2D          *vertTex ;
		VERTEX_BLENDTEX_2D *vertBlend ;

		vertNoTex = (VERTEX_NOTEX_2D    *)GRH.NoTexVertexBuffer ;
		vertTex   = (VERTEX_2D          *)GRH.TexVertexBuffer ;
		vertBlend = (VERTEX_BLENDTEX_2D *)GRH.BlendTexVertexBuffer ;
		
		for( i = 0 ; i < D3DDEV_NOTEX_VERTMAXNUM ; i ++, vertNoTex ++ )
		{
			vertNoTex->pos.z = 0.0F ;
			vertNoTex->rhw   = 1.0F ;
		}

		for( i = 0 ; i < D3DDEV_TEX_VERTMAXNUM ; i ++, vertTex ++ )
		{
			vertTex->pos.z = 0.0F ;
			vertTex->rhw   = 1.0F ;
		}

		for( i = 0 ; i < D3DDEV_BLENDTEX_VERTMAXNUM ; i ++, vertBlend ++ )
		{
			vertBlend->pos.z    = 0.0F ;
			vertBlend->rhw      = 1.0F ;
			vertBlend->specular = 0xffffffff ;
		}
		
		GRH.VertexBufferPoint[ 0 ][ 0 ] = ( BYTE * )GRH.NoTexVertexBuffer ;
		GRH.VertexBufferPoint[ 0 ][ 1 ] = ( BYTE * )GRH.TexVertexBuffer ;
		GRH.VertexBufferPoint[ 0 ][ 2 ] = ( BYTE * )GRH.BlendTexVertexBuffer ;
		GRH.VertexBufferPoint[ 1 ][ 0 ] = ( BYTE * )GRH.Vertex3DBuffer ;
		GRH.VertexBufferPoint[ 1 ][ 1 ] = ( BYTE * )GRH.Vertex3DBuffer ;
	}

	// 描画ステータスのセット
	{
		float FloatParam ;

		// テクスチャ描画用設定
		for( i = 0 ; i < USE_TEXTURESTAGE_NUM ; i ++ )
		{
			if( GBASE.TexAddressModeU[ i ] == 0 )
				GBASE.TexAddressModeU[ i ] = D_D3DTADDRESS_CLAMP ;
			if( GBASE.TexAddressModeV[ i ] == 0 )
				GBASE.TexAddressModeV[ i ] = D_D3DTADDRESS_CLAMP ;
			if( GBASE.TexAddressModeW[ i ] == 0 )
				GBASE.TexAddressModeW[ i ] = D_D3DTADDRESS_CLAMP ;
		}
		for( i = 0 ; i < USE_TEXTURESTAGE_NUM ; i ++ )
		{
			// テクスチャアドレスモード設定
			GraphicsDevice_SetSamplerState( i, D_D3DSAMP_ADDRESSU, GBASE.TexAddressModeU[ i ] ) ;
			GraphicsDevice_SetSamplerState( i, D_D3DSAMP_ADDRESSV, GBASE.TexAddressModeV[ i ] ) ;
			GraphicsDevice_SetSamplerState( i, D_D3DSAMP_ADDRESSW, GBASE.TexAddressModeW[ i ] ) ;

			// フィリタリングモードを設定
			switch( GRH.DrawMode )
			{
			case DX_DRAWMODE_NEAREST :
				GRH.MagFilter[ i ] = D_D3DTEXF_POINT ;
				GRH.MinFilter[ i ] = D_D3DTEXF_POINT ;
				GRH.MipFilter[ i ] = D_D3DTEXF_POINT ;
				break ;

			case DX_DRAWMODE_BILINEAR :
				GRH.MagFilter[ i ] = D_D3DTEXF_LINEAR ;
				GRH.MinFilter[ i ] = D_D3DTEXF_LINEAR ;
				GRH.MipFilter[ i ] = D_D3DTEXF_LINEAR ;
				break ;

			case DX_DRAWMODE_ANISOTROPIC :
				GRH.MagFilter[ i ] = D_D3DTEXF_ANISOTROPIC ;
				GRH.MinFilter[ i ] = D_D3DTEXF_ANISOTROPIC ;
				GRH.MipFilter[ i ] = D_D3DTEXF_LINEAR ;
				break ;
			}
			GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MAGFILTER, GRH.MagFilter[ i ] ) ;
			GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MINFILTER, GRH.MinFilter[ i ] ) ;
			GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MIPFILTER, GRH.MipFilter[ i ] ) ;

			// 初期最大異方性をセット
			GRH.MaxAnisotropyDim[ i ] = 1 ;
		}

		// 最後のドット描画しない
//		GraphicsDevice_SetRenderState( D_D3DRS_LASTPIXEL, TRUE ) ;

		// カリングオフ
		GraphicsDevice_SetRenderState( D_D3DRS_CULLMODE, D_D3DCULL_NONE ) ;

		// ライティングＯＮ
		GraphicsDevice_SetRenderState( D_D3DRS_LIGHTING, TRUE ) ;

		// フラットシェーディング
		GraphicsDevice_SetRenderState( D_D3DRS_SHADEMODE, D_D3DSHADE_FLAT ) ;

		// 描画ブレンドなし
//		GraphicsDevice_SetRenderState( D_D3DRS_ALPHABLENDENABLE, FALSE ) ;

		// ディザリングＯＦＦ
		GraphicsDevice_SetRenderState( D_D3DRS_DITHERENABLE, FALSE ) ;

		// スペキュラライトＯＦＦ
		GraphicsDevice_SetRenderState( D_D3DRS_SPECULARENABLE, TRUE ) ;

		// アンビエントライトソースはマテリアル
		GraphicsDevice_SetRenderState( D_D3DRS_AMBIENTMATERIALSOURCE, D_D3DMCS_MATERIAL  ) ;

		// 法線の正規化を行う
		GraphicsDevice_SetRenderState( D_D3DRS_NORMALIZENORMALS, TRUE ) ;

		// フォグは無効
		GraphicsDevice_SetRenderState( D_D3DRS_FOGENABLE, FALSE ) ;
		GraphicsDevice_SetRenderState( D_D3DRS_FOGVERTEXMODE, D_D3DFOG_NONE ) ;
		GraphicsDevice_SetRenderState( D_D3DRS_FOGCOLOR, 0 ) ;
		FloatParam = 0.0f ;
		GraphicsDevice_SetRenderState( D_D3DRS_FOGSTART, *( ( DWORD * )&FloatParam ) ) ;
		FloatParam = 1.0f ;
		GraphicsDevice_SetRenderState( D_D3DRS_FOGEND, *( ( DWORD * )&FloatParam ) ) ;

		// マテリアルのパラメータを取得
		{
			D_D3DMATERIAL9 Material ;

			GraphicsDevice_GetMaterial( &Material ) ;
			GRH.Material.Diffuse.r = Material.Diffuse.r ;
			GRH.Material.Diffuse.g = Material.Diffuse.g ;
			GRH.Material.Diffuse.b = Material.Diffuse.b ;
			GRH.Material.Diffuse.a = Material.Diffuse.a ;
			GRH.Material.Specular.r = Material.Specular.r ;
			GRH.Material.Specular.g = Material.Specular.g ;
			GRH.Material.Specular.b = Material.Specular.b ;
			GRH.Material.Specular.a = Material.Specular.a ;
			GRH.Material.Emissive.r = Material.Emissive.r ;
			GRH.Material.Emissive.g = Material.Emissive.g ;
			GRH.Material.Emissive.b = Material.Emissive.b ;
			GRH.Material.Emissive.a = Material.Emissive.a ;
			GRH.Material.Ambient.r = Material.Ambient.r ;
			GRH.Material.Ambient.g = Material.Ambient.g ;
			GRH.Material.Ambient.b = Material.Ambient.b ;
			GRH.Material.Ambient.a = Material.Ambient.a ;
			GRH.Material.Power = Material.Power ;
		}
	}

	// ブレンディングパラメータを初期化する
	_MEMSET( &GRH.BlendInfo, 0, sizeof( DIRECT3DBLENDINFO ) ) ;
	GRH.BlendInfo.UseTextureStageNum = 0 ;
	for( i = 0 ; i < USE_TEXTURESTAGE_NUM ; i ++ )
	{
		GRH.BlendInfo.TextureStageInfo[i].Texture       = NULL ;
		GRH.BlendInfo.TextureStageInfo[i].ResultTempARG = FALSE ;
		GRH.BlendInfo.TextureStageInfo[i].AlphaARG1     = D_D3DTA_TEXTURE ;
		GRH.BlendInfo.TextureStageInfo[i].AlphaARG2     = D_D3DTA_DIFFUSE ;
		GRH.BlendInfo.TextureStageInfo[i].AlphaOP       = D_D3DTOP_DISABLE ;
		GRH.BlendInfo.TextureStageInfo[i].ColorARG1     = D_D3DTA_TEXTURE ;
		GRH.BlendInfo.TextureStageInfo[i].ColorARG2     = D_D3DTA_DIFFUSE ;
		GRH.BlendInfo.TextureStageInfo[i].ColorOP       = D_D3DTOP_DISABLE ;
	}

	GRH.DiffuseColor            = 0xffffffff ;

	GRH.DrawPrepAlwaysFlag      = TRUE ;
	GRH.EnableZBufferFlag		= TRUE ;
	GRH.WriteZBufferFlag		= FALSE ; 
	GRH.ZBufferCmpType			= DX_CMP_LESSEQUAL ;
	GRH.ZBias					= 0 ;
	GRH.FillMode				= D_D3DFILL_SOLID ;
	GRH.UseDiffuseRGBColor		= FALSE ;
	GRH.UseDiffuseAlphaColor	= FALSE ;
	GRH.BlendMode				= DX_BLENDMODE_NOBLEND ;
	GRH.BlendGraphBorderParam	= -1 ;
	GRH.AlphaTestMode           = -1 ;
	GRH.AlphaTestParam          = 0 ;
	GRH.AlphaChannelValidFlag	= FALSE ;
	GRH.AlphaTestValidFlag		= FALSE ;
	GRH.ChangeBlendParamFlag	= TRUE ;
	GRH.ChangeTextureFlag		= FALSE ;
	GRH.BlendMaxNotDrawFlag		= FALSE ;
	GRH.CullMode				= FALSE ;
	GRH.UseSpecular             = TRUE ;

	GRH.Viewport.X				= 0 ;
	GRH.Viewport.Y				= 0 ;
	GRH.Viewport.Width			= GRA2.MainScreenSizeX ;
	GRH.Viewport.Height			= GRA2.MainScreenSizeY ;
	GRH.Viewport.MinZ			= 0.0f ;
	GRH.Viewport.MaxZ			= 1.0f ;

	for( i = 0 ; i < USE_TEXTURESTAGE_NUM ; i ++ )
	{
		GRH.TexAddressModeU[ i ] = GBASE.TexAddressModeU[ i ] ;
		GRH.TexAddressModeV[ i ] = GBASE.TexAddressModeV[ i ] ;
		GRH.TexAddressModeW[ i ] = GBASE.TexAddressModeW[ i ] ;
	}
	GRH.PerspectiveFlag			= FALSE ;
	GRH.LightFlag				= TRUE ;
//	GRH.AlphaValidFlag			= FALSE ;
//	GRH.AlphaBlendEnable		= FALSE ;
	GRH.DrawMode				= DX_DRAWMODE_OTHER ;
	GRH.MaxAnisotropy			= 1 ;
	GRH.TargetSurface[ 0 ]		= GRH.BackBufferSurface ;
	GRH.BeginSceneFlag			= FALSE ;
//	GRH.BlendParam				= 0 ;
	GRH.BlendTexture			= NULL ;
	GRH.BlendGraphType			= 0 ;
	GRH.RenderTexture			= NULL ;
	GRH.ShadeMode				= DX_SHADEMODE_FLAT ;
	GRH.VertexNum				= 0 ;
	GRH.VertexBufferNextAddress = GRH.TexVertexBuffer ;
	GRH.VertexType				= VERTEXTYPE_TEX ;
//	GRH.VertexBufferUseFlag		= FALSE ;
//	GRH.ColorKeyFlag			= FALSE ;
	GRH.FogEnable				= FALSE ;
	GRH.FogColor				= 0 ;
	GRH.FogMode					= DX_FOGMODE_NONE ;
	GRH.FogStart				= 0.0f ;
	GRH.FogEnd					= 1.0f ;

	// 設定をリフレッシュ
	RefreshRenderStateHardware() ;

	// おまじない
	{
		VERTEX_NOTEX_2D *vec ;

		BeginScene() ;
		DrawPreparation( NULL, 0 ) ;

		GETVERTEX_POINT( vec ) ;

		vec->pos.x = 0.0f ;
		vec->pos.y = 0.0f ;
		vec->pos.z = 0.0f ;

		ADD4VERTEX_POINT
	}

	// 終了
	return 0 ;
}

// 一時的にハードウエアを破棄した際に、破棄前の状態を作り出すための関数
static int ReInitializeHardware()
{
	int i ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画ステータスのセット
	{
		// テクスチャ描画用設定
//		GraphicsDevice_SetTextureStageState( 0, D_D3DTSS_ADDRESS, D_D3DTADDRESS_CLAMP );

		// ディザリングＯＦＦ
		GraphicsDevice_SetRenderState( D_D3DRS_DITHERENABLE, FALSE ) ;
	}

	// 初期化フラグを立てる
	GRH.InitializeFlag = TRUE ;

	// 必ず DrawPreparation を実行するフラグを立てる
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 削除前と同じ環境を作り出す
	{
		// 描画先の設定
//		if( GRH.TargetSurface != NULL )
//			SetRenderTargetHardware( GRH.TargetSurface ) ;

		// テクスチャのリセット
		GRH.RenderTexture = NULL ;

		// 描画頂点もリセット
		GRH.VertexNum = 0 ;

		// 描画ブレンドモードの設定
		SetDrawBlendModeHardware( GRH.BlendMode, GRH.AlphaTestValidFlag, GRH.AlphaChannelValidFlag ) ;
//		RefreshBlendStateHardware( DevHandle ) ;

		// 描画画像の色を無視するかどうかをセットする
		SetIgnoreDrawGraphColorHardware( GRH.IgnoreGraphColorFlag ) ;

		// カリングモードのセット
		SetUseCullingHardware( GRH.CullMode ) ;

		// 描画モードの設定
		SetDrawModeHardware( GRH.DrawMode ) ;

		// シェーディングモードのセット
		SetShadeModeHardware( GRH.ShadeMode ) ;

		// 異方性フィルタリングの設定をセット
		SetMaxAnisotropyHardware( GRH.MaxAnisotropy ) ;

		// カリングモードの設定をセット
		SetUseCullingHardware( GRH.CullMode ) ;

		// UVアドレッシングモードの設定をセット
		for( i = 0 ; i < 8 ; i ++ )
		{
			SetTextureAddressUHardware( GRH.TexAddressModeU[ i ], i ) ;
			SetTextureAddressVHardware( GRH.TexAddressModeV[ i ], i ) ;
			SetTextureAddressWHardware( GRH.TexAddressModeW[ i ], i ) ;
		}

		// テクスチャ座標変換行列を使用するかどうかの設定をセット
		for( i = 0 ; i < 8 ; i ++ )
		{
			SetTextureAddressTransformMatrixHardware( GRH.TextureTransformUse[ i ], &GRH.TextureTransformMatrix[ i ], i ) ;
		}

		// フォグの設定をセット
		SetFogEnableHardware( GRH.FogEnable ) ;
		SetFogModeHardware( GRH.FogMode ) ;
		SetFogColorHardware( GRH.FogColor ) ;
		SetFogStartEndHardware( GRH.FogStart, GRH.FogEnd ) ;
		SetFogDensityHardware( GRH.FogDensity ) ;

		// Ｚバッファの設定をセット
		SetUseZBufferHardware( GRH.EnableZBufferFlag ) ;
		SetWriteZBufferHardware( GRH.WriteZBufferFlag ) ;
		SetZBufferCmpTypeHardware( GRH.ZBufferCmpType ) ;
		SetZBiasHardware( GRH.ZBias ) ;
		SetFillModeHardware( GRH.FillMode ) ;

		// 行列の再設定
		NS_SetTransformToWorld( &GBASE.WorldMatrix ) ;
		NS_SetTransformToView( &GBASE.ViewMatrix ) ;
		_SetTransformToProjection( &GBASE.ProjectionMatrix ) ;
		NS_SetTransformToViewport( &GBASE.ViewportMatrix ) ;

		// マテリアルの再設定
		SetMaterialHardware( &GRH.Material ) ;
		SetUseSpecularHardware( GRH.UseSpecular ) ;
		SetMaterialUseVertexDiffuseColorHardware( GRH.MaterialUseVertexDiffuseColor ) ;
		SetMaterialUseVertexSpecularColorHardware( GRH.MaterialUseVertexSpecularColor ) ;

		// ライトの再設定
		SetAmbientColorHardware(
			( ( ( DWORD )( _FTOL( GRH.GlobalAmbientLightColor.a ) * 255 ) ) << 24 ) | 
			( ( ( DWORD )( _FTOL( GRH.GlobalAmbientLightColor.r ) * 255 ) ) << 16 ) | 
			( ( ( DWORD )( _FTOL( GRH.GlobalAmbientLightColor.g ) * 255 ) ) << 8  ) | 
			( ( ( DWORD )( _FTOL( GRH.GlobalAmbientLightColor.b ) * 255 ) ) << 0  ) ) ;
		SetUseLightFlagHardware( GRH.LightFlag ) ;
		for( i = 0 ; i < 256 ; i ++ )
		{
			if( GRH.LightParam[ i ].Type == 0 ) continue ;
			SetLightHardware( i, &GRH.LightParam[ i ] ) ;
			SetLightEnableHardware( i, GRH.LightEnableFlag[ i ] ) ;
		}

		// 描画領域の設定
		{
			D_D3DVIEWPORT9 Viewport ;

			// ビューポートのセッティング
			_MEMSET( &Viewport, 0, sizeof( Viewport ) ) ;
			Viewport.X		= GBASE.DrawArea.left ;
			Viewport.Y		= GBASE.DrawArea.top ;
			Viewport.Width	= GBASE.DrawArea.right  - GBASE.DrawArea.left ;
			Viewport.Height	= GBASE.DrawArea.bottom - GBASE.DrawArea.top ;
			Viewport.MinZ	= 0.0f ;
			Viewport.MaxZ	= 1.0f ;

			// セット
			SetViewportHardware( &Viewport ) ;
			SetScissorRectHardware( &GBASE.DrawArea ) ;
		}

		// 各ステージで使用するテクスチャ座標のリセット
		D_ResetTextureCoord() ;
	
		// 設定を反映
		RefreshBlendStateHardware() ;
		RefreshRenderStateHardware() ;
	}

	// 初期化フラグを倒す
	GRH.InitializeFlag = FALSE ;

	// 終了
	return 0 ;
}

// Ｄｉｒｅｃｔ３ＤＤｅｖｉｃｅ基本設定
static int SetBaseHardwareState()
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 書き出し
		RenderVertexHardware() ;
	}

	// アルファブレンディングカラーキー無効
//	GraphicsDevice_SetRenderState( D_D3DRS_COLORKEYBLENDENABLE, FALSE ) ;

	// 最後のドット描画しない
//	GraphicsDevice_SetRenderState( D_D3DRS_LASTPIXEL, TRUE ) ;

	// テクスチャ描画用設定
	GraphicsDevice_SetSamplerState( 0, D_D3DSAMP_ADDRESSU, GRH.TexAddressModeU[ 0 ] ) ;
	GraphicsDevice_SetSamplerState( 0, D_D3DSAMP_ADDRESSV, GRH.TexAddressModeV[ 0 ] ) ;
	GraphicsDevice_SetSamplerState( 1, D_D3DSAMP_ADDRESSU, GRH.TexAddressModeU[ 1 ] ) ;
	GraphicsDevice_SetSamplerState( 1, D_D3DSAMP_ADDRESSV, GRH.TexAddressModeV[ 1 ] ) ;
	GraphicsDevice_SetSamplerState( 2, D_D3DSAMP_ADDRESSU, GRH.TexAddressModeU[ 2 ] ) ;
	GraphicsDevice_SetSamplerState( 2, D_D3DSAMP_ADDRESSV, GRH.TexAddressModeV[ 2 ] ) ;
	GraphicsDevice_SetSamplerState( 3, D_D3DSAMP_ADDRESSU, GRH.TexAddressModeU[ 3 ] ) ;
	GraphicsDevice_SetSamplerState( 3, D_D3DSAMP_ADDRESSV, GRH.TexAddressModeV[ 3 ] ) ;
	GraphicsDevice_SetTextureStageState( 0, D_D3DTSS_TEXCOORDINDEX, 0 ) ;
	GraphicsDevice_SetTextureStageState( 1, D_D3DTSS_TEXCOORDINDEX, 1 ) ;
	GraphicsDevice_SetTextureStageState( 2, D_D3DTSS_TEXCOORDINDEX, 1 ) ;
	GraphicsDevice_SetTextureStageState( 3, D_D3DTSS_TEXCOORDINDEX, 0 ) ;
	GRH.BlendInfo.TextureStageInfo[ 0 ].TextureCoordIndex = 0 ;
	GRH.BlendInfo.TextureStageInfo[ 1 ].TextureCoordIndex = 1 ;
	GRH.BlendInfo.TextureStageInfo[ 2 ].TextureCoordIndex = 1 ;
	GRH.BlendInfo.TextureStageInfo[ 3 ].TextureCoordIndex = 0 ;
	if( GRH.ValidTexTempRegFlag )
	{
		GraphicsDevice_SetTextureStageState( 0, D_D3DTSS_RESULTARG, D_D3DTA_CURRENT ) ;
		GraphicsDevice_SetTextureStageState( 1, D_D3DTSS_RESULTARG, D_D3DTA_CURRENT ) ;
		GraphicsDevice_SetTextureStageState( 2, D_D3DTSS_RESULTARG, D_D3DTA_CURRENT ) ;
		GraphicsDevice_SetTextureStageState( 3, D_D3DTSS_RESULTARG, D_D3DTA_CURRENT ) ;
		GRH.BlendInfo.TextureStageInfo[ 0 ].ResultTempARG = FALSE ;
		GRH.BlendInfo.TextureStageInfo[ 1 ].ResultTempARG = FALSE ;
		GRH.BlendInfo.TextureStageInfo[ 2 ].ResultTempARG = FALSE ;
		GRH.BlendInfo.TextureStageInfo[ 3 ].ResultTempARG = FALSE ;
	}

	// パースペクティブコレクト設定
//	GraphicsDevice_SetRenderState( D_D3DRS_TEXTUREPERSPECTIVE, GRH.PerspectiveFlag ) ;

	// シェーディングモード設定
	GraphicsDevice_SetRenderState( D_D3DRS_SHADEMODE, GRH.ShadeMode ) ;

	// ライティング設定
	GraphicsDevice_SetRenderState( D_D3DRS_LIGHTING, GRH.LightFlag ) ;

	// カリング設定
	GraphicsDevice_SetRenderState( D_D3DRS_CULLMODE, D_D3DCULL_NONE ) ;

	// ディザリングＯＦＦ
	GraphicsDevice_SetRenderState( D_D3DRS_DITHERENABLE, FALSE ) ;
	
	// シェーダーの定数をセット
	static float ZeroOne[ 4 ]        = { 0.0f, 1.0f, 0.0f, 0.0f } ;
	static float ZeroHalfOneTwo[ 4 ] = { 0.0f, 0.5f, 1.0f, 2.0f } ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_LIB, DX_VS_CONSTF_ZERO_ONE,         ZeroOne,        1, TRUE ) ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB, DX_PS_CONSTF_ZERO_HALF_ONE_TWO, ZeroHalfOneTwo, 1, TRUE ) ;

	// 固定機能パイプラインに戻す
	if( GRH.SetVS )
	{
		GraphicsDevice_SetVertexShader( NULL ) ;
		GRH.SetVS = NULL ;
		GRH.SetVD = NULL ;
	}

	if( GRH.SetPS )
	{
		GraphicsDevice_SetPixelShader( NULL ) ;
		GRH.SetPS = NULL ;
		GRH.NormalPS = FALSE ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}
	GRH.SetFVF = 0 ;
	GRH.SetIB = NULL ;
	GRH.SetVB = NULL ;

	// 終了
	return 0 ;
}




// ブレンドテーブル(デバッグ用)
static const char *__BufferBlendName[] =
{
	NULL,
	"D3DBLEND_ZERO",
	"D3DBLEND_ONE",
	"D3DBLEND_SRCCOLOR",
	"D3DBLEND_INVSRCCOLOR",
	"D3DBLEND_SRCALPHA",
	"D3DBLEND_INVSRCALPHA",
	"D3DBLEND_DESTALPHA",
	"D3DBLEND_INVDESTALPHA",
	"D3DBLEND_DESTCOLOR",
	"D3DBLEND_INVDESTCOLOR",
	"D3DBLEND_SRCALPHASAT",
	"D3DBLEND_BOTHSRCALPHA",
	"D3DBLEND_BOTHINVSRCALPHA",
} ;

// 要素テーブル(デバッグ用)
static const char *__TextureStage_ARGName[] =
{
	"D3DTA_DIFFUSE",
	"D3DTA_CURRENT",
	"D3DTA_TEXTURE",
	"D3DTA_TFACTOR",
} ;

// ブレンドテーブル(デバッグ用)
static const char *__TextureStage_OPName[] =
{
	NULL, 
	"D3DTOP_DISABLE",
	"D3DTOP_SELECTARG1",
	"D3DTOP_SELECTARG2",

	"D3DTOP_MODULATE",
	"D3DTOP_MODULATE2X",
	"D3DTOP_MODULATE4X",

	"D3DTOP_ADD",
	"D3DTOP_ADDSIGNED",
	"D3DTOP_ADDSIGNED2X",
	"D3DTOP_SUBTRACT",
	"D3DTOP_ADDSMOOTH",

	"D3DTOP_BLENDDIFFUSEALPHA",
	"D3DTOP_BLENDTEXTUREALPHA",
	"D3DTOP_BLENDFACTORALPHA",

	"D3DTOP_BLENDTEXTUREALPHAPM",
	"D3DTOP_BLENDCURRENTALPHA",

	"D3DTOP_PREMODULATE",
	"D3DTOP_MODULATEALPHA_ADDCOLOR",
	"D3DTOP_MODULATECOLOR_ADDALPHA",
	"D3DTOP_MODULATEINVALPHA_ADDCOLOR",
	"D3DTOP_MODULATEINVCOLOR_ADDALPHA",

	"D3DTOP_BUMPENVMAP",
	"D3DTOP_BUMPENVMAPLUMINANCE",
	"D3DTOP_DOTPRODUCT3",
} ;


// ＲＧＢ値ブレンドステートテーブル
// [ブレンドモード値]
// [
//   0:DESTBLEND
//   1:SRCBLEND
//   2:使用テクスチャブレンドテーブル( TEXTURE_BLEND_TABLE_INDEX_NORMAL 等 )
//   3:使用BLENDOP
//   4:αブレンド機能を使用するかどうか( 1:使用する 0:使用しない )
//   5:αチャンネルの存在する描画先の場合にピクセルシェーダーを使用したαブレンドを行うかどうか( 1:行う  0:行わない )
// ]
#define RGB_BLENDSTATE_TABLE_DESTBLEND				(0)
#define RGB_BLENDSTATE_TABLE_SRCBLEND				(1)
#define RGB_BLENDSTATE_TABLE_TEXBLENDTABLEINDEX		(2)
#define RGB_BLENDSTATE_TABLE_BLENDOP				(3)
#define RGB_BLENDSTATE_TABLE_ALPHABLENDENABLE		(4)
#define RGB_BLENDSTATE_TABLE_SHADERALPHABLEND		(5)

#define TEXTURE_BLEND_TABLE_INDEX_NORMAL			(0)			// 0:通常描画
#define TEXTURE_BLEND_TABLE_INDEX_MUL				(1)			// 1:乗算描画
#define TEXTURE_BLEND_TABLE_INDEX_INVERSE			(2)			// 2:RGB反転
#define TEXTURE_BLEND_TABLE_INDEX_X4				(3)			// 3:描画輝度4倍
#define TEXTURE_BLEND_TABLE_INDEX_PMA_NORMAL		(4)			// 4:乗算済みαブレンドモードの通常描画
#define TEXTURE_BLEND_TABLE_INDEX_PMA_INVERSE		(5)			// 5:乗算済みαブレンドモードのRGB反転
#define TEXTURE_BLEND_TABLE_INDEX_PMA_X4			(6)			// 6:乗算済みαブレンドモードの描画輝度4倍
#define TEXTURE_BLEND_TABLE_INDEX_NUM				(7)
static const int __RGBBlendStateTable[ DX_BLENDMODE_NUM ][ 6 ] =
{
	{ -1,						-1,							0, D_D3DBLENDOP_ADD,			0, 0 },	// DX_BLENDMODE_NOBLEND			ノーブレンド
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_SRCALPHA,		0, D_D3DBLENDOP_ADD,			1, 1 },	// DX_BLENDMODE_ALPHA			αブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_SRCALPHA,		0, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_ADD				加算ブレンド
	{ D_D3DBLEND_ZERO,			D_D3DBLEND_INVDESTCOLOR,	0, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_SUB				減算ブレンド
	{ D_D3DBLEND_SRCCOLOR,		D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_MUL				乗算ブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_SRCALPHA,		0, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_SUB2			内部処理用減算ブレンド１
	{ -1,						-1,							0, D_D3DBLENDOP_ADD,			0, 0 },	// DX_BLENDMODE_XOR				XORブレンド(非対応)
	{ -1,						-1,							0, D_D3DBLENDOP_ADD,			0, 0 },	// 欠番
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_DESTCOLOR		カラーは更新されない
	{ D_D3DBLEND_ZERO,			D_D3DBLEND_INVDESTCOLOR,	0, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_INVDESTCOLOR	描画先の色の反転値を掛ける
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_SRCALPHA,		2, D_D3DBLENDOP_ADD,			1, 1 },	// DX_BLENDMODE_INVSRC			描画元の色を反転する
	{ D_D3DBLEND_SRCCOLOR,		D_D3DBLEND_ZERO,			1, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_MULA			アルファチャンネル考慮付き乗算ブレンド
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_SRCALPHA,		3, D_D3DBLENDOP_ADD,			1, 1 },	// DX_BLENDMODE_ALPHA_X4		αブレンドの描画側の輝度を最大４倍にできるモード
	{ D_D3DBLEND_ONE,			D_D3DBLEND_SRCALPHA,		3, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_ADD_X4			加算ブレンドの描画側の輝度を最大４倍にできるモード
	{ D_D3DBLEND_ZERO,			D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_SRCCOLOR		描画元のカラーでそのまま描画される
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD,			1, 0 },	// DX_BLENDMODE_HALF_ADD		半加算ブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_SRCALPHA,		0, D_D3DBLENDOP_REVSUBTRACT,	1, 0 },	// DX_BLENDMODE_SUB1			出力ブレンドが使用可能な場合の減算ブレンド

	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_ONE,				4, D_D3DBLENDOP_ADD,			1 },	// DX_BLENDMODE_PMA_ALPHA		乗算済みαブレンドモードのαブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ONE,				4, D_D3DBLENDOP_ADD,			1 },	// DX_BLENDMODE_PMA_ADD			乗算済みαブレンドモードの加算ブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ONE,				4, D_D3DBLENDOP_REVSUBTRACT,	1 },	// DX_BLENDMODE_PMA_SUB			乗算済みαブレンドモードの減算ブレンド
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_ONE,				5, D_D3DBLENDOP_ADD,			1 },	// DX_BLENDMODE_PMA_INVSRC		乗算済みαブレンドモードの描画元の色を反転する
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_ONE,				6, D_D3DBLENDOP_ADD,			1 },	// DX_BLENDMODE_PMA_ALPHA_X4	乗算済みαブレンドモードのαブレンドの描画側の輝度を最大４倍にできるモード
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ONE,				6, D_D3DBLENDOP_ADD,			1 },	// DX_BLENDMODE_PMA_ADD_X4		乗算済みαブレンドモードの加算ブレンドの描画側の輝度を最大４倍にできるモード
} ;

// Ａ値ブレンドステートテーブル[ブレンドモード値][ 0:DESTBLEND  1:SRCBLEND  2:シェーダーαブレンドを使用するか( 0:使用しない  1:使用する )  3:使用BLENDOP ]
#define ALPHA_BLENDSTATE_TABLE_DESTBLEND			(0)
#define ALPHA_BLENDSTATE_TABLE_SRCBLEND				(1)
#define ALPHA_BLENDSTATE_TABLE_USESHADERBLEND		(2)
#define ALPHA_BLENDSTATE_TABLE_BLENDOP				(3)
static const int __ABlendStateTable[ DX_BLENDMODE_NUM ][ 4 ] =
{
	{ -1,						-1,							0, D_D3DBLENDOP_ADD			},  // DX_BLENDMODE_NOBLEND			ノーブレンド
	{ -1,						-1,							1, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_ALPHA			αブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_ADD				加算ブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_SUB				減算ブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_MUL				乗算ブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_SUB2			内部処理用減算ブレンド１
	{ -1,						-1,							0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_XOR				XORブレンド(非対応)
	{ -1,						-1,							0, D_D3DBLENDOP_ADD			},	// 欠番
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_DESTCOLOR		カラーは更新されない
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_INVDESTCOLOR	描画先の色の反転値を掛ける
	{ -1,						-1,							1, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_INVSRC			描画元の色を反転する
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_MULA			アルファチャンネル考慮付き乗算ブレンド
	{ -1,						-1,							1, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_ALPHA_X4		αブレンドの描画側の輝度を最大４倍にできるモード
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_ADD_X4			加算ブレンドの描画側の輝度を最大４倍にできるモード
	{ D_D3DBLEND_ZERO,			D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_SRCCOLOR		描画元のカラーでそのまま描画される
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_HALF_ADD		半加算ブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ZERO,			0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_SUB1			出力ブレンドが使用可能な場合の減算ブレンド

	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_PMA_ALPHA		乗算済みαブレンドモードのαブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_PMA_ADD			乗算済みαブレンドモードの加算ブレンド
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ONE,				0, D_D3DBLENDOP_REVSUBTRACT },	// DX_BLENDMODE_PMA_SUB			乗算済みαブレンドモードの減算ブレンド
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_PMA_INVSRC		乗算済みαブレンドモードの描画元の色を反転する
	{ D_D3DBLEND_INVSRCALPHA,	D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_PMA_ALPHA_X4	乗算済みαブレンドモードのαブレンドの描画側の輝度を最大４倍にできるモード
	{ D_D3DBLEND_ONE,			D_D3DBLEND_ONE,				0, D_D3DBLENDOP_ADD			},	// DX_BLENDMODE_PMA_ADD_X4		乗算済みαブレンドモードの加算ブレンドの描画側の輝度を最大４倍にできるモード
} ;

#define __NONE		(-1)

#define __DIFF		D_D3DTA_DIFFUSE
#define __CURR		D_D3DTA_CURRENT
#define __TEX_		D_D3DTA_TEXTURE
#define __FACT		D_D3DTA_TFACTOR
#define __SPEC		D_D3DTA_SPECULAR
#define __COMP		D_D3DTA_COMPLEMENT
#define __ALRP		D_D3DTA_ALPHAREPLICATE
#define __TEMP		D_D3DTA_TEMP

#define __DISB		D_D3DTOP_DISABLE
#define __SEL1		D_D3DTOP_SELECTARG1
#define __SEL2		D_D3DTOP_SELECTARG2
#define __MUL1		D_D3DTOP_MODULATE
#define __MUL2		D_D3DTOP_MODULATE2X
#define __MUL4		D_D3DTOP_MODULATE4X
#define __ADD1		D_D3DTOP_ADD
#define __SUB1		D_D3DTOP_SUBTRACT
#define __BLDC		D_D3DTOP_BLENDCURRENTALPHA 
#define __BLDF		D_D3DTOP_BLENDFACTORALPHA 

#define __NUM(x)	((void *)(x))
#define DISB_ST		{NULL, -1, -1, __NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},

// 減算ブレンド用ステート
static const DIRECT3DTEXTURESTAGEINFO __TexSubBlendStageStateTable[USE_TEXTURESTAGE_NUM] =
{
	/*Stage 0*/{__NUM(1),0,0,__NONE,__DIFF,__SEL2,	__DIFF,__NONE,__SEL1},
	/*Stage 1*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage 2*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage 3*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage 4*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage 5*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage 6*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage 7*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage 8*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage 9*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage10*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
	/*Stage11*/{    NULL,0,0,__NONE,__NONE,__DISB,	__NONE,__NONE,__DISB},
} ;

// テクスチャーステージステート
//0:[0:通常描画 1:MUL 2:RGB反転 3:描画輝度4倍 4:乗算済みαブレンドモードの通常描画 5:乗算済みαブレンドモードのRGB反転 6:乗算済みαブレンドモードの描画輝度4倍]
//1:[0:ブレンドテクスチャ無し  1:DX_BLENDGRAPHTYPE_NORMAL  2:DX_BLENDGRAPHTYPE_WIPE  3:DX_BLENDGRAPHTYPE_ALPHA ]
//2:[0:ディフューズRGBカラー無し  1:ディフューズRGBカラーあり]
//3:[0:ディフューズAlphaカラー無し  1:ディフューズAlphaカラーあり]
//4:[0:αチャンネル無し　1:αチャンネルあり  2:αテストあり]
//5:[ テクスチャーステージナンバー ]
static const DIRECT3DTEXTURESTAGEINFO __TexStageStateTable[ TEXTURE_BLEND_TABLE_INDEX_NUM ][4][2][2][3][USE_TEXTURESTAGE_NUM] =
{
	// 通常描画
	{
		// ブレンドテクスチャ無し
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラーなし
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_NORMAL
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_WIPE
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__MUL1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__NONE,__SEL1},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL1},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_ALPHA
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
	},

	// MUL描画
	{
		// ブレンドテクスチャ無し
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __NONE,__DIFF,__SEL2,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __NONE,__DIFF,__SEL2,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__DIFF,__MUL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__DIFF,__MUL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラーなし
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__NONE,__SEL1,	__CURR,__FACT,__BLDC}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_NORMAL
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_WIPE
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_ALPHA
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						 DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
	},

	// RGB反転
	{
		// ブレンドテクスチャ無し
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラーなし
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0, __NONE,__DIFF,__SEL2,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0, __NONE,__DIFF,__SEL2,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0, __TEX_,__DIFF,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0, __TEX_,__DIFF,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_NORMAL
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_WIPE
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_ALPHA
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
	},

	// 描画輝度４倍
	{
		// ブレンドテクスチャ無し
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラーなし
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_NORMAL
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_WIPE
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_ALPHA
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
	},

	// 乗算済みαブレンドモードの通常描画
	{
		// ブレンドテクスチャ無し
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラーなし
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF         ,__MUL1},
						/*Stage1*/{       0, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF         ,__MUL1},
						/*Stage1*/{       0, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF         ,__MUL1},
						/*Stage1*/{       0, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_NORMAL
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1}, 
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_WIPE
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__MUL1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF | __ALRP,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE         ,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF | __ALRP,__MUL1},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__NONE         ,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL1},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_ALPHA
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__DIFF | __ALRP,__MUL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__DIFF | __ALRP,__MUL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__DIFF | __ALRP,__MUL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__DIFF | __ALRP,__MUL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__DIFF | __ALRP,__MUL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__DIFF | __ALRP,__MUL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
	},

	// 乗算済みαブレンドモードのRGB反転
	{
		// ブレンドテクスチャ無し
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_ | __COMP,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_ | __COMP,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_ | __COMP,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラーなし
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0, __NONE,__DIFF,__SEL2,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __NONE,__DIFF,__SEL2,	__TEX_ | __COMP,__DIFF         ,__MUL1}, 
						/*Stage1*/{       0, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__DIFF,__MUL1,	__TEX_ | __COMP,__DIFF         ,__MUL1},
						/*Stage1*/{       0, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__DIFF,__MUL1,	__TEX_ | __COMP,__DIFF         ,__MUL1},
						/*Stage1*/{       0, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_NORMAL
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__BLDF,	__CURR         ,__TEX_         ,__BLDF},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_WIPE
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR         ,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__NONE,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR         ,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF | __ALRP,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR         ,__NONE         ,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF | __ALRP,__MUL1},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR         ,__NONE         ,__SEL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR         ,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF         ,__MUL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__CURR,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR         ,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE         ,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_ | __COMP,__DIFF         ,__MUL1},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_ALPHA
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_         ,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR         ,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR | __COMP,__DIFF         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR         ,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
	},

	// 乗算済みαブレンドモードの描画輝度４倍
	{
		// ブレンドテクスチャ無し
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF         ,__MUL4},
						/*Stage1*/{    NULL, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage1*/{    NULL, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage1*/{    NULL, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラーなし
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(1), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(1), 0, 0,__TEX_,__NONE,__SEL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0,__NONE,__DIFF,__SEL2,	__TEX_,__DIFF         ,__MUL4},
						/*Stage1*/{    NULL, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage1*/{    NULL, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0,__TEX_,__DIFF,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage1*/{    NULL, 0, 0,__CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_NORMAL
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(6), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_         ,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_         ,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage5*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(6), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_         ,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_         ,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage5*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(6), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_         ,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_         ,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage5*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(5), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(6), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_         ,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_         ,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage5*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(6), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_         ,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_         ,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage5*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(6), 1, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 0, 0, __CURR,__TEX_,__SUB1,	__CURR,__TEX_         ,__SUB1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__FACT,__MUL1,	__CURR,__FACT         ,__MUL1},
						/*Stage3*/{    NULL, 0, 0, __CURR,__TEX_,__ADD1,	__CURR,__TEX_         ,__ADD1},
						/*Stage4*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage5*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_WIPE
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage2*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __CURR,__DIFF,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage2*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __SPEC,__CURR,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __DIFF,__CURR,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__FACT,__ADD1,	__NONE,__DIFF         ,__SEL2},
						/*Stage1*/{    NULL, 1, 0, __TEX_,__CURR,__MUL1,	__TEX_,__DIFF         ,__MUL4},
						/*Stage2*/{    NULL, 1, 0, __DIFF,__CURR,__MUL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
		//ブレンドテクスチャあり DX_BLENDGRAPHTYPE_ALPHA
		{
			//ディフューズRGBカラー無し
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(2), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
			//ディフューズRGBカラーあり
			{
				//ディフューズAlphaカラー無し
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(3), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF,__MUL4}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
				//ディフューズAlphaカラーあり
				{
					//αチャンネル無し
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},

					//αチャンネルあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
					
					//αテストあり
					{
						/*Stage0*/{__NUM(4), 0, 0, __TEX_,__NONE,__SEL1,	__TEX_,__NONE         ,__SEL1},
						/*Stage1*/{    NULL, 1, 0, __CURR,__TEX_,__MUL1,	__CURR,__NONE         ,__SEL1},
						/*Stage2*/{    NULL, 0, 0, __CURR,__DIFF,__MUL1,	__CURR,__DIFF         ,__MUL4},
						/*Stage3*/{    NULL, 0, 0, __CURR,__NONE,__SEL1,	__CURR,__DIFF | __ALRP,__MUL1}, DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST DISB_ST
					},
				},
			},
		},
	},
} ;

#undef __DIFF
#undef __CURR
#undef __TEX_
#undef __FACT
#undef __SPEC
#undef __TEMP

#undef __DISB
#undef __SEL1
#undef __SEL2
#undef __MUL1
#undef __MUL2
#undef __MUL4
#undef __ADD1

#undef __NUM

// ブレンド設定を更新(Direct3D に反映)する
static int  RefreshBlendStateHardware( DIRECT3DBLENDINFO *pUserInfo, int TextureStageIsTextureAndTextureCoordOnlyFlag, int TextureIsGraphHandleFlag )
{
	DIRECT3DBLENDINFO BlendInfo ;
	int AlphaTableIndex ;
	int BlendTextureIndex ;
	int NextBlendMode ;
	int i ;
	int StageNum ;
	int TextureOnly ;
	DIRECT3DTEXTURESTAGEINFO *Dest ;
	const DIRECT3DTEXTURESTAGEINFO *Src, *TextureStageInfo ;
	DX_DIRECT3DTEXTURE9 *StageTexture[USE_TEXTURESTAGE_NUM] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL } ;
	DX_DIRECT3DPIXELSHADER9 *UsePixelShader = NULL ;
	IMAGEDATA2 *Image2 ;
	SHADOWMAPDATA *ShadowMap ;
	int UseFloatFactorColor = FALSE ;
	FLOAT4 FloatFactorColor ;
	DIRECT3DTEXTURESTAGEINFO TempTextureStageInfo[ USE_TEXTURESTAGE_NUM ] ;
	int UseShaderFlag ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	UseShaderFlag = GRH.UseShader && GRH.NormalDraw_NotUseShader == FALSE ? TRUE : FALSE ;

	BlendInfo.TextureStageInfo[0].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[1].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[2].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[3].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[4].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[5].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[6].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[7].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[8].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[9].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[10].ResultTempARG = FALSE ;
	BlendInfo.TextureStageInfo[11].ResultTempARG = FALSE ;

	BlendInfo.SeparateAlphaBlendEnable = FALSE ;
	BlendInfo.SrcBlendAlpha = -1 ;
	BlendInfo.DestBlendAlpha = -1 ;
	BlendInfo.BlendOpAlpha = -1 ;

	// ユーザー指定のブレンド情報があるかどうかで処理を分岐
	TextureOnly = FALSE ;
	if( pUserInfo )
	{
		StageNum = pUserInfo->UseTextureStageNum ;

		_MEMCPY( &BlendInfo, pUserInfo, sizeof( DIRECT3DBLENDINFO ) - sizeof( pUserInfo->TextureStageInfo ) ) ;
		TextureStageInfo = pUserInfo->TextureStageInfo ;
		TextureOnly = TextureStageIsTextureAndTextureCoordOnlyFlag ;

		// グラフィックハンドルからテクスチャを取得する
		if( TextureIsGraphHandleFlag )
		{
			for( i = 0 ; i < StageNum ; i ++ )
			{
				if( !GRAPHCHK( ( LONG_PTR )pUserInfo->TextureStageInfo[ i ].Texture, Image2 ) )
				{
					StageTexture[ i ] = Image2->Hard.Draw[ 0 ].Tex->Texture ;
				}
				else
				if( !SHADOWMAPCHK( ( LONG_PTR )pUserInfo->TextureStageInfo[ i ].Texture, ShadowMap ) )
				{
					StageTexture[ i ] = ShadowMap->Texture ;
				}
				else
				{
					StageTexture[ i ] = NULL ;
				}
			}
		}
		else
		{
			for( i = 0 ; i < StageNum ; i ++ )
			{
				StageTexture[ i ] = ( DX_DIRECT3DTEXTURE9 * )pUserInfo->TextureStageInfo[ i ].Texture ;
			}
		}

		GRH.UseAlphaChDrawShader = FALSE ;
	}
	else
	if( GRH.UserBlendInfoFlag == TRUE )
	{
		StageNum = GRH.UserBlendInfo.UseTextureStageNum ;

		_MEMCPY( &BlendInfo, &GRH.UserBlendInfo, sizeof( DIRECT3DBLENDINFO ) - sizeof( GRH.UserBlendInfo.TextureStageInfo ) ) ;
		TextureStageInfo = GRH.UserBlendInfo.TextureStageInfo ;
		TextureOnly = GRH.UserBlendInfoTextureStageIsTextureAndTextureCoordOnlyFlag ;

		// グラフィックハンドルからテクスチャを取得する
		if( TextureIsGraphHandleFlag )
		{
			for( i = 0 ; i < StageNum ; i ++ )
			{
				if( !GRAPHCHK( ( LONG_PTR )GRH.UserBlendInfo.TextureStageInfo[ i ].Texture, Image2 ) )
				{
					StageTexture[ i ] = Image2->Hard.Draw[ 0 ].Tex->Texture ;
				}
				else
				if( !SHADOWMAPCHK( ( LONG_PTR )GRH.UserBlendInfo.TextureStageInfo[ i ].Texture, ShadowMap ) )
				{
					StageTexture[ i ] = ShadowMap->Texture ;
				}
				else
				{
					StageTexture[ i ] = NULL ;
				}
			}
		}
		else
		{
			for( i = 0 ; i < StageNum ; i ++ )
			{
				StageTexture[ i ] = ( DX_DIRECT3DTEXTURE9 * )GRH.UserBlendInfo.TextureStageInfo[ i ].Texture ;
			}
		}

		GRH.UseAlphaChDrawShader = FALSE ;
	}
	else
	{
		// 初期化フラグが立っておらず、且つパラメータが一切変更されて無かったら何もしない
		if( GRH.InitializeFlag == FALSE && GRH.ChangeBlendParamFlag == FALSE && GRH.ChangeTextureFlag == FALSE ) return -1 ; 

		// 描画テクスチャのみ変更された場合は描画テクスチャの変更のみ行う
		if( GRH.InitializeFlag == FALSE && GRH.ChangeBlendParamFlag == FALSE && GRH.ChangeTextureFlag == TRUE )
		{
			// ブレンドテクスチャがある場合と無い場合で処理を分岐
			if( GRH.BlendTexture != NULL )
			{
				// ある場合

				if( UseShaderFlag )
				{
					// 使用するテクスチャーアドレスをセット
					GraphicsDevice_SetTexture( 0, GRH.RenderTexture ) ;
					GRH.BlendInfo.TextureStageInfo[0].Texture = GRH.RenderTexture ;

					GraphicsDevice_SetTexture( 1, GRH.BlendTexture ) ;
					GRH.BlendInfo.TextureStageInfo[1].Texture = GRH.BlendTexture ;
				}
				else
				{
					// モードによって処理を変更
					switch( GRH.BlendGraphType )
					{
					case DX_BLENDGRAPHTYPE_NORMAL :
						GraphicsDevice_SetTexture( 0, GRH.BlendTexture ) ;
						GRH.BlendInfo.TextureStageInfo[0].Texture = GRH.BlendTexture ;

						GraphicsDevice_SetTexture( 1, GRH.RenderTexture ) ;
						GRH.BlendInfo.TextureStageInfo[1].Texture = GRH.RenderTexture ;

						GraphicsDevice_SetTexture( 3, GRH.RenderTexture ) ;
						GRH.BlendInfo.TextureStageInfo[3].Texture = GRH.RenderTexture ;
						break;

					case DX_BLENDGRAPHTYPE_WIPE :
						GraphicsDevice_SetTexture( 0, GRH.BlendTexture ) ;
						GRH.BlendInfo.TextureStageInfo[0].Texture = GRH.BlendTexture ;

						// αチャンネルが有効な場合とそうでない場合で処理を分岐
						if( GRH.AlphaChannelValidFlag == TRUE )
						{
							GraphicsDevice_SetTexture( 2, GRH.RenderTexture ) ;
							GRH.BlendInfo.TextureStageInfo[2].Texture = GRH.RenderTexture ;
	//						StageTexture[2] = GRH.RenderTexture ;
						}
						else
						{
							GraphicsDevice_SetTexture( 1, GRH.RenderTexture ) ;
							GRH.BlendInfo.TextureStageInfo[1].Texture = GRH.RenderTexture ;
	//						StageTexture[1] = GRH.RenderTexture ;
						}
						break ;

					case DX_BLENDGRAPHTYPE_ALPHA :
						GraphicsDevice_SetTexture( 0, GRH.RenderTexture ) ;
						GRH.BlendInfo.TextureStageInfo[0].Texture = GRH.RenderTexture ;

						GraphicsDevice_SetTexture( 1, GRH.BlendTexture ) ;
						GRH.BlendInfo.TextureStageInfo[1].Texture = GRH.BlendTexture ;
						break;
					}
				}
			}
			else
			{
				// 無い場合
				GraphicsDevice_SetTexture( 0, GRH.RenderTexture ) ;
				GRH.BlendInfo.TextureStageInfo[0].Texture = GRH.RenderTexture ;
	//			StageTexture[0] = GRH.RenderTexture ;
			}

			// テクスチャが変更された、フラグを倒す
			GRH.ChangeTextureFlag = FALSE ;
			GRH.DrawPrepAlwaysFlag = TRUE ;

			// 終了
			return 0 ;
		}

		// テクスチャが変更された、フラグを倒す
		GRH.ChangeTextureFlag = FALSE ;
		GRH.DrawPrepAlwaysFlag = TRUE ;

		// パラメータが変更された、フラグを倒す
		GRH.ChangeBlendParamFlag = FALSE ;

		// 頂点書き出し
	//	RenderVertexHardware() ;

		// ブレンドモードの決定
		{
			NextBlendMode = GRH.BlendMode ;
			switch( GRH.BlendMode )
			{
			case DX_BLENDMODE_SUB :
				// 減算ブレンド指定で D3DRS_BLENDOP が使用可能な場合は 14番目のブレンドモードを使用する
				if( GRH.ValidDestBlendOp )
				{
					NextBlendMode = DX_BLENDMODE_SUB1 ;
				}
				break ;

			case DX_BLENDMODE_NOBLEND :
				// 描画先にα値がある場合は DX_BLENDMODE_NOBLEND でもブレンドモードは DX_BLENDMODE_SRCCOLOR にする
				if( GBASE.AlphaChDrawMode )
				{
					NextBlendMode = DX_BLENDMODE_SRCCOLOR ;
				}

				// 描画元画像にαチャンネルがある場合やブレンド画像の有無など条件次第で DX_BLENDMODE_ALPHA を使用する
				if( GRH.RenderTexture != NULL )
				{
					if( GRH.BlendTexture != NULL )
					{
						switch( GRH.BlendGraphType )
						{
						case DX_BLENDGRAPHTYPE_NORMAL :
						case DX_BLENDGRAPHTYPE_ALPHA :
							if( GRH.AlphaTestValidFlag == TRUE || GRH.AlphaChannelValidFlag == TRUE )
							{
								NextBlendMode = DX_BLENDMODE_ALPHA ;
							}
							break ;

						case DX_BLENDGRAPHTYPE_WIPE :
							NextBlendMode = DX_BLENDMODE_ALPHA ;
							break ;
						}
					}
					else
					{
						if( GRH.AlphaChannelValidFlag == TRUE )
						{
							NextBlendMode = DX_BLENDMODE_ALPHA ;
						}
					}
				}
				break ;
			}
		}
		
		// ソースブレンドとデストブレンドの値をセット
		BlendInfo.DestBlend = __RGBBlendStateTable[ NextBlendMode ][ RGB_BLENDSTATE_TABLE_DESTBLEND ] ;
		BlendInfo.SrcBlend  = __RGBBlendStateTable[ NextBlendMode ][ RGB_BLENDSTATE_TABLE_SRCBLEND ] ;
		BlendInfo.BlendOp   = __RGBBlendStateTable[ NextBlendMode ][ RGB_BLENDSTATE_TABLE_BLENDOP ] ;
		BlendInfo.FactorColor = 0xffffffff ;

		// Direct3D のαブレンド機能を使用するブレンドモードかどうかを取得する
		BlendInfo.AlphaBlendEnable = __RGBBlendStateTable[ NextBlendMode ][ RGB_BLENDSTATE_TABLE_ALPHABLENDENABLE ] ;

		// 書き込みのα値を正しく計算するブレンドモードを使用するかどうかで処理を分岐
		GRH.UseAlphaChDrawShader = FALSE ;
		if( 0 ) // 重いのでとりあえず無効化
		{
			if( UseShaderFlag && GBASE.AlphaChDrawMode )
			{
				// ブレンド処理にシェーダーを使用する場合とそうでない場合で分岐
				if( __RGBBlendStateTable[ NextBlendMode ][ RGB_BLENDSTATE_TABLE_SHADERALPHABLEND ] == 1 )
				{
					GRH.UseAlphaChDrawShader = TRUE ;

					BlendInfo.SeparateAlphaBlendEnable = FALSE ;
					BlendInfo.SrcBlend       = D_D3DBLEND_ONE ;
					BlendInfo.DestBlend      = D_D3DBLEND_ZERO ;
					BlendInfo.BlendOp        = D_D3DBLENDOP_ADD ;
					BlendInfo.SrcBlendAlpha  = -1 ;
					BlendInfo.DestBlendAlpha = -1 ;
					BlendInfo.BlendOpAlpha   = -1 ;
				}
			}
		}

		// カレントテクスチャが無い場合とある場合で分岐
		if( GRH.RenderTexture == NULL )
		{
			// カレントテクスチャが無い場合は線や箱の描画と判断、テクスチャステージは無効にする

			// とりあえず描画処理を行う
			GRH.BlendMaxNotDrawFlag = FALSE ;
			
			// シェーダーを使用するかどうかで処理を分岐
			if( UseShaderFlag )
			{
				UsePixelShader = GRH.BaseNoneTexPixelShader[ __RGBBlendStateTable[ NextBlendMode ][ RGB_BLENDSTATE_TABLE_TEXBLENDTABLEINDEX ] ][ GRH.UseAlphaChDrawShader ] ;
				StageNum = 0 ;
			}
			else
			{
				// 減算ブレンドの反転処理の時のみ専用のテーブルを使用する
				if( NextBlendMode == DX_BLENDMODE_SUB )
				{
					TextureStageInfo = __TexSubBlendStageStateTable ;
					StageNum = (int)(DWORD_PTR)TextureStageInfo[0].Texture ;
				}
				else
				{
					IMAGEDATA2 *WhiteTex ;

					BlendInfo.TextureStageInfo[0].TextureCoordIndex = 0 ;
					BlendInfo.TextureStageInfo[1].TextureCoordIndex = 0 ;
					BlendInfo.TextureStageInfo[1].AlphaARG1 = D_D3DTA_DIFFUSE ;
					BlendInfo.TextureStageInfo[1].AlphaARG2 = D_D3DTA_DIFFUSE ;
					BlendInfo.TextureStageInfo[1].AlphaOP   = D_D3DTOP_DISABLE ;
					BlendInfo.TextureStageInfo[1].ColorARG1 = D_D3DTA_DIFFUSE ;
					BlendInfo.TextureStageInfo[1].ColorARG2 = D_D3DTA_DIFFUSE ;
					BlendInfo.TextureStageInfo[1].ColorOP   = D_D3DTOP_DISABLE ;
					StageNum = 1 ;
					switch( __RGBBlendStateTable[ NextBlendMode ][ RGB_BLENDSTATE_TABLE_TEXBLENDTABLEINDEX ] )
					{
					case TEXTURE_BLEND_TABLE_INDEX_NORMAL :	// 通常描画
						BlendInfo.TextureStageInfo[0].AlphaARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaOP   = D_D3DTOP_SELECTARG2 ;
						BlendInfo.TextureStageInfo[0].ColorARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].ColorARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].ColorOP   = D_D3DTOP_SELECTARG2 ;
						break ;

					case TEXTURE_BLEND_TABLE_INDEX_MUL :	// 乗算描画
						BlendInfo.TextureStageInfo[0].AlphaARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaOP   = D_D3DTOP_SELECTARG2 ;
						BlendInfo.TextureStageInfo[0].ColorARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].ColorARG2 = D_D3DTA_TFACTOR ;
						BlendInfo.TextureStageInfo[0].ColorOP   = D_D3DTOP_BLENDDIFFUSEALPHA ;
						break ;

					case TEXTURE_BLEND_TABLE_INDEX_INVERSE :	// ＲＧＢ反転
						BlendInfo.TextureStageInfo[0].AlphaARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaOP   = D_D3DTOP_SELECTARG2 ;
						BlendInfo.TextureStageInfo[0].ColorARG1 = D_D3DTA_DIFFUSE | D_D3DTA_COMPLEMENT;
						BlendInfo.TextureStageInfo[0].ColorARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].ColorOP   = D_D3DTOP_SELECTARG1 ;
						break ;

					case TEXTURE_BLEND_TABLE_INDEX_X4 :	// 描画輝度4倍
						if( GRH.WhiteTexHandle <= 0 )
						{
							LOADGRAPH_GPARAM GParam ;

							InitLoadGraphGParam( &GParam ) ;
							InitSetupGraphHandleGParam_Normal_NonDrawValid( &GParam.CreateGraphGParam.InitHandleGParam, 16, TRUE, FALSE ) ;
							GParam.CreateGraphGParam.InitHandleGParam.TransColor = ( BYTE )255 << 16 | ( BYTE )0 << 8 | ( BYTE )255 ;
							GRH.WhiteTexHandle = CreateGraphFromMem_UseGParam( &GParam, FALSE, GRH.WhiteTexHandle, WhiteTga8x8TextureFileImage, 84 ) ;
							NS_SetDeleteHandleFlag( GRH.WhiteTexHandle, &GRH.WhiteTexHandle ) ;
							NS_SetDeviceLostDeleteGraphFlag( GRH.WhiteTexHandle, TRUE ) ;
							BeginScene() ;
						}
						GRAPHCHK( GRH.WhiteTexHandle, WhiteTex ) ;
						StageTexture[0] = WhiteTex->Orig->Hard.Tex[ 0 ].Texture ;
						BlendInfo.TextureStageInfo[0].AlphaARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaOP   = D_D3DTOP_SELECTARG2 ;
						BlendInfo.TextureStageInfo[0].ColorARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].ColorARG2 = D_D3DTA_TEXTURE ;
						BlendInfo.TextureStageInfo[0].ColorOP   = D_D3DTOP_MODULATE4X ;
						break ;

					case TEXTURE_BLEND_TABLE_INDEX_PMA_NORMAL :		// 乗算済みαブレンドモードの通常描画
						BlendInfo.TextureStageInfo[0].AlphaARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaOP   = D_D3DTOP_SELECTARG2 ;
						BlendInfo.TextureStageInfo[0].ColorARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].ColorARG2 = D_D3DTA_DIFFUSE | D_D3DTA_ALPHAREPLICATE ;
						BlendInfo.TextureStageInfo[0].ColorOP   = D_D3DTOP_MODULATE ;
						break ;

					case TEXTURE_BLEND_TABLE_INDEX_PMA_INVERSE :	// 乗算済みαブレンドモードのRGB反転
						BlendInfo.TextureStageInfo[0].AlphaARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaOP   = D_D3DTOP_SELECTARG2 ;
						BlendInfo.TextureStageInfo[0].ColorARG1 = D_D3DTA_DIFFUSE | D_D3DTA_COMPLEMENT;
						BlendInfo.TextureStageInfo[0].ColorARG2 = D_D3DTA_DIFFUSE | D_D3DTA_ALPHAREPLICATE ;
						BlendInfo.TextureStageInfo[0].ColorOP   = D_D3DTOP_MODULATE ;
						break ;

					case TEXTURE_BLEND_TABLE_INDEX_PMA_X4 :			// 乗算済みαブレンドモードの描画輝度4倍
						if( GRH.WhiteTexHandle <= 0 )
						{
							LOADGRAPH_GPARAM GParam ;

							InitLoadGraphGParam( &GParam ) ;
							InitSetupGraphHandleGParam_Normal_NonDrawValid( &GParam.CreateGraphGParam.InitHandleGParam, 16, TRUE, FALSE ) ;
							GParam.CreateGraphGParam.InitHandleGParam.TransColor = ( BYTE )255 << 16 | ( BYTE )0 << 8 | ( BYTE )255 ;
							GRH.WhiteTexHandle = CreateGraphFromMem_UseGParam( &GParam, FALSE, GRH.WhiteTexHandle, WhiteTga8x8TextureFileImage, 84 ) ;
							NS_SetDeleteHandleFlag( GRH.WhiteTexHandle, &GRH.WhiteTexHandle ) ;
							NS_SetDeviceLostDeleteGraphFlag( GRH.WhiteTexHandle, TRUE ) ;
							BeginScene() ;
						}
						GRAPHCHK( GRH.WhiteTexHandle, WhiteTex ) ;
						StageTexture[0] = WhiteTex->Orig->Hard.Tex[ 0 ].Texture ;
						BlendInfo.TextureStageInfo[0].AlphaARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].AlphaOP   = D_D3DTOP_SELECTARG2 ;
						BlendInfo.TextureStageInfo[0].ColorARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[0].ColorARG2 = D_D3DTA_TEXTURE ;
						BlendInfo.TextureStageInfo[0].ColorOP   = D_D3DTOP_MODULATE4X ;

						BlendInfo.TextureStageInfo[1].AlphaARG1 = D_D3DTA_CURRENT ;
						BlendInfo.TextureStageInfo[1].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[1].AlphaOP   = D_D3DTOP_SELECTARG1 ;
						BlendInfo.TextureStageInfo[1].ColorARG1 = D_D3DTA_CURRENT ;
						BlendInfo.TextureStageInfo[1].ColorARG2 = D_D3DTA_DIFFUSE | D_D3DTA_ALPHAREPLICATE ;
						BlendInfo.TextureStageInfo[1].ColorOP   = D_D3DTOP_MODULATE ;

						BlendInfo.TextureStageInfo[2].AlphaARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[2].AlphaARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[2].AlphaOP   = D_D3DTOP_DISABLE ;
						BlendInfo.TextureStageInfo[2].ColorARG1 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[2].ColorARG2 = D_D3DTA_DIFFUSE ;
						BlendInfo.TextureStageInfo[2].ColorOP   = D_D3DTOP_DISABLE ;
						StageNum = 2 ;
						break ;
					}

					TextureStageInfo = BlendInfo.TextureStageInfo ;
				}
			}

			// αテストは行わない
			BlendInfo.AlphaTestEnable = FALSE ;
			BlendInfo.AlphaRef        = GRH.BlendInfo.AlphaRef ;
			BlendInfo.AlphaFunc       = GRH.BlendInfo.AlphaFunc ;

			// 頂点タイプのセット
			GRH.VertexType = VERTEXTYPE_NOTEX ;
			GRH.VertexBufferNextAddress = GRH.VertexBufferPoint[ GRH.Use3DVertex ][ GRH.VertexType ] ;
		}
		else
		{
			// カレントテクスチャがある場合はテクスチャステージブレンドテーブルから値を取得する

			// ブレンドテクスチャーがあるかどうかを取得する
			BlendTextureIndex = GRH.BlendTexture != NULL ? GRH.BlendGraphType + 1 : 0 ;

			// 使用するテクスチャブレンドステージステータステーブルのインデックスをセット
			AlphaTableIndex = 0 ;
			if( GRH.AlphaChannelValidFlag || GRH.AlphaTestValidFlag || ( GRH.EnableZBufferFlag && BlendTextureIndex == 0 ) )
			{
				AlphaTableIndex = GRH.AlphaChannelValidFlag ? 1 : 2 ;
			}

			// ブレンドテクスチャーを使用するかどうかで分岐
			if( BlendTextureIndex != 0 )
			{
				int TableIndex ;

				// ブレンドテクスチャーがある場合は AlphaTestValidFlag は無視

				// 使用するテーブルのインデックスを割り出す
				if( NextBlendMode == DX_BLENDMODE_ADD_X4 || NextBlendMode == DX_BLENDMODE_ALPHA_X4 )
				{
					TableIndex = TEXTURE_BLEND_TABLE_INDEX_X4 ;
				}
				else
				if( NextBlendMode == DX_BLENDMODE_INVSRC )
				{
					TableIndex = TEXTURE_BLEND_TABLE_INDEX_INVERSE ;
				}
				else
				{
					TableIndex = TEXTURE_BLEND_TABLE_INDEX_NORMAL ;
				}
				
				// シェーダーを使用するかどうかで処理を分岐
				if( UseShaderFlag )
				{
					// 使用するテクスチャーアドレスをセット
					StageTexture[0] = GRH.RenderTexture ;
					StageTexture[1] = GRH.BlendTexture ;
					StageTexture[2] = NULL ;
					StageNum = 2 ;
				}
				else
				{
					// テクスチャーステージステートの設定値を取得する
					TextureStageInfo = BlendInfo.TextureStageInfo ;
					memcpy( BlendInfo.TextureStageInfo,
							__TexStageStateTable[ TableIndex ][ BlendTextureIndex ][ GRH.UseDiffuseRGBColor ][ GRH.UseDiffuseAlphaColor ][ AlphaTableIndex ],
							 sizeof( DIRECT3DTEXTURESTAGEINFO ) * USE_TEXTURESTAGE_NUM ) ;

/*
					int p[5] ;

					p[0] = TableIndex ;
					p[1] = BlendTextureIndex ;
					p[2] = GRH.UseDiffuseRGBColor ;
					p[3] = GRH.UseDiffuseAlphaColor ;
					p[4] = AlphaTableIndex ;
*/
					StageNum = (int)(DWORD_PTR)TextureStageInfo[0].Texture ;
				}

				// 頂点タイプのセット
				GRH.VertexType = VERTEXTYPE_BLENDTEX ;
				GRH.VertexBufferNextAddress = GRH.VertexBufferPoint[ GRH.Use3DVertex ][ GRH.VertexType ] ;

				// ブレンドタイプによって処理を分岐
				switch( GRH.BlendGraphType )
				{
				case DX_BLENDGRAPHTYPE_NORMAL :
					// とりあえず描画処理を行う
					GRH.BlendMaxNotDrawFlag = FALSE ;

					// α処理が有効な場合はα値が０の場合のみ表示されないようにする
					if( GRH.AlphaTestValidFlag == TRUE || BlendInfo.AlphaBlendEnable == TRUE || GRH.AlphaChannelValidFlag == TRUE )
					{
						BlendInfo.AlphaTestEnable = TRUE ;
						BlendInfo.AlphaRef        = 0 ;
						BlendInfo.AlphaFunc       = D_D3DCMP_GREATER ;
					}
					else
					{
						BlendInfo.AlphaTestEnable = FALSE ;
						BlendInfo.AlphaRef        = GRH.BlendInfo.AlphaRef ;
						BlendInfo.AlphaFunc       = GRH.BlendInfo.AlphaFunc ;
					}

					// クロスフェード率を設定する
					BlendInfo.FactorColor = ( GRH.BlendGraphFadeRatio << 24 ) | 0x00ffffff ;

					// シェーダーを使用するかどうかで処理を分岐
					if( UseShaderFlag == FALSE )
					{
						// 使用するテクスチャーアドレスをセットと頂点タイプ、テクスチャステージが使用するテクスチャ座標のインデックスをセットする
						StageTexture[0] = GRH.BlendTexture ;
						StageTexture[1] = GRH.RenderTexture ;
						StageTexture[2] = NULL ;

						// テクスチャカラー無視フラグが立っている場合はテクスチャ要素を無効にする
						if( GRH.IgnoreGraphColorFlag )
						{
							BlendInfo.TextureStageInfo[ 0 ].ColorARG1 = D_D3DTA_DIFFUSE ;
							BlendInfo.TextureStageInfo[ 0 ].ColorARG2 = -1 ;
							BlendInfo.TextureStageInfo[ 0 ].ColorOP = D_D3DTOP_SELECTARG1 ;
							BlendInfo.TextureStageInfo[ 1 ].ColorARG1 = D_D3DTA_CURRENT ;
							BlendInfo.TextureStageInfo[ 1 ].ColorARG2 = -1 ;
							BlendInfo.TextureStageInfo[ 1 ].ColorOP = D_D3DTOP_SELECTARG1 ;
							if( StageNum == 3 )
							{
								BlendInfo.TextureStageInfo[ 2 ].ColorARG1 = D_D3DTA_CURRENT ;
								BlendInfo.TextureStageInfo[ 2 ].ColorARG2 = -1 ;
								BlendInfo.TextureStageInfo[ 2 ].ColorOP = D_D3DTOP_SELECTARG1 ;
							}
						}
					}
					else
					{
						// 使用するシェーダーをセット
						UsePixelShader = GRH.BaseUseTexPixelShader[ 1 ][ TableIndex ][ GRH.IgnoreGraphColorFlag ? 1 : 0 ][ AlphaTableIndex == 0 ? 1 : 0 ][ GRH.UseAlphaChDrawShader ] ;
					}
					break ;

				case DX_BLENDGRAPHTYPE_WIPE :
					// ブレンド境界値が最大の場合は何も描画しない
					GRH.BlendMaxNotDrawFlag = GRH.BlendGraphBorderParam == 255 ? TRUE : FALSE ;

					// シェーダーを使用するかどうかで処理を分岐
					if( UseShaderFlag == FALSE )
					{
						// 使用するテクスチャーアドレスをセットと頂点タイプ、テクスチャステージが使用するテクスチャ座標のインデックスをセットする
						StageTexture[0] = GRH.BlendTexture ;
						if( GRH.AlphaChannelValidFlag == TRUE )
						{
							StageTexture[1] = NULL ;
							StageTexture[2] = GRH.RenderTexture ;
						}
						else
						{
							StageTexture[1] = GRH.RenderTexture ;
						}
					}
					else
					{
						// 使用するシェーダーをセット
						UsePixelShader = GRH.BaseUseTexPixelShader[ 2 ][ TableIndex ][ GRH.IgnoreGraphColorFlag ? 1 : 0 ][ AlphaTableIndex == 0 ? 1 : 0 ][ GRH.UseAlphaChDrawShader ] ;

						// float型の FactorColor を使用する
						UseFloatFactorColor = TRUE ;
						FloatFactorColor.x = 0.0f ;
						FloatFactorColor.y = 0.0f ;
						FloatFactorColor.z = 0.0f ;
						FloatFactorColor.w = 0.0f ;
					}

					// 境界範囲が１以下かどうかで処理を分岐
					if( GRH.BlendGraphBorderRange <= 1 )
					{
						// ここはもう殆ど例外処理 -------------------------------------------

						// αテストを使用する
						BlendInfo.AlphaTestEnable = TRUE ;
						BlendInfo.AlphaRef = GRH.BlendGraphBorderParam ;
						BlendInfo.AlphaFunc = D_D3DCMP_GREATEREQUAL ;

						// αブレンド機能ＯＦＦ
						BlendInfo.AlphaBlendEnable = FALSE ;

						// 増分するα値は無し
						if( UseShaderFlag )
						{
							FloatFactorColor.w = 0.0f ;
							FloatFactorColor.z = 1.0f ;
						}
						else
						{
							BlendInfo.FactorColor = 0x00FFFFFF | ( 0 << 24 ) ;
						}

						// もし画像がαチャンネルを使用していて、且つ BlendGraphBorderParam が 0 だったら
						// AlphaRef を０にしない
						if( ( GRH.AlphaChannelValidFlag || GRH.AlphaTestValidFlag ) && GRH.BlendGraphBorderParam == 0 )
						{
							BlendInfo.AlphaRef = 1 ;
						}

						// -------------------------------------------------------------------
					}
					else
					{
						int p ;
					
						// αブレンドによるテクスチャブレンド

						// αテストは行わない
						BlendInfo.AlphaTestEnable = FALSE ;
						BlendInfo.AlphaRef        = GRH.BlendInfo.AlphaRef ;
						BlendInfo.AlphaFunc       = GRH.BlendInfo.AlphaFunc ;

						// αブレンド機能ＯＮ
						BlendInfo.AlphaBlendEnable = TRUE ;

						// 境界範囲によって４段階
						if( GRH.BlendGraphBorderRange <= 64 )
						{
							// ×４

							p = 1280 - GRH.BlendGraphBorderParam * 1280 / 255 ; 
							BlendInfo.TextureStageInfo[1].AlphaOP = D_D3DTOP_MODULATE4X ;

							// ブレンドテクスチャのブレンド値によって合成パラメータを変更
							if( p < 1024 )
							{
								BlendInfo.FactorColor = 0x00FFFFFF | ( ( 255 - p * 255 / 1024 ) << 24 ) ;
								BlendInfo.TextureStageInfo[0].AlphaOP = D_D3DTOP_SUBTRACT ;

								if( UseShaderFlag )
								{
									FloatFactorColor.w = - ( float )( BlendInfo.FactorColor >> 24 ) / 255.0f ;
								}
							}
							else
							{
								BlendInfo.FactorColor = 0x00FFFFFF | ( ( 64 * ( p - 1024 ) / 256 ) << 24 ) ;
								BlendInfo.TextureStageInfo[0].AlphaOP = D_D3DTOP_ADD ;

								if( UseShaderFlag )
								{
									FloatFactorColor.w = ( float )( BlendInfo.FactorColor >> 24 ) / 255.0f ;
								}
							}

							if( UseShaderFlag )
							{
								FloatFactorColor.z = 4.0f ;
							}
						}
						else
						if( GRH.BlendGraphBorderRange <= 128 )
						{
							// ×２

							p = 768 - GRH.BlendGraphBorderParam * 768 / 255 ; 
							BlendInfo.TextureStageInfo[1].AlphaOP = D_D3DTOP_MODULATE2X ;

							// ブレンドテクスチャのブレンド値によって合成パラメータを変更
							if( p < 512 )
							{
								BlendInfo.FactorColor = 0x00FFFFFF | ( ( 255 - p * 255 / 512 ) << 24 ) ;
								BlendInfo.TextureStageInfo[0].AlphaOP = D_D3DTOP_SUBTRACT ;

								if( UseShaderFlag )
								{
									FloatFactorColor.w = - ( float )( BlendInfo.FactorColor >> 24 ) / 255.0f ;
								}
							}
							else
							{
								BlendInfo.FactorColor = 0x00FFFFFF | ( ( 128 * ( p - 512 ) / 256 ) << 24 ) ;
								BlendInfo.TextureStageInfo[0].AlphaOP = D_D3DTOP_ADD ;

								if( UseShaderFlag )
								{
									FloatFactorColor.w = ( float )( BlendInfo.FactorColor >> 24 ) / 255.0f ;
								}
							}

							if( UseShaderFlag )
							{
								FloatFactorColor.z = 2.0f ;
							}
						}
						else
						{
							// ×１

							p = 512 - GRH.BlendGraphBorderParam * 512 / 255 ; 
							BlendInfo.TextureStageInfo[1].AlphaOP = D_D3DTOP_MODULATE ;

							// ブレンドテクスチャのブレンド値によって合成パラメータを変更
							if( p < 256 )
							{
								BlendInfo.FactorColor = 0x00FFFFFF | ( ( 255 - p * 255 / 256 ) << 24 ) ;
								BlendInfo.TextureStageInfo[0].AlphaOP = D_D3DTOP_SUBTRACT ;

								if( UseShaderFlag )
								{
									FloatFactorColor.w = - ( float )( BlendInfo.FactorColor >> 24 ) / 255.0f ;
								}
							}
							else
							{
								BlendInfo.FactorColor = 0x00FFFFFF | ( ( 255 * ( p - 256 ) / 256 ) << 24 ) ;
								BlendInfo.TextureStageInfo[0].AlphaOP = D_D3DTOP_ADD ;

								if( UseShaderFlag )
								{
									FloatFactorColor.w = ( float )( BlendInfo.FactorColor >> 24 ) / 255.0f ;
								}
							}

							if( UseShaderFlag )
							{
								FloatFactorColor.z = 1.0f ;
							}
						}
					}

					if( UseShaderFlag == FALSE )
					{
						// テクスチャカラー無視フラグが立っている場合はテクスチャ要素を無効にする
						if( GRH.IgnoreGraphColorFlag )
						{
							int TargetNumber ;

							if( GRH.AlphaChannelValidFlag == TRUE )
							{
								TargetNumber = 2 ;
							}
							else
							{
								TargetNumber = 1 ;
							}

							if( BlendInfo.TextureStageInfo[ TargetNumber ].ColorARG1 == D_D3DTA_TEXTURE &&
								BlendInfo.TextureStageInfo[ TargetNumber ].ColorOP == D_D3DTOP_SELECTARG1 )
							{
								BlendInfo.TextureStageInfo[ TargetNumber ].ColorARG1 = D_D3DTA_CURRENT ;
							}
							else
							if( BlendInfo.TextureStageInfo[ TargetNumber ].ColorARG1 == ( D_D3DTA_TEXTURE | D_D3DTA_COMPLEMENT ) &&
								BlendInfo.TextureStageInfo[ TargetNumber ].ColorOP == D_D3DTOP_SELECTARG1 )
							{
								BlendInfo.TextureStageInfo[ TargetNumber ].ColorARG1 = D_D3DTA_CURRENT | D_D3DTA_COMPLEMENT ;
							}
							else
							if( BlendInfo.TextureStageInfo[ TargetNumber ].ColorARG1 == D_D3DTA_TEXTURE &&
								( BlendInfo.TextureStageInfo[ TargetNumber ].ColorOP == D_D3DTOP_MODULATE ||
								  BlendInfo.TextureStageInfo[ TargetNumber ].ColorOP == D_D3DTOP_MODULATE2X ||
								  BlendInfo.TextureStageInfo[ TargetNumber ].ColorOP == D_D3DTOP_MODULATE4X ) )
							{
								BlendInfo.TextureStageInfo[ TargetNumber ].ColorOP = D_D3DTOP_SELECTARG2 ;
							}
						}
					}
					break ;

				case DX_BLENDGRAPHTYPE_ALPHA :
					// とりあえず描画処理を行う
					GRH.BlendMaxNotDrawFlag = FALSE ;

					// α処理が有効な場合はα値が０の場合のみ表示されないようにする
					if( BlendInfo.AlphaBlendEnable == TRUE )
					{
						BlendInfo.AlphaTestEnable = TRUE ;
						BlendInfo.AlphaRef        = 0 ;
						BlendInfo.AlphaFunc       = D_D3DCMP_GREATER ;
					}
					else
					{
						BlendInfo.AlphaTestEnable = FALSE ;
						BlendInfo.AlphaRef        = GRH.BlendInfo.AlphaRef ;
						BlendInfo.AlphaFunc       = GRH.BlendInfo.AlphaFunc ;
					}

					// シェーダーを使用するかどうかで処理を分岐
					if( UseShaderFlag == FALSE )
					{
						// 使用するテクスチャーアドレスをセットと頂点タイプ、テクスチャステージが使用するテクスチャ座標のインデックスをセットする
						StageTexture[0] = GRH.RenderTexture ;
						StageTexture[1] = GRH.BlendTexture ;
						StageTexture[2] = NULL ;

						// テクスチャカラー無視フラグが立っている場合はテクスチャカラー要素を無効にする
						if( GRH.IgnoreGraphColorFlag )
						{
							BlendInfo.TextureStageInfo[ 0 ].ColorARG1 = D_D3DTA_DIFFUSE ;
						}
					}
					else
					{
						// 使用するシェーダーをセット
						UsePixelShader = GRH.BaseUseTexPixelShader[ 3 ][ TableIndex ][ GRH.IgnoreGraphColorFlag ? 1 : 0 ][ AlphaTableIndex == 0 ? 1 : 0 ][ GRH.UseAlphaChDrawShader ] ;
					}
					break ;
				}
			}
			else
			{
				// ブレンドテクスチャーが無い場合

				// とりあえず描画処理を行う
				GRH.BlendMaxNotDrawFlag = FALSE ;

				// 頂点タイプのセット
				GRH.VertexType = VERTEXTYPE_TEX ;
				GRH.VertexBufferNextAddress = GRH.VertexBufferPoint[ GRH.Use3DVertex ][ GRH.VertexType ] ;

				// シェーダーを使用するかどうかで処理を分岐
				if( UseShaderFlag )
				{
					// 使用するピクセルシェーダーをセット
					UsePixelShader = GRH.BaseUseTexPixelShader[ 0 ][ __RGBBlendStateTable[NextBlendMode][RGB_BLENDSTATE_TABLE_TEXBLENDTABLEINDEX] ][ GRH.IgnoreGraphColorFlag ? 1 : 0 ][ AlphaTableIndex == 0 ? 1 : 0 ][ GRH.UseAlphaChDrawShader ] ;

					// 使用するテクスチャの数は一つ
					StageNum = 1 ;
				}
				else
				{
					// テクスチャーステージステートの設定値を取得する
					TextureStageInfo = __TexStageStateTable[ __RGBBlendStateTable[ NextBlendMode ][ RGB_BLENDSTATE_TABLE_TEXBLENDTABLEINDEX ] ][ FALSE ][ GRH.UseDiffuseRGBColor ][ GRH.UseDiffuseAlphaColor ][ AlphaTableIndex ] ;
					StageNum = (int)(DWORD_PTR)TextureStageInfo[0].Texture ;

					// テクスチャカラー無視フラグが立っている場合はテクスチャ要素を無効にする
					if( GRH.IgnoreGraphColorFlag )
					{
						_MEMCPY( TempTextureStageInfo, TextureStageInfo, sizeof( DIRECT3DTEXTURESTAGEINFO ) * ( StageNum + 1 ) ) ;
						if( TempTextureStageInfo[ 0 ].ColorARG1 == D_D3DTA_TEXTURE )
						{
							TempTextureStageInfo[ 0 ].ColorARG1 = D_D3DTA_TFACTOR ;
						}
						else
						if( TempTextureStageInfo[ 0 ].ColorARG1 == ( D_D3DTA_TEXTURE | D_D3DTA_COMPLEMENT ) )
						{
							TempTextureStageInfo[ 0 ].ColorARG1 = D_D3DTA_TFACTOR | D_D3DTA_COMPLEMENT ;
						}
						TextureStageInfo = TempTextureStageInfo ;
					}
				}

				// αテストを使用するかどうかで処理を分岐
				if( GRH.AlphaTestValidFlag == TRUE )
				{
					// αテストを行う(透過色処理以外にαテストはブレンドテクスチャでも使用している)
					BlendInfo.AlphaTestEnable = TRUE ;
					BlendInfo.AlphaRef = 16 ;
					BlendInfo.AlphaFunc = D_D3DCMP_GREATER ;
				}
				else
				{
					// α処理が有効な場合はα値が０の場合のみ表示されないようにする
					if( BlendInfo.AlphaBlendEnable == TRUE )
					{
						BlendInfo.AlphaTestEnable = TRUE ;
						BlendInfo.AlphaRef        = 0 ;
						BlendInfo.AlphaFunc       = D_D3DCMP_GREATER ;
					}
					else
					{
						BlendInfo.AlphaTestEnable = FALSE ;
						BlendInfo.AlphaRef        = GRH.BlendInfo.AlphaRef ;
						BlendInfo.AlphaFunc       = GRH.BlendInfo.AlphaFunc ;
					}
				}

				// 使用するテクスチャーアドレスをセット
				StageTexture[0] = GRH.RenderTexture ;
			}
		}

		// αチャンネルを正しく計算するシェーダーを使用する場合はレンダリングターゲットのテクスチャをセットする
		if( GRH.UseAlphaChDrawShader )
		{
			StageTexture[ 2 ] = GRH.RenderTargetTexture ;
			if( StageNum < 3 )
			{
				for( i = StageNum ; i < 2 ; i ++ )
				{
					StageTexture[ i ] = NULL ;
				}
				StageNum = 3 ;
			}
		}
		
		// 初期化フラグが立っているかどうかで処理を分岐	
		if( StageNum != GRH.BlendInfo.UseTextureStageNum )
		{
			int InitFlag ;
			
			GRH.BlendInfo.UseTextureStageNum = StageNum ;
			
			InitFlag = GRH.InitializeFlag ;

			GRH.InitializeFlag = TRUE ;
			SetDrawModeHardware( GRH.DrawMode ) ;
			SetMaxAnisotropyHardware( GRH.MaxAnisotropy ) ;
			GRH.InitializeFlag = InitFlag ;
		}
		if( StageNum < USE_TEXTURESTAGE_NUM ) StageNum ++ ;

		// アルファテストパラメータが有効な場合はそれを優先する
		if( GRH.AlphaTestMode != -1 )
		{
			BlendInfo.AlphaTestEnable = TRUE ;
			BlendInfo.AlphaFunc = GRH.AlphaTestMode ;
			BlendInfo.AlphaRef = GRH.AlphaTestParam ;
		}
	}
	if( GRH.InitializeFlag == TRUE )
	{
		// 立っている場合は状態を全て更新する

//		GraphicsDevice_SetRenderState( D_D3DRS_COLORKEYENABLE, BlendInfo.AlphaTestEnable ) ;
//		GRH.BlendInfo.AlphaTestEnable = BlendInfo.AlphaTestEnable ;

		GraphicsDevice_SetRenderState( D_D3DRS_ALPHAFUNC, BlendInfo.AlphaFunc ) ;
		GRH.BlendInfo.AlphaFunc = BlendInfo.AlphaFunc ;

		GraphicsDevice_SetRenderState( D_D3DRS_ALPHAREF, BlendInfo.AlphaRef ) ;
		GRH.BlendInfo.AlphaRef = BlendInfo.AlphaRef ;
		
		GraphicsDevice_SetRenderState( D_D3DRS_ALPHATESTENABLE, BlendInfo.AlphaTestEnable ) ;
		GRH.BlendInfo.AlphaTestEnable = BlendInfo.AlphaTestEnable ;

		GraphicsDevice_SetRenderState( D_D3DRS_ALPHABLENDENABLE, BlendInfo.AlphaBlendEnable ) ;
		GRH.BlendInfo.AlphaBlendEnable = BlendInfo.AlphaBlendEnable ;
			
		if( UseShaderFlag == FALSE )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_TEXTUREFACTOR, BlendInfo.FactorColor ) ;
		}
		GRH.BlendInfo.FactorColor = BlendInfo.FactorColor ;

		{
			if( UseFloatFactorColor )
			{
				*( ( FLOAT4 * )GRH.FactorColorPSConstantF ) = FloatFactorColor ;
			}
			else
			{
				GRH.FactorColorPSConstantF[ 0 ] = (   BlendInfo.FactorColor         & 0xff ) / 255.0f ;
				GRH.FactorColorPSConstantF[ 1 ] = ( ( BlendInfo.FactorColor >> 8  ) & 0xff ) / 255.0f ;
				GRH.FactorColorPSConstantF[ 2 ] = ( ( BlendInfo.FactorColor >> 16 ) & 0xff ) / 255.0f ;
				GRH.FactorColorPSConstantF[ 3 ] = ( ( BlendInfo.FactorColor >> 24 ) & 0xff ) / 255.0f ;
			}
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_PS_FLOAT,
				DX_SHADERCONSTANTSET_LIB,
				DX_PS_CONSTF_FACTORCOLOR,
				GRH.FactorColorPSConstantF,
				1,
				TRUE
			) ;
		}

		if( BlendInfo.SrcBlend != -1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_SRCBLEND, BlendInfo.SrcBlend ) ;
			GRH.BlendInfo.SrcBlend = BlendInfo.SrcBlend ;
		}
		else
		if( GRH.BlendInfo.SrcBlend > 1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_SRCBLEND, GRH.BlendInfo.SrcBlend ) ;
		}

		if( BlendInfo.DestBlend != -1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_DESTBLEND, BlendInfo.DestBlend ) ;
			GRH.BlendInfo.DestBlend = BlendInfo.DestBlend ;
		}
		else
		if( GRH.BlendInfo.DestBlend > 1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_DESTBLEND, GRH.BlendInfo.DestBlend ) ;
		}

		if( BlendInfo.BlendOp != -1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_BLENDOP, BlendInfo.BlendOp ) ;
			GRH.BlendInfo.BlendOp = BlendInfo.BlendOp ;
		}
		else
		if( GRH.BlendInfo.BlendOp > 1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_BLENDOP, GRH.BlendInfo.BlendOp ) ;
		}

		GraphicsDevice_SetRenderState( D_D3DRS_SEPARATEALPHABLENDENABLE, BlendInfo.SeparateAlphaBlendEnable ) ;
		GRH.BlendInfo.SeparateAlphaBlendEnable = BlendInfo.SeparateAlphaBlendEnable ;

		if( BlendInfo.SrcBlendAlpha != -1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_SRCBLENDALPHA, BlendInfo.SrcBlendAlpha ) ;
			GRH.BlendInfo.SrcBlendAlpha = BlendInfo.SrcBlendAlpha ;
		}
		else
		if( GRH.BlendInfo.SrcBlendAlpha > 1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_SRCBLENDALPHA, GRH.BlendInfo.SrcBlendAlpha ) ;
		}

		if( BlendInfo.DestBlendAlpha != -1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_DESTBLENDALPHA, BlendInfo.DestBlendAlpha ) ;
			GRH.BlendInfo.DestBlendAlpha = BlendInfo.DestBlendAlpha ;
		}
		else
		if( GRH.BlendInfo.DestBlendAlpha > 1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_DESTBLENDALPHA, GRH.BlendInfo.DestBlendAlpha ) ;
		}

		if( BlendInfo.BlendOpAlpha != -1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_BLENDOPALPHA, BlendInfo.BlendOpAlpha ) ;
			GRH.BlendInfo.BlendOpAlpha = BlendInfo.BlendOpAlpha ;
		}
		else
		if( GRH.BlendInfo.BlendOpAlpha > 1 )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_BLENDOPALPHA, GRH.BlendInfo.BlendOpAlpha ) ;
		}

		if( UseShaderFlag )
		{
			Src = NULL ;
		}
		else
		{
			Src  = TextureStageInfo ;
		}
		Dest = GRH.BlendInfo.TextureStageInfo ;
		for( i = 0 ; i < USE_TEXTURESTAGE_NUM ; i ++, Src ++, Dest ++ )
		{
//			if( i >= 2 && Src[-1].AlphaOP == D_D3DTOP_DISABLE && TextureOnly == FALSE ) break ;

			if( i < StageNum )
			{
				GraphicsDevice_SetTexture( i, StageTexture[i] ) ;
				Dest->Texture = StageTexture[i] ;

				if( UseShaderFlag == FALSE )
				{
					if( Src->TextureCoordIndex != -1 )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_TEXCOORDINDEX, Src->TextureCoordIndex ) ;
						Dest->TextureCoordIndex = Src->TextureCoordIndex ;
					}
				}
			}
			else
			{
				GraphicsDevice_SetTexture( i, NULL ) ;
				Dest->Texture = NULL ;

				if( UseShaderFlag == FALSE )
				{
					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_TEXCOORDINDEX, 0 ) ;
					Dest->TextureCoordIndex = 0 ;
				}
			}

			if( TextureOnly || ( UseShaderFlag && i != 0 ) ) continue ;

			if( UseShaderFlag )
			{
				GraphicsDevice_SetPixelShader( UsePixelShader ) ;
				GRH.SetPS = UsePixelShader ;
				GRH.NormalPS = TRUE ;
				GRH.DrawPrepAlwaysFlag = TRUE ;
			}
			else
			{
				if( i < StageNum )
				{
					if( GRH.ValidTexTempRegFlag )
					{
						if( Src->ResultTempARG != -1 )
						{
							GraphicsDevice_SetTextureStageState( i, D_D3DTSS_RESULTARG, Src->ResultTempARG ? D_D3DTA_TEMP : D_D3DTA_CURRENT ) ;
							Dest->ResultTempARG = Src->ResultTempARG ;
						}
					}

					if( Src->AlphaOP != -1 )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAOP, Src->AlphaOP ) ;
						Dest->AlphaOP = Src->AlphaOP ;
					}

					if( Src->AlphaARG1 != -1 )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAARG1, Src->AlphaARG1 ) ;
						Dest->AlphaARG1 = Src->AlphaARG1 ;
					}

					if( Src->AlphaARG2 != -1 )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAARG2, Src->AlphaARG2 ) ;
						Dest->AlphaARG2 = Src->AlphaARG2 ;
					}

					if( Src->ColorOP != -1 )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLOROP, Src->ColorOP ) ;
						Dest->ColorOP = Src->ColorOP ;
					}

					if( Src->ColorARG1 != -1 )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLORARG1, Src->ColorARG1 ) ;
						Dest->ColorARG1 = Src->ColorARG1 ;
					}

					if( Src->ColorARG2 != -1 )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLORARG2, Src->ColorARG2 ) ;
						Dest->ColorARG2 = Src->ColorARG2 ;
					}
				}
				else
				{
					if( GRH.ValidTexTempRegFlag )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_RESULTARG, D_D3DTA_CURRENT ) ;
						Dest->ResultTempARG = FALSE ;
					}

					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAOP, D_D3DTOP_DISABLE ) ;
					Dest->AlphaOP = D_D3DTOP_DISABLE ;

					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAARG1, D_D3DTA_DIFFUSE ) ;
					Dest->AlphaARG1 = D_D3DTA_DIFFUSE ;

					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAARG2, D_D3DTA_DIFFUSE ) ;
					Dest->AlphaARG2 = D_D3DTA_DIFFUSE ;

					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLOROP, D_D3DTOP_DISABLE ) ;
					Dest->ColorOP = D_D3DTOP_DISABLE ;

					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLORARG1, D_D3DTA_DIFFUSE ) ;
					Dest->ColorARG1 = D_D3DTA_DIFFUSE ;

					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLORARG2, D_D3DTA_DIFFUSE ) ;
					Dest->ColorARG2 = D_D3DTA_DIFFUSE ;
				}
			}
		}
	}
	else
	{
		// 立っていない場合は変更点のみ再設定する

/*		if( BlendInfo.AlphaTestEnable != GRH.BlendInfo.AlphaTestEnable )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_COLORKEYENABLE, BlendInfo.AlphaTestEnable ) ;
			GRH.BlendInfo.AlphaTestEnable = BlendInfo.AlphaTestEnable ;
		}
*/
		if( BlendInfo.AlphaFunc != GRH.BlendInfo.AlphaFunc )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_ALPHAFUNC, BlendInfo.AlphaFunc ) ;
			GRH.BlendInfo.AlphaFunc = BlendInfo.AlphaFunc ;
		}

		if( BlendInfo.AlphaRef != GRH.BlendInfo.AlphaRef )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_ALPHAREF, BlendInfo.AlphaRef ) ;
			GRH.BlendInfo.AlphaRef = BlendInfo.AlphaRef ;
		}
		
		if( BlendInfo.AlphaTestEnable != GRH.BlendInfo.AlphaTestEnable )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_ALPHATESTENABLE, BlendInfo.AlphaTestEnable ) ;
			GRH.BlendInfo.AlphaTestEnable = BlendInfo.AlphaTestEnable ;
		}
		
		if( BlendInfo.AlphaBlendEnable != GRH.BlendInfo.AlphaBlendEnable )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_ALPHABLENDENABLE, BlendInfo.AlphaBlendEnable ) ;
			GRH.BlendInfo.AlphaBlendEnable = BlendInfo.AlphaBlendEnable ;
		}
			
		if( BlendInfo.FactorColor != GRH.BlendInfo.FactorColor )
		{
			if( UseShaderFlag == FALSE )
			{
				GraphicsDevice_SetRenderState( D_D3DRS_TEXTUREFACTOR, BlendInfo.FactorColor ) ;
			}
			GRH.BlendInfo.FactorColor = BlendInfo.FactorColor ;
		}

		{
			float FactorData[ 4 ] ;

			if( UseFloatFactorColor )
			{
				*( ( FLOAT4 * )FactorData ) = FloatFactorColor ;
			}
			else
			{
				FactorData[ 0 ] = (   BlendInfo.FactorColor         & 0xff ) / 255.0f ;
				FactorData[ 1 ] = ( ( BlendInfo.FactorColor >> 8  ) & 0xff ) / 255.0f ;
				FactorData[ 2 ] = ( ( BlendInfo.FactorColor >> 16 ) & 0xff ) / 255.0f ;
				FactorData[ 3 ] = ( ( BlendInfo.FactorColor >> 24 ) & 0xff ) / 255.0f ;
			}
			if( _MEMCMP( GRH.FactorColorPSConstantF, FactorData, sizeof( float ) * 4 ) != 0 )
			{
				_MEMCPY( GRH.FactorColorPSConstantF, FactorData, sizeof( float ) * 4 ) ;
				SetShaderConstantSet(
					&GRH.ShaderConstantInfo,
					DX_SHADERCONSTANTTYPE_PS_FLOAT,
					DX_SHADERCONSTANTSET_LIB,
					DX_PS_CONSTF_FACTORCOLOR,
					FactorData,
					1,
					TRUE
				) ;
			}
		}

		if( BlendInfo.SrcBlend != -1 && BlendInfo.SrcBlend != GRH.BlendInfo.SrcBlend )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_SRCBLEND, BlendInfo.SrcBlend ) ;
			GRH.BlendInfo.SrcBlend = BlendInfo.SrcBlend ;
		}

		if( BlendInfo.DestBlend != -1 && BlendInfo.DestBlend != GRH.BlendInfo.DestBlend )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_DESTBLEND, BlendInfo.DestBlend ) ;
			GRH.BlendInfo.DestBlend = BlendInfo.DestBlend ;
		}

		if( BlendInfo.BlendOp != -1 && BlendInfo.BlendOp != GRH.BlendInfo.BlendOp )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_BLENDOP, BlendInfo.BlendOp ) ;
			GRH.BlendInfo.BlendOp = BlendInfo.BlendOp ;
		}

		if( BlendInfo.SeparateAlphaBlendEnable != GRH.BlendInfo.SeparateAlphaBlendEnable )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_SEPARATEALPHABLENDENABLE, BlendInfo.SeparateAlphaBlendEnable ) ;
			GRH.BlendInfo.SeparateAlphaBlendEnable = BlendInfo.SeparateAlphaBlendEnable ;
		}

		if( BlendInfo.SrcBlendAlpha != -1 && BlendInfo.SrcBlendAlpha != GRH.BlendInfo.SrcBlendAlpha )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_SRCBLENDALPHA, BlendInfo.SrcBlendAlpha ) ;
			GRH.BlendInfo.SrcBlendAlpha = BlendInfo.SrcBlendAlpha ;
		}

		if( BlendInfo.DestBlendAlpha != -1 && BlendInfo.DestBlendAlpha != GRH.BlendInfo.DestBlendAlpha )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_DESTBLENDALPHA, BlendInfo.DestBlendAlpha ) ;
			GRH.BlendInfo.DestBlendAlpha = BlendInfo.DestBlendAlpha ;
		}

		if( BlendInfo.BlendOpAlpha != -1 && BlendInfo.BlendOpAlpha != GRH.BlendInfo.BlendOpAlpha )
		{
			GraphicsDevice_SetRenderState( D_D3DRS_BLENDOPALPHA, BlendInfo.BlendOpAlpha ) ;
			GRH.BlendInfo.BlendOpAlpha = BlendInfo.BlendOpAlpha ;
		}


		if( UseShaderFlag )
		{
			Src = NULL ;
		}
		else
		{
			Src  = TextureStageInfo ;
		}
		int UseShaderStageNum = GRH.UseAlphaChDrawShader ? 3 : 2 ;
		Dest = GRH.BlendInfo.TextureStageInfo ;
		for( i = 0 ; i < StageNum ; i ++, Src ++, Dest ++ )
		{
			if( i >= UseShaderStageNum && ( UseShaderFlag || Src[-1].AlphaOP == D_D3DTOP_DISABLE ) && TextureOnly == FALSE ) break ;

			if( StageTexture[i] != Dest->Texture )
			{
				HRESULT hr ;

				hr = GraphicsDevice_SetTexture( i, StageTexture[i] ) ;
				Dest->Texture = StageTexture[i] ;
			}

			if( UseShaderFlag == FALSE )
			{
				if( Src->TextureCoordIndex != -1 && Src->TextureCoordIndex != Dest->TextureCoordIndex )
				{
					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_TEXCOORDINDEX, Src->TextureCoordIndex ) ;
					Dest->TextureCoordIndex = Src->TextureCoordIndex ;
				}
			}

			if( TextureOnly || ( UseShaderFlag && i != 0 ) ) continue ;

			if( UseShaderFlag )
			{
				if( GRH.SetPS != UsePixelShader )
				{
					GraphicsDevice_SetPixelShader( UsePixelShader ) ;
					GRH.SetPS = UsePixelShader ;
					GRH.NormalPS = TRUE ;
					GRH.DrawPrepAlwaysFlag = TRUE ;
				}
			}
			else
			{
				if( GRH.ValidTexTempRegFlag )
				{
					if( Src->ResultTempARG != -1 && Src->ResultTempARG != Dest->ResultTempARG )
					{
						GraphicsDevice_SetTextureStageState( i, D_D3DTSS_RESULTARG, Src->ResultTempARG ? D_D3DTA_TEMP : D_D3DTA_CURRENT ) ;
						Dest->ResultTempARG = Src->ResultTempARG ;
					}
				}

				if( Src->AlphaOP != -1 && Src->AlphaOP != Dest->AlphaOP )
				{
					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAOP, Src->AlphaOP ) ;
					Dest->AlphaOP = Src->AlphaOP ;
				}

				if( Src->AlphaARG1 != -1 && Src->AlphaARG1 != Dest->AlphaARG1 )
				{
					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAARG1, Src->AlphaARG1 ) ;
					Dest->AlphaARG1 = Src->AlphaARG1 ;
				}

				if( Src->AlphaARG2 != -1 && Src->AlphaARG2 != Dest->AlphaARG2 )
				{
					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_ALPHAARG2, Src->AlphaARG2 ) ;
					Dest->AlphaARG2 = Src->AlphaARG2 ;
				}

				if( Src->ColorOP != -1 && Src->ColorOP != Dest->ColorOP )
				{
					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLOROP, Src->ColorOP ) ;
					Dest->ColorOP = Src->ColorOP ;
				}

				if( Src->ColorARG1 != -1 && Src->ColorARG1 != Dest->ColorARG1 )
				{
					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLORARG1, Src->ColorARG1 ) ;
					Dest->ColorARG1 = Src->ColorARG1 ;
				}

				if( Src->ColorARG2 != -1 && Src->ColorARG2 != Dest->ColorARG2 )
				{
					GraphicsDevice_SetTextureStageState( i, D_D3DTSS_COLORARG2, Src->ColorARG2 ) ;
					Dest->ColorARG2 = Src->ColorARG2 ;
				}
			}
		}
		for( ; i < USE_TEXTURESTAGE_NUM ; i ++, Dest ++ )
		{
			if( Dest->Texture != NULL )
			{
				GraphicsDevice_SetTexture( i, NULL ) ;
				Dest->Texture = NULL ;
			}
		}
	}
	
	// 終了
	return 0 ;
}

// 描画モードのセット
static int  SetDrawModeHardware( int DrawMode )
{
	int i, num ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.DrawMode == DrawMode && GRH.InitializeFlag == FALSE ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// レンダリング設定を変更する
	num = GRH.BlendInfo.UseTextureStageNum ;
	if( num < 4 ) num = 4 ;
	switch( DrawMode )
	{
	case DX_DRAWMODE_BILINEAR :
		// バイリニア描画
		for( i = 0 ; i < num ; i ++ )
		{
			if( GRH.MagFilter[ i ] != D_D3DTEXF_LINEAR || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MAGFILTER, D_D3DTEXF_LINEAR ) ;
				GRH.MagFilter[ i ] = D_D3DTEXF_LINEAR ;
			}
			if( GRH.MinFilter[ i ] != D_D3DTEXF_LINEAR || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MINFILTER, D_D3DTEXF_LINEAR ) ;
				GRH.MinFilter[ i ] = D_D3DTEXF_LINEAR ;
			}
			if( GRH.MipFilter[ i ] != D_D3DTEXF_LINEAR || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MIPFILTER, D_D3DTEXF_NONE ) ;
				GRH.MipFilter[ i ] = D_D3DTEXF_NONE ;
			}
		}
		break ;

	case DX_DRAWMODE_NEAREST :
		// 二アレストネイバー
		for( i = 0 ; i < num ; i ++ )
		{
			if( GRH.MagFilter[ i ] != D_D3DTEXF_POINT || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MAGFILTER, D_D3DTEXF_POINT ) ;
				GRH.MagFilter[ i ] = D_D3DTEXF_POINT ;
			}
			if( GRH.MinFilter[ i ] != D_D3DTEXF_POINT || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MINFILTER, D_D3DTEXF_POINT ) ;
				GRH.MinFilter[ i ] = D_D3DTEXF_POINT ;
			}
			if( GRH.MipFilter[ i ] != D_D3DTEXF_POINT || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MIPFILTER, D_D3DTEXF_NONE ) ;
				GRH.MipFilter[ i ] = D_D3DTEXF_NONE ;
			}
		}
		break ;

	case DX_DRAWMODE_ANISOTROPIC :
		// 異方性フィルタリング
		for( i = 0 ; i < num ; i ++ )
		{
			if( GRH.MagFilter[ i ] != D_D3DTEXF_LINEAR || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MAGFILTER, D_D3DTEXF_LINEAR ) ;
				GRH.MagFilter[ i ] = D_D3DTEXF_LINEAR ;
			}
			if( GRH.MinFilter[ i ] != D_D3DTEXF_ANISOTROPIC || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MINFILTER, D_D3DTEXF_ANISOTROPIC ) ;
				GRH.MinFilter[ i ] = D_D3DTEXF_ANISOTROPIC ;
			}
			if( GRH.MipFilter[ i ] != D_D3DTEXF_LINEAR || GRH.InitializeFlag )
			{
				GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MIPFILTER, D_D3DTEXF_LINEAR ) ;
				GRH.MipFilter[ i ] = D_D3DTEXF_LINEAR ;
			}
		}
		break ;

	default : return -1 ;
	}
	GRH.DrawMode = DrawMode ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// 最大異方性のセット
static int SetMaxAnisotropyHardware( int MaxAnisotropy )
{
	int i, num ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.MaxAnisotropy == MaxAnisotropy && GRH.InitializeFlag == FALSE ) return 0 ;

	// 値の補正
	if( MaxAnisotropy < 1 )
		MaxAnisotropy = 1 ;

	// 頂点書き出し
	RenderVertexHardware() ;

	// レンダリング設定を変更する
	num = GRH.BlendInfo.UseTextureStageNum ;
	if( num < 4 ) num = 4 ;
	for( i = 0 ; i < num ; i ++ )
	{
		if( GRH.MaxAnisotropyDim[ i ] != MaxAnisotropy )
		{
			GraphicsDevice_SetSamplerState( i, D_D3DSAMP_MAXANISOTROPY, MaxAnisotropy ) ;
			GRH.MaxAnisotropyDim[ i ] = MaxAnisotropy ;
		}
	}

	GRH.MaxAnisotropy = MaxAnisotropy ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// 描画ブレンドモードの設定
static int SetDrawBlendModeHardware( int BlendMode, int AlphaTestValidFlag, int AlphaChannelValidFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( GRH.InitializeFlag == FALSE && GRH.BlendMode == BlendMode && GRH.AlphaTestValidFlag == AlphaTestValidFlag && GRH.AlphaChannelValidFlag == AlphaChannelValidFlag ) return 0 ;

	// 頂点の書き出し
	RenderVertexHardware() ;

	GRH.BlendMode             = BlendMode ;
	GRH.AlphaChannelValidFlag = AlphaChannelValidFlag ;
	GRH.AlphaTestValidFlag    = AlphaTestValidFlag ;
	GRH.DrawPrepAlwaysFlag    = TRUE ;

	// パラメータが変更された、フラグを立てる
	GRH.ChangeBlendParamFlag = TRUE ;

	return 0 ;
}

// 描画時の画像の色を無視するかどうかを設定する
static int	SetIgnoreDrawGraphColorHardware( int EnableFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( GRH.InitializeFlag == FALSE &&
		GRH.IgnoreGraphColorFlag == EnableFlag )
		return 0 ;

	// 頂点の書き出し
	RenderVertexHardware() ;

	GRH.IgnoreGraphColorFlag = EnableFlag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// パラメータが変更された、フラグを立てる
	GRH.ChangeBlendParamFlag = TRUE ;

	return 0 ;
}

// アルファテストの設定
static int  SetDrawAlphaTestHardware( int TestMode, int TestParam )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( GRH.InitializeFlag == FALSE && GRH.AlphaTestMode == TestMode && GRH.AlphaTestParam == TestParam ) return 0 ;

	// 頂点の書き出し
	RenderVertexHardware() ;

	GRH.AlphaTestMode  = TestMode ;
	GRH.AlphaTestParam = TestParam ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// パラメータが変更された、フラグを立てる
	GRH.ChangeBlendParamFlag = TRUE ;

	return 0 ;
}

// 描画対象の変更
extern int SetRenderTargetHardware( DX_DIRECT3DSURFACE9 *TargetSurface, int TargetIndex )
{
	D_D3DSURFACE_DESC SurfaceDesc ;
	HRESULT hr ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( TargetIndex < 0 || TargetIndex >= DX_RENDERTARGET_COUNT ) return -1 ;

	if( GRH.TargetSurface[ TargetIndex ] == TargetSurface && GRH.InitializeFlag == FALSE ) return 0 ;

	// 頂点書き出し
	RenderVertexHardware() ;

	// レンダリングターゲットの変更
	hr = GraphicsDevice_SetRenderTarget( TargetIndex, TargetSurface ) ;

	// レンダリングターゲットの保存
	GRH.TargetSurface[ TargetIndex ] = TargetSurface ;

	// ビューポートの設定値を更新
	if( TargetIndex == 0 )
	{
		GraphicsSurface_GetDesc( TargetSurface, &SurfaceDesc ) ; 
		SetViewportHardwareEasy( 0, 0, SurfaceDesc.Width, SurfaceDesc.Height ) ;
	}

	// 終了
	return  0 ;
}

// テクスチャステージステートを直接指定する( NULL で無効 )
extern int SetUserBlendInfo( DIRECT3DBLENDINFO *BlendInfo, int TextureStageIsTextureAndTextureCoordOnlyFlag )
{
	RenderVertexHardware() ;

	if( BlendInfo == NULL )
	{
		GRH.UserBlendInfoFlag = FALSE ;
	}
	else
	{
		GRH.UserBlendInfo = *BlendInfo ;
		GRH.UserBlendInfoTextureStageIsTextureAndTextureCoordOnlyFlag = TextureStageIsTextureAndTextureCoordOnlyFlag ;
		GRH.UserBlendInfoFlag = TRUE ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
		GRH.ChangeBlendParamFlag = TRUE ;
		GRH.ChangeTextureFlag = TRUE ;

		// ブレンドモード情報をリフレッシュ
		RefreshBlendStateHardware() ;
	}

	// 終了
	return 0 ;
}

// Ｚバッファの有効無効のセット
static int SetUseZBufferHardware( int Flag )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// フラグが同じだったら何もせず終了
	if( GRH.InitializeFlag == FALSE && GRH.EnableZBufferFlag == Flag ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// Ｚバッファの有効状態を変更
	GraphicsDevice_SetRenderState( D_D3DRS_ZENABLE, Flag == TRUE ? D_D3DZB_TRUE : D_D3DZB_FALSE ) ;
	GRH.EnableZBufferFlag = Flag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// Ｚバッファの書き込みの有無をセット
static int SetWriteZBufferHardware( int Flag )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// フラグが同じだったら何もせず終了
	if( GRH.InitializeFlag == FALSE && GRH.WriteZBufferFlag == Flag ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// Ｚバッファの書き込み状態を変更
	GraphicsDevice_SetRenderState( D_D3DRS_ZWRITEENABLE, Flag ) ;
	GRH.WriteZBufferFlag = Flag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// Ｚ値の比較タイプをセット
static int SetZBufferCmpTypeHardware( int CmpType )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// タイプが同じだったら何もせず終了
	if( GRH.InitializeFlag == FALSE && GRH.ZBufferCmpType == CmpType ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// Ｚ値の比較タイプを変更
	GraphicsDevice_SetRenderState( D_D3DRS_ZFUNC, CmpType ) ;
	GRH.ZBufferCmpType = CmpType ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// Ｚバイアスをセット
static int SetZBiasHardware( int Bias )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// バイアス値が同じだったら何もせず終了
	if( GRH.InitializeFlag == FALSE && GRH.ZBias == Bias ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// Ｚバイアスを変更
	GraphicsDevice_SetRenderState( D_D3DRS_DEPTHBIAS, Bias ) ;
	GRH.ZBias = Bias ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// フィルモードをセット
static int	SetFillModeHardware( int FillMode )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// フィルモードが同じだったら何もせず終了
	if( GRH.InitializeFlag == FALSE && GRH.FillMode == FillMode ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// フィルモードを変更
	GraphicsDevice_SetRenderState( D_D3DRS_FILLMODE, FillMode ) ;
	GRH.FillMode = FillMode ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// テクスチャをセットする 
__inline static int SetTextureHardware( DX_DIRECT3DTEXTURE9 * RenderTexture )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( RenderTexture == GRH.RenderTexture && GRH.InitializeFlag == FALSE ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// テクスチャが変更された、フラグを立てる
	GRH.ChangeTextureFlag = TRUE ;

	// テクスチャの有り無しが変更された場合はブレンドパラメータの変更も行うフラグもセットする
	if( ( GRH.RenderTexture == NULL && RenderTexture != NULL ) ||
		( GRH.RenderTexture != NULL && RenderTexture == NULL ) )
		GRH.ChangeBlendParamFlag = TRUE ;

	// テクスチャセット
	GRH.RenderTexture = RenderTexture ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// ブレンドするテクスチャをセットする 
__inline static int SetBlendTextureHardware( DX_DIRECT3DTEXTURE9 *BlendTexture, int TexWidth, int TexHeight )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( GRH.InitializeFlag == FALSE && BlendTexture == GRH.BlendTexture ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点の書き出し
		RenderVertexHardware() ;
	}

	// テクスチャが変更された、フラグを立てる
	GRH.ChangeTextureFlag = TRUE ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// ブレンドテクスチャの有り無しが変更された場合はブレンドパラメータの変更も行うフラグもセットする
	if( ( GRH.BlendTexture == NULL && BlendTexture != NULL ) ||
		( GRH.BlendTexture != NULL && BlendTexture == NULL ) )
		GRH.ChangeBlendParamFlag = TRUE ;

	// テクスチャセット
	GRH.BlendTexture = BlendTexture ;

	// テクスチャの幅と高さを保存
	if( BlendTexture != NULL )
	{
		GRH.BlendTextureWidth  = ( float )TexWidth  ;
		GRH.BlendTextureHeight = ( float )TexHeight ;
		GRH.InvBlendTextureWidth  = 1.0F / GRH.BlendTextureWidth ;
		GRH.InvBlendTextureHeight = 1.0F / GRH.BlendTextureHeight ;
	}

	// 終了
	return 0 ;
}

// ブレンドするテクスチャのパラメータをセットする
__inline static int SetBlendTextureParamHardware( int BlendType, int *Param )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// パラメータを保存
	switch( BlendType )
	{
	case DX_BLENDGRAPHTYPE_NORMAL :
		if( GRH.InitializeFlag == FALSE &&
			BlendType == GRH.BlendGraphType &&
			GRH.BlendGraphFadeRatio == Param[ 0 ] )
			return 0 ;

		if( GRH.InitializeFlag == FALSE )
		{
			// 頂点の書き出し
			RenderVertexHardware() ;
		}

		GRH.BlendGraphFadeRatio = Param[ 0 ] ;
		break;

	case DX_BLENDGRAPHTYPE_WIPE:
		if( GRH.InitializeFlag == FALSE &&
			BlendType == GRH.BlendGraphType &&
			GRH.BlendGraphBorderParam == Param[ 0 ] &&
			GRH.BlendGraphBorderRange == Param[ 1 ] )
			return 0 ;

		if( GRH.InitializeFlag == FALSE )
		{
			// 頂点の書き出し
			RenderVertexHardware() ;
		}

		GRH.BlendGraphBorderParam = Param[ 0 ] ;
		GRH.BlendGraphBorderRange = Param[ 1 ] ;
		break;

	case DX_BLENDGRAPHTYPE_ALPHA :
		if( GRH.InitializeFlag == FALSE &&
			BlendType == GRH.BlendGraphType )
			return 0 ;

		if( GRH.InitializeFlag == FALSE )
		{
			// 頂点の書き出し
			RenderVertexHardware() ;
		}
		break;
	}

	// ブレンドタイプを保存する
	GRH.BlendGraphType = BlendType ;

	// パラメータが変更された、フラグを立てる
	GRH.ChangeBlendParamFlag = TRUE ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// ディフューズカラーのα値を使用するかどうかフラグをセットする
static int SetUseDiffuseAlphaColorFlagHardware( int UseFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( UseFlag == GRH.UseDiffuseAlphaColor && GRH.InitializeFlag == FALSE ) return 0 ;

	// 頂点の書き出し
	RenderVertexHardware() ;

	// パラメータの保存
	GRH.UseDiffuseAlphaColor = UseFlag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// パラメータが変更された、フラグを立てる
	GRH.ChangeBlendParamFlag = TRUE ;

	// 終了
	return 0 ;
}

// ディフューズカラーのＲＧＢ値を使用するかどうかフラグをセットする
static int SetUseDiffuseRGBColorFlagHardware( int UseFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	if( UseFlag == GRH.UseDiffuseRGBColor && GRH.InitializeFlag == FALSE ) return 0 ;

	// 頂点の書き出し
	RenderVertexHardware() ;

	// パラメータの保存
	GRH.UseDiffuseRGBColor = UseFlag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// パラメータが変更された、フラグを立てる
	GRH.ChangeBlendParamFlag = TRUE ;

	// 終了
	return 0 ;
}

// 描画設定をリフレッシュ
static void RefreshRenderStateHardware()
{
	if( GraphicsDevice_IsValid() == 0 ) return ;

	// 初期化フラグを立てる
	GRH.InitializeFlag = TRUE ;

	// DrawPreparation を行うべきフラグを立てる
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 設定のリフレッシュ
	SetFogEnableHardware         ( GRH.FogEnable          ) ;
	SetViewportHardware          ( &GRH.Viewport          ) ;
	SetScissorRectHardware       ( &GRH.ScissorRect       ) ;
	SetTextureHardware			 ( GRH.RenderTexture      ) ;
	SetBaseHardwareState         (                        ) ;
	SetDrawModeHardware          ( GRH.DrawMode           ) ;
//	SetDrawBlendModeHardware     ( GRH.BlendMode, GRH.AlphaChannelValidFlag  ) ;
	RefreshBlendStateHardware    (                        ) ;
	SetUseZBufferHardware        ( GRH.EnableZBufferFlag  ) ;
	SetWriteZBufferHardware      ( GRH.WriteZBufferFlag   ) ;
	SetZBufferCmpTypeHardware    ( GRH.ZBufferCmpType     ) ;
	SetZBiasHardware             ( GRH.ZBias              ) ;
	SetFillModeHardware          ( GRH.FillMode           ) ;
	SetUseCullingHardware        ( GRH.CullMode           ) ;
	SetShadeModeHardware         ( GRH.ShadeMode          ) ;
	SetMaterialHardware          ( &GRH.Material          ) ;
	SetUseSpecularHardware       ( GRH.UseSpecular        ) ;
	SetMaterialUseVertexDiffuseColorHardware( GRH.MaterialUseVertexDiffuseColor ) ;
	SetMaterialUseVertexSpecularColorHardware( GRH.MaterialUseVertexSpecularColor ) ;

	if( GraphicsDevice_IsValid() != 0 )
	{
		GraphicsDevice_SetVertexShaderConstantF( 0, ( float * )GRH.ShaderConstantInfo.FixInfo[ DX_SHADERCONSTANTTYPE_VS_FLOAT ].Float4, 256 ) ;
		GraphicsDevice_SetVertexShaderConstantI( 0, ( int   * )GRH.ShaderConstantInfo.FixInfo[ DX_SHADERCONSTANTTYPE_VS_INT   ].Int4,   16  ) ;
		GraphicsDevice_SetVertexShaderConstantB( 0, ( BOOL  * )GRH.ShaderConstantInfo.FixInfo[ DX_SHADERCONSTANTTYPE_VS_BOOL  ].Bool,   16  ) ;

		GraphicsDevice_SetPixelShaderConstantF( 0, ( float * )GRH.ShaderConstantInfo.FixInfo[ DX_SHADERCONSTANTTYPE_PS_FLOAT ].Float4, 224 ) ;
		GraphicsDevice_SetPixelShaderConstantI( 0, ( int   * )GRH.ShaderConstantInfo.FixInfo[ DX_SHADERCONSTANTTYPE_PS_INT   ].Int4,   16  ) ;
		GraphicsDevice_SetPixelShaderConstantB( 0, ( BOOL  * )GRH.ShaderConstantInfo.FixInfo[ DX_SHADERCONSTANTTYPE_PS_BOOL  ].Bool,   16  ) ;
	}

	// 初期化フラグを倒す
	GRH.InitializeFlag = FALSE ;
}

// ワールド変換用行列をセットする
static int SetTransformToWorldHardware( const MATRIX *Matrix )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	GraphicsDevice_SetTransform( D_D3DTS_WORLDMATRIX( 0 ), ( D_D3DMATRIX * )Matrix ) ;

//	if( GRH.UseShader )
	{
		// 転置行列を頂点シェーダーにセットする
		MATRIX TransMat ;
		CreateTransposeMatrix( &TransMat, Matrix ) ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTF_WORLD_MAT_START,
			&TransMat,
			4,
			TRUE
		) ;
	}

	// 終了
	return 0 ;
}

// アンビエントライトとエミッシブカラーを掛け合わせたパラメータを更新する
void RefreshAmbientAndEmissiveParam()
{
	int i ;
	COLOR Result ;

	// 結果値を初期化
	Result.r = 0.0f ;
	Result.g = 0.0f ;
	Result.b = 0.0f ;
	Result.a = 0.0f ;

	// 有効なライトのアンビエントカラーとマテリアルのアンビエントカラーを乗算したものをシェーダーにセットする
	for( i = 0 ; i <= GRH.LightEnableMaxIndex ; i ++ )
	{
		if( GRH.LightEnableFlag[ i ] == FALSE ) continue ;
		Result.r = GRH.LightParam[ i ].Ambient.r * GRH.Material.Ambient.r ;
		Result.g = GRH.LightParam[ i ].Ambient.g * GRH.Material.Ambient.g ;
		Result.b = GRH.LightParam[ i ].Ambient.b * GRH.Material.Ambient.b ;
		Result.a = GRH.LightParam[ i ].Ambient.a * GRH.Material.Ambient.a ;

		// バーテックスシェーダーとピクセルシェーダーに反映する
		if( i < DX_VS_CONSTB_LIGHT_NUM )
		{
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_VS_FLOAT,
				DX_SHADERCONSTANTSET_LIB,
				DX_VS_CONSTF_LIGHT_START + DX_VS_CONSTF_LIGHT_UNITSIZE * i + DX_VS_CONSTF_LGT_AMBIENT,
				&Result,
				1,
				TRUE
			) ;
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_PS_FLOAT,
				DX_SHADERCONSTANTSET_LIB,
				DX_PS_CONSTF_LIGHT_START  + DX_PS_CONSTF_LIGHT_UNITSIZE  * i + DX_PS_CONSTF_LGT_AMBIENT,
				&Result,
				1,
				TRUE
			) ;
		}
		if( i < DX_PS_CONSTB_LIGHT2_NUM )
		{
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_PS_FLOAT,
				DX_SHADERCONSTANTSET_LIB,
				DX_PS_CONSTF_LIGHT2_START  + DX_PS_CONSTF_LIGHT2_UNITSIZE  * i + DX_PS_CONSTF_LGT2_AMBIENT,
				&Result,
				1,
				TRUE
			) ;
		}
	}

	// グローバルアンビエントライトカラーとマテリアルアンビエントカラーを乗算したものとエミッシブカラーを加算したものを作成する
	Result.r = GRH.GlobalAmbientLightColor.r * GRH.Material.Ambient.r + GRH.Material.Emissive.r ;
	Result.g = GRH.GlobalAmbientLightColor.g * GRH.Material.Ambient.g + GRH.Material.Emissive.g ;
	Result.b = GRH.GlobalAmbientLightColor.b * GRH.Material.Ambient.b + GRH.Material.Emissive.b ;
	Result.a = GRH.GlobalAmbientLightColor.a * GRH.Material.Ambient.a + GRH.Material.Emissive.a ;

	// バーテックスシェーダーとピクセルシェーダーに反映する
	SetShaderConstantSet(
		&GRH.ShaderConstantInfo,
		DX_SHADERCONSTANTTYPE_VS_FLOAT,
		DX_SHADERCONSTANTSET_LIB,
		DX_VS_CONSTF_AMBIENT_EMISSIVE,
		&Result,
		1,
		TRUE
	) ;
	SetShaderConstantSet(
		&GRH.ShaderConstantInfo,
		DX_SHADERCONSTANTTYPE_PS_FLOAT,
		DX_SHADERCONSTANTSET_LIB,
		DX_PS_CONSTF_AMBIENT_EMISSIVE,
		&Result,
		1,
		TRUE
	) ;
}

// 使用するシェーダーのインデックスの値を更新する
static void RefreshUseShaderIndex()
{
	int LightMode[ DX_PS_CONSTB_LIGHT2_NUM ] ;
	int PhongValid ;
	int i ;
	int UseShadowMap ;

	if( GRH.UseShader == FALSE ) return ;

	PhongValid = 0 ;
	LightMode[ 0 ] = 0 ;
	LightMode[ 1 ] = 0 ;
	LightMode[ 2 ] = 0 ;
	LightMode[ 3 ] = 0 ;
	LightMode[ 4 ] = 0 ;
	LightMode[ 5 ] = 0 ;
	GRH.UseOnlyPixelLightingTypeCode = FALSE ;
	if( GRH.LightFlag )
	{
		for( i = 0 ; i < DX_PS_CONSTB_LIGHT2_NUM ; i ++ )
		{
			if( GRH.LightEnableFlag[ i ] )
			{
				LightMode[ i ] = GRH.LightParam[ i ].Type ;
				PhongValid = 1 ;

				// 頂点単位ライティングではライトは３つまでしか対応していない
				if( i >= 3 )
				{
					GRH.UseOnlyPixelLightingTypeCode = TRUE ;
				}
			}
		}
	}

	UseShadowMap = FALSE ;
	for( i = 0 ; i < MAX_USE_SHADOWMAP_NUM ; i ++ )
	{
		if( GBASE.ShadowMap[ i ] > 0 )
		{
			UseShadowMap = TRUE ;
			break ;
		}
	}

	GRH.UseBaseVertexShaderIndex =
		VERTEXSHADER_TYPE( GRH.ShadowMapDraw ? VERTEXSHADER_TYPE_DRAW_SHADOWMAP : VERTEXSHADER_TYPE_NORMAL ) +
		VERTEXSHADER_SHADOWMAP( UseShadowMap ? 1 : 0 ) +
		VERTEXSHADER_FOGMODE( GRH.FogEnable ? GRH.FogMode : DX_FOGMODE_NONE ) +
		VERTEXSHADER_LIGHTINDEX( GRA2.LightIndexList20[ LightMode[ 0 ] ][ LightMode[ 1 ] ][ LightMode[ 2 ] ] )
	;

	GRH.UseBasePixelShaderIndex =
		PIXELSHADER_TYPE( GRH.ShadowMapDraw ? PIXELSHADER_TYPE_DRAW_SHADOWMAP : PIXELSHADER_TYPE_NORMAL ) +
		PIXELSHADER_SHADOWMAP( UseShadowMap ? 1 : 0 ) +
		PIXELSHADER_LIGHTINDEX( 
			GRA2.LightIndexList10
				[ LightMode[ 0 ] == DX_LIGHTTYPE_D3DLIGHT_DIRECTIONAL ? 2 : ( LightMode[ 0 ] ? 1 : 0 ) ]
				[ LightMode[ 1 ] == DX_LIGHTTYPE_D3DLIGHT_DIRECTIONAL ? 2 : ( LightMode[ 1 ] ? 1 : 0 ) ]
				[ LightMode[ 2 ] == DX_LIGHTTYPE_D3DLIGHT_DIRECTIONAL ? 2 : ( LightMode[ 2 ] ? 1 : 0 ) ] 
		)
	;

	GRH.UseBaseVertexShaderIndex_PL =
		PIXELLIGHTING_VERTEXSHADER_FOGMODE( GRH.FogEnable ? GRH.FogMode : DX_FOGMODE_NONE ) +
		PIXELLIGHTING_VERTEXSHADER_SHADOWMAP( UseShadowMap ? 1 : 0 )
	;

	GRH.UseBasePixelShaderIndex_PL =
		PIXELLIGHTING_PIXELSHADER_LIGHTINDEX( GRA2.LightIndexList84[ LightMode[ 0 ] ][ LightMode[ 1 ] ][ LightMode[ 2 ] ][ LightMode[ 3 ] ][ LightMode[ 4 ] ][ LightMode[ 5 ] ] ) +
		PIXELLIGHTING_PIXELSHADER_SHADOWMAP( UseShadowMap ? 1 : 0 )
	;
}

// ビュー変換用行列をセットする
static int SetTransformToViewHardware( const MATRIX *Matrix )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	GraphicsDevice_SetTransform( D_D3DTS_VIEW, ( D_D3DMATRIX * )Matrix ) ;

//	if( GRH.UseShader )
	{
		int i ;
		VECTOR Dir, Pos ;
		float Data[ 2 ][ 4 ] ;
		MATRIX RotateTransMat ;

		// 転置行列を頂点シェーダーにセットする
		MATRIX TransMat ;
		CreateTransposeMatrix( &TransMat, Matrix ) ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTF_VIEW_MAT,
			&TransMat,
			4,
			TRUE
		) ;

		// ライトの位置・方向の再計算
		RotateTransMat = *Matrix ;
		RotateTransMat.m[ 3 ][ 0 ] = 0.0f ;
		RotateTransMat.m[ 3 ][ 1 ] = 0.0f ;
		RotateTransMat.m[ 3 ][ 2 ] = 0.0f ;
		for( i = 0 ; i < DX_PS_CONSTB_LIGHT2_NUM ; i ++ )
		{
			VectorTransform( &Dir, &GRH.LightParam[ i ].Direction, &RotateTransMat ) ;
			VectorTransform( &Pos, &GRH.LightParam[ i ].Position,  &GBASE.ViewMatrix ) ;
			Data[ 0 ][ 0 ] = Pos.x ;
			Data[ 0 ][ 1 ] = Pos.y ;
			Data[ 0 ][ 2 ] = Pos.z ;
			Data[ 0 ][ 3 ] = 1.0f ;
			Data[ 1 ][ 0 ] = Dir.x ;
			Data[ 1 ][ 1 ] = Dir.y ;
			Data[ 1 ][ 2 ] = Dir.z ;
			Data[ 1 ][ 3 ] = 0.0f ;
			if( i < DX_VS_CONSTF_LIGHT_NUM )
			{
				SetShaderConstantSet(
					&GRH.ShaderConstantInfo,
					DX_SHADERCONSTANTTYPE_VS_FLOAT,
					DX_SHADERCONSTANTSET_LIB,
					DX_VS_CONSTF_LIGHT_START + i * DX_VS_CONSTF_LIGHT_UNITSIZE,
					Data[ 0 ],
					2,
					TRUE
				) ;
			}
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_PS_FLOAT,
				DX_SHADERCONSTANTSET_LIB,
				DX_PS_CONSTF_LIGHT2_START + i * DX_PS_CONSTF_LIGHT2_UNITSIZE,
				Data[ 0 ],
				2,
				TRUE
			) ;
		}
	}

	// 終了
	return 0 ;
}


// 投影変換用行列をセットする
static int SetTransformToProjectionHardware( const MATRIX *Matrix )
{
	MATRIX TransMat ;

	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	GraphicsDevice_SetTransform( D_D3DTS_PROJECTION, ( D_D3DMATRIX * )Matrix ) ;

	// 転置行列を頂点シェーダーにセットする
//	if( GRH.UseShader )
	{
		CreateTransposeMatrix( &TransMat, Matrix ) ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTF_PROJECTION_MAT,
			&TransMat,
			4,
			TRUE
		) ;
	}

	// 終了
	return 0 ;
}


// ライトのセット
static int SetLightHardware( int LightNumber, LIGHT *Light )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// バッファにたまった頂点を書き出す
	RenderVertexHardware() ;

	// パラメータの保存
	if( LightNumber < 256 && LightNumber >= 0 )
	{
		GRH.LightParam[ LightNumber ] = *Light ;
	}

	// バーテックスシェーダーとピクセルシェーダーにも反映する
//	if( GRH.UseShader )
	{
		if( LightNumber < DX_PS_CONSTB_LIGHT2_NUM )
		{
			float Data[ 7 ][ 4 ] ;
			float ThetaSin, ThetaCos ;
			float PhiSin, PhiCos ;
			VECTOR Dir, Pos ;

			Dir = VTransformSR( Light->Direction, GBASE.ViewMatrix ) ;
			Pos = VTransform(   Light->Position,  GBASE.ViewMatrix ) ;
			Data[ 0 ][ 0 ] = Pos.x ;
			Data[ 0 ][ 1 ] = Pos.y ;
			Data[ 0 ][ 2 ] = Pos.z ;
			Data[ 0 ][ 3 ] = 1.0f ;
			Data[ 1 ][ 0 ] = Dir.x ;
			Data[ 1 ][ 1 ] = Dir.y ;
			Data[ 1 ][ 2 ] = Dir.z ;
			Data[ 1 ][ 3 ] = 0.0f ;
			Data[ 2 ][ 0 ] = Light->Diffuse.r ;
			Data[ 2 ][ 1 ] = Light->Diffuse.g ;
			Data[ 2 ][ 2 ] = Light->Diffuse.b ;
			Data[ 2 ][ 3 ] = Light->Diffuse.a ;
			Data[ 3 ][ 0 ] = Light->Specular.r ;
			Data[ 3 ][ 1 ] = Light->Specular.g ;
			Data[ 3 ][ 2 ] = Light->Specular.b ;
			Data[ 3 ][ 3 ] = Light->Specular.a ;
			Data[ 4 ][ 0 ] = Light->Ambient.r ;
			Data[ 4 ][ 1 ] = Light->Ambient.g ;
			Data[ 4 ][ 2 ] = Light->Ambient.b ;
			Data[ 4 ][ 3 ] = Light->Ambient.a ;
			Data[ 5 ][ 0 ] = Light->Range * Light->Range ;
			Data[ 5 ][ 1 ] = Light->Falloff ;
			Data[ 5 ][ 2 ] = Light->Attenuation0 ;
			Data[ 5 ][ 3 ] = Light->Attenuation1 ;
			Data[ 6 ][ 0 ] = Light->Attenuation2 ;
			_SINCOS( Light->Theta / 2.0f, &ThetaSin, &ThetaCos ) ;
			_SINCOS( Light->Phi / 2.0f, &PhiSin, &PhiCos ) ;
			Data[ 6 ][ 1 ] = PhiCos ;
			Data[ 6 ][ 2 ] = 1.0f / ( ThetaCos - PhiCos ) ;
			Data[ 6 ][ 3 ] = 0.0f ;
			if( LightNumber < DX_VS_CONSTF_LIGHT_NUM )
			{
				SetShaderConstantSet(
					&GRH.ShaderConstantInfo,
					DX_SHADERCONSTANTTYPE_VS_FLOAT,
					DX_SHADERCONSTANTSET_LIB,
					DX_VS_CONSTF_LIGHT_START + LightNumber * DX_VS_CONSTF_LIGHT_UNITSIZE,
					Data[ 0 ],
					DX_VS_CONSTF_LIGHT_UNITSIZE,
					TRUE
				) ;
				SetShaderConstantSet(
					&GRH.ShaderConstantInfo,
					DX_SHADERCONSTANTTYPE_PS_FLOAT,
					DX_SHADERCONSTANTSET_LIB,
					DX_PS_CONSTF_LIGHT_START  + LightNumber * DX_PS_CONSTF_LIGHT_UNITSIZE,
					Data[ 2 ],
					DX_PS_CONSTF_LIGHT_UNITSIZE,
					TRUE
				) ;
			}
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_PS_FLOAT,
				DX_SHADERCONSTANTSET_LIB,
				DX_PS_CONSTF_LIGHT2_START + LightNumber * DX_PS_CONSTF_LIGHT2_UNITSIZE,
				Data[ 0 ],
				DX_PS_CONSTF_LIGHT2_UNITSIZE,
				TRUE
			) ;

			// アンビエントカラーとエミッシブカラーを掛け合わせた情報を更新する
			RefreshAmbientAndEmissiveParam() ;
		}

		if( LightNumber < DX_VS_CONSTB_LIGHT_NUM )
		{
			BOOL BData[ 2 ] ;
			BData[ 0 ] = Light->Type == D_D3DLIGHT_SPOT || Light->Type == D_D3DLIGHT_POINT ;
			BData[ 1 ] = Light->Type == D_D3DLIGHT_SPOT ;
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_VS_BOOL,
				DX_SHADERCONSTANTSET_LIB,
				DX_VS_CONSTB_LIGHT_START + LightNumber * DX_VS_CONSTB_LIGHT_UNITSIZE + DX_VS_CONSTB_LGT_POINT_OR_SPOT,
				BData,
				2,
				TRUE
			) ;
		}

		// 使用するシェーダーのインデックスを更新する
		RefreshUseShaderIndex() ;
	}

	return GraphicsDevice_SetLight( LightNumber, ( D_D3DLIGHT9 * )Light ) == D_D3D_OK ? 0 : -1 ;
}

// ライトの有効、無効を変更
static int SetLightEnableHardware( int LightNumber, int EnableState )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// バッファにたまった頂点を書き出す
	RenderVertexHardware() ;

	if( LightNumber < 256 )
	{
		GRH.LightEnableFlag[ LightNumber ] = EnableState ;

		// 有効なライトの最大インデックスを更新
		if( EnableState == TRUE )
		{
			if( GRH.LightEnableMaxIndex < LightNumber )
				GRH.LightEnableMaxIndex = LightNumber ;
		}
		else
		{
			if( GRH.LightEnableMaxIndex == LightNumber )
			{
				int i ;

				for( i = LightNumber ; i > 0 && GRH.LightEnableFlag[ i ] == FALSE ; i -- ){}
				GRH.LightEnableMaxIndex = i ;
			}
		}

		// アンビエントカラーとエミッシブカラーを掛け合わせた情報を更新する
		RefreshAmbientAndEmissiveParam() ;
	}

	if( GRH.UseShader == TRUE && LightNumber < DX_VS_CONSTB_LIGHT_NUM )
	{
		BOOL BData ;
		BData = EnableState ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_BOOL,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTB_LIGHT_START + LightNumber * DX_VS_CONSTB_LIGHT_UNITSIZE + DX_VS_CONSTB_LGT_USE,
			&BData,
			1,
			TRUE
		) ;
	}

	// 使用するシェーダーのインデックスを更新する
	RefreshUseShaderIndex() ;

	return GraphicsDevice_LightEnable( LightNumber, EnableState ) == D_D3D_OK ? 0 : -1 ;
}


// マテリアルのセット
static int SetMaterialHardware( MATERIAL *Material )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// 既存のパラメータと同じ場合は何もしない
	if( GRH.InitializeFlag == FALSE &&
		*( ( DWORD * )&GRH.Material.Ambient.a )  == *( ( DWORD * )&Material->Ambient.a  ) &&
		*( ( DWORD * )&GRH.Material.Ambient.r )  == *( ( DWORD * )&Material->Ambient.r  ) &&
		*( ( DWORD * )&GRH.Material.Ambient.g )  == *( ( DWORD * )&Material->Ambient.g  ) &&
		*( ( DWORD * )&GRH.Material.Ambient.b )  == *( ( DWORD * )&Material->Ambient.b  ) &&
		*( ( DWORD * )&GRH.Material.Diffuse.a )  == *( ( DWORD * )&Material->Diffuse.a  ) &&
		*( ( DWORD * )&GRH.Material.Diffuse.r )  == *( ( DWORD * )&Material->Diffuse.r  ) &&
		*( ( DWORD * )&GRH.Material.Diffuse.g )  == *( ( DWORD * )&Material->Diffuse.g  ) &&
		*( ( DWORD * )&GRH.Material.Diffuse.b )  == *( ( DWORD * )&Material->Diffuse.b  ) &&
		*( ( DWORD * )&GRH.Material.Emissive.a ) == *( ( DWORD * )&Material->Emissive.a ) &&
		*( ( DWORD * )&GRH.Material.Emissive.r ) == *( ( DWORD * )&Material->Emissive.r ) &&
		*( ( DWORD * )&GRH.Material.Emissive.g ) == *( ( DWORD * )&Material->Emissive.g ) &&
		*( ( DWORD * )&GRH.Material.Emissive.b ) == *( ( DWORD * )&Material->Emissive.b ) &&
		*( ( DWORD * )&GRH.Material.Specular.a ) == *( ( DWORD * )&Material->Specular.a ) &&
		*( ( DWORD * )&GRH.Material.Specular.r ) == *( ( DWORD * )&Material->Specular.r ) &&
		*( ( DWORD * )&GRH.Material.Specular.g ) == *( ( DWORD * )&Material->Specular.g ) &&
		*( ( DWORD * )&GRH.Material.Specular.b ) == *( ( DWORD * )&Material->Specular.b ) &&
		*( ( DWORD * )&GRH.Material.Power )      == *( ( DWORD * )&Material->Power      ) )
		return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// パラメータを保存
	GRH.Material = *Material ;

	// バーテックスシェーダーとピクセルシェーダーにも反映する
//	if( GRH.UseShader )
	{
		float Data[ 3 ][ 4 ] ;

		Data[ 0 ][ 0 ] = Material->Diffuse.r ;
		Data[ 0 ][ 1 ] = Material->Diffuse.g ;
		Data[ 0 ][ 2 ] = Material->Diffuse.b ;
		Data[ 0 ][ 3 ] = Material->Diffuse.a ;
		Data[ 1 ][ 0 ] = Material->Specular.r ;
		Data[ 1 ][ 1 ] = Material->Specular.g ;
		Data[ 1 ][ 2 ] = Material->Specular.b ;
		Data[ 1 ][ 3 ] = Material->Specular.a ;
		Data[ 2 ][ 0 ] = Material->Power ;
		Data[ 2 ][ 1 ] = 0.0f ;
		Data[ 2 ][ 2 ] = 0.0f ;
		Data[ 2 ][ 3 ] = 0.0f ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTF_MATERIAL_START,
			Data[ 0 ],
			DX_VS_CONSTF_MATERIAL_SIZE,
			TRUE
		) ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_PS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_PS_CONSTF_MATERIAL_START,
			Data[ 0 ],
			DX_PS_CONSTF_MATERIAL_SIZE,
			TRUE
		) ;

		// アンビエントカラーとエミッシブカラーを掛け合わせたものを更新
		RefreshAmbientAndEmissiveParam() ;
	}

	return GraphicsDevice_SetMaterial( ( D_D3DMATERIAL9 * )Material ) == D_D3D_OK ? 0 : -1 ;
}

// スペキュラを使用するかどうかをセット
static int SetUseSpecularHardware( int UseFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// 既存のパラメータと同じ場合は何もしない
	if( GRH.UseSpecular == UseFlag && GRH.InitializeFlag == FALSE ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// パラメータを保存
	GRH.UseSpecular = UseFlag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	return GraphicsDevice_SetRenderState( D_D3DRS_SPECULARENABLE, UseFlag ) == D_D3D_OK ? 0 : -1 ;
}

// 頂点のディフューズカラーをマテリアルのディフューズカラーとして使用するかどうかを設定する
static int SetMaterialUseVertexDiffuseColorHardware( int UseFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// 既存のパラメータと同じ場合は何もしない
	if( GRH.MaterialUseVertexDiffuseColor == UseFlag && GRH.InitializeFlag == FALSE ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// パラメータを保存
	GRH.MaterialUseVertexDiffuseColor = UseFlag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// バーテックスシェーダーに反映する
//	if( GRH.UseShader )
	{
		float Data[ 4 ] ;

		Data[ 0 ] = GRH.MaterialUseVertexDiffuseColor  ? 1.0f : 0.0f ;
		Data[ 1 ] = GRH.MaterialUseVertexSpecularColor ? 1.0f : 0.0f ;
		Data[ 2 ] = 0.0f ;
		Data[ 3 ] = 0.0f ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTF_DIF_SPE_SOURCE,
			Data,
			1,
			TRUE
		) ;
	}

	return GraphicsDevice_SetRenderState( D_D3DRS_DIFFUSEMATERIALSOURCE, UseFlag ? D_D3DMCS_COLOR1 : D_D3DMCS_MATERIAL ) == D_D3D_OK ? 0 : -1 ;
}

// 頂点のスペキュラカラーをマテリアルのスペキュラカラーとして使用するかどうかを設定する
static int SetMaterialUseVertexSpecularColorHardware( int UseFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// 既存のパラメータと同じ場合は何もしない
	if( GRH.MaterialUseVertexSpecularColor == UseFlag && GRH.InitializeFlag == FALSE ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// パラメータを保存
	GRH.MaterialUseVertexSpecularColor = UseFlag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// バーテックスシェーダーに反映する
//	if( GRH.UseShader )
	{
		float Data[ 4 ] ;

		Data[ 0 ] = GRH.MaterialUseVertexDiffuseColor  ? 1.0f : 0.0f ;
		Data[ 1 ] = GRH.MaterialUseVertexSpecularColor ? 1.0f : 0.0f ;
		Data[ 2 ] = 0.0f ;
		Data[ 3 ] = 0.0f ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTF_DIF_SPE_SOURCE,
			Data,
			1,
			TRUE
		) ;
	}

	return GraphicsDevice_SetRenderState( D_D3DRS_SPECULARMATERIALSOURCE, UseFlag ? D_D3DMCS_COLOR2 : D_D3DMCS_MATERIAL ) == D_D3D_OK ? 0 : -1 ;
}

// カリングの有無をセット 
static int SetUseCullingHardware( int State )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// モードが同じだったら何もせず終了
	if( GRH.InitializeFlag == FALSE && GRH.CullMode == State ) return 0 ;
	
	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	// カリングの設定を変更
	GraphicsDevice_SetRenderState( D_D3DRS_CULLMODE, State == 2 ? D_D3DCULL_CW : ( State ? D_D3DCULL_CCW : D_D3DCULL_NONE ) ) == D_D3D_OK ? 0 : -1 ;
	GRH.CullMode = State;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0;
}

// アンビエントカラーのセット
static int SetAmbientColorHardware( int Color )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// バッファにたまった頂点を書き出す
	RenderVertexHardware() ;

	// アンビエントカラーを保存する
	GRH.GlobalAmbientLightColor.r = ( float )( ( DWORD )( Color >> 16 ) & 0xff ) / 255.0f ;
	GRH.GlobalAmbientLightColor.g = ( float )( ( DWORD )( Color >>  8 ) & 0xff ) / 255.0f ;
	GRH.GlobalAmbientLightColor.b = ( float )( ( DWORD )( Color >>  0 ) & 0xff ) / 255.0f ;
	GRH.GlobalAmbientLightColor.a = ( float )( ( DWORD )( Color >> 24 ) & 0xff ) / 255.0f ;

	// アンビエントライトとエミッシブカラーを掛け合わせたパラメータを更新する
	RefreshAmbientAndEmissiveParam() ;

	return GraphicsDevice_SetRenderState( D_D3DRS_AMBIENT, ( DWORD )Color ) == D_D3D_OK ? 0 : -1 ;
}

// シェーディングモードのセット
static int SetShadeModeHardware( int ShadeMode )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( GRH.ShadeMode == ShadeMode && GRH.InitializeFlag == FALSE ) return 0 ;

	GRH.ShadeMode = ShadeMode ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 頂点書き出し
		RenderVertexHardware() ;
	}

	return GraphicsDevice_SetRenderState( D_D3DRS_SHADEMODE, ShadeMode ) == D_D3D_OK ? 0 : -1 ;
}

// テクスチャーのアドレッシングモードをセットする
static int SetTextureAddressHardware( int AddressMode, int Stage )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( Stage == -1 )
	{
		if( AddressMode == GRH.TexAddressModeU[  0 ] && AddressMode == GRH.TexAddressModeV[  0 ] && AddressMode == GRH.TexAddressModeW[  0 ] &&
			AddressMode == GRH.TexAddressModeU[  1 ] && AddressMode == GRH.TexAddressModeV[  1 ] && AddressMode == GRH.TexAddressModeW[  1 ] &&
			AddressMode == GRH.TexAddressModeU[  2 ] && AddressMode == GRH.TexAddressModeV[  2 ] && AddressMode == GRH.TexAddressModeW[  2 ] &&
			AddressMode == GRH.TexAddressModeU[  3 ] && AddressMode == GRH.TexAddressModeV[  3 ] && AddressMode == GRH.TexAddressModeW[  3 ] &&
			AddressMode == GRH.TexAddressModeU[  4 ] && AddressMode == GRH.TexAddressModeV[  4 ] && AddressMode == GRH.TexAddressModeW[  4 ] &&
			AddressMode == GRH.TexAddressModeU[  5 ] && AddressMode == GRH.TexAddressModeV[  5 ] && AddressMode == GRH.TexAddressModeW[  5 ] &&
			AddressMode == GRH.TexAddressModeU[  6 ] && AddressMode == GRH.TexAddressModeV[  6 ] && AddressMode == GRH.TexAddressModeW[  6 ] &&
			AddressMode == GRH.TexAddressModeU[  7 ] && AddressMode == GRH.TexAddressModeV[  7 ] && AddressMode == GRH.TexAddressModeW[  7 ] &&
			AddressMode == GRH.TexAddressModeU[  8 ] && AddressMode == GRH.TexAddressModeV[  8 ] && AddressMode == GRH.TexAddressModeW[  8 ] &&
			AddressMode == GRH.TexAddressModeU[  9 ] && AddressMode == GRH.TexAddressModeV[  9 ] && AddressMode == GRH.TexAddressModeW[  9 ] &&
			AddressMode == GRH.TexAddressModeU[ 10 ] && AddressMode == GRH.TexAddressModeV[ 10 ] && AddressMode == GRH.TexAddressModeW[ 10 ] &&
			AddressMode == GRH.TexAddressModeU[ 11 ] && AddressMode == GRH.TexAddressModeV[ 11 ] && AddressMode == GRH.TexAddressModeW[ 11 ] &&
			GRH.InitializeFlag == FALSE ) return 0 ;

		RenderVertexHardware() ;

		GRH.TexAddressModeU[ 0 ] = AddressMode ;
		GRH.TexAddressModeU[ 1 ] = AddressMode ;
		GRH.TexAddressModeU[ 2 ] = AddressMode ;
		GRH.TexAddressModeU[ 3 ] = AddressMode ;
		GRH.TexAddressModeU[ 4 ] = AddressMode ;
		GRH.TexAddressModeU[ 5 ] = AddressMode ;
		GRH.TexAddressModeU[ 6 ] = AddressMode ;
		GRH.TexAddressModeU[ 7 ] = AddressMode ;
		GRH.TexAddressModeU[ 8 ] = AddressMode ;
		GRH.TexAddressModeU[ 9 ] = AddressMode ;
		GRH.TexAddressModeU[ 10 ] = AddressMode ;
		GRH.TexAddressModeU[ 11 ] = AddressMode ;

		GRH.TexAddressModeV[ 0 ] = AddressMode ;
		GRH.TexAddressModeV[ 1 ] = AddressMode ;
		GRH.TexAddressModeV[ 2 ] = AddressMode ;
		GRH.TexAddressModeV[ 3 ] = AddressMode ;
		GRH.TexAddressModeV[ 4 ] = AddressMode ;
		GRH.TexAddressModeV[ 5 ] = AddressMode ;
		GRH.TexAddressModeV[ 6 ] = AddressMode ;
		GRH.TexAddressModeV[ 7 ] = AddressMode ;
		GRH.TexAddressModeV[ 8 ] = AddressMode ;
		GRH.TexAddressModeV[ 9 ] = AddressMode ;
		GRH.TexAddressModeV[ 10 ] = AddressMode ;
		GRH.TexAddressModeV[ 11 ] = AddressMode ;

		GRH.TexAddressModeW[ 0 ] = AddressMode ;
		GRH.TexAddressModeW[ 1 ] = AddressMode ;
		GRH.TexAddressModeW[ 2 ] = AddressMode ;
		GRH.TexAddressModeW[ 3 ] = AddressMode ;
		GRH.TexAddressModeW[ 4 ] = AddressMode ;
		GRH.TexAddressModeW[ 5 ] = AddressMode ;
		GRH.TexAddressModeW[ 6 ] = AddressMode ;
		GRH.TexAddressModeW[ 7 ] = AddressMode ;
		GRH.TexAddressModeW[ 8 ] = AddressMode ;
		GRH.TexAddressModeW[ 9 ] = AddressMode ;
		GRH.TexAddressModeW[ 10 ] = AddressMode ;
		GRH.TexAddressModeW[ 11 ] = AddressMode ;

		GRH.DrawPrepAlwaysFlag = TRUE ;

		GraphicsDevice_SetSamplerState( 11, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 11, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 11, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 10, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 10, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 10, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 9, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 9, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 9, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 8, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 8, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 8, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 7, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 7, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 7, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 6, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 6, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 6, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 5, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 5, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 5, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 4, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 4, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 4, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 3, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 3, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 3, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 2, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 2, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 2, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 1, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 1, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 1, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 0, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 0, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		return GraphicsDevice_SetSamplerState( 0, D_D3DSAMP_ADDRESSW, AddressMode ) == D_D3D_OK ? 0 : -1 ;
	}
	else
	{
		if( Stage < 0 || Stage >= USE_TEXTURESTAGE_NUM ) return -1 ;
		if( AddressMode == GRH.TexAddressModeU[ Stage ] &&
			AddressMode == GRH.TexAddressModeV[ Stage ] &&
			AddressMode == GRH.TexAddressModeW[ Stage ] && GRH.InitializeFlag == FALSE ) return 0 ;

		RenderVertexHardware() ;

		GRH.TexAddressModeU[ Stage ] = AddressMode ;
		GRH.TexAddressModeV[ Stage ] = AddressMode ;
		GRH.TexAddressModeW[ Stage ] = AddressMode ;

		GRH.DrawPrepAlwaysFlag = TRUE ;

		GraphicsDevice_SetSamplerState( Stage, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( Stage, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		return GraphicsDevice_SetSamplerState( Stage, D_D3DSAMP_ADDRESSW, AddressMode ) == D_D3D_OK ? 0 : -1 ;
	}
}

// テクスチャーのアドレッシングモードをセットする
static int SetTextureAddressUHardware( int AddressMode, int Stage )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( Stage == -1 )
	{
		if( AddressMode == GRH.TexAddressModeU[ 0 ] &&
			AddressMode == GRH.TexAddressModeU[ 1 ] &&
			AddressMode == GRH.TexAddressModeU[ 2 ] &&
			AddressMode == GRH.TexAddressModeU[ 3 ] &&
			AddressMode == GRH.TexAddressModeU[ 4 ] &&
			AddressMode == GRH.TexAddressModeU[ 5 ] &&
			AddressMode == GRH.TexAddressModeU[ 6 ] &&
			AddressMode == GRH.TexAddressModeU[ 7 ] &&
			AddressMode == GRH.TexAddressModeU[ 8 ] &&
			AddressMode == GRH.TexAddressModeU[ 9 ] &&
			AddressMode == GRH.TexAddressModeU[ 10 ] &&
			AddressMode == GRH.TexAddressModeU[ 11 ] &&
			GRH.InitializeFlag == FALSE ) return 0 ;

		RenderVertexHardware() ;

		GRH.TexAddressModeU[ 0 ] = AddressMode ;
		GRH.TexAddressModeU[ 1 ] = AddressMode ;
		GRH.TexAddressModeU[ 2 ] = AddressMode ;
		GRH.TexAddressModeU[ 3 ] = AddressMode ;
		GRH.TexAddressModeU[ 4 ] = AddressMode ;
		GRH.TexAddressModeU[ 5 ] = AddressMode ;
		GRH.TexAddressModeU[ 6 ] = AddressMode ;
		GRH.TexAddressModeU[ 7 ] = AddressMode ;
		GRH.TexAddressModeU[ 8 ] = AddressMode ;
		GRH.TexAddressModeU[ 9 ] = AddressMode ;
		GRH.TexAddressModeU[ 10 ] = AddressMode ;
		GRH.TexAddressModeU[ 11 ] = AddressMode ;
		GRH.DrawPrepAlwaysFlag = TRUE ;

		GraphicsDevice_SetSamplerState( 11, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 10, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 9, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 8, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 7, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 6, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 5, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 4, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 3, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 2, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 1, D_D3DSAMP_ADDRESSU, AddressMode ) ;
		return GraphicsDevice_SetSamplerState( 0, D_D3DSAMP_ADDRESSU, AddressMode ) == D_D3D_OK ? 0 : -1 ;
	}
	else
	{
		if( Stage < 0 || Stage >= USE_TEXTURESTAGE_NUM ) return -1 ;
		if( AddressMode == GRH.TexAddressModeU[ Stage ] && GRH.InitializeFlag == FALSE ) return 0 ;

		RenderVertexHardware() ;

		GRH.TexAddressModeU[ Stage ] = AddressMode ;
		GRH.DrawPrepAlwaysFlag = TRUE ;

		return GraphicsDevice_SetSamplerState( Stage, D_D3DSAMP_ADDRESSU, AddressMode ) == D_D3D_OK ? 0 : -1 ;
	}
}

// テクスチャーのアドレッシングモードをセットする
static int SetTextureAddressVHardware( int AddressMode, int Stage )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( Stage == -1 )
	{
		if( AddressMode == GRH.TexAddressModeV[ 0 ] &&
			AddressMode == GRH.TexAddressModeV[ 1 ] &&
			AddressMode == GRH.TexAddressModeV[ 2 ] &&
			AddressMode == GRH.TexAddressModeV[ 3 ] &&
			AddressMode == GRH.TexAddressModeV[ 4 ] &&
			AddressMode == GRH.TexAddressModeV[ 5 ] &&
			AddressMode == GRH.TexAddressModeV[ 6 ] &&
			AddressMode == GRH.TexAddressModeV[ 7 ] &&
			AddressMode == GRH.TexAddressModeV[ 8 ] &&
			AddressMode == GRH.TexAddressModeV[ 9 ] &&
			AddressMode == GRH.TexAddressModeV[ 10 ] &&
			AddressMode == GRH.TexAddressModeV[ 11 ] &&
			GRH.InitializeFlag == FALSE ) return 0 ;

		RenderVertexHardware() ;

		GRH.TexAddressModeV[ 0 ] = AddressMode ;
		GRH.TexAddressModeV[ 1 ] = AddressMode ;
		GRH.TexAddressModeV[ 2 ] = AddressMode ;
		GRH.TexAddressModeV[ 3 ] = AddressMode ;
		GRH.TexAddressModeV[ 4 ] = AddressMode ;
		GRH.TexAddressModeV[ 5 ] = AddressMode ;
		GRH.TexAddressModeV[ 6 ] = AddressMode ;
		GRH.TexAddressModeV[ 7 ] = AddressMode ;
		GRH.TexAddressModeV[ 8 ] = AddressMode ;
		GRH.TexAddressModeV[ 9 ] = AddressMode ;
		GRH.TexAddressModeV[ 10 ] = AddressMode ;
		GRH.TexAddressModeV[ 11 ] = AddressMode ;
		GRH.DrawPrepAlwaysFlag = TRUE ;

		GraphicsDevice_SetSamplerState( 11, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 10, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 9, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 8, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 7, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 6, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 5, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 4, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 3, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 2, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 1, D_D3DSAMP_ADDRESSV, AddressMode ) ;
		return GraphicsDevice_SetSamplerState( 0, D_D3DSAMP_ADDRESSV, AddressMode ) == D_D3D_OK ? 0 : -1 ;
	}
	else
	{
		if( Stage < 0 || Stage >= USE_TEXTURESTAGE_NUM ) return -1 ;
		if( AddressMode == GRH.TexAddressModeV[ Stage ] && GRH.InitializeFlag == FALSE ) return 0 ;

		RenderVertexHardware() ;

		GRH.TexAddressModeV[ Stage ] = AddressMode ;
		GRH.DrawPrepAlwaysFlag = TRUE ;

		return GraphicsDevice_SetSamplerState( Stage, D_D3DSAMP_ADDRESSV, AddressMode ) == D_D3D_OK ? 0 : -1 ;
	}
}

// テクスチャーのアドレッシングモードをセットする
static int SetTextureAddressWHardware( int AddressMode, int Stage )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( Stage == -1 )
	{
		if( AddressMode == GRH.TexAddressModeW[ 0 ] &&
			AddressMode == GRH.TexAddressModeW[ 1 ] &&
			AddressMode == GRH.TexAddressModeW[ 2 ] &&
			AddressMode == GRH.TexAddressModeW[ 3 ] &&
			AddressMode == GRH.TexAddressModeW[ 4 ] &&
			AddressMode == GRH.TexAddressModeW[ 5 ] &&
			AddressMode == GRH.TexAddressModeW[ 6 ] &&
			AddressMode == GRH.TexAddressModeW[ 7 ] &&
			AddressMode == GRH.TexAddressModeW[ 8 ] &&
			AddressMode == GRH.TexAddressModeW[ 9 ] &&
			AddressMode == GRH.TexAddressModeW[ 10 ] &&
			AddressMode == GRH.TexAddressModeW[ 11 ] &&
			GRH.InitializeFlag == FALSE ) return 0 ;

		RenderVertexHardware() ;

		GRH.TexAddressModeW[ 0 ] = AddressMode ;
		GRH.TexAddressModeW[ 1 ] = AddressMode ;
		GRH.TexAddressModeW[ 2 ] = AddressMode ;
		GRH.TexAddressModeW[ 3 ] = AddressMode ;
		GRH.TexAddressModeW[ 4 ] = AddressMode ;
		GRH.TexAddressModeW[ 5 ] = AddressMode ;
		GRH.TexAddressModeW[ 6 ] = AddressMode ;
		GRH.TexAddressModeW[ 7 ] = AddressMode ;
		GRH.TexAddressModeW[ 8 ] = AddressMode ;
		GRH.TexAddressModeW[ 9 ] = AddressMode ;
		GRH.TexAddressModeW[ 10 ] = AddressMode ;
		GRH.TexAddressModeW[ 11 ] = AddressMode ;

		GraphicsDevice_SetSamplerState( 11, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 10, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 9, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 8, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 7, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 6, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 5, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 4, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 3, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 2, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		GraphicsDevice_SetSamplerState( 1, D_D3DSAMP_ADDRESSW, AddressMode ) ;
		return GraphicsDevice_SetSamplerState( 0, D_D3DSAMP_ADDRESSW, AddressMode ) == D_D3D_OK ? 0 : -1 ;
	}
	else
	{
		if( Stage < 0 || Stage >= USE_TEXTURESTAGE_NUM ) return -1 ;
		if( AddressMode == GRH.TexAddressModeW[ Stage ] && GRH.InitializeFlag == FALSE ) return 0 ;

		RenderVertexHardware() ;

		GRH.TexAddressModeW[ Stage ] = AddressMode ;
		return GraphicsDevice_SetSamplerState( Stage, D_D3DSAMP_ADDRESSW, AddressMode ) == D_D3D_OK ? 0 : -1 ;
	}
}

// テクスチャ座標変換行列をセットする
static int	SetTextureAddressTransformMatrixHardware( int Use, MATRIX *Matrix, int Stage )
{
	if( Stage == -1 )
	{
		RenderVertexHardware() ;

		if( Use == TRUE )
		{
			GraphicsDevice_SetTextureStageState( 0, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_COUNT3 ) ;
			GraphicsDevice_SetTextureStageState( 1, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_COUNT3 ) ;
			GraphicsDevice_SetTextureStageState( 2, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_COUNT3 ) ;
			GraphicsDevice_SetTextureStageState( 3, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_COUNT3 ) ;
			GraphicsDevice_SetTransform( D_D3DTS_TEXTURE0, ( D_D3DMATRIX * )Matrix ) ;
			GraphicsDevice_SetTransform( D_D3DTS_TEXTURE1, ( D_D3DMATRIX * )Matrix ) ;
			GraphicsDevice_SetTransform( D_D3DTS_TEXTURE2, ( D_D3DMATRIX * )Matrix ) ;
			GraphicsDevice_SetTransform( D_D3DTS_TEXTURE3, ( D_D3DMATRIX * )Matrix ) ;
		}
		else
		{
			GraphicsDevice_SetTextureStageState( 0, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_DISABLE ) ;
			GraphicsDevice_SetTextureStageState( 1, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_DISABLE ) ;
			GraphicsDevice_SetTextureStageState( 2, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_DISABLE ) ;
			GraphicsDevice_SetTextureStageState( 3, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_DISABLE ) ;
		}
		GRH.TextureTransformUse[ 0 ] = Use ;
		GRH.TextureTransformUse[ 1 ] = Use ;
		GRH.TextureTransformUse[ 2 ] = Use ;
		GRH.TextureTransformUse[ 3 ] = Use ;
		GRH.TextureTransformMatrix[ 0 ] = *Matrix ;
		GRH.TextureTransformMatrix[ 1 ] = *Matrix ;
		GRH.TextureTransformMatrix[ 2 ] = *Matrix ;
		GRH.TextureTransformMatrix[ 3 ] = *Matrix ;
	}
	else
	{
		if( Stage >= 8 || GRH.TextureTransformUse[ Stage ] == FALSE && Use == FALSE )
			return 0 ;

		RenderVertexHardware() ;

		if( Use == TRUE )
		{
			if( GRH.TextureTransformUse[ Stage ] == FALSE )
			{
				GraphicsDevice_SetTextureStageState( Stage, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_COUNT3 ) ;
			}
			GraphicsDevice_SetTransform( ( D_D3DTRANSFORMSTATETYPE )( D_D3DTS_TEXTURE0 + Stage ), ( D_D3DMATRIX * )Matrix ) ;
		}
		else
		{
			GraphicsDevice_SetTextureStageState( Stage, D_D3DTSS_TEXTURETRANSFORMFLAGS, D_D3DTTFF_DISABLE ) ;
		}
		GRH.TextureTransformUse[ Stage ] = Use ;
		GRH.TextureTransformMatrix[ Stage ] = *Matrix ;
	}
	return 0 ;
}

// フォグを有効にするかどうかを設定する( TRUE:有効  FALSE:無効 )
static int	SetFogEnableHardware( int Flag )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( Flag == GRH.FogEnable && GRH.InitializeFlag == FALSE ) return 0 ;

	RenderVertexHardware() ;

	GRH.FogEnable = Flag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 使用するシェーダーのインデックスを更新する
	RefreshUseShaderIndex() ;

	{
		BOOL BData ;
		BData = Flag == 0 ? 0 : 1 ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_BOOL,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTB_FOG_USE,
			&BData,
			1,
			TRUE
		) ;
	}

	return GraphicsDevice_SetRenderState( D_D3DRS_FOGENABLE, Flag ) == D_D3D_OK ? 0 : -1 ;
}

// フォグモードを設定する
static int	SetFogModeHardware( int Mode /* DX_FOGMODE_NONE 等 */ )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( Mode == GRH.FogMode && GRH.InitializeFlag == FALSE ) return 0 ;

	RenderVertexHardware() ;

	// バーテックスシェーダー用のパラメータセット
	if( GRH.UseShader )
	{
		BOOL BData[ 4 ] ;

		BData[ 0 ] = Mode == DX_FOGMODE_LINEAR ;
		BData[ 1 ] = Mode == DX_FOGMODE_EXP ;
		BData[ 2 ] = Mode == DX_FOGMODE_EXP2 ;
		BData[ 3 ] = Mode != DX_FOGMODE_NONE ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_BOOL,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTB_FOG_LINEAR,
			BData,
			4,
			TRUE
		) ;
	}

	GRH.FogMode = Mode ;

	// 使用するシェーダーのインデックスを更新する
	RefreshUseShaderIndex() ;

	return GraphicsDevice_SetRenderState( D_D3DRS_FOGVERTEXMODE, Mode ) == D_D3D_OK ? 0 : -1 ;
}

// フォグカラーを変更する
static int	SetFogColorHardware( DWORD Color )
{
	float Data[ 4 ] ;

	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( Color == GRH.FogColor && GRH.InitializeFlag == FALSE ) return 0 ;

	RenderVertexHardware() ;

//	if( GRH.UseShader )
	{
		Data[ 0 ] = ( ( Color >> 16 ) & 0xff ) / 255.0f ;
		Data[ 1 ] = ( ( Color >>  8 ) & 0xff ) / 255.0f ;
		Data[ 2 ] = ( ( Color >>  0 ) & 0xff ) / 255.0f ;
		Data[ 3 ] = 1.0f ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_PS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_PS_CONSTF_FOG_COLOR,
			Data,
			1,
			TRUE
		) ;
	}

	GRH.FogColor = Color ;
	return GraphicsDevice_SetRenderState( D_D3DRS_FOGCOLOR, Color ) == D_D3D_OK ? 0 : -1 ;
}

// フォグが始まる距離と終了する距離を設定する( 0.0f ～ 1.0f )
static int	SetFogStartEndHardware( float Start, float End )
{
	float Data[ 4 ] ;

	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	RenderVertexHardware() ;

	if( Start != GRH.FogStart || GRH.InitializeFlag == TRUE )
	{
		GRH.FogStart = Start ;
		GraphicsDevice_SetRenderState( D_D3DRS_FOGSTART, *(( DWORD *)&Start) ) ;

		// バーテックスシェーダー用のパラメータセット
//		if( GRH.UseShader )
		{
			Data[ 0 ] = GRH.FogEnd / ( GRH.FogEnd - GRH.FogStart ) ;
			Data[ 1 ] = -1.0f / ( GRH.FogEnd - GRH.FogStart ) ;
			Data[ 2 ] = GRH.FogDensity ;
			Data[ 3 ] = 2.71828183f ;
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_VS_FLOAT,
				DX_SHADERCONSTANTSET_LIB,
				DX_VS_CONSTF_FOG,
				Data,
				1,
				TRUE
			) ;
		}
	}

	if( End != GRH.FogEnd || GRH.InitializeFlag == TRUE )
	{
		GRH.FogEnd = End ;
		GraphicsDevice_SetRenderState( D_D3DRS_FOGEND, *(( DWORD *)&End) ) ;

		// バーテックスシェーダー用のパラメータセット
//		if( GRH.UseShader )
		{
			Data[ 0 ] = GRH.FogEnd / ( GRH.FogEnd - GRH.FogStart ) ;
			Data[ 1 ] = -1.0f / ( GRH.FogEnd - GRH.FogStart ) ;
			Data[ 2 ] = GRH.FogDensity ;
			Data[ 3 ] = 2.71828183f ;
			SetShaderConstantSet(
				&GRH.ShaderConstantInfo,
				DX_SHADERCONSTANTTYPE_VS_FLOAT,
				DX_SHADERCONSTANTSET_LIB,
				DX_VS_CONSTF_FOG,
				Data,
				1,
				TRUE
			) ;
		}
	}

	// 終了
	return 0 ;
}

// フォグの密度を設定する( 0.0f ～ 1.0f )
static int	SetFogDensityHardware( float Density )
{
	float Data[ 4 ] ;
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( Density == GRH.FogDensity && GRH.InitializeFlag == FALSE ) return 0 ;

	RenderVertexHardware() ;

	GRH.FogDensity = Density ;

	// バーテックスシェーダー用のパラメータセット
//	if( GRH.UseShader )
	{
		Data[ 0 ] = GRH.FogEnd / ( GRH.FogEnd - GRH.FogStart ) ;
		Data[ 1 ] = -1.0f / ( GRH.FogEnd - GRH.FogStart ) ;
		Data[ 2 ] = GRH.FogDensity ;
		Data[ 3 ] = 2.71828183f ;
		SetShaderConstantSet(
			&GRH.ShaderConstantInfo,
			DX_SHADERCONSTANTTYPE_VS_FLOAT,
			DX_SHADERCONSTANTSET_LIB,
			DX_VS_CONSTF_FOG,
			Data,
			1,
			TRUE
		) ;
	}

	return GraphicsDevice_SetRenderState( D_D3DRS_FOGDENSITY, *(( DWORD *)&Density) ) == D_D3D_OK ? 0 : -1 ;
}

// ライトの有無フラグをセットする
static int SetUseLightFlagHardware( int LightFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( LightFlag == GRH.LightFlag && GRH.InitializeFlag == FALSE ) return 0 ;

	GRH.LightFlag = LightFlag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	RefreshUseShaderIndex() ;

	return GraphicsDevice_SetRenderState( D_D3DRS_LIGHTING, LightFlag ) == D_D3D_OK ? 0 : -1 ;
}

// ２次元配列的に配置された頂点データを頂点バッファに追加する
static int SetPlaneVertexHardware( VERTEX_2D *GraphVert, int xnum, int ynum )
{
	int i, j, k, l ;

	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	if( xnum < 2 || ynum < 2 ) return -1 ;

	// トライアングルリストモードの場合はバッファは使用しない
	RenderVertexHardware() ;

	// バッファを使用しない設定になっていたらこの場で描画
	{
#define MAX_POSNUM		1000
		WORD list[MAX_POSNUM] ;

		// 頂点インデックスリストを作成する
		k = 0 ;
		l = 0 ;
		for( i = 0 ; i < ynum - 1 ; i ++ )
		{
			// 頂点数が超えそうだったら描画
			if( k + xnum * 2 + 2 > MAX_POSNUM )
			{
				SETFVF( VERTEXFVF_2D )
				GraphicsDevice_DrawIndexedPrimitiveUP(
					D_D3DPT_TRIANGLESTRIP,
					0,
					xnum * ynum,
					k - 2,
					list,
					D_D3DFMT_INDEX16,
					GraphVert,
					sizeof( VERTEX_2D ) ) ;
				k = 0 ;
			}

			// 前の行からの続きだった場合はストリップの連続用の頂点を出力		
			if( k != 0 )
			{
				list[k] = ( WORD )( l + xnum ) ;
				k ++ ;
			}
			
			for( j = 0 ; j < xnum ; j ++, l ++ )
			{
				list[k] = ( WORD )( l + xnum ) ;
				list[k+1] = ( WORD )l ;
				k += 2 ;
			}
			if( i != ynum - 2 )
			{
				list[k] = list[k-1] ;
				k ++ ;
			}
		}
		if( k != 0 )
		{
			SETFVF( VERTEXFVF_2D )
			GraphicsDevice_DrawIndexedPrimitiveUP(
				D_D3DPT_TRIANGLESTRIP,
				0,
				xnum * ynum,
				k - 2,
				list,
				D_D3DFMT_INDEX16,
				GraphVert,
				sizeof( VERTEX_2D ) ) ;
		}
#undef	MAX_POSNUM
	}

	// 終了
	return 0 ;
}

// ビューポートをセットする
static int  SetViewportHardware( D_D3DVIEWPORT9 *Viewport )
{
	HRESULT hr ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( Viewport->X      == GRH.Viewport.X      &&
		Viewport->Y      == GRH.Viewport.Y      &&
		Viewport->Width  == GRH.Viewport.Width  &&
		Viewport->Height == GRH.Viewport.Height &&
		GRH.InitializeFlag == FALSE ) return 0 ;

	// 書き出す
	if( GRH.InitializeFlag == FALSE )
	{
		RenderVertexHardware() ;
	}

	// 描画を終了させておく
	EndScene() ;

	// ビューポートのセッティング
	hr = GraphicsDevice_SetViewport( Viewport ) ;
	if( hr != D_D3D_OK )
		return DXST_ERRORLOGFMT_ADD(( _T( "ビューポートのセットに失敗しました ErrorCode %x\n" ), hr ));

	// ビューポートの情報の保存
	GRH.Viewport = *Viewport ;

	// 終了
	return 0 ;
}

// ビューポートをセットする( 簡易版 )
extern int SetViewportHardwareEasy( int x1, int y1, int x2, int y2 )
{
	D_D3DVIEWPORT9 Viewport ;

	Viewport.X = x1 ;
	Viewport.Y = y1 ;
	Viewport.Width = ( DWORD )( x2 - x1 ) ;
	Viewport.Height = ( DWORD )( y2 - y1 ) ;
	Viewport.MinZ = 0.0f ;
	Viewport.MaxZ = 1.0f ;

	return SetViewportHardware( &Viewport ) ;
}

// シザー矩形を設定する
static int	SetScissorRectHardware( RECT *Rect )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( Rect->left   == GRH.ScissorRect.left   &&
		Rect->right  == GRH.ScissorRect.right  &&
		Rect->top    == GRH.ScissorRect.top    &&
		Rect->bottom == GRH.ScissorRect.bottom &&
		GRH.InitializeFlag == FALSE ) return 0 ;

	if( GRH.InitializeFlag == FALSE )
	{
		// 書き出す
		RenderVertexHardware() ;
	}

	// 描画を終了させておく
	EndScene() ;

	// シザー矩形のセッティング
	GraphicsDevice_SetScissorRect( Rect ) ;

	// シザー矩形の保存
	GRH.ScissorRect = *Rect ;

	// 終了
	return 0 ;
}

// シザー矩形を有効にするかどうかを設定
static int	SetScissorTestEnableHardware( int Enable )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( Enable == GRH.ScissorTestEnable &&
		GRH.InitializeFlag == FALSE ) return 0 ;

	// 書き出す
	RenderVertexHardware() ;

	// 描画を終了させておく
	EndScene() ;

	// シザー矩形の有効・無効のセッティング
	GraphicsDevice_SetRenderState( D_D3DRS_SCISSORTESTENABLE, Enable ) ;

	// シザー矩形の有効・無効のセッティングを保存
	GRH.ScissorTestEnable = Enable ;

	// 終了
	return 0 ;
}

// 縁付きフォント描画を行うかどうかを設定
static int SetEdgeFontDrawFlagHardware( int EdgeFontFlag )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( EdgeFontFlag == GRH.EdgeFontDrawFlag && GRH.InitializeFlag == FALSE ) return 0 ;

	// 書き出す
	RenderVertexHardware() ;

	// シザー矩形の有効・無効のセッティングを保存
	GRH.EdgeFontDrawFlag = EdgeFontFlag ;

	// パラメータが変更された、フラグを立てる
	GRH.ChangeBlendParamFlag = TRUE ;

	// 終了
	return 0 ;
}

#ifndef DX_NON_ASYNCLOAD
int RenderVertexHardwareASyncCallback( ASYNCLOAD_MAINTHREAD_REQUESTINFO * /*Info*/ )
{
	return RenderVertexHardware( FALSE ) ;
}
#endif // DX_NON_ASYNCLOAD

// 頂点バッファに溜まった頂点データをレンダリングする
extern int	RenderVertexHardware( int ASyncThread )
{
#ifndef DX_NON_ASYNCLOAD
	if( ASyncThread )
	{
		ASYNCLOAD_MAINTHREAD_REQUESTINFO AInfo ;

		AInfo.Function = RenderVertexHardwareASyncCallback ;
		return AddASyncLoadRequestMainThreadInfo( &AInfo ) ;
	}
#endif // DX_NON_ASYNCLOAD

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 頂点が一つも無かったら描画は行わない
	if( GRH.VertexNum != 0 && DxLib_GetEndRequest() == FALSE )
	{
		// BeginScene をしていなかったらする
		if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;

		// 非描画フラグが立っていなければレンダリングする
		if( GRH.BlendMaxNotDrawFlag == FALSE )
		{
			if( GRH.VertexNum != 0 )
			{
				int PrimNum ;

				PrimNum = 0 ;
				switch( GRH.PrimitiveType )
				{
				case D_D3DPT_POINTLIST     : PrimNum = GRH.VertexNum ;     break ;
				case D_D3DPT_LINELIST      : PrimNum = GRH.VertexNum / 2 ; break ;
				case D_D3DPT_LINESTRIP     : PrimNum = GRH.VertexNum - 1 ; break ;
				case D_D3DPT_TRIANGLELIST  : PrimNum = GRH.VertexNum / 3 ; break ;
				case D_D3DPT_TRIANGLESTRIP : PrimNum = GRH.VertexNum - 2 ; break ;
				case D_D3DPT_TRIANGLEFAN   : PrimNum = GRH.VertexNum - 2 ; break ;
				}

				SETFVF( D3DDev_VertexType[ GRH.Use3DVertex ][ GRH.VertexType ] );
				if( GRH.Use3DVertex )
				{
					SetTransformToWorldHardware( &GlobalIdentMatrix ) ;
				}
				GraphicsDevice_DrawPrimitiveUP(
					GRH.PrimitiveType,
					PrimNum,
					GRH.VertexBufferPoint[ GRH.Use3DVertex ][ GRH.VertexType ],
					D3DDev_VertexSize[ GRH.Use3DVertex ][ GRH.VertexType ] ) ;

				if( GRH.Use3DVertex )
				{
					SetTransformToWorldHardware( &GBASE.WorldMatrix ) ;
				}

			}
		}
	}

	GRH.VertexNum = 0 ;
	GRH.VertexBufferNextAddress = GRH.VertexBufferPoint[ GRH.Use3DVertex ][ GRH.VertexType ] ;

	// 終了
	return 0 ;
}

// 描画準備を行う
static void FASTCALL DrawPreparation( DX_DIRECT3DTEXTURE9 *Texture, int ParamFlag )
{
	int ColorKey, AlphaTest, AlphaChannel, UseDiffuseRGB, UseDiffuseAlpha, ShadeMode, Specular, EdgeFont ;

	// 縁付きフォントの描画かどうかのフラグを取得
	EdgeFont = ( ParamFlag & DRAWPREP_EDGEFONT ) != 0 ? TRUE : FALSE ;

	// 必ず DrawPreparation を行うべきというフラグを倒す
	GRH.DrawPrepAlwaysFlag = FALSE ;

	// シェーダーがセットされていたら外す
	if( ( ParamFlag & DRAWPREP_NOTSHADERRESET ) == 0 )
	{
		if( GRH.SetVS || GRH.InitializeFlag )
		{
			GraphicsDevice_SetVertexShader( NULL ) ;
			GRH.SetVS = NULL ;
			GRH.SetVD = NULL ;
			GRH.SetFVF = 0 ;
		}

		if( GRH.NormalPS == FALSE )
		{
			if( GRH.SetPS || GRH.InitializeFlag )
			{
				GraphicsDevice_SetPixelShader( NULL ) ;
				GRH.SetPS = NULL ;
			}
		}
	}

	GRH.SetIB = NULL ;
	GRH.SetVB = NULL ;

	// ライトを使うかどうかで処理を分岐
	if( ( ParamFlag & DRAWPREP_LIGHTING ) != 0 && GBASE.Light.ProcessDisable == FALSE )
	{
		// ライトの設定が変更されていたら変更を適応する
		if( GBASE.Light.D3DChange )
		{
			RefreshLightState() ;
		}
		else
		{
			// ライトが有効なのに一時的に無効になっていたら有効にする
			if( GRH.LightFlag == 0 )
			{
				SetUseLightFlagHardware( TRUE ) ;
			}
		}

		// マテリアルの設定が外部から変更されていたら元に戻す
		if( GBASE.Light.ChangeMaterial )
		{
			GBASE.Light.ChangeMaterial = 0 ;
			SetMaterialHardware( ( MATERIAL * )&GBASE.Light.Material ) ;
		}

		// 頂点カラーをマテリアルのカラーとして使用するかどうかをセットする
		if( ( GBASE.Light.MaterialNotUseVertexDiffuseColor ? FALSE : TRUE ) != GRH.MaterialUseVertexDiffuseColor )
			SetMaterialUseVertexDiffuseColorHardware( GBASE.Light.MaterialNotUseVertexDiffuseColor ? FALSE : TRUE ) ;
		if( ( GBASE.Light.MaterialNotUseVertexSpecularColor ? FALSE : TRUE ) != GRH.MaterialUseVertexSpecularColor )
			SetMaterialUseVertexSpecularColorHardware( GBASE.Light.MaterialNotUseVertexSpecularColor ? FALSE : TRUE ) ;
	}
	else
	{
		// ライトが有効になっていたら無効にする
		if( GRH.LightFlag == 1 )
		{
			SetUseLightFlagHardware( FALSE ) ;
		}
	}

	// スペキュラを使用するかどうかの設定を行う
	Specular = ( GBASE.NotUseSpecular == FALSE && ( ParamFlag & DRAWPREP_SPECULAR ) != 0 ) ? TRUE : FALSE ;
	if( Specular != GRH.UseSpecular )
		SetUseSpecularHardware( Specular ) ;

	// Ｚバッファの設定を行う
	if( ParamFlag & DRAWPREP_3D )
	{
		if( GBASE.EnableZBufferFlag3D )
		{
			if( GRH.EnableZBufferFlag != GBASE.EnableZBufferFlag3D ) SetUseZBufferHardware(     GBASE.EnableZBufferFlag3D ) ;
			if( GRH.WriteZBufferFlag  != GBASE.WriteZBufferFlag3D  ) SetWriteZBufferHardware(   GBASE.WriteZBufferFlag3D  ) ;
			if( GRH.ZBufferCmpType    != GBASE.ZBufferCmpType3D    ) SetZBufferCmpTypeHardware( GBASE.ZBufferCmpType3D    ) ;
			if( GRH.ZBias             != GBASE.ZBias3D             ) SetZBiasHardware(          GBASE.ZBias3D             ) ;
		}
		else
		{
			if( GRH.EnableZBufferFlag ) SetUseZBufferHardware( FALSE ) ;
		}
	}
	else
	{
		if( GBASE.EnableZBufferFlag2D )
		{
			if( GRH.EnableZBufferFlag != GBASE.EnableZBufferFlag2D ) SetUseZBufferHardware(     GBASE.EnableZBufferFlag2D ) ;
			if( GRH.WriteZBufferFlag  != GBASE.WriteZBufferFlag2D  ) SetWriteZBufferHardware(   GBASE.WriteZBufferFlag2D  ) ;
			if( GRH.ZBufferCmpType    != GBASE.ZBufferCmpType2D    ) SetZBufferCmpTypeHardware( GBASE.ZBufferCmpType2D    ) ;
			if( GRH.ZBias             != GBASE.ZBias2D             ) SetZBiasHardware(          GBASE.ZBias2D             ) ;
		}
		else
		{
			if( GRH.EnableZBufferFlag ) SetUseZBufferHardware( FALSE ) ;
			if( GRH.WriteZBufferFlag  ) SetWriteZBufferHardware( FALSE ) ;
		}
	}

	// フィルモードのセット
	if( GRH.FillMode != GBASE.FillMode ) SetFillModeHardware( GBASE.FillMode ) ;

	// フォグの設定を行う
	if( ParamFlag & DRAWPREP_FOG )
	{
		if( GRH.FogEnable != GBASE.FogEnable ) SetFogEnableHardware( GBASE.FogEnable ) ;
	}
	else
	{
		if( GRH.FogEnable ) SetFogEnableHardware( FALSE ) ;
	}

	// ブレンディング関係のセッティングを行う場合のみ実行する
	if( ( ParamFlag & DRAWPREP_NOBLENDSETTING ) == 0 )
	{
		// 前回とまったく同じ場合は何もせずに終了
//		if( Format    == GRH.DrawPrepFormat   &&
//			Texture   == GRH.DrawPrepTexture  &&
//			ParamFlag == GRH.DrawPrepParamFlag ) return ;

		// フラグの初期化
		ColorKey     = FALSE ;
		AlphaTest    = FALSE ;
		AlphaChannel = FALSE ;

		// テクスチャーを使用するかどうかで処理を分岐
		// 使用しない場合は初期値のまま
		if( Texture )
		{
			// 透過色処理を行わない場合はカラーキーもαテストもαチャンネルも使用しないので初期値のまま
			// 透過色処理を行う場合のみ処理をする
			if( ParamFlag & DRAWPREP_TRANS )
			{
				int TexAlphaTestFlag = ( ParamFlag & DRAWPREP_TEXALPHATEST ) != 0 ? 1 : 0 ;
				int TexAlphaChFlag   = ( ParamFlag & DRAWPREP_TEXALPHACH   ) != 0 ? 1 : 0 ;

				// テクスチャにαビットがあるかどうかで処理を分岐
				if( TexAlphaTestFlag || TexAlphaChFlag )
				{
					// テクスチャにαビットがある場合カラーキーは使用しない(ので初期値のまま)
/*
					// αテストでも頂点座標のデータ型が浮動小数点型で、且つテクスチャフィルタリングモードが
					// 線形補間だった場合はαチャンネルとして扱う
					if( VectorIntFlag == FALSE && GBASE.DrawMode == DX_DRAWMODE_BILINEAR )
					{
						AlphaChannel = TRUE ;
					}
					else
					{
						// それ以外の場合はテクスチャーのフラグに委ねる
						AlphaTest = Format->AlphaTestFlag ;
						AlphaChannel = Format->AlphaChFlag ;
					}
*/
					// αテストでも頂点座標のデータ型が浮動小数点型で、且つテクスチャフィルタリングモードが
					// 線形補間であるか、ブレンドモードが DX_BLENDMODE_NOBLEND 以外だったらαチャンネルとして扱う
					if( ( GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendMode != DX_BLENDMODE_DESTCOLOR ) ||
						( ( ParamFlag & DRAWPREP_VECTORINT ) == 0 && GBASE.DrawMode == DX_DRAWMODE_BILINEAR ) )
//					if( VectorIntFlag == FALSE && GBASE.DrawMode == DX_DRAWMODE_BILINEAR )
					{
						AlphaChannel = TRUE ;
					}
					else
					{
						// それ以外の場合はテクスチャーのフラグに委ねる
						AlphaTest    = TexAlphaTestFlag ;
						AlphaChannel = TexAlphaChFlag ;
					}
				}
				else
				{
					// テクスチャにαビットがない場合カラーキーを使用する(か、どうかは TransFlag 次第 )
					ColorKey = TRUE ;
				}
			}
		}

		// ディフーズカラーを使用するかどうかをセット
		UseDiffuseRGB   = ( ParamFlag & DRAWPREP_DIFFUSERGB )   || ( GBASE.bDrawBright & 0xffffff ) != 0xffffff ;
		UseDiffuseAlpha = ( ParamFlag & DRAWPREP_DIFFUSEALPHA ) || ( GBASE.BlendMode != DX_BLENDMODE_NOBLEND || GBASE.UseNoBlendModeParam /*&& ( GBASE.BlendMode != DX_BLENDMODE_ALPHA || GBASE.BlendParam != 255 )*/ ) ;

		// 調整されたパラメータをセットする
		if( UseDiffuseRGB             != GRH.UseDiffuseRGBColor     ) SetUseDiffuseRGBColorFlagHardware(   UseDiffuseRGB   ) ;
		if( UseDiffuseAlpha           != GRH.UseDiffuseAlphaColor   ) SetUseDiffuseAlphaColorFlagHardware( UseDiffuseAlpha ) ;
		if( Texture                   != GRH.RenderTexture          ) SetTextureHardware(                  Texture         ) ;
		if( GRH.IgnoreGraphColorFlag  != GBASE.IgnoreGraphColorFlag ) SetIgnoreDrawGraphColorHardware( GBASE.IgnoreGraphColorFlag ) ;
		if( GRH.BlendMode             != GBASE.BlendMode ||
			GRH.AlphaTestValidFlag    != AlphaTest ||
			GRH.AlphaChannelValidFlag != AlphaChannel               ) SetDrawBlendModeHardware( GBASE.BlendMode, AlphaTest, AlphaChannel ) ;
		if( GRH.EdgeFontDrawFlag      != EdgeFont                   ) SetEdgeFontDrawFlagHardware( EdgeFont ) ;
		if( GRH.AlphaTestMode         != GBASE.AlphaTestMode ||
			GRH.AlphaTestParam        != GBASE.AlphaTestParam       ) SetDrawAlphaTestHardware( GBASE.AlphaTestMode, GBASE.AlphaTestParam ) ;
		if( GRH.ChangeBlendParamFlag || GRH.ChangeTextureFlag || ( GRH.UseShader && GRH.NormalDraw_NotUseShader == FALSE && GRH.NormalPS == FALSE ) ) RefreshBlendStateHardware() ;
	}

	// シェーディングモードのセット
	ShadeMode = ( ParamFlag & DRAWPREP_GOURAUDSHADE ) ? D_D3DSHADE_GOURAUD : D_D3DSHADE_FLAT ;

	if( ShadeMode          != GRH.ShadeMode        ) SetShadeModeHardware(      ShadeMode           ) ;
	if( GRH.DrawMode       != GBASE.DrawMode       ) SetDrawModeHardware(       GBASE.DrawMode      ) ;
	if( GRH.MaxAnisotropy  != GBASE.MaxAnisotropy  ) SetMaxAnisotropyHardware(  GBASE.MaxAnisotropy ) ;
	if( ParamFlag & DRAWPREP_CULLING )
	{
		if( GRH.CullMode   != GBASE.CullMode       ) SetUseCullingHardware(     GBASE.CullMode      ) ;
	}
	else
	{
		if( GRH.CullMode   != DX_CULLING_NONE      ) SetUseCullingHardware(     DX_CULLING_NONE     ) ;
	}
	if( GRH.TextureTransformMatrixDirectChange     )
	{
		SetTextureAddressTransformMatrixHardware( GBASE.TextureTransformUse, &GBASE.TextureTransformMatrix, -1 ) ;
		GRH.TextureTransformMatrixDirectChange = FALSE ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}
	if( ParamFlag & DRAWPREP_TEXADDRESS )
	{
		if( GRH.TexAddressModeU[ 0 ] != GBASE.TexAddressModeU[ 0 ] ) SetTextureAddressUHardware( GBASE.TexAddressModeU[ 0 ], 0 ) ;
		if( GRH.TexAddressModeU[ 1 ] != GBASE.TexAddressModeU[ 1 ] ) SetTextureAddressUHardware( GBASE.TexAddressModeU[ 1 ], 1 ) ;
		if( GRH.TexAddressModeU[ 2 ] != GBASE.TexAddressModeU[ 2 ] ) SetTextureAddressUHardware( GBASE.TexAddressModeU[ 2 ], 2 ) ;
		if( GRH.TexAddressModeU[ 3 ] != GBASE.TexAddressModeU[ 3 ] ) SetTextureAddressUHardware( GBASE.TexAddressModeU[ 3 ], 3 ) ;
		if( GRH.TexAddressModeU[ 4 ] != GBASE.TexAddressModeU[ 4 ] ) SetTextureAddressUHardware( GBASE.TexAddressModeU[ 4 ], 4 ) ;
		if( GRH.TexAddressModeU[ 5 ] != GBASE.TexAddressModeU[ 5 ] ) SetTextureAddressUHardware( GBASE.TexAddressModeU[ 5 ], 5 ) ;
		if( GRH.TexAddressModeU[ 6 ] != GBASE.TexAddressModeU[ 6 ] ) SetTextureAddressUHardware( GBASE.TexAddressModeU[ 6 ], 6 ) ;
		if( GRH.TexAddressModeU[ 7 ] != GBASE.TexAddressModeU[ 7 ] ) SetTextureAddressUHardware( GBASE.TexAddressModeU[ 7 ], 7 ) ;

		if( GRH.TexAddressModeV[ 0 ] != GBASE.TexAddressModeV[ 0 ] ) SetTextureAddressVHardware( GBASE.TexAddressModeV[ 0 ], 0 ) ;
		if( GRH.TexAddressModeV[ 1 ] != GBASE.TexAddressModeV[ 1 ] ) SetTextureAddressVHardware( GBASE.TexAddressModeV[ 1 ], 1 ) ;
		if( GRH.TexAddressModeV[ 2 ] != GBASE.TexAddressModeV[ 2 ] ) SetTextureAddressVHardware( GBASE.TexAddressModeV[ 2 ], 2 ) ;
		if( GRH.TexAddressModeV[ 3 ] != GBASE.TexAddressModeV[ 3 ] ) SetTextureAddressVHardware( GBASE.TexAddressModeV[ 3 ], 3 ) ;
		if( GRH.TexAddressModeV[ 4 ] != GBASE.TexAddressModeV[ 4 ] ) SetTextureAddressVHardware( GBASE.TexAddressModeV[ 4 ], 4 ) ;
		if( GRH.TexAddressModeV[ 5 ] != GBASE.TexAddressModeV[ 5 ] ) SetTextureAddressVHardware( GBASE.TexAddressModeV[ 5 ], 5 ) ;
		if( GRH.TexAddressModeV[ 6 ] != GBASE.TexAddressModeV[ 6 ] ) SetTextureAddressVHardware( GBASE.TexAddressModeV[ 6 ], 6 ) ;
		if( GRH.TexAddressModeV[ 7 ] != GBASE.TexAddressModeV[ 7 ] ) SetTextureAddressVHardware( GBASE.TexAddressModeV[ 7 ], 7 ) ;
	}
	else
	{
		if( GRH.TexAddressModeU[ 0 ] != DX_TEXADDRESS_CLAMP || GRH.TexAddressModeV[ 0 ] != DX_TEXADDRESS_CLAMP ) SetTextureAddressHardware( DX_TEXADDRESS_CLAMP, 0 ) ;
		if( GRH.TexAddressModeU[ 1 ] != DX_TEXADDRESS_CLAMP || GRH.TexAddressModeV[ 1 ] != DX_TEXADDRESS_CLAMP ) SetTextureAddressHardware( DX_TEXADDRESS_CLAMP, 1 ) ;
		if( GRH.TexAddressModeU[ 2 ] != DX_TEXADDRESS_CLAMP || GRH.TexAddressModeV[ 2 ] != DX_TEXADDRESS_CLAMP ) SetTextureAddressHardware( DX_TEXADDRESS_CLAMP, 2 ) ;
		if( GRH.TexAddressModeU[ 3 ] != DX_TEXADDRESS_CLAMP || GRH.TexAddressModeV[ 3 ] != DX_TEXADDRESS_CLAMP ) SetTextureAddressHardware( DX_TEXADDRESS_CLAMP, 3 ) ;
	}

/*
	SetDrawBlendModeHardware( GBASE.BlendMode, GBASE.BlendParam,  ) ;

	if( ( Format->AlphaTestFlag || Format->AlphaChFlag ) && ( TransFlag != GRH.AlphaValidFlag ) )
	{
		SetDrawBlendModeHardware( DX_BLENDMODE_BLINEALPHA ,
									Format->AlphaTestFlag ? ( TransFlag  ? TRUE : FALSE ) : ( Format->AlphaChFlag ? TRUE : FALSE ) ) ;
	}
*/
	// パラメータを保存
//	GRH.DrawPrepFormat    = Format ;
	GRH.DrawPrepTexture   = Texture ;
	GRH.DrawPrepParamFlag = ParamFlag ;
}

// ハードウエアアクセラレータ使用版 DrawBillboard3DHardware
static int	DrawBillboard3DHardware( VECTOR Pos, float cx, float cy, float Size, float Angle, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int TurnFlag, int DrawFlag, RECT *DrawArea )
{
	VERTEX_2D *DrawVect ;
	VERTEX_2D TempVect[ 6 ] ;
	VERTEX_3D *DrawVect3D ;
	VERTEX_BLENDTEX_2D *DrawVectB ;
	VERTEX_BLENDTEX_2D TempVectB[ 6 ] ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	IMAGEDATA2_HARD_DRAW *BlendDrawTex ;
	IMAGEDATA2_ORIG *Orig ;
	IMAGEDATA2_HARD_VERT *TexVect ;
	IMAGEDATA2_HARD_VERT *BlendTexVect = NULL ;
	DWORD DiffuseColor ;
	int DrawTexNum ;
	int i, Flag ;
	int BlendGraphNoIncFlag ;
	float SizeX, SizeY, f ;
	VECTOR SrcVec[ 4 ], SrcVec2[ 4 ] ;
	float Sin = 0.0f, Cos = 1.0f, ScaleX, ScaleY ;
	float dleft = 0.0f, dright = 0.0f, dtop = 0.0f, dbottom = 0.0f ;

	Orig = Image2->Orig ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// 描画準備
	if( DrawFlag )
	{
		if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
		Flag = TransFlag | DRAWPREP_3D | DRAWPREP_FOG | DRAWPREP_TEXADDRESS ;
		DRAWPREP_TEX( Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		dleft   = -100000000.0f ;
		dright  =  100000000.0f ;
		dtop    = -100000000.0f ;
		dbottom =  100000000.0f ;
	}

	// 頂点データを取得
	DiffuseColor = GRH.DiffuseColor ;

	// 描画情報の数をセット
	DrawTexNum = Image2->Hard.DrawNum ;

	// 描画情報の数がブレンド画像と異なっていたら０番目のテクスチャだけを使用する
	BlendGraphNoIncFlag = FALSE ;
	if( BlendImage2 != NULL && BlendImage2->Hard.DrawNum != Image2->Hard.DrawNum )
	{
		BlendGraphNoIncFlag = TRUE ;
	}

	// 描画情報配列のアドレスをセットしておく
	DrawTex = Image2->Hard.Draw ;
	BlendDrawTex = NULL ;
	if( BlendImage2 != NULL )
	{
		BlendDrawTex = BlendImage2->Hard.Draw ;
	}

	// サイズと座標関係の事前計算
	SizeX = Size ;
	SizeY = Size * ( float )Image2->Height / ( float )Image2->Width ;

	ScaleX = SizeX / Image2->Width ;
	ScaleY = SizeY / Image2->Height ;
	cx *= Image2->Width ;
	cy *= Image2->Height ;

	// 回転する場合は回転値を求めておく
	if( Angle != 0.0 )
	{
		_SINCOS( (float)Angle, &Sin, &Cos ) ;
	}

	// テクスチャーの数だけ繰り返す
	for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
	{
		// 描画するテクスチャーのセット
		if( DrawFlag )
		{
			if( GRH.RenderTexture != DrawTex->Tex->Texture )
				SetTextureHardware( DrawTex->Tex->Texture ) ;
			if( BlendDrawTex != NULL )
			{
				if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
					SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
			}
			if( GRH.ChangeTextureFlag )
				RefreshBlendStateHardware() ;
		}

		TexVect = DrawTex->Vertex ;
		if( BlendDrawTex != NULL )
		{
			BlendTexVect = BlendDrawTex->Vertex ;
		}

		// ブレンドグラフィックを使用していなくて、且つ描画する場合は高速な処理を使用する
		if( GRH.VertexType != VERTEXTYPE_BLENDTEX && DrawFlag == TRUE )
		{
			GETVERTEX_BILLBOARD( DrawVect3D ) ;

			// 回転する場合としない場合で処理を分岐
			if( Angle != 0.0 )
			{
				// ローカル座標準備
				SrcVec[2].x = SrcVec[0].x = ( -cx + TexVect[0].x ) * ScaleX ;
				SrcVec[3].x = SrcVec[1].x = ( -cx + TexVect[1].x ) * ScaleX ;

				SrcVec[1].y = SrcVec[0].y = ( -cy + Image2->Height - TexVect[0].y ) * ScaleY ;
				SrcVec[3].y = SrcVec[2].y = ( -cy + Image2->Height - TexVect[2].y ) * ScaleY ;

				// 回転計算
				f             = SrcVec[ 0 ].x * Cos - SrcVec[ 0 ].y * Sin ;	
				SrcVec[ 0 ].y = SrcVec[ 0 ].x * Sin + SrcVec[ 0 ].y * Cos ;
				SrcVec[ 0 ].x = f ;

				f             = SrcVec[ 1 ].x * Cos - SrcVec[ 1 ].y * Sin ;	
				SrcVec[ 1 ].y = SrcVec[ 1 ].x * Sin + SrcVec[ 1 ].y * Cos ;
				SrcVec[ 1 ].x = f ;

				f             = SrcVec[ 2 ].x * Cos - SrcVec[ 2 ].y * Sin ;	
				SrcVec[ 2 ].y = SrcVec[ 2 ].x * Sin + SrcVec[ 2 ].y * Cos ;
				SrcVec[ 2 ].x = f ;

				f             = SrcVec[ 3 ].x * Cos - SrcVec[ 3 ].y * Sin ;	
				SrcVec[ 3 ].y = SrcVec[ 3 ].x * Sin + SrcVec[ 3 ].y * Cos ;
				SrcVec[ 3 ].x = f ;

				// ビルボード座標をワールド座標へ変換
				DrawVect3D[ 0 ].pos.x = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][0] + SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
				DrawVect3D[ 0 ].pos.y = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][1] + SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
				DrawVect3D[ 0 ].pos.z = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][2] + SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

				DrawVect3D[ 1 ].pos.x = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][0] + SrcVec[ 1 ].y * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
				DrawVect3D[ 1 ].pos.y = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][1] + SrcVec[ 1 ].y * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
				DrawVect3D[ 1 ].pos.z = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][2] + SrcVec[ 1 ].y * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

				DrawVect3D[ 2 ].pos.x = SrcVec[ 2 ].x * GBASE.BillboardMatrix.m[0][0] + SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
				DrawVect3D[ 2 ].pos.y = SrcVec[ 2 ].x * GBASE.BillboardMatrix.m[0][1] + SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
				DrawVect3D[ 2 ].pos.z = SrcVec[ 2 ].x * GBASE.BillboardMatrix.m[0][2] + SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

				DrawVect3D[ 3 ].pos.x = SrcVec[ 3 ].x * GBASE.BillboardMatrix.m[0][0] + SrcVec[ 3 ].y * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
				DrawVect3D[ 3 ].pos.y = SrcVec[ 3 ].x * GBASE.BillboardMatrix.m[0][1] + SrcVec[ 3 ].y * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
				DrawVect3D[ 3 ].pos.z = SrcVec[ 3 ].x * GBASE.BillboardMatrix.m[0][2] + SrcVec[ 3 ].y * GBASE.BillboardMatrix.m[1][2] + Pos.z ;
			}
			else
			{
				VECTOR TempVecX[ 2 ], TempVecY[ 2 ] ;

				// ローカル座標準備
				SrcVec[0].x = ( -cx + TexVect[0].x ) * ScaleX ;
				SrcVec[1].x = ( -cx + TexVect[1].x ) * ScaleX ;

				SrcVec[0].y = ( -cy + Image2->Height - TexVect[0].y ) * ScaleY ;
				SrcVec[2].y = ( -cy + Image2->Height - TexVect[2].y ) * ScaleY ;

				// ビルボード座標をワールド座標へ変換
				TempVecX[ 0 ].x = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][0] + Pos.x ;
				TempVecX[ 0 ].y = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][1] + Pos.y ;
				TempVecX[ 0 ].z = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][2] + Pos.z ;

				TempVecX[ 1 ].x = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][0] + Pos.x ;
				TempVecX[ 1 ].y = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][1] + Pos.y ;
				TempVecX[ 1 ].z = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][2] + Pos.z ;

				TempVecY[ 0 ].x = SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][0] ;
				TempVecY[ 0 ].y = SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][1] ;
				TempVecY[ 0 ].z = SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][2] ;

				TempVecY[ 1 ].x = SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][0] ;
				TempVecY[ 1 ].y = SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][1] ;
				TempVecY[ 1 ].z = SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][2] ;

				DrawVect3D[ 0 ].pos.x = TempVecX[ 0 ].x + TempVecY[ 0 ].x ;
				DrawVect3D[ 0 ].pos.y = TempVecX[ 0 ].y + TempVecY[ 0 ].y ;
				DrawVect3D[ 0 ].pos.z = TempVecX[ 0 ].z + TempVecY[ 0 ].z ;

				DrawVect3D[ 1 ].pos.x = TempVecX[ 1 ].x + TempVecY[ 0 ].x ;
				DrawVect3D[ 1 ].pos.y = TempVecX[ 1 ].y + TempVecY[ 0 ].y ;
				DrawVect3D[ 1 ].pos.z = TempVecX[ 1 ].z + TempVecY[ 0 ].z ;

				DrawVect3D[ 2 ].pos.x = TempVecX[ 0 ].x + TempVecY[ 1 ].x ;
				DrawVect3D[ 2 ].pos.y = TempVecX[ 0 ].y + TempVecY[ 1 ].y ;
				DrawVect3D[ 2 ].pos.z = TempVecX[ 0 ].z + TempVecY[ 1 ].z ;

				DrawVect3D[ 3 ].pos.x = TempVecX[ 1 ].x + TempVecY[ 1 ].x ;
				DrawVect3D[ 3 ].pos.y = TempVecX[ 1 ].y + TempVecY[ 1 ].y ;
				DrawVect3D[ 3 ].pos.z = TempVecX[ 1 ].z + TempVecY[ 1 ].z ;
			}

			DrawVect3D[4].pos = DrawVect3D[2].pos ;
			DrawVect3D[5].pos = DrawVect3D[1].pos ;

			*( ( DWORD * )&DrawVect3D[0].b ) = 
			*( ( DWORD * )&DrawVect3D[3].b ) = DiffuseColor ;

			if( TurnFlag )
			{
				DrawVect3D[5].u = DrawVect3D[3].u = DrawVect3D[1].u = TexVect[0].u ;
				DrawVect3D[4].u = DrawVect3D[2].u = DrawVect3D[0].u = TexVect[1].u ;
			}
			else
			{
				DrawVect3D[4].u = DrawVect3D[2].u = DrawVect3D[0].u = TexVect[0].u ;
				DrawVect3D[5].u = DrawVect3D[3].u = DrawVect3D[1].u = TexVect[1].u ;
			}
			DrawVect3D[5].v = DrawVect3D[1].v = DrawVect3D[0].v = TexVect[0].v ;
			DrawVect3D[4].v = DrawVect3D[3].v = DrawVect3D[2].v = TexVect[2].v ;

			// テクスチャーを描画する
			ADD4VERTEX_BILLBOARD
		}
		else
		{
			// ビルボードの４頂点を得る
			{
				// 回転する場合としない場合で処理を分岐
				if( Angle != 0.0 )
				{
					// ローカル座標準備
					SrcVec[2].x = SrcVec[0].x = ( -cx + TexVect[0].x ) * ScaleX ;
					SrcVec[3].x = SrcVec[1].x = ( -cx + TexVect[1].x ) * ScaleX ;

					SrcVec[1].y = SrcVec[0].y = ( -cy + Image2->Height - TexVect[0].y ) * ScaleY ;
					SrcVec[3].y = SrcVec[2].y = ( -cy + Image2->Height - TexVect[2].y ) * ScaleY ;

					// 回転計算
					f             = SrcVec[ 0 ].x * Cos - SrcVec[ 0 ].y * Sin ;	
					SrcVec[ 0 ].y = SrcVec[ 0 ].x * Sin + SrcVec[ 0 ].y * Cos ;
					SrcVec[ 0 ].x = f ;

					f             = SrcVec[ 1 ].x * Cos - SrcVec[ 1 ].y * Sin ;	
					SrcVec[ 1 ].y = SrcVec[ 1 ].x * Sin + SrcVec[ 1 ].y * Cos ;
					SrcVec[ 1 ].x = f ;

					f             = SrcVec[ 2 ].x * Cos - SrcVec[ 2 ].y * Sin ;	
					SrcVec[ 2 ].y = SrcVec[ 2 ].x * Sin + SrcVec[ 2 ].y * Cos ;
					SrcVec[ 2 ].x = f ;

					f             = SrcVec[ 3 ].x * Cos - SrcVec[ 3 ].y * Sin ;	
					SrcVec[ 3 ].y = SrcVec[ 3 ].x * Sin + SrcVec[ 3 ].y * Cos ;
					SrcVec[ 3 ].x = f ;

					// ビルボード座標をワールド座標へ変換
					SrcVec2[ 0 ].x = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][0] + SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
					SrcVec2[ 0 ].y = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][1] + SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
					SrcVec2[ 0 ].z = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][2] + SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

					SrcVec2[ 1 ].x = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][0] + SrcVec[ 1 ].y * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
					SrcVec2[ 1 ].y = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][1] + SrcVec[ 1 ].y * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
					SrcVec2[ 1 ].z = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][2] + SrcVec[ 1 ].y * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

					SrcVec2[ 2 ].x = SrcVec[ 2 ].x * GBASE.BillboardMatrix.m[0][0] + SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
					SrcVec2[ 2 ].y = SrcVec[ 2 ].x * GBASE.BillboardMatrix.m[0][1] + SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
					SrcVec2[ 2 ].z = SrcVec[ 2 ].x * GBASE.BillboardMatrix.m[0][2] + SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

					SrcVec2[ 3 ].x = SrcVec[ 3 ].x * GBASE.BillboardMatrix.m[0][0] + SrcVec[ 3 ].y * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
					SrcVec2[ 3 ].y = SrcVec[ 3 ].x * GBASE.BillboardMatrix.m[0][1] + SrcVec[ 3 ].y * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
					SrcVec2[ 3 ].z = SrcVec[ 3 ].x * GBASE.BillboardMatrix.m[0][2] + SrcVec[ 3 ].y * GBASE.BillboardMatrix.m[1][2] + Pos.z ;
				}
				else
				{
					VECTOR TempVecX[ 2 ], TempVecY[ 2 ] ;

					// ローカル座標準備
					SrcVec[0].x = ( -cx + TexVect[0].x ) * ScaleX ;
					SrcVec[1].x = ( -cx + TexVect[1].x ) * ScaleX ;

					SrcVec[0].y = ( -cy + Image2->Height - TexVect[0].y ) * ScaleY ;
					SrcVec[2].y = ( -cy + Image2->Height - TexVect[2].y ) * ScaleY ;

					// ビルボード座標をワールド座標へ変換
					TempVecX[ 0 ].x = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][0] + Pos.x ;
					TempVecX[ 0 ].y = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][1] + Pos.y ;
					TempVecX[ 0 ].z = SrcVec[ 0 ].x * GBASE.BillboardMatrix.m[0][2] + Pos.z ;

					TempVecX[ 1 ].x = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][0] + Pos.x ;
					TempVecX[ 1 ].y = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][1] + Pos.y ;
					TempVecX[ 1 ].z = SrcVec[ 1 ].x * GBASE.BillboardMatrix.m[0][2] + Pos.z ;

					TempVecY[ 0 ].x = SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][0] ;
					TempVecY[ 0 ].y = SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][1] ;
					TempVecY[ 0 ].z = SrcVec[ 0 ].y * GBASE.BillboardMatrix.m[1][2] ;

					TempVecY[ 1 ].x = SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][0] ;
					TempVecY[ 1 ].y = SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][1] ;
					TempVecY[ 1 ].z = SrcVec[ 2 ].y * GBASE.BillboardMatrix.m[1][2] ;

					SrcVec2[ 0 ].x = TempVecX[ 0 ].x + TempVecY[ 0 ].x ;
					SrcVec2[ 0 ].y = TempVecX[ 0 ].y + TempVecY[ 0 ].y ;
					SrcVec2[ 0 ].z = TempVecX[ 0 ].z + TempVecY[ 0 ].z ;

					SrcVec2[ 1 ].x = TempVecX[ 1 ].x + TempVecY[ 0 ].x ;
					SrcVec2[ 1 ].y = TempVecX[ 1 ].y + TempVecY[ 0 ].y ;
					SrcVec2[ 1 ].z = TempVecX[ 1 ].z + TempVecY[ 0 ].z ;

					SrcVec2[ 2 ].x = TempVecX[ 0 ].x + TempVecY[ 1 ].x ;
					SrcVec2[ 2 ].y = TempVecX[ 0 ].y + TempVecY[ 1 ].y ;
					SrcVec2[ 2 ].z = TempVecX[ 0 ].z + TempVecY[ 1 ].z ;

					SrcVec2[ 3 ].x = TempVecX[ 1 ].x + TempVecY[ 1 ].x ;
					SrcVec2[ 3 ].y = TempVecX[ 1 ].y + TempVecY[ 1 ].y ;
					SrcVec2[ 3 ].z = TempVecX[ 1 ].z + TempVecY[ 1 ].z ;
				}
			}

			// 頂点タイプによって処理を分岐
			switch( GRH.VertexType )
			{
			case VERTEXTYPE_BLENDTEX :
				// ブレンドテクスチャを使用する

				// 頂点バッファの取得
				if( DrawFlag )
				{
					GETVERTEX_QUAD( DrawVectB )
				}
				else
				{
					DrawVectB = TempVectB ;
				}

				// スクリーン座標に変換
				DrawVectB[0].pos.x = SrcVec2[0].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
				DrawVectB[0].pos.y = SrcVec2[0].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
				DrawVectB[0].pos.z = SrcVec2[0].x * GBASE.BlendMatrix.m[0][2] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][2] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
				DrawVectB[0].rhw   = SrcVec2[0].x * GBASE.BlendMatrix.m[0][3] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][3] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

				DrawVectB[3].rhw = 
				DrawVectB[2].rhw = 
				DrawVectB[1].rhw = 
				DrawVectB[0].rhw = 1.0F / DrawVectB[0].rhw ;
				DrawVectB[0].pos.x *= DrawVectB[0].rhw ;
				DrawVectB[0].pos.y *= DrawVectB[0].rhw ;
				DrawVectB[3].pos.z =
				DrawVectB[2].pos.z =
				DrawVectB[1].pos.z =
				DrawVectB[0].pos.z *= DrawVectB[0].rhw ;

				DrawVectB[1].pos.x = ( SrcVec2[1].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[1].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[1].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVectB[0].rhw ;
				DrawVectB[1].pos.y = ( SrcVec2[1].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[1].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[1].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVectB[0].rhw ;
				DrawVectB[2].pos.x = ( SrcVec2[2].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[2].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[2].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVectB[0].rhw ;
				DrawVectB[2].pos.y = ( SrcVec2[2].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[2].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[2].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVectB[0].rhw ;
				DrawVectB[3].pos.x = ( SrcVec2[3].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[3].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[3].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVectB[0].rhw ;
				DrawVectB[3].pos.y = ( SrcVec2[3].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[3].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[3].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVectB[0].rhw ;

				DrawVectB[4].pos = DrawVectB[2].pos ;
				DrawVectB[5].pos = DrawVectB[1].pos ;
				DrawVectB[4].rhw = DrawVectB[2].rhw ;
				DrawVectB[5].rhw = DrawVectB[1].rhw ;

				DrawVectB[0].color	= 
				DrawVectB[3].color	= DiffuseColor ;

				if( TurnFlag )
				{
					DrawVectB[5].u1 = DrawVectB[3].u1 = DrawVectB[1].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
					DrawVectB[4].u1 = DrawVectB[2].u1 = DrawVectB[0].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				}
				else
				{
					DrawVectB[4].u1 = DrawVectB[2].u1 = DrawVectB[0].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
					DrawVectB[5].u1 = DrawVectB[3].u1 = DrawVectB[1].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				}
				DrawVectB[4].u2 = DrawVectB[2].u2 = DrawVectB[0].u2 = TexVect[0].u ;
				DrawVectB[5].u2 = DrawVectB[3].u2 = DrawVectB[1].u2 = TexVect[1].u ;

				DrawVectB[5].v1 = DrawVectB[1].v1 = DrawVectB[0].v1 = ( TexVect[0].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				DrawVectB[4].v1 = DrawVectB[3].v1 = DrawVectB[2].v1 = ( TexVect[2].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;

				DrawVectB[5].v2 = DrawVectB[1].v2 = DrawVectB[0].v2 = TexVect[0].v ;
				DrawVectB[4].v2 = DrawVectB[3].v2 = DrawVectB[2].v2 = TexVect[2].v ;

				// テクスチャーを描画する
				if( DrawFlag )
				{
					ADD4VERTEX_BLENDTEX
				}
				else
				{
					if( dright  > DrawVectB[ 0 ].pos.x ) dright  = DrawVectB[ 0 ].pos.x ;
					if( dright  > DrawVectB[ 1 ].pos.x ) dright  = DrawVectB[ 1 ].pos.x ;
					if( dright  > DrawVectB[ 2 ].pos.x ) dright  = DrawVectB[ 2 ].pos.x ;
					if( dright  > DrawVectB[ 3 ].pos.x ) dright  = DrawVectB[ 3 ].pos.x ;

					if( dleft   < DrawVectB[ 0 ].pos.x ) dleft   = DrawVectB[ 0 ].pos.x ;
					if( dleft   < DrawVectB[ 1 ].pos.x ) dleft   = DrawVectB[ 1 ].pos.x ;
					if( dleft   < DrawVectB[ 2 ].pos.x ) dleft   = DrawVectB[ 2 ].pos.x ;
					if( dleft   < DrawVectB[ 3 ].pos.x ) dleft   = DrawVectB[ 3 ].pos.x ;

					if( dbottom > DrawVectB[ 0 ].pos.y ) dbottom = DrawVectB[ 0 ].pos.y ;
					if( dbottom > DrawVectB[ 1 ].pos.y ) dbottom = DrawVectB[ 1 ].pos.y ;
					if( dbottom > DrawVectB[ 2 ].pos.y ) dbottom = DrawVectB[ 2 ].pos.y ;
					if( dbottom > DrawVectB[ 3 ].pos.y ) dbottom = DrawVectB[ 3 ].pos.y ;

					if( dtop    < DrawVectB[ 0 ].pos.y ) dtop    = DrawVectB[ 0 ].pos.y ;
					if( dtop    < DrawVectB[ 1 ].pos.y ) dtop    = DrawVectB[ 1 ].pos.y ;
					if( dtop    < DrawVectB[ 2 ].pos.y ) dtop    = DrawVectB[ 2 ].pos.y ;
					if( dtop    < DrawVectB[ 3 ].pos.y ) dtop    = DrawVectB[ 3 ].pos.y ;
				}

				if( BlendGraphNoIncFlag == FALSE )
				{
					BlendDrawTex ++ ;
				}
				break ;

			case VERTEXTYPE_TEX :
				// ブレンドテクスチャを使用しない

				// 頂点バッファの取得
				if( DrawFlag )
				{
					GETVERTEX_QUAD( DrawVect )
				}
				else
				{
					DrawVect = TempVect;
				}

				// スクリーン座標に変換
				DrawVect[0].pos.x = SrcVec2[0].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
				DrawVect[0].pos.y = SrcVec2[0].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
				DrawVect[0].pos.z = SrcVec2[0].x * GBASE.BlendMatrix.m[0][2] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][2] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
				DrawVect[0].rhw   = SrcVec2[0].x * GBASE.BlendMatrix.m[0][3] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][3] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

				DrawVect[3].rhw = 
				DrawVect[2].rhw = 
				DrawVect[1].rhw = 
				DrawVect[0].rhw = 1.0F / DrawVect[0].rhw ;
				DrawVect[0].pos.x *= DrawVect[0].rhw ;
				DrawVect[0].pos.y *= DrawVect[0].rhw ;
				DrawVect[3].pos.z =
				DrawVect[2].pos.z =
				DrawVect[1].pos.z =
				DrawVect[0].pos.z *= DrawVect[0].rhw ;

				DrawVect[1].pos.x = ( SrcVec2[1].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[1].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[1].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVect[0].rhw ;
				DrawVect[1].pos.y = ( SrcVec2[1].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[1].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[1].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVect[0].rhw ;
				DrawVect[2].pos.x = ( SrcVec2[2].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[2].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[2].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVect[0].rhw ;
				DrawVect[2].pos.y = ( SrcVec2[2].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[2].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[2].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVect[0].rhw ;
				DrawVect[3].pos.x = ( SrcVec2[3].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[3].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[3].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVect[0].rhw ;
				DrawVect[3].pos.y = ( SrcVec2[3].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[3].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[3].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVect[0].rhw ;

				DrawVect[4].pos = DrawVect[2].pos ;
				DrawVect[5].pos = DrawVect[1].pos ;
				DrawVect[4].rhw = DrawVect[2].rhw ;
				DrawVect[5].rhw = DrawVect[1].rhw ;

				DrawVect[0].color	= 
				DrawVect[3].color	= DiffuseColor ;

				if( TurnFlag )
				{
					DrawVect[5].u       = DrawVect[3].u       = DrawVect[1].u       = TexVect[0].u ;
					DrawVect[4].u       = DrawVect[2].u       = DrawVect[0].u       = TexVect[1].u ;
				}
				else
				{
					DrawVect[4].u       = DrawVect[2].u       = DrawVect[0].u       = TexVect[0].u ;
					DrawVect[5].u       = DrawVect[3].u       = DrawVect[1].u       = TexVect[1].u ;
				}
				DrawVect[5].v       = DrawVect[1].v       = DrawVect[0].v       = TexVect[0].v ;
				DrawVect[4].v       = DrawVect[3].v       = DrawVect[2].v       = TexVect[2].v ;

				// テクスチャーを描画する
				if( DrawFlag )
				{
					ADD4VERTEX_TEX
				}
				else
				{
					if( dright  > DrawVect[ 0 ].pos.x ) dright  = DrawVect[ 0 ].pos.x ;
					if( dright  > DrawVect[ 1 ].pos.x ) dright  = DrawVect[ 1 ].pos.x ;
					if( dright  > DrawVect[ 2 ].pos.x ) dright  = DrawVect[ 2 ].pos.x ;
					if( dright  > DrawVect[ 3 ].pos.x ) dright  = DrawVect[ 3 ].pos.x ;

					if( dleft   < DrawVect[ 0 ].pos.x ) dleft   = DrawVect[ 0 ].pos.x ;
					if( dleft   < DrawVect[ 1 ].pos.x ) dleft   = DrawVect[ 1 ].pos.x ;
					if( dleft   < DrawVect[ 2 ].pos.x ) dleft   = DrawVect[ 2 ].pos.x ;
					if( dleft   < DrawVect[ 3 ].pos.x ) dleft   = DrawVect[ 3 ].pos.x ;

					if( dbottom > DrawVect[ 0 ].pos.y ) dbottom = DrawVect[ 0 ].pos.y ;
					if( dbottom > DrawVect[ 1 ].pos.y ) dbottom = DrawVect[ 1 ].pos.y ;
					if( dbottom > DrawVect[ 2 ].pos.y ) dbottom = DrawVect[ 2 ].pos.y ;
					if( dbottom > DrawVect[ 3 ].pos.y ) dbottom = DrawVect[ 3 ].pos.y ;

					if( dtop    < DrawVect[ 0 ].pos.y ) dtop    = DrawVect[ 0 ].pos.y ;
					if( dtop    < DrawVect[ 1 ].pos.y ) dtop    = DrawVect[ 1 ].pos.y ;
					if( dtop    < DrawVect[ 2 ].pos.y ) dtop    = DrawVect[ 2 ].pos.y ;
					if( dtop    < DrawVect[ 3 ].pos.y ) dtop    = DrawVect[ 3 ].pos.y ;
				}
				break ;
			}
		}
	}

	if( DrawFlag == FALSE )
	{
		DrawArea->left   = _FTOL( dleft   ) - 1 ;
		DrawArea->right  = _FTOL( dright  ) + 1 ;
		DrawArea->top    = _FTOL( dtop    ) - 1 ;
		DrawArea->bottom = _FTOL( dbottom ) + 1 ;
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawModiBillboard3DHardware
static int DrawModiBillboard3DHardware( VECTOR Pos, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int DrawFlag, RECT *DrawArea )
{
	VERTEX_2D *DrawVect ;
	VERTEX_3D *DrawVect3D ;
	VERTEX_BLENDTEX_2D *DrawVectB ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	IMAGEDATA2_HARD_DRAW *BlendDrawTex ;
	IMAGEDATA2_ORIG *Orig ;
	IMAGEDATA2_HARD_VERT *TexVect ;
	IMAGEDATA2_HARD_VERT *BlendTexVect = NULL ;
	DWORD DiffuseColor ;
	int DrawTexNum ;
	int i, Flag ;
	int BlendGraphNoIncFlag ;
	VECTOR SrcVec2[ 4 ] ;
	float dleft = 0.0f, dright = 0.0f, dtop = 0.0f, dbottom = 0.0f;

	Orig = Image2->Orig ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// 描画準備
	if( DrawFlag )
	{
		if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
		Flag = TransFlag | DRAWPREP_3D | DRAWPREP_FOG | DRAWPREP_TEXADDRESS ;
		DRAWPREP_TEX( Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		dleft   = -100000000.0f ;
		dright  =  100000000.0f ;
		dtop    = -100000000.0f ;
		dbottom =  100000000.0f ;
	}

	// 頂点データを取得
	DiffuseColor = GRH.DiffuseColor ;

	// 描画情報の数をセット
	DrawTexNum = Image2->Hard.DrawNum ;

	// 描画情報の数がブレンド画像と異なっていたら０番目のテクスチャだけを使用する
	BlendGraphNoIncFlag = FALSE ;
	if( BlendImage2 != NULL && BlendImage2->Hard.DrawNum != Image2->Hard.DrawNum )
	{
		BlendGraphNoIncFlag = TRUE ;
	}

	// 描画情報配列のアドレスをセットしておく
	DrawTex = Image2->Hard.Draw ;
	BlendDrawTex = NULL ;
	if( BlendImage2 != NULL )
	{
		BlendDrawTex = BlendImage2->Hard.Draw ;
	}

	// テクスチャーの数だけ繰り返す
	for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
	{
		// 描画するテクスチャーのセット
		if( DrawFlag )
		{
			if( GRH.RenderTexture != DrawTex->Tex->Texture )
				SetTextureHardware( DrawTex->Tex->Texture ) ;
			if( BlendDrawTex != NULL )
			{
				if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
					SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
			}
			if( GRH.ChangeTextureFlag )
				RefreshBlendStateHardware() ;
		}

		TexVect = DrawTex->Vertex ;
		if( BlendDrawTex != NULL )
		{
			BlendTexVect = BlendDrawTex->Vertex ;
		}

		// ブレンドグラフィックを使用していなくて、且つ描画する場合は高速な処理を使用する
		if( GRH.VertexType != VERTEXTYPE_BLENDTEX && DrawFlag == TRUE )
		{
			GETVERTEX_BILLBOARD( DrawVect3D ) ;

			// ビルボード座標をワールド座標へ変換
			DrawVect3D[ 0 ].pos.x = x1 * GBASE.BillboardMatrix.m[0][0] + y1 * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
			DrawVect3D[ 0 ].pos.y = x1 * GBASE.BillboardMatrix.m[0][1] + y1 * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
			DrawVect3D[ 0 ].pos.z = x1 * GBASE.BillboardMatrix.m[0][2] + y1 * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

			DrawVect3D[ 1 ].pos.x = x2 * GBASE.BillboardMatrix.m[0][0] + y2 * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
			DrawVect3D[ 1 ].pos.y = x2 * GBASE.BillboardMatrix.m[0][1] + y2 * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
			DrawVect3D[ 1 ].pos.z = x2 * GBASE.BillboardMatrix.m[0][2] + y2 * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

			DrawVect3D[ 2 ].pos.x = x4 * GBASE.BillboardMatrix.m[0][0] + y4 * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
			DrawVect3D[ 2 ].pos.y = x4 * GBASE.BillboardMatrix.m[0][1] + y4 * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
			DrawVect3D[ 2 ].pos.z = x4 * GBASE.BillboardMatrix.m[0][2] + y4 * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

			DrawVect3D[ 3 ].pos.x = x3 * GBASE.BillboardMatrix.m[0][0] + y3 * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
			DrawVect3D[ 3 ].pos.y = x3 * GBASE.BillboardMatrix.m[0][1] + y3 * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
			DrawVect3D[ 3 ].pos.z = x3 * GBASE.BillboardMatrix.m[0][2] + y3 * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

			DrawVect3D[4].pos = DrawVect3D[2].pos ;
			DrawVect3D[5].pos = DrawVect3D[1].pos ;

			*( ( DWORD * )&DrawVect3D[0].b ) = 
			*( ( DWORD * )&DrawVect3D[3].b )	= DiffuseColor ;

			DrawVect3D[4].u       = DrawVect3D[2].u       = DrawVect3D[0].u       = TexVect[0].u ;
			DrawVect3D[5].u       = DrawVect3D[3].u       = DrawVect3D[1].u       = TexVect[1].u ;
			DrawVect3D[5].v       = DrawVect3D[1].v       = DrawVect3D[0].v       = TexVect[0].v ;
			DrawVect3D[4].v       = DrawVect3D[3].v       = DrawVect3D[2].v       = TexVect[2].v ;

			// テクスチャーを描画する
			ADD4VERTEX_BILLBOARD
		}
		else
		{
			// ビルボードの４頂点を得る
			{
				// ビルボード座標をワールド座標へ変換
				SrcVec2[ 0 ].x = x1 * GBASE.BillboardMatrix.m[0][0] + y1 * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
				SrcVec2[ 0 ].y = x1 * GBASE.BillboardMatrix.m[0][1] + y1 * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
				SrcVec2[ 0 ].z = x1 * GBASE.BillboardMatrix.m[0][2] + y1 * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

				SrcVec2[ 1 ].x = x2 * GBASE.BillboardMatrix.m[0][0] + y2 * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
				SrcVec2[ 1 ].y = x2 * GBASE.BillboardMatrix.m[0][1] + y2 * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
				SrcVec2[ 1 ].z = x2 * GBASE.BillboardMatrix.m[0][2] + y2 * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

				SrcVec2[ 2 ].x = x4 * GBASE.BillboardMatrix.m[0][0] + y4 * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
				SrcVec2[ 2 ].y = x4 * GBASE.BillboardMatrix.m[0][1] + y4 * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
				SrcVec2[ 2 ].z = x4 * GBASE.BillboardMatrix.m[0][2] + y4 * GBASE.BillboardMatrix.m[1][2] + Pos.z ;

				SrcVec2[ 3 ].x = x3 * GBASE.BillboardMatrix.m[0][0] + y3 * GBASE.BillboardMatrix.m[1][0] + Pos.x ;
				SrcVec2[ 3 ].y = x3 * GBASE.BillboardMatrix.m[0][1] + y3 * GBASE.BillboardMatrix.m[1][1] + Pos.y ;
				SrcVec2[ 3 ].z = x3 * GBASE.BillboardMatrix.m[0][2] + y3 * GBASE.BillboardMatrix.m[1][2] + Pos.z ;
			}

			// 頂点タイプによって処理を分岐
			switch( GRH.VertexType )
			{
			case VERTEXTYPE_BLENDTEX :
				// ブレンドテクスチャを使用する

				// 頂点バッファの取得
				GETVERTEX_QUAD( DrawVectB )

				// スクリーン座標に変換
				DrawVectB[0].pos.x = SrcVec2[0].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
				DrawVectB[0].pos.y = SrcVec2[0].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
				DrawVectB[0].pos.z = SrcVec2[0].x * GBASE.BlendMatrix.m[0][2] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][2] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
				DrawVectB[0].rhw   = SrcVec2[0].x * GBASE.BlendMatrix.m[0][3] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][3] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

				DrawVectB[3].rhw = 
				DrawVectB[2].rhw = 
				DrawVectB[1].rhw = 
				DrawVectB[0].rhw = 1.0F / DrawVectB[0].rhw ;
				DrawVectB[0].pos.x *= DrawVectB[0].rhw ;
				DrawVectB[0].pos.y *= DrawVectB[0].rhw ;
				DrawVectB[3].pos.z =
				DrawVectB[2].pos.z =
				DrawVectB[1].pos.z =
				DrawVectB[0].pos.z *= DrawVectB[0].rhw ;

				DrawVectB[1].pos.x = ( SrcVec2[1].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[1].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[1].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVectB[0].rhw ;
				DrawVectB[1].pos.y = ( SrcVec2[1].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[1].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[1].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVectB[0].rhw ;
				DrawVectB[2].pos.x = ( SrcVec2[2].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[2].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[2].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVectB[0].rhw ;
				DrawVectB[2].pos.y = ( SrcVec2[2].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[2].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[2].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVectB[0].rhw ;
				DrawVectB[3].pos.x = ( SrcVec2[3].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[3].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[3].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVectB[0].rhw ;
				DrawVectB[3].pos.y = ( SrcVec2[3].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[3].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[3].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVectB[0].rhw ;

				DrawVectB[4].pos = DrawVectB[2].pos ;
				DrawVectB[5].pos = DrawVectB[1].pos ;
				DrawVectB[4].rhw = DrawVectB[2].rhw ;
				DrawVectB[5].rhw = DrawVectB[1].rhw ;

				DrawVectB[0].color	= 
				DrawVectB[3].color	= DiffuseColor ;

				DrawVectB[4].u1 = DrawVectB[2].u1 = DrawVectB[0].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				DrawVectB[5].u1 = DrawVectB[3].u1 = DrawVectB[1].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				DrawVectB[5].v1 = DrawVectB[1].v1 = DrawVectB[0].v1 = ( TexVect[0].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				DrawVectB[4].v1 = DrawVectB[3].v1 = DrawVectB[2].v1 = ( TexVect[2].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;

				DrawVectB[4].u2 = DrawVectB[2].u2 = DrawVectB[0].u2 = TexVect[0].u ;
				DrawVectB[5].u2 = DrawVectB[3].u2 = DrawVectB[1].u2 = TexVect[1].u ;
				DrawVectB[5].v2 = DrawVectB[1].v2 = DrawVectB[0].v2 = TexVect[0].v ;
				DrawVectB[4].v2 = DrawVectB[3].v2 = DrawVectB[2].v2 = TexVect[2].v ;

				// テクスチャーを描画する
				if( DrawFlag )
				{
					ADD4VERTEX_BLENDTEX
				}
				else
				{
					if( dright  > DrawVectB[ 0 ].pos.x ) dright  = DrawVectB[ 0 ].pos.x ;
					if( dright  > DrawVectB[ 1 ].pos.x ) dright  = DrawVectB[ 1 ].pos.x ;
					if( dright  > DrawVectB[ 2 ].pos.x ) dright  = DrawVectB[ 2 ].pos.x ;
					if( dright  > DrawVectB[ 3 ].pos.x ) dright  = DrawVectB[ 3 ].pos.x ;

					if( dleft   < DrawVectB[ 0 ].pos.x ) dleft   = DrawVectB[ 0 ].pos.x ;
					if( dleft   < DrawVectB[ 1 ].pos.x ) dleft   = DrawVectB[ 1 ].pos.x ;
					if( dleft   < DrawVectB[ 2 ].pos.x ) dleft   = DrawVectB[ 2 ].pos.x ;
					if( dleft   < DrawVectB[ 3 ].pos.x ) dleft   = DrawVectB[ 3 ].pos.x ;

					if( dbottom > DrawVectB[ 0 ].pos.y ) dbottom = DrawVectB[ 0 ].pos.y ;
					if( dbottom > DrawVectB[ 1 ].pos.y ) dbottom = DrawVectB[ 1 ].pos.y ;
					if( dbottom > DrawVectB[ 2 ].pos.y ) dbottom = DrawVectB[ 2 ].pos.y ;
					if( dbottom > DrawVectB[ 3 ].pos.y ) dbottom = DrawVectB[ 3 ].pos.y ;

					if( dtop    < DrawVectB[ 0 ].pos.y ) dtop    = DrawVectB[ 0 ].pos.y ;
					if( dtop    < DrawVectB[ 1 ].pos.y ) dtop    = DrawVectB[ 1 ].pos.y ;
					if( dtop    < DrawVectB[ 2 ].pos.y ) dtop    = DrawVectB[ 2 ].pos.y ;
					if( dtop    < DrawVectB[ 3 ].pos.y ) dtop    = DrawVectB[ 3 ].pos.y ;
				}

				if( BlendGraphNoIncFlag == FALSE )
				{
					BlendDrawTex ++ ;
				}
				break ;

			case VERTEXTYPE_TEX :
				// ブレンドテクスチャを使用しない

				// 頂点バッファの取得
				GETVERTEX_QUAD( DrawVect )

				// スクリーン座標に変換
				DrawVect[0].pos.x = SrcVec2[0].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
				DrawVect[0].pos.y = SrcVec2[0].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
				DrawVect[0].pos.z = SrcVec2[0].x * GBASE.BlendMatrix.m[0][2] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][2] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
				DrawVect[0].rhw   = SrcVec2[0].x * GBASE.BlendMatrix.m[0][3] + SrcVec2[0].y * GBASE.BlendMatrix.m[1][3] + SrcVec2[0].z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

				DrawVect[3].rhw = 
				DrawVect[2].rhw = 
				DrawVect[1].rhw = 
				DrawVect[0].rhw = 1.0F / DrawVect[0].rhw ;
				DrawVect[0].pos.x *= DrawVect[0].rhw ;
				DrawVect[0].pos.y *= DrawVect[0].rhw ;
				DrawVect[3].pos.z =
				DrawVect[2].pos.z =
				DrawVect[1].pos.z =
				DrawVect[0].pos.z *= DrawVect[0].rhw ;

				DrawVect[1].pos.x = ( SrcVec2[1].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[1].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[1].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVect[0].rhw ;
				DrawVect[1].pos.y = ( SrcVec2[1].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[1].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[1].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVect[0].rhw ;
				DrawVect[2].pos.x = ( SrcVec2[2].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[2].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[2].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVect[0].rhw ;
				DrawVect[2].pos.y = ( SrcVec2[2].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[2].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[2].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVect[0].rhw ;
				DrawVect[3].pos.x = ( SrcVec2[3].x * GBASE.BlendMatrix.m[0][0] + SrcVec2[3].y * GBASE.BlendMatrix.m[1][0] + SrcVec2[3].z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0] ) * DrawVect[0].rhw ;
				DrawVect[3].pos.y = ( SrcVec2[3].x * GBASE.BlendMatrix.m[0][1] + SrcVec2[3].y * GBASE.BlendMatrix.m[1][1] + SrcVec2[3].z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1] ) * DrawVect[0].rhw ;

				DrawVect[4].pos = DrawVect[2].pos ;
				DrawVect[5].pos = DrawVect[1].pos ;
				DrawVect[4].rhw = DrawVect[2].rhw ;
				DrawVect[5].rhw = DrawVect[1].rhw ;

				DrawVect[0].color	= 
				DrawVect[3].color	= DiffuseColor ;

				DrawVect[4].u       = DrawVect[2].u       = DrawVect[0].u       = TexVect[0].u ;
				DrawVect[5].u       = DrawVect[3].u       = DrawVect[1].u       = TexVect[1].u ;
				DrawVect[5].v       = DrawVect[1].v       = DrawVect[0].v       = TexVect[0].v ;
				DrawVect[4].v       = DrawVect[3].v       = DrawVect[2].v       = TexVect[2].v ;

				// テクスチャーを描画する
				if( DrawFlag )
				{
					ADD4VERTEX_TEX
				}
				else
				{
					if( dright  > DrawVect[ 0 ].pos.x ) dright  = DrawVect[ 0 ].pos.x ;
					if( dright  > DrawVect[ 1 ].pos.x ) dright  = DrawVect[ 1 ].pos.x ;
					if( dright  > DrawVect[ 2 ].pos.x ) dright  = DrawVect[ 2 ].pos.x ;
					if( dright  > DrawVect[ 3 ].pos.x ) dright  = DrawVect[ 3 ].pos.x ;

					if( dleft   < DrawVect[ 0 ].pos.x ) dleft   = DrawVect[ 0 ].pos.x ;
					if( dleft   < DrawVect[ 1 ].pos.x ) dleft   = DrawVect[ 1 ].pos.x ;
					if( dleft   < DrawVect[ 2 ].pos.x ) dleft   = DrawVect[ 2 ].pos.x ;
					if( dleft   < DrawVect[ 3 ].pos.x ) dleft   = DrawVect[ 3 ].pos.x ;

					if( dbottom > DrawVect[ 0 ].pos.y ) dbottom = DrawVect[ 0 ].pos.y ;
					if( dbottom > DrawVect[ 1 ].pos.y ) dbottom = DrawVect[ 1 ].pos.y ;
					if( dbottom > DrawVect[ 2 ].pos.y ) dbottom = DrawVect[ 2 ].pos.y ;
					if( dbottom > DrawVect[ 3 ].pos.y ) dbottom = DrawVect[ 3 ].pos.y ;

					if( dtop    < DrawVect[ 0 ].pos.y ) dtop    = DrawVect[ 0 ].pos.y ;
					if( dtop    < DrawVect[ 1 ].pos.y ) dtop    = DrawVect[ 1 ].pos.y ;
					if( dtop    < DrawVect[ 2 ].pos.y ) dtop    = DrawVect[ 2 ].pos.y ;
					if( dtop    < DrawVect[ 3 ].pos.y ) dtop    = DrawVect[ 3 ].pos.y ;
				}
				break ;
			}
		}
	}

	if( DrawFlag == FALSE )
	{
		DrawArea->left   = _FTOL( dleft   ) - 1 ;
		DrawArea->right  = _FTOL( dright  ) + 1 ;
		DrawArea->top    = _FTOL( dtop    ) - 1 ;
		DrawArea->bottom = _FTOL( dbottom ) + 1 ;
	}

	// 終了
	return 0 ;
}



// 分岐が必要な描画系関数

// ハードウエアアクセラレータ使用版 DrawGraph
static int  DrawGraphHardware( int x, int y, float xf, float yf, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int IntFlag )
{
	VERTEX_2D *DrawVect, *Vect ;
	VERTEX_BLENDTEX_2D *DrawVectB, *VectB ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	IMAGEDATA2_HARD_DRAW *BlendDrawTex = NULL ;
	IMAGEDATA2_ORIG *Orig ;
	IMAGEDATA2_HARD_VERT *TexVect ;
	IMAGEDATA2_HARD_VERT *BlendTexVect ;
	DWORD DiffuseColor ;
	int DrawTexNum ;
	int i, j, Flag ;
	int BlendGraphNoIncFlag ;
	float left, right, top, bottom ;
	float Vx, Vy, VBx, VBy ;
	DWORD drawz;

	Orig = Image2->Orig ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// float座標補正
	xf -= 0.5F ;
	yf -= 0.5F ;

	// 描画準備
	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
	Flag = TransFlag | ( IntFlag << 1 ) ;
	DRAWPREP_TEX( Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )

	// 頂点データを取得
	DiffuseColor = GRH.DiffuseColor ;

	// 描画情報の数をセット
	DrawTexNum = Image2->Hard.DrawNum ;

	// 描画情報の数がブレンド画像と異なっていたら０番目のテクスチャだけを使用する
	BlendGraphNoIncFlag = FALSE ;
	if( BlendImage2 != NULL && BlendImage2->Hard.DrawNum != Image2->Hard.DrawNum )
	{
		BlendGraphNoIncFlag = TRUE ;
	}

	// 描画情報配列のアドレスをセットしておく
	DrawTex = Image2->Hard.Draw ;
	if( BlendImage2 != NULL )
	{
		BlendDrawTex = BlendImage2->Hard.Draw ;
	}

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *( ( DWORD * )&GBASE.DrawZ ) ;

	// 描画範囲からはみ出ているかどうかで処理を分岐
	if( IN_DRAWAREA_CHECK( x, y, x + Image2->Width, y + Image2->Height ) )
//	if( x + Image2->Width < GBASE.DrawArea.right && x > GBASE.DrawArea.left &&
//		y + Image2->Height < GBASE.DrawArea.bottom && y > GBASE.DrawArea.right )
	{
		// はみ出ていない場合

		// 頂点タイプによって処理を分岐
		if( GRH.VertexType == VERTEXTYPE_BLENDTEX )
		{
			// ブレンドテクスチャを使用する

			// テクスチャーの数だけ繰り返す
			for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
			{
				// 描画するテクスチャーのセット
				if( GRH.RenderTexture != DrawTex->Tex->Texture )
					SetTextureHardware( DrawTex->Tex->Texture ) ;
				if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
					SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
				if( GRH.ChangeTextureFlag )
					RefreshBlendStateHardware() ;

				// 頂点バッファの取得
				GETVERTEX_QUAD( DrawVectB )
				
				TexVect = DrawTex->Vertex ;
				BlendTexVect = BlendDrawTex->Vertex ;

				DrawVectB[0].color = 
				DrawVectB[3].color = ( DWORD )DiffuseColor ;

				DrawVectB[4].pos.x = DrawVectB[2].pos.x = DrawVectB[0].pos.x = xf + TexVect[0].x ;
				DrawVectB[5].pos.x = DrawVectB[3].pos.x = DrawVectB[1].pos.x = xf + TexVect[1].x ;
				DrawVectB[5].pos.y = DrawVectB[1].pos.y = DrawVectB[0].pos.y = yf + TexVect[0].y ;
				DrawVectB[4].pos.y = DrawVectB[3].pos.y = DrawVectB[2].pos.y = yf + TexVect[2].y ;

				DrawVectB[4].u1 = DrawVectB[2].u1 = DrawVectB[0].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				DrawVectB[5].u1 = DrawVectB[3].u1 = DrawVectB[1].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				DrawVectB[5].v1 = DrawVectB[1].v1 = DrawVectB[0].v1 = ( TexVect[0].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				DrawVectB[4].v1 = DrawVectB[3].v1 = DrawVectB[2].v1 = ( TexVect[2].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;

				DrawVectB[4].u2 = DrawVectB[2].u2 = DrawVectB[0].u2 = TexVect[0].u ;
				DrawVectB[5].u2 = DrawVectB[3].u2 = DrawVectB[1].u2 = TexVect[1].u ;
				DrawVectB[5].v2 = DrawVectB[1].v2 = DrawVectB[0].v2 = TexVect[0].v ;
				DrawVectB[4].v2 = DrawVectB[3].v2 = DrawVectB[2].v2 = TexVect[2].v ;

				if( GRH.UseAlphaChDrawShader )
				{
					DrawVectB[4].sc_u   = DrawVectB[2].sc_u   = DrawVectB[0].sc_u   = ( DrawVectB[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVectB[5].sc_u   = DrawVectB[3].sc_u   = DrawVectB[1].sc_u   = ( DrawVectB[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVectB[5].sc_v   = DrawVectB[1].sc_v   = DrawVectB[0].sc_v   = ( DrawVectB[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					DrawVectB[4].sc_v   = DrawVectB[3].sc_v   = DrawVectB[2].sc_v   = ( DrawVectB[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				*((DWORD *)&DrawVectB[0].pos.z) =
				*((DWORD *)&DrawVectB[1].pos.z) =
				*((DWORD *)&DrawVectB[2].pos.z) =
				*((DWORD *)&DrawVectB[3].pos.z) =
				*((DWORD *)&DrawVectB[4].pos.z) =
				*((DWORD *)&DrawVectB[5].pos.z) = drawz;

				// テクスチャーを描画する
				ADD4VERTEX_BLENDTEX

				if( BlendGraphNoIncFlag == FALSE )
				{
					BlendDrawTex ++ ;
				}
			}
		}
		else
		{
			// ブレンドテクスチャを使用しない

			// テクスチャーの数だけ繰り返す
			i = 0 ;
			for(;;)
			{
				// 頂点バッファの取得
				GETVERTEX_QUAD( DrawVect )

				// 頂点データ準備
				TexVect = DrawTex->Vertex ;
				DrawVect[0].color	= 
				DrawVect[3].color	= DiffuseColor ;

				DrawVect[4].pos.x   = DrawVect[2].pos.x   = DrawVect[0].pos.x   = TexVect[0].x + xf ;
				DrawVect[5].pos.x   = DrawVect[3].pos.x   = DrawVect[1].pos.x   = TexVect[1].x + xf ;
				DrawVect[5].pos.y   = DrawVect[1].pos.y   = DrawVect[0].pos.y   = TexVect[0].y + yf ;
				DrawVect[4].pos.y   = DrawVect[3].pos.y   = DrawVect[2].pos.y   = TexVect[2].y + yf ;

				DrawVect[4].u       = DrawVect[2].u       = DrawVect[0].u       = TexVect[0].u ;
				DrawVect[5].u       = DrawVect[3].u       = DrawVect[1].u       = TexVect[1].u ;
				DrawVect[5].v       = DrawVect[1].v       = DrawVect[0].v       = TexVect[0].v ;
				DrawVect[4].v       = DrawVect[3].v       = DrawVect[2].v       = TexVect[2].v ;

				if( GRH.UseAlphaChDrawShader )
				{
					DrawVect[4].sc_u   = DrawVect[2].sc_u   = DrawVect[0].sc_u   = ( DrawVect[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVect[5].sc_u   = DrawVect[3].sc_u   = DrawVect[1].sc_u   = ( DrawVect[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVect[5].sc_v   = DrawVect[1].sc_v   = DrawVect[0].sc_v   = ( DrawVect[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					DrawVect[4].sc_v   = DrawVect[3].sc_v   = DrawVect[2].sc_v   = ( DrawVect[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				*((DWORD *)&DrawVect[0].pos.z) =
				*((DWORD *)&DrawVect[1].pos.z) =
				*((DWORD *)&DrawVect[2].pos.z) =
				*((DWORD *)&DrawVect[3].pos.z) =
				*((DWORD *)&DrawVect[4].pos.z) =
				*((DWORD *)&DrawVect[5].pos.z) = drawz;

				// テクスチャーを描画する
				ADD4VERTEX_TEX

				i ++ ;
				if( i >= DrawTexNum ) break ;

				// 描画するテクスチャーのセット
				DrawTex ++ ;
				SetTextureHardware( DrawTex->Tex->Texture ) ;
				RefreshBlendStateHardware() ;
			}
		}
	}
	else
	{
		// はみ出ている場合

		// 完全にはみ出ていたら何もせず終了
		if( OUT_DRAWAREA_CHECK( x, y, x + Image2->Width, y + Image2->Height ) ) return 0 ;
//		if( x > GBASE.DrawArea.right || x + Image2->Width < GBASE.DrawArea.left ||
//			y > GBASE.DrawArea.bottom || y + Image2->Height < GBASE.DrawArea.top ) return 0 ;

		// 描画矩形の保存
		left	= GBASE.DrawAreaF.left   ;
		top		= GBASE.DrawAreaF.top    ;
		right	= GBASE.DrawAreaF.right  ;
		bottom	= GBASE.DrawAreaF.bottom ;

		// 頂点タイプによって処理を分岐
		switch( GRH.VertexType )
		{
		case VERTEXTYPE_BLENDTEX :
			// ブレンドテクスチャを使用する

			// テクスチャーの数だけ繰り返す
			for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
			{
				// 描画するテクスチャーのセット
				if( GRH.RenderTexture != DrawTex->Tex->Texture )
					SetTextureHardware( DrawTex->Tex->Texture ) ;
				if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
					SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
				if( GRH.ChangeTextureFlag )
					RefreshBlendStateHardware() ;

				// 頂点バッファの取得
				GETVERTEX_QUAD( DrawVectB )
				
				// 頂点データを初期化する
				VectB = DrawVectB ;
				TexVect = DrawTex->Vertex ;
				BlendTexVect = BlendDrawTex->Vertex ;

				Vx  = 1.0F / ( float )DrawTex->Tex->TexWidth  ;
				Vy  = 1.0F / ( float )DrawTex->Tex->TexHeight ;
				VBx = GRH.InvBlendTextureWidth  ;
				VBy = GRH.InvBlendTextureHeight ;

				DrawVectB[0].color = 
				DrawVectB[3].color = ( DWORD )DiffuseColor ;

				DrawVectB[2].pos.x = DrawVectB[0].pos.x = xf + TexVect[0].x ;
				DrawVectB[3].pos.x = DrawVectB[1].pos.x = xf + TexVect[1].x ;
				DrawVectB[1].pos.y = DrawVectB[0].pos.y = yf + TexVect[0].y ;
				DrawVectB[3].pos.y = DrawVectB[2].pos.y = yf + TexVect[2].y ;

				DrawVectB[2].u1 = DrawVectB[0].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				DrawVectB[3].u1 = DrawVectB[1].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				DrawVectB[1].v1 = DrawVectB[0].v1 = ( TexVect[0].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				DrawVectB[3].v1 = DrawVectB[2].v1 = ( TexVect[2].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;

				DrawVectB[2].u2 = DrawVectB[0].u2 = TexVect[0].u ;
				DrawVectB[3].u2 = DrawVectB[1].u2 = TexVect[1].u ;
				DrawVectB[1].v2 = DrawVectB[0].v2 = TexVect[0].v ;
				DrawVectB[3].v2 = DrawVectB[2].v2 = TexVect[2].v ;

				for( j = 0 ; j < 4 ; j ++, VectB ++ )
				{
					// 描画矩形から出ていた場合の補正処理
					if( VectB->pos.x < left )
					{
						VectB->u2 += ( left - VectB->pos.x ) * Vx ;
						VectB->u1 += ( left - VectB->pos.x ) * VBx ;
						VectB->pos.x = left ;
					}
					else
					if( VectB->pos.x > right )
					{
						VectB->u2 -= ( VectB->pos.x - right ) * Vx ;
						VectB->u1 -= ( VectB->pos.x - right ) * VBx ;
						VectB->pos.x = right ;
					}	

					if( VectB->pos.y < top )
					{
						VectB->v2 += ( top - VectB->pos.y ) * Vy ;
						VectB->v1 += ( top - VectB->pos.y ) * VBy ;
						VectB->pos.y = top ;
					}
					else
					if( VectB->pos.y > bottom )
					{
						VectB->v2 -= ( VectB->pos.y - bottom ) * Vy ;
						VectB->v1 -= ( VectB->pos.y - bottom ) * VBy ;
						VectB->pos.y = bottom ;
					}
				}

				if( GRH.UseAlphaChDrawShader )
				{
					DrawVectB[0].sc_u = ( DrawVectB[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVectB[0].sc_v = ( DrawVectB[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					DrawVectB[1].sc_u = ( DrawVectB[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVectB[1].sc_v = ( DrawVectB[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					DrawVectB[2].sc_u = ( DrawVectB[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVectB[2].sc_v = ( DrawVectB[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					DrawVectB[3].sc_u = ( DrawVectB[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVectB[3].sc_v = ( DrawVectB[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				DrawVectB[4] = DrawVectB[2] ;
				DrawVectB[5] = DrawVectB[1] ;

				*((DWORD *)&DrawVectB[0].pos.z) =
				*((DWORD *)&DrawVectB[1].pos.z) =
				*((DWORD *)&DrawVectB[2].pos.z) =
				*((DWORD *)&DrawVectB[3].pos.z) =
				*((DWORD *)&DrawVectB[4].pos.z) =
				*((DWORD *)&DrawVectB[5].pos.z) = drawz;

				// テクスチャーを描画する
				ADD4VERTEX_BLENDTEX

				if( BlendGraphNoIncFlag == FALSE )
				{
					BlendDrawTex ++ ;
				}
			}
			break ;
		
		case VERTEXTYPE_TEX :
			// ブレンドテクスチャを使用しない

			// テクスチャーの数だけ繰り返す
			i = 0 ;
			for(;;)
			{
				// 頂点バッファの取得
				GETVERTEX_QUAD( DrawVect )
				
				// 頂点データ準備
				TexVect = DrawTex->Vertex ;
				DrawVect[0].color	= 
				DrawVect[3].color	= DiffuseColor ;

				DrawVect[2].pos.x   = DrawVect[0].pos.x   = TexVect[0].x + xf ;
				DrawVect[3].pos.x   = DrawVect[1].pos.x   = TexVect[1].x + xf ;
				DrawVect[1].pos.y   = DrawVect[0].pos.y   = TexVect[0].y + yf ;
				DrawVect[3].pos.y   = DrawVect[2].pos.y   = TexVect[2].y + yf ;

				DrawVect[2].u       = DrawVect[0].u       = TexVect[0].u ;
				DrawVect[3].u       = DrawVect[1].u       = TexVect[1].u ;
				DrawVect[1].v       = DrawVect[0].v       = TexVect[0].v ;
				DrawVect[3].v       = DrawVect[2].v       = TexVect[2].v ;
				
				// 頂点データを初期化する
				Vect = DrawVect ;
				Vx	= 1.0F / ( float )DrawTex->Tex->TexWidth ;
				Vy	= 1.0F / ( float )DrawTex->Tex->TexHeight ;
				for( j = 0 ; j < 4 ; j ++, Vect ++ )
				{
					// 描画矩形から出ていた場合の補正処理
					if( Vect->pos.x < left )
					{
						Vect->u += ( left - Vect->pos.x ) * Vx ;
						Vect->pos.x = left ;
					}
					else
					if( Vect->pos.x > right )
					{
						Vect->u -= ( Vect->pos.x - right ) * Vx ;
						Vect->pos.x = right ;
					}	

					if( Vect->pos.y < top )
					{
						Vect->v += ( top - Vect->pos.y ) * Vy ;
						Vect->pos.y = top ;
					}
					else
					if( Vect->pos.y > bottom )
					{
						Vect->v -= ( Vect->pos.y - bottom ) * Vy ;
						Vect->pos.y = bottom ;
					}
				}
				
				if( GRH.UseAlphaChDrawShader )
				{
					DrawVect[0].sc_u = ( DrawVect[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVect[0].sc_v = ( DrawVect[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					DrawVect[1].sc_u = ( DrawVect[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVect[1].sc_v = ( DrawVect[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					DrawVect[2].sc_u = ( DrawVect[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVect[2].sc_v = ( DrawVect[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					DrawVect[3].sc_u = ( DrawVect[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					DrawVect[3].sc_v = ( DrawVect[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				DrawVect[4] = DrawVect[2] ;
				DrawVect[5] = DrawVect[1] ;

				*((DWORD *)&DrawVect[0].pos.z) =
				*((DWORD *)&DrawVect[1].pos.z) =
				*((DWORD *)&DrawVect[2].pos.z) =
				*((DWORD *)&DrawVect[3].pos.z) =
				*((DWORD *)&DrawVect[4].pos.z) =
				*((DWORD *)&DrawVect[5].pos.z) = drawz;

				// テクスチャーを描画する
				ADD4VERTEX_TEX

				i ++ ;
				if( i >= DrawTexNum ) break ;

				// 描画するテクスチャーのセット
				DrawTex ++ ;
				SetTextureHardware( DrawTex->Tex->Texture ) ;
				RefreshBlendStateHardware() ;
			}
			break ;
		}
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawExtendGraph
static int  DrawExtendGraphHardware( int x1, int y1, int x2, int y2, float x1f, float y1f, float x2f, float y2f, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int IntFlag )
{
	VERTEX_2D *Vect ;
	VERTEX_BLENDTEX_2D *VectDataB, *VectB ; 
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	IMAGEDATA2_HARD_DRAW *BlendDrawTex = NULL ;
	IMAGEDATA2_HARD_VERT *TexVect ;
	IMAGEDATA2_HARD_VERT *BlendTexVect ;
	IMAGEDATA2_ORIG *Orig ;
	int DrawTexNum ;
	int i, j ;
	int BlendGraphNoIncFlag ;
	float GraphExRateX, GraphExRateY ;
//	int ReverseX = FALSE, ReverseY = FALSE ;
	int Reverse ;
//	int AdjX = FALSE, AdjY = FALSE ;
	float left, right, top, bottom ;
	float Vx, Vy ;
	float VBx, VBy ;
	int DiffuseColor ;
	DWORD drawz;
	int Flag ;

	Orig = Image2->Orig ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// 描画判定
//	if( x2 - x1 == Image2->Width && y2 - y1 == Image2->Height ) return G_D3D_DrawGraph( x1, y1, GraphData, TransFlag ) ; 	

	// 幅がなかった場合はエラー
	if( x1 == x2 || y1 == y2 ) return -1 ;

	// 描画の準備
	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
	Flag = TransFlag | ( IntFlag ? ( GBASE.DrawMode == DX_DRAWMODE_BILINEAR ? 0 : DRAWPREP_VECTORINT ) : 0 ) ;
	DRAWPREP_TEX( Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )

	// ディフューズカラーの取得
	DiffuseColor = GRH.DiffuseColor ;

	// 描画情報の数をセット
	DrawTexNum = Image2->Hard.DrawNum ;

	// 描画情報の数がブレンド画像と異なっていたら０番目のテクスチャだけを使用する
	BlendGraphNoIncFlag = FALSE ;
	if( BlendImage2 != NULL && BlendImage2->Hard.DrawNum != Image2->Hard.DrawNum )
	{
		BlendGraphNoIncFlag = TRUE ;
	}

	// 描画情報配列のアドレスをセットしておく
	DrawTex = Image2->Hard.Draw ;
	if( BlendImage2 != NULL )
	{
		BlendDrawTex = BlendImage2->Hard.Draw ;
	}

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 拡大率を取得しておく
	GraphExRateX = ( x2f - x1f ) / Image2->Width ;
	GraphExRateY = ( y2f - y1f ) / Image2->Height ;
	Reverse = ( GraphExRateX < 0 ) != ( GraphExRateY < 0 ) ;

	x1f -= 0.5F ;
	y1f -= 0.5F ;

	if( x1 > x2 ){ i = x2; x2 = x1; x1 = i; }
	if( y1 > y2 ){ i = y2; y2 = y1; y1 = i; }

	// 描画範囲からはみ出ているかどうかで処理を分岐
	if( IN_DRAWAREA_CHECK( x1, y1, x2, y2 ) )
	{
		// 頂点タイプによって処理を分岐
		switch( GRH.VertexType )
		{
		case VERTEXTYPE_BLENDTEX :	// ブレンドテクスチャを使用する
			// テクスチャーの数だけ繰り返す
			for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
			{
				// 描画するテクスチャーのセット
				if( GRH.RenderTexture != DrawTex->Tex->Texture )
					SetTextureHardware( DrawTex->Tex->Texture ) ;
				if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
					SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
				if( GRH.ChangeTextureFlag )
					RefreshBlendStateHardware() ;

				// 頂点データを初期化する
				GETVERTEX_QUAD( VectDataB )
				
				TexVect = DrawTex->Vertex ;
				BlendTexVect = BlendDrawTex->Vertex ;

				VectDataB[0].color = 
				VectDataB[3].color = ( DWORD )DiffuseColor ;

				VectDataB[4].pos.x = VectDataB[2].pos.x = VectDataB[0].pos.x = TexVect[0].x * GraphExRateX + x1f ;
				VectDataB[5].pos.x = VectDataB[3].pos.x = VectDataB[1].pos.x = TexVect[1].x * GraphExRateX + x1f ;
				VectDataB[5].pos.y = VectDataB[1].pos.y = VectDataB[0].pos.y = TexVect[0].y * GraphExRateY + y1f ;
				VectDataB[4].pos.y = VectDataB[3].pos.y = VectDataB[2].pos.y = TexVect[2].y * GraphExRateY + y1f ;

				VectDataB[4].u1 = VectDataB[2].u1 = VectDataB[0].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectDataB[5].u1 = VectDataB[3].u1 = VectDataB[1].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectDataB[5].v1 = VectDataB[1].v1 = VectDataB[0].v1 = ( TexVect[0].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				VectDataB[4].v1 = VectDataB[3].v1 = VectDataB[2].v1 = ( TexVect[2].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;

				VectDataB[4].u2 = VectDataB[2].u2 = VectDataB[0].u2 = TexVect[0].u ;
				VectDataB[5].u2 = VectDataB[3].u2 = VectDataB[1].u2 = TexVect[1].u ;
				VectDataB[5].v2 = VectDataB[1].v2 = VectDataB[0].v2 = TexVect[0].v ;
				VectDataB[4].v2 = VectDataB[3].v2 = VectDataB[2].v2 = TexVect[2].v ;

				if( GRH.UseAlphaChDrawShader )
				{
					VectDataB[4].sc_u = VectDataB[2].sc_u = VectDataB[0].sc_u = ( VectDataB[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectDataB[5].sc_u = VectDataB[3].sc_u = VectDataB[1].sc_u = ( VectDataB[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectDataB[5].sc_v = VectDataB[1].sc_v = VectDataB[0].sc_v = ( VectDataB[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					VectDataB[4].sc_v = VectDataB[3].sc_v = VectDataB[2].sc_v = ( VectDataB[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				*((DWORD *)&VectDataB[0].pos.z) =
				*((DWORD *)&VectDataB[1].pos.z) =
				*((DWORD *)&VectDataB[2].pos.z) =
				*((DWORD *)&VectDataB[3].pos.z) =
				*((DWORD *)&VectDataB[4].pos.z) =
				*((DWORD *)&VectDataB[5].pos.z) = drawz;

				// テクスチャーを描画する
				ADD4VERTEX_BLENDTEX

				if( BlendGraphNoIncFlag == FALSE )
				{
					BlendDrawTex ++ ;
				}
			}
			break ;

		case VERTEXTYPE_TEX :	// ブレンドテクスチャを使用しない
			// テクスチャーの数だけ繰り返す
			i = 0 ;
			for(;;)
			{
				// 頂点データを初期化する
				GETVERTEX_QUAD( Vect )
				
				TexVect = DrawTex->Vertex ;
				
				Vect[0].color = 
				Vect[3].color = ( DWORD )DiffuseColor ;

				Vect[4].pos.x = Vect[2].pos.x = Vect[0].pos.x = TexVect[0].x * GraphExRateX + x1f ;
				Vect[5].pos.x = Vect[3].pos.x = Vect[1].pos.x = TexVect[1].x * GraphExRateX + x1f ;
				Vect[5].pos.y = Vect[1].pos.y = Vect[0].pos.y = TexVect[0].y * GraphExRateY + y1f ;
				Vect[4].pos.y = Vect[3].pos.y = Vect[2].pos.y = TexVect[2].y * GraphExRateY + y1f ;

				Vect[4].u       = Vect[2].u       = Vect[0].u       = TexVect[0].u ;
				Vect[5].u       = Vect[3].u       = Vect[1].u       = TexVect[1].u ;
				Vect[5].v       = Vect[1].v       = Vect[0].v       = TexVect[0].v ;
				Vect[4].v       = Vect[3].v       = Vect[2].v       = TexVect[2].v ;

				if( GRH.UseAlphaChDrawShader )
				{
					Vect[4].sc_u = Vect[2].sc_u = Vect[0].sc_u = ( Vect[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[5].sc_u = Vect[3].sc_u = Vect[1].sc_u = ( Vect[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[5].sc_v = Vect[1].sc_v = Vect[0].sc_v = ( Vect[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[4].sc_v = Vect[3].sc_v = Vect[2].sc_v = ( Vect[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				*((DWORD *)&Vect[0].pos.z) =
				*((DWORD *)&Vect[1].pos.z) =
				*((DWORD *)&Vect[2].pos.z) =
				*((DWORD *)&Vect[3].pos.z) =
				*((DWORD *)&Vect[4].pos.z) =
				*((DWORD *)&Vect[5].pos.z) = drawz;

				// テクスチャーを描画する
				ADD4VERTEX_TEX

				i ++ ;
				if( i >= DrawTexNum ) break ;

				// 描画するテクスチャーのセット
				DrawTex ++ ;
				SetTextureHardware( DrawTex->Tex->Texture ) ;
				RefreshBlendStateHardware() ;
			}
			break ;
		}
	}
	else
	{
		// 完全にはみ出ていたら何もせず終了
		if( OUT_DRAWAREA_CHECK( x1, y1, x2, y2 ) ) return 0 ;

		// 描画矩形の保存
		left	= GBASE.DrawAreaF.left   - 0.5f + GBASE.WindowDrawRect.left ;
		top		= GBASE.DrawAreaF.top    - 0.5f + GBASE.WindowDrawRect.top  ;
		right	= GBASE.DrawAreaF.right  - 0.5f + GBASE.WindowDrawRect.left ;
		bottom	= GBASE.DrawAreaF.bottom - 0.5f + GBASE.WindowDrawRect.top  ;

		// 頂点タイプによって処理を分岐
		switch( GRH.VertexType )
		{
		case VERTEXTYPE_BLENDTEX :	// ブレンドテクスチャを使用する
			// テクスチャーの数だけ繰り返す
			for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
			{
				// 描画するテクスチャーのセット
				if( GRH.RenderTexture != DrawTex->Tex->Texture )
					SetTextureHardware( DrawTex->Tex->Texture ) ;
				if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
					SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
				if( GRH.ChangeTextureFlag )
					RefreshBlendStateHardware() ;

				GETVERTEX_QUAD( VectDataB )
				
				VectB = VectDataB ;
				Vx = 1.0F / ( DrawTex->Tex->TexWidth * GraphExRateX ) ;
				Vy = 1.0F / ( DrawTex->Tex->TexHeight * GraphExRateY ) ;
				VBx = GRH.InvBlendTextureWidth ;
				VBy = GRH.InvBlendTextureHeight ;

				// 頂点データを初期化する
				TexVect = DrawTex->Vertex ;
				BlendTexVect = BlendDrawTex->Vertex ;

				VectDataB[0].color = 
				VectDataB[3].color = ( DWORD )DiffuseColor ;

				VectDataB[2].pos.x = VectDataB[0].pos.x = TexVect[0].x * GraphExRateX + x1f ;
				VectDataB[3].pos.x = VectDataB[1].pos.x = TexVect[1].x * GraphExRateX + x1f ;
				VectDataB[1].pos.y = VectDataB[0].pos.y = TexVect[0].y * GraphExRateY + y1f ;
				VectDataB[3].pos.y = VectDataB[2].pos.y = TexVect[2].y * GraphExRateY + y1f ;

				VectDataB[2].u1 = VectDataB[0].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectDataB[3].u1 = VectDataB[1].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectDataB[1].v1 = VectDataB[0].v1 = ( TexVect[0].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				VectDataB[3].v1 = VectDataB[2].v1 = ( TexVect[2].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;

				VectDataB[2].u2 = VectDataB[0].u2 = TexVect[0].u ;
				VectDataB[3].u2 = VectDataB[1].u2 = TexVect[1].u ;
				VectDataB[1].v2 = VectDataB[0].v2 = TexVect[0].v ;
				VectDataB[3].v2 = VectDataB[2].v2 = TexVect[2].v ;

				for( j = 0 ; j < 4 ; j ++, VectB ++ )
				{
					// 描画矩形から出ていた場合の補正処理
					if( VectB->pos.x < left )
					{
						VectB->u2 += ( left - VectB->pos.x ) * Vx ;
						VectB->u1 += ( left - VectB->pos.x ) * VBx ;
						VectB->pos.x = left ;
					}
					else
					if( VectB->pos.x > right )
					{
						VectB->u2 -= ( VectB->pos.x - right ) * Vx ;
						VectB->u1 -= ( VectB->pos.x - right ) * VBx ;
						VectB->pos.x = right ;
					}	

					if( VectB->pos.y < top )
					{
						VectB->v2 += ( top - VectB->pos.y ) * Vy ;
						VectB->v1 += ( top - VectB->pos.y ) * VBy ;
						VectB->pos.y = top ;
					}
					else
					if( VectB->pos.y > bottom )
					{
						VectB->v2 -= ( VectB->pos.y - bottom ) * Vy ;
						VectB->v1 -= ( VectB->pos.y - bottom ) * VBy ;
						VectB->pos.y = bottom ;
					}
				}

				if( GRH.UseAlphaChDrawShader )
				{
					VectDataB[0].sc_u = ( VectDataB[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectDataB[0].sc_v = ( VectDataB[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					VectDataB[1].sc_u = ( VectDataB[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectDataB[1].sc_v = ( VectDataB[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					VectDataB[2].sc_u = ( VectDataB[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectDataB[2].sc_v = ( VectDataB[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					VectDataB[3].sc_u = ( VectDataB[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectDataB[3].sc_v = ( VectDataB[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				*((DWORD *)&VectDataB[0].pos.z) =
				*((DWORD *)&VectDataB[1].pos.z) =
				*((DWORD *)&VectDataB[2].pos.z) =
				*((DWORD *)&VectDataB[3].pos.z) = drawz;

				VectDataB[4] = VectDataB[2] ;
				VectDataB[5] = VectDataB[1] ;

				// テクスチャーを描画する
				ADD4VERTEX_BLENDTEX

				if( BlendGraphNoIncFlag == FALSE )
				{
					BlendDrawTex ++ ;
				}
			}
			break ;

		case VERTEXTYPE_TEX :	// ブレンドテクスチャを使用しない
			// テクスチャーの数だけ繰り返す
			i = 0 ;
			for(;;)
			{
				// 頂点データを初期化する
				Vx = 1.0F / ( DrawTex->Tex->TexWidth * GraphExRateX ) ;
				Vy = 1.0F / ( DrawTex->Tex->TexHeight * GraphExRateY ) ;
				GETVERTEX_QUAD( Vect )
				
				TexVect = DrawTex->Vertex ;

				Vect[0].color = 
				Vect[3].color = ( DWORD )DiffuseColor ;

				Vect[2].pos.x = Vect[0].pos.x = TexVect[0].x * GraphExRateX + x1f ;
				Vect[3].pos.x = Vect[1].pos.x = TexVect[1].x * GraphExRateX + x1f ;
				Vect[1].pos.y = Vect[0].pos.y = TexVect[0].y * GraphExRateY + y1f ;
				Vect[3].pos.y = Vect[2].pos.y = TexVect[2].y * GraphExRateY + y1f ;

				Vect[2].u       = Vect[0].u       = TexVect[0].u ;
				Vect[3].u       = Vect[1].u       = TexVect[1].u ;
				Vect[1].v       = Vect[0].v       = TexVect[0].v ;
				Vect[3].v       = Vect[2].v       = TexVect[2].v ;

				*((DWORD *)&Vect[0].pos.z) =
				*((DWORD *)&Vect[1].pos.z) =
				*((DWORD *)&Vect[2].pos.z) =
				*((DWORD *)&Vect[3].pos.z) = drawz;

				for( j = 0 ; j < 4 ; j ++, Vect ++ )
				{
					// 描画矩形から出ていた場合の補正処理
					if( Vect->pos.x < left )
					{
						Vect->u += ( left - Vect->pos.x ) * Vx ;
						Vect->pos.x = left ;
					}
					else
					if( Vect->pos.x > right )
					{
						Vect->u -= ( Vect->pos.x - right ) * Vx ;
						Vect->pos.x = right ;
					}	

					if( Vect->pos.y < top )
					{
						Vect->v += ( top - Vect->pos.y ) * Vy ;
						Vect->pos.y = top ;
					}
					else
					if( Vect->pos.y > bottom )
					{
						Vect->v -= ( Vect->pos.y - bottom ) * Vy ;
						Vect->pos.y = bottom ;
					}
				}

				if( GRH.UseAlphaChDrawShader )
				{
					Vect[-4].sc_u = ( Vect[-4].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[-4].sc_v = ( Vect[-4].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[-3].sc_u = ( Vect[-3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[-3].sc_v = ( Vect[-3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[-2].sc_u = ( Vect[-2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[-2].sc_v = ( Vect[-2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[-1].sc_u = ( Vect[-1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[-1].sc_v = ( Vect[-1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				Vect[0] = Vect[-2] ;
				Vect[1] = Vect[-3] ;

				// テクスチャーを描画する
				ADD4VERTEX_TEX

				i ++ ;
				if( i >= DrawTexNum ) break ;

				// 描画するテクスチャーのセット
				DrawTex ++ ;
				SetTextureHardware( DrawTex->Tex->Texture ) ;
				RefreshBlendStateHardware() ;
			}
			break ;
		}
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawRotaGraph
static int DrawRotaGraphHardware( int x, int y, float xf, float yf, double ExRate, double Angle, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, int TurnFlag, int IntFlag )
{
	VERTEX_2D *Vect ;
	VERTEX_BLENDTEX_2D *VectB ;
	int DiffuseColor ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	IMAGEDATA2_HARD_DRAW *BlendDrawTex = NULL ;
	IMAGEDATA2_HARD_VERT *TexVect ;
	IMAGEDATA2_HARD_VERT *BlendTexVect ;
	int DrawTexNum ;
	int i ; 
	float Sin = 0.0f, Cos = 1.0f ;
	int BlendGraphNoIncFlag ;
	float XBuf[2], YBuf[2] ;
	float ExtendRate = ( float )ExRate ; 
	float ExtendRateX ;
	DWORD drawz;
//	BOOL Adj = FALSE ;
	float CenX, CenY ;
	float fx, fy ;
	int hx = 0, hy = 0 ;
	int FastCode, SinCosNone, AngleCheck, AlwaysCheck ;
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// 幅がなかった場合はエラー
	if( ExRate == 0.0 ) return -1 ;

	// 描画の準備
	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
	Flag = TransFlag ;
	DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )

	// 回転要素が無いか調べる
	if( Angle == 0.0 )
	{
		SinCosNone = 1;
	}
	else
	{
		SinCosNone = 0;
		_SINCOS( (float)Angle, &Sin, &Cos ) ;
	}
//	if( _FABS( (float)Angle ) < 0.0001 && ExRate < 1.001 && ExRate > 0.999 ) Adj = TRUE ;

	// 座標の補正
	if( IntFlag || GBASE.DrawMode == DX_DRAWMODE_NEAREST )
	{
		AlwaysCheck = 0 ;
		FastCode    = 0 ;
		hx          = Image2->Width % 2 ;
		hy          = Image2->Height % 2 ;
		fx = xf - ( float )x ;
		fy = yf - ( float )y ;
		if( fx < 0.0f ) fx = -fx;
		if( fy < 0.0f ) fy = -fy;
		if( fx < 0.00001f && fy < 0.00001f )
		{
			if( ExRate == 1.0 )
			{
				if( hx == hy )
				{
					if( hx == 0 )
					{
						CenX = ( float )(Image2->Width >> 1) ;
						CenY = ( float )(Image2->Height >> 1) ;
						xf   = ( float )x - 0.5F ;
						yf   = ( float )y - 0.5F ;
					}
					else
					{
						CenX = ( float )Image2->Width * 0.5F ;
						CenY = ( float )Image2->Height * 0.5F ;
						xf   = ( float )x ;
						yf   = ( float )y ;
						FastCode = 1;
					}
				}
				else
				{
					CenX = ( float )Image2->Width * 0.5F ;
					CenY = ( float )Image2->Height * 0.5F ;
					xf   = ( float )x ;
					yf   = ( float )y ;
						
					if( hx == 0 ) CenX -= 0.5F ;
					if( hy == 0 ) CenY -= 0.5F ;
				}
			}
			else
			{
				CenX = ( float )Image2->Width * 0.5F ;
				CenY = ( float )Image2->Height * 0.5F ;
				xf   = ( float )x - 0.5F ;
				yf   = ( float )y - 0.5F ;
				FastCode = 1 ;
			}
		}
		else
		{
			CenX = ( float )Image2->Width * 0.5F ;
			CenY = ( float )Image2->Height * 0.5F ;
			xf   = ( float )x ;
			yf   = ( float )y ;
			AlwaysCheck = 1 ;
		}
	}
	else
	{
		CenX = ( float )Image2->Width * 0.5F ;
		CenY = ( float )Image2->Height * 0.5F ;
		xf -= 0.5F ;
		yf -= 0.5F ;
		AngleCheck = 0 ;
		AlwaysCheck = 0 ;
		FastCode = 1 ;
	}

	// 微妙な回転値のチェックを行うかどうかを調べる
	if( IntFlag == TRUE && AlwaysCheck == 0 && SinCosNone == 0 && ( hx == 1 || hy == 1 ) &&
		( ( Angle < DX_PI / 180.0 *         - 4.0   ) ||
		  ( Angle > DX_PI / 180.0 * ( 360.0 + 4.0 ) ) ||
		  ( Angle > DX_PI / 180.0 *         - 4.0   && Angle < DX_PI / 180.0 *           4.0   ) ||
		  ( Angle > DX_PI / 180.0 * (  90.0 - 4.0 ) && Angle < DX_PI / 180.0 * (  90.0 + 4.0 ) ) ||
		  ( Angle > DX_PI / 180.0 * ( 180.0 - 4.0 ) && Angle < DX_PI / 180.0 * ( 180.0 + 4.0 ) ) ||
		  ( Angle > DX_PI / 180.0 * ( 270.0 - 4.0 ) && Angle < DX_PI / 180.0 * ( 270.0 + 4.0 ) ) ||
		  ( Angle > DX_PI / 180.0 * ( 360.0 - 4.0 ) && Angle < DX_PI / 180.0 * ( 360.0 + 4.0 ) ) ) )
	{
		AngleCheck = 1 ;
	}
	else
	{
		AngleCheck = 0 ;
	}

	// 頂点データを取得（今のところ色情報のセットのみ）
	DiffuseColor = GRH.DiffuseColor ;

	// 描画情報の数をセット
	DrawTexNum = Image2->Hard.DrawNum ;

	// 描画情報の数がブレンド画像と異なっていたら０番目のテクスチャだけを使用する
	BlendGraphNoIncFlag = FALSE ;
	if( BlendImage2 != NULL && BlendImage2->Hard.DrawNum != Image2->Hard.DrawNum )
	{
		BlendGraphNoIncFlag = TRUE ;
	}

	// 描画情報配列のアドレスをセットしておく
	DrawTex = Image2->Hard.Draw ;
	if( BlendImage2 != NULL )
	{
		BlendDrawTex = BlendImage2->Hard.Draw ;
	}

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 反転を考慮した横方向の拡大率をセット
	ExtendRateX = ( ( TurnFlag == TRUE ) ? -1.0f : 1.0f ) * ExtendRate ;

	// 頂点タイプによって処理を分岐
	switch( GRH.VertexType )
	{
	case VERTEXTYPE_BLENDTEX :	// ブレンドテクスチャを使用する
		// テクスチャーの数だけ繰り返す
		if( DrawTexNum == 1 && FastCode == 1 )
		{
			// 描画するテクスチャーのセット
			if( GRH.RenderTexture != DrawTex->Tex->Texture )
				SetTextureHardware( DrawTex->Tex->Texture ) ;
			if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
				SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
			if( GRH.ChangeTextureFlag )
				RefreshBlendStateHardware() ;

			// 頂点データを初期化する
			GETVERTEX_QUAD( VectB )

			TexVect = DrawTex->Vertex ;
			BlendTexVect = BlendDrawTex->Vertex ;

			VectB[0].color = 
			VectB[3].color = ( DWORD )DiffuseColor ;

			XBuf[0] = ( TexVect[0].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
			YBuf[0] = ( TexVect[0].y - CenY ) * ExtendRate ;
			XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
			YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
			VectB[0].pos.x =  XBuf[1] + xf ;
			VectB[0].pos.y =  YBuf[1] + yf ;
			VectB[3].pos.x = -XBuf[1] + xf ;
			VectB[3].pos.y = -YBuf[1] + yf ;
			
			XBuf[0] = ( TexVect[1].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
			YBuf[0] = ( TexVect[1].y - CenY ) * ExtendRate ;
			XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
			YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
			VectB[5].pos.x = VectB[1].pos.x =  XBuf[1] + xf ;
			VectB[5].pos.y = VectB[1].pos.y =  YBuf[1] + yf ;
			VectB[4].pos.x = VectB[2].pos.x = -XBuf[1] + xf ;
			VectB[4].pos.y = VectB[2].pos.y = -YBuf[1] + yf ;

			VectB[4].u1 = VectB[2].u1 = VectB[0].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
			VectB[5].u1 = VectB[3].u1 = VectB[1].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
			VectB[5].v1 = VectB[1].v1 = VectB[0].v1 = ( TexVect[0].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
			VectB[4].v1 = VectB[3].v1 = VectB[2].v1 = ( TexVect[2].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;

			VectB[4].u2 = VectB[2].u2 = VectB[0].u2 = TexVect[0].u ;
			VectB[5].u2 = VectB[3].u2 = VectB[1].u2 = TexVect[1].u ;
			VectB[5].v2 = VectB[1].v2 = VectB[0].v2 = TexVect[0].v ;
			VectB[4].v2 = VectB[3].v2 = VectB[2].v2 = TexVect[2].v ;

			if( GRH.UseAlphaChDrawShader )
			{
				VectB[0].sc_u =					( VectB[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectB[0].sc_v =					( VectB[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectB[3].sc_u =					( VectB[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectB[3].sc_v =					( VectB[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectB[5].sc_u = VectB[1].sc_u =	( VectB[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectB[5].sc_v = VectB[1].sc_v =	( VectB[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectB[4].sc_u = VectB[2].sc_u =	( VectB[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectB[4].sc_v = VectB[2].sc_v =	( VectB[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			}

			*((DWORD *)&VectB[0].pos.z) =
			*((DWORD *)&VectB[1].pos.z) =
			*((DWORD *)&VectB[2].pos.z) =
			*((DWORD *)&VectB[3].pos.z) =
			*((DWORD *)&VectB[4].pos.z) =
			*((DWORD *)&VectB[5].pos.z) = drawz;

			// テクスチャーを描画する
			ADD4VERTEX_BLENDTEX

			if( BlendGraphNoIncFlag == FALSE )
			{
				BlendDrawTex ++ ;
			}
		}
		else
		{
			// テクスチャーの数だけ繰り返す
			for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
			{
				// 描画するテクスチャーのセット
				if( GRH.RenderTexture != DrawTex->Tex->Texture )
					SetTextureHardware( DrawTex->Tex->Texture ) ;
				if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
					SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
				if( GRH.ChangeTextureFlag )
					RefreshBlendStateHardware() ;

				// 頂点データを初期化する
				GETVERTEX_QUAD( VectB )

				TexVect = DrawTex->Vertex ;
				BlendTexVect = BlendDrawTex->Vertex ;

				VectB[0].color = 
				VectB[3].color = ( DWORD )DiffuseColor ;

				XBuf[0] = ( TexVect[0].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
				YBuf[0] = ( TexVect[0].y - CenY ) * ExtendRate ;
				XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
				YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
				VectB[0].pos.x =  XBuf[1] + xf ;
				VectB[0].pos.y =  YBuf[1] + yf ;

				XBuf[0] = ( TexVect[1].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
				YBuf[0] = ( TexVect[1].y - CenY ) * ExtendRate ;
				XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
				YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
				VectB[5].pos.x = VectB[1].pos.x =  XBuf[1] + xf ;
				VectB[5].pos.y = VectB[1].pos.y =  YBuf[1] + yf ;

				XBuf[0] = ( TexVect[2].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
				YBuf[0] = ( TexVect[2].y - CenY ) * ExtendRate ;
				XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
				YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
				VectB[4].pos.x = VectB[2].pos.x =  XBuf[1] + xf ;
				VectB[4].pos.y = VectB[2].pos.y =  YBuf[1] + yf ;

				XBuf[0] = ( TexVect[3].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
				YBuf[0] = ( TexVect[3].y - CenY ) * ExtendRate ;
				XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
				YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
				VectB[3].pos.x =  XBuf[1] + xf ;
				VectB[3].pos.y =  YBuf[1] + yf ;

				VectB[0].u1 = ( TexVect[0].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectB[1].u1 = ( TexVect[1].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectB[2].u1 = ( TexVect[2].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectB[3].u1 = ( TexVect[3].x - BlendTexVect[0].x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectB[4].u1 = VectB[2].u1 ;
				VectB[5].u1 = VectB[1].u1 ;
				
				VectB[0].v1 = ( TexVect[0].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				VectB[1].v1 = ( TexVect[1].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				VectB[2].v1 = ( TexVect[2].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				VectB[3].v1 = ( TexVect[3].y - BlendTexVect[0].y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;
				VectB[4].v1 = VectB[2].v1 ;
				VectB[5].v1 = VectB[1].v1 ;

				VectB[4].u2 = VectB[2].u2 = VectB[0].u2 = TexVect[0].u ;
				VectB[5].u2 = VectB[3].u2 = VectB[1].u2 = TexVect[1].u ;
				VectB[5].v2 = VectB[1].v2 = VectB[0].v2 = TexVect[0].v ;
				VectB[4].v2 = VectB[3].v2 = VectB[2].v2 = TexVect[2].v ;

				if( GRH.UseAlphaChDrawShader )
				{
					VectB[0].sc_u =					( VectB[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectB[0].sc_v =					( VectB[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					VectB[3].sc_u =					( VectB[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectB[3].sc_v =					( VectB[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					VectB[5].sc_u = VectB[1].sc_u =	( VectB[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectB[5].sc_v = VectB[1].sc_v =	( VectB[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					VectB[4].sc_u = VectB[2].sc_u =	( VectB[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectB[4].sc_v = VectB[2].sc_v =	( VectB[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				*((DWORD *)&VectB[0].pos.z) =
				*((DWORD *)&VectB[1].pos.z) =
				*((DWORD *)&VectB[2].pos.z) =
				*((DWORD *)&VectB[3].pos.z) =
				*((DWORD *)&VectB[4].pos.z) =
				*((DWORD *)&VectB[5].pos.z) = drawz;

				// テクスチャーを描画する
				ADD4VERTEX_BLENDTEX

				if( BlendGraphNoIncFlag == FALSE )
				{
					BlendDrawTex ++ ;
				}
			}
		}
		break ;

	case VERTEXTYPE_TEX :	// ブレンドテクスチャを使用しない
		// テクスチャーの数だけ繰り返す
		if( DrawTexNum == 1 && FastCode == 1 )
		{
			if( SinCosNone == 0 )
			{
				// 頂点データを初期化する
				GETVERTEX_QUAD( Vect )
				
				TexVect = DrawTex->Vertex ;

				Vect[0].color = 
				Vect[3].color = ( DWORD )DiffuseColor ;

				Vect[4].u = Vect[2].u = Vect[0].u = TexVect[0].u ;
				Vect[5].u = Vect[3].u = Vect[1].u = TexVect[1].u ;
				Vect[5].v = Vect[1].v = Vect[0].v = TexVect[0].v ;
				Vect[4].v = Vect[3].v = Vect[2].v = TexVect[2].v ;

				XBuf[0] = ( TexVect[0].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
				YBuf[0] = ( TexVect[0].y - CenY ) * ExtendRate ;
				XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
				YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
				Vect[0].pos.x =  XBuf[1] + xf ;
				Vect[0].pos.y =  YBuf[1] + yf ;
				Vect[3].pos.x = -XBuf[1] + xf ;
				Vect[3].pos.y = -YBuf[1] + yf ;
				
				XBuf[0] = ( TexVect[1].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
				YBuf[0] = ( TexVect[1].y - CenY ) * ExtendRate ;
				XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
				YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
				Vect[5].pos.x = Vect[1].pos.x =  XBuf[1] + xf ;
				Vect[5].pos.y = Vect[1].pos.y =  YBuf[1] + yf ;
				Vect[4].pos.x = Vect[2].pos.x = -XBuf[1] + xf ;
				Vect[4].pos.y = Vect[2].pos.y = -YBuf[1] + yf ;

				*((DWORD *)&Vect[0].pos.z) =
				*((DWORD *)&Vect[1].pos.z) =
				*((DWORD *)&Vect[2].pos.z) =
				*((DWORD *)&Vect[3].pos.z) =
				*((DWORD *)&Vect[4].pos.z) =
				*((DWORD *)&Vect[5].pos.z) = drawz;

				if( AlwaysCheck )
				{
					if( ( ( ( *((DWORD *)&Vect[0].pos.x) == *((DWORD *)&Vect[2].pos.x) ) ||
							( ( Vect[0].pos.x > Vect[2].pos.x ) && ( Vect[0].pos.x < Vect[2].pos.x + 0.01f ) ) ||
							( ( Vect[2].pos.x > Vect[0].pos.x ) && ( Vect[2].pos.x < Vect[0].pos.x + 0.01f ) ) ) &&
							_FABS( Vect[0].pos.x - _FTOL( Vect[0].pos.x ) ) < 0.0001f ) ||
						( ( ( *((DWORD *)&Vect[0].pos.x) == *((DWORD *)&Vect[1].pos.x) ) ||
							( ( Vect[0].pos.x > Vect[1].pos.x ) && ( Vect[0].pos.x < Vect[1].pos.x + 0.01f ) ) ||
							( ( Vect[1].pos.x > Vect[0].pos.x ) && ( Vect[1].pos.x < Vect[0].pos.x + 0.01f ) ) ) &&
							_FABS( Vect[0].pos.x - _FTOL( Vect[0].pos.x ) ) < 0.0001f ) )
					{
						Vect[0].pos.x -= 0.5f;
						Vect[1].pos.x -= 0.5f;
						Vect[2].pos.x -= 0.5f;
						Vect[3].pos.x -= 0.5f;
						Vect[4].pos.x -= 0.5f;
						Vect[5].pos.x -= 0.5f;
					}

					if( ( ( ( *((DWORD *)&Vect[0].pos.y) == *((DWORD *)&Vect[2].pos.y) ) ||
							( ( Vect[0].pos.y > Vect[2].pos.y ) && ( Vect[0].pos.y < Vect[2].pos.y + 0.01f ) ) ||
							( ( Vect[2].pos.y > Vect[0].pos.y ) && ( Vect[2].pos.y < Vect[0].pos.y + 0.01f ) ) ) &&
							_FABS( Vect[0].pos.y - _FTOL( Vect[0].pos.y ) ) < 0.0001f ) ||
						( ( ( *((DWORD *)&Vect[0].pos.y) == *((DWORD *)&Vect[1].pos.y) ) ||
							( ( Vect[0].pos.y > Vect[1].pos.y ) && ( Vect[0].pos.y < Vect[1].pos.y + 0.01f ) ) ||
							( ( Vect[1].pos.y > Vect[0].pos.y ) && ( Vect[1].pos.y < Vect[0].pos.y + 0.01f ) ) ) &&
							_FABS( Vect[0].pos.y - _FTOL( Vect[0].pos.y ) ) < 0.0001f ) )
					{
						Vect[0].pos.y -= 0.5f;
						Vect[1].pos.y -= 0.5f;
						Vect[2].pos.y -= 0.5f;
						Vect[3].pos.y -= 0.5f;
						Vect[4].pos.y -= 0.5f;
						Vect[5].pos.y -= 0.5f;
					}
				}
				else
				if( AngleCheck )
				{
					if( hx &&
						( *((DWORD *)&Vect[0].pos.x) == *((DWORD *)&Vect[2].pos.x) ) ||
						( ( Vect[0].pos.x > Vect[2].pos.x - 0.01f ) && ( Vect[0].pos.x < Vect[2].pos.x + 0.01f ) ) ||
						( ( Vect[2].pos.x > Vect[0].pos.x - 0.01f ) && ( Vect[2].pos.x < Vect[0].pos.x + 0.01f ) ) ||
						( *((DWORD *)&Vect[0].pos.x) == *((DWORD *)&Vect[1].pos.x) ) ||
						( ( Vect[0].pos.x > Vect[1].pos.x - 0.01f ) && ( Vect[0].pos.x < Vect[1].pos.x + 0.01f ) ) ||
						( ( Vect[1].pos.x > Vect[0].pos.x - 0.01f ) && ( Vect[1].pos.x < Vect[0].pos.x + 0.01f ) ) )
					{
						Vect[0].pos.x -= 0.5f;
						Vect[1].pos.x -= 0.5f;
						Vect[2].pos.x -= 0.5f;
						Vect[3].pos.x -= 0.5f;
						Vect[4].pos.x -= 0.5f;
						Vect[5].pos.x -= 0.5f;
					}

					if( hy &&
						( *((DWORD *)&Vect[0].pos.y) == *((DWORD *)&Vect[1].pos.y) ) ||
						( ( Vect[0].pos.y > Vect[1].pos.y - 0.01f ) && ( Vect[0].pos.y < Vect[1].pos.y + 0.01f ) ) ||
						( ( Vect[1].pos.y > Vect[0].pos.y - 0.01f ) && ( Vect[1].pos.y < Vect[0].pos.y + 0.01f ) ) ||
						( *((DWORD *)&Vect[0].pos.y) == *((DWORD *)&Vect[2].pos.y) ) ||
						( ( Vect[0].pos.y > Vect[2].pos.y - 0.01f ) && ( Vect[0].pos.y < Vect[2].pos.y + 0.01f ) ) ||
						( ( Vect[2].pos.y > Vect[0].pos.y - 0.01f ) && ( Vect[2].pos.y < Vect[0].pos.y + 0.01f ) ) )
					{
						Vect[0].pos.y -= 0.5f;
						Vect[1].pos.y -= 0.5f;
						Vect[2].pos.y -= 0.5f;
						Vect[3].pos.y -= 0.5f;
						Vect[4].pos.y -= 0.5f;
						Vect[5].pos.y -= 0.5f;
					}
				}

				if( GRH.UseAlphaChDrawShader )
				{
					Vect[0].sc_u = ( Vect[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[0].sc_v = ( Vect[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[1].sc_u = ( Vect[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[1].sc_v = ( Vect[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[2].sc_u = ( Vect[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[2].sc_v = ( Vect[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[3].sc_u = ( Vect[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[3].sc_v = ( Vect[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[4].sc_u = ( Vect[4].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[4].sc_v = ( Vect[4].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[5].sc_u = ( Vect[5].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[5].sc_v = ( Vect[5].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				// テクスチャーを描画する
				ADD4VERTEX_TEX
			}
			else
			{
				// 頂点データを初期化する
				GETVERTEX_QUAD( Vect )
				
				TexVect = DrawTex->Vertex ;

				Vect[0].color = 
				Vect[3].color = ( DWORD )DiffuseColor ;

				Vect[4].u = Vect[2].u = Vect[0].u = TexVect[0].u ;
				Vect[5].u = Vect[3].u = Vect[1].u = TexVect[1].u ;
				Vect[5].v = Vect[1].v = Vect[0].v = TexVect[0].v ;
				Vect[4].v = Vect[3].v = Vect[2].v = TexVect[2].v ;

				XBuf[0] = ( TexVect[0].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
				YBuf[0] = ( TexVect[0].y - CenY ) * ExtendRate ;
				Vect[0].pos.x =  XBuf[0] + xf ;
				Vect[0].pos.y =  YBuf[0] + yf ;
				Vect[3].pos.x = -XBuf[0] + xf ;
				Vect[3].pos.y = -YBuf[0] + yf ;
				
				XBuf[0] = ( TexVect[1].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
				YBuf[0] = ( TexVect[1].y - CenY ) * ExtendRate ;
				Vect[5].pos.x = Vect[1].pos.x =  XBuf[0] + xf ;
				Vect[5].pos.y = Vect[1].pos.y =  YBuf[0] + yf ;
				Vect[4].pos.x = Vect[2].pos.x = -XBuf[0] + xf ;
				Vect[4].pos.y = Vect[2].pos.y = -YBuf[0] + yf ;

				if( GRH.UseAlphaChDrawShader )
				{
					Vect[0].sc_u =					( Vect[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[0].sc_v =					( Vect[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[3].sc_u =					( Vect[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[3].sc_v =					( Vect[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[5].sc_u = Vect[1].sc_u =	( Vect[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[5].sc_v = Vect[1].sc_v =	( Vect[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					Vect[4].sc_u = Vect[2].sc_u =	( Vect[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					Vect[4].sc_v = Vect[2].sc_v =	( Vect[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}

				*((DWORD *)&Vect[0].pos.z) =
				*((DWORD *)&Vect[1].pos.z) =
				*((DWORD *)&Vect[2].pos.z) =
				*((DWORD *)&Vect[3].pos.z) =
				*((DWORD *)&Vect[4].pos.z) =
				*((DWORD *)&Vect[5].pos.z) = drawz;

				// テクスチャーを描画する
				ADD4VERTEX_TEX
			}
		}
		else
		{
			if( SinCosNone == 0 )
			{
				// テクスチャーの数だけ繰り返す
				i = 0 ;
				for(;;)
				{
					// 頂点データを初期化する
					GETVERTEX_QUAD( Vect )
					
					TexVect = DrawTex->Vertex ;

					Vect[0].color = 
					Vect[3].color = ( DWORD )DiffuseColor ;

					Vect[4].u = Vect[2].u = Vect[0].u = TexVect[0].u ;
					Vect[5].u = Vect[3].u = Vect[1].u = TexVect[1].u ;
					Vect[5].v = Vect[1].v = Vect[0].v = TexVect[0].v ;
					Vect[4].v = Vect[3].v = Vect[2].v = TexVect[2].v ;

					XBuf[0] = ( TexVect[0].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
					YBuf[0] = ( TexVect[0].y - CenY ) * ExtendRate ;
					XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
					YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
					Vect[0].pos.x =  XBuf[1] + xf ;
					Vect[0].pos.y =  YBuf[1] + yf ;

					XBuf[0] = ( TexVect[1].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
					YBuf[0] = ( TexVect[1].y - CenY ) * ExtendRate ;
					XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
					YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
					Vect[5].pos.x = Vect[1].pos.x =  XBuf[1] + xf ;
					Vect[5].pos.y = Vect[1].pos.y =  YBuf[1] + yf ;

					XBuf[0] = ( TexVect[2].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
					YBuf[0] = ( TexVect[2].y - CenY ) * ExtendRate ;
					XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
					YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
					Vect[4].pos.x = Vect[2].pos.x =  XBuf[1] + xf ;
					Vect[4].pos.y = Vect[2].pos.y =  YBuf[1] + yf ;

					XBuf[0] = ( TexVect[3].x - CenX ) * ExtendRateX ;		// グラフィック座標の補正 + 拡大計算
					YBuf[0] = ( TexVect[3].y - CenY ) * ExtendRate ;
					XBuf[1] = XBuf[0] * Cos - YBuf[0] * Sin ;					// 回転計算 + スクリーン座標用意銅
					YBuf[1] = XBuf[0] * Sin + YBuf[0] * Cos ;
					Vect[3].pos.x =  XBuf[1] + xf ;
					Vect[3].pos.y =  YBuf[1] + yf ;

					*((DWORD *)&Vect[0].pos.z) =
					*((DWORD *)&Vect[1].pos.z) =
					*((DWORD *)&Vect[2].pos.z) =
					*((DWORD *)&Vect[3].pos.z) =
					*((DWORD *)&Vect[4].pos.z) =
					*((DWORD *)&Vect[5].pos.z) = drawz;

					if( AlwaysCheck )
					{
						float f;

						f = _FABS( Vect[0].pos.x - _FTOL( Vect[0].pos.x ) );
						if( ( ( ( *((DWORD *)&Vect[0].pos.x) == *((DWORD *)&Vect[2].pos.x) ) ||
							    ( ( Vect[0].pos.x >= Vect[2].pos.x - 0.01f ) && ( Vect[0].pos.x < Vect[2].pos.x + 0.01f ) ) ||
							    ( ( Vect[2].pos.x >= Vect[0].pos.x - 0.01f ) && ( Vect[2].pos.x < Vect[0].pos.x + 0.01f ) ) ) &&
							    ( f < 0.001f || f > 0.999f ) ) ||
							( ( ( *((DWORD *)&Vect[0].pos.x) == *((DWORD *)&Vect[1].pos.x) ) ||
							    ( ( Vect[0].pos.x >= Vect[1].pos.x - 0.01f ) && ( Vect[0].pos.x < Vect[1].pos.x + 0.01f ) ) ||
							    ( ( Vect[1].pos.x >= Vect[0].pos.x - 0.01f ) && ( Vect[1].pos.x < Vect[0].pos.x + 0.01f ) ) ) &&
							    ( f < 0.001f || f > 0.999f ) ) )
						{
							Vect[0].pos.x -= 0.5f;
							Vect[1].pos.x -= 0.5f;
							Vect[2].pos.x -= 0.5f;
							Vect[3].pos.x -= 0.5f;
							Vect[4].pos.x -= 0.5f;
							Vect[5].pos.x -= 0.5f;
						}

						f = _FABS( Vect[0].pos.y - _FTOL( Vect[0].pos.y ) );
						if( ( ( ( *((DWORD *)&Vect[0].pos.y) == *((DWORD *)&Vect[2].pos.y) ) ||
							    ( ( Vect[0].pos.y >= Vect[2].pos.y - 0.01f ) && ( Vect[0].pos.y < Vect[2].pos.y + 0.01f ) ) ||
							    ( ( Vect[2].pos.y >= Vect[0].pos.y - 0.01f ) && ( Vect[2].pos.y < Vect[0].pos.y + 0.01f ) ) ) &&
							    ( f < 0.001f || f > 0.999f ) ) ||
							( ( ( *((DWORD *)&Vect[0].pos.y) == *((DWORD *)&Vect[1].pos.y) ) ||
							    ( ( Vect[0].pos.y >= Vect[1].pos.y - 0.01f ) && ( Vect[0].pos.y < Vect[1].pos.y + 0.01f ) ) ||
							    ( ( Vect[1].pos.y >= Vect[0].pos.y - 0.01f ) && ( Vect[1].pos.y < Vect[0].pos.y + 0.01f ) ) ) &&
							    ( f < 0.001f || f > 0.999f ) ) )
						{
							Vect[0].pos.y -= 0.5f;
							Vect[1].pos.y -= 0.5f;
							Vect[2].pos.y -= 0.5f;
							Vect[3].pos.y -= 0.5f;
							Vect[4].pos.y -= 0.5f;
							Vect[5].pos.y -= 0.5f;
						}
					}
					else
					if( AngleCheck )
					{
						float f;

						if( hx )
						{
							f = _FABS( Vect[0].pos.x - _FTOL( Vect[0].pos.x ) );
							if( ( ( ( *((DWORD *)&Vect[0].pos.x) == *((DWORD *)&Vect[2].pos.x) ) ||
									( ( Vect[0].pos.x >= Vect[2].pos.x - 0.01f ) && ( Vect[0].pos.x < Vect[2].pos.x + 0.01f ) ) ||
									( ( Vect[2].pos.x >= Vect[0].pos.x - 0.01f ) && ( Vect[2].pos.x < Vect[0].pos.x + 0.01f ) ) ) &&
									( f < 0.001f || f > 0.999f ) ) ||
								( ( ( *((DWORD *)&Vect[0].pos.x) == *((DWORD *)&Vect[1].pos.x) ) ||
									( ( Vect[0].pos.x >= Vect[1].pos.x - 0.01f ) && ( Vect[0].pos.x < Vect[1].pos.x + 0.01f ) ) ||
									( ( Vect[1].pos.x >= Vect[0].pos.x - 0.01f ) && ( Vect[1].pos.x < Vect[0].pos.x + 0.01f ) ) ) &&
									( f < 0.001f || f > 0.999f ) ) )
							{
								Vect[0].pos.x -= 0.5f;
								Vect[1].pos.x -= 0.5f;
								Vect[2].pos.x -= 0.5f;
								Vect[3].pos.x -= 0.5f;
								Vect[4].pos.x -= 0.5f;
								Vect[5].pos.x -= 0.5f;
							}
						}

						if( hy )
						{
							f = _FABS( Vect[0].pos.y - _FTOL( Vect[0].pos.y ) );
							if( ( ( ( *((DWORD *)&Vect[0].pos.y) == *((DWORD *)&Vect[2].pos.y) ) ||
									( ( Vect[0].pos.y >= Vect[2].pos.y - 0.01f ) && ( Vect[0].pos.y < Vect[2].pos.y + 0.01f ) ) ||
									( ( Vect[2].pos.y >= Vect[0].pos.y - 0.01f ) && ( Vect[2].pos.y < Vect[0].pos.y + 0.01f ) ) ) &&
									( f < 0.001f || f > 0.999f ) ) ||
								( ( ( *((DWORD *)&Vect[0].pos.y) == *((DWORD *)&Vect[1].pos.y) ) ||
									( ( Vect[0].pos.y >= Vect[1].pos.y - 0.01f ) && ( Vect[0].pos.y < Vect[1].pos.y + 0.01f ) ) ||
									( ( Vect[1].pos.y >= Vect[0].pos.y - 0.01f ) && ( Vect[1].pos.y < Vect[0].pos.y + 0.01f ) ) ) &&
									( f < 0.001f || f > 0.999f ) ) )
							{
								Vect[0].pos.y -= 0.5f;
								Vect[1].pos.y -= 0.5f;
								Vect[2].pos.y -= 0.5f;
								Vect[3].pos.y -= 0.5f;
								Vect[4].pos.y -= 0.5f;
								Vect[5].pos.y -= 0.5f;
							}
						}
					}

					if( GRH.UseAlphaChDrawShader )
					{
						Vect[0].sc_u = ( Vect[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[0].sc_v = ( Vect[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
						Vect[1].sc_u = ( Vect[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[1].sc_v = ( Vect[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
						Vect[2].sc_u = ( Vect[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[2].sc_v = ( Vect[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
						Vect[3].sc_u = ( Vect[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[3].sc_v = ( Vect[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
						Vect[4].sc_u = ( Vect[4].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[4].sc_v = ( Vect[4].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
						Vect[5].sc_u = ( Vect[5].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[5].sc_v = ( Vect[5].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					}

					// テクスチャーを描画する
					ADD4VERTEX_TEX

					i ++ ;
					if( i >= DrawTexNum ) break ;

					// 描画するテクスチャーのセット
					DrawTex ++ ;
					SetTextureHardware( DrawTex->Tex->Texture ) ;
					RefreshBlendStateHardware() ;
				}
			}
			else
			{
				// テクスチャーの数だけ繰り返す
				i = 0 ;
				for(;;)
				{
					// 頂点データを初期化する
					GETVERTEX_QUAD( Vect )
					
					TexVect = DrawTex->Vertex ;

					Vect[0].color = 
					Vect[3].color = ( DWORD )DiffuseColor ;

					Vect[4].u = Vect[2].u = Vect[0].u = TexVect[0].u ;
					Vect[5].u = Vect[3].u = Vect[1].u = TexVect[1].u ;
					Vect[5].v = Vect[1].v = Vect[0].v = TexVect[0].v ;
					Vect[4].v = Vect[3].v = Vect[2].v = TexVect[2].v ;

					Vect[0].pos.x =                 ( TexVect[0].x - CenX ) * ExtendRateX + xf;	// グラフィック座標の補正 + 拡大計算
					Vect[0].pos.y =                 ( TexVect[0].y - CenY ) * ExtendRate  + yf;

					Vect[5].pos.x = Vect[1].pos.x = ( TexVect[1].x - CenX ) * ExtendRateX + xf;	// グラフィック座標の補正 + 拡大計算
					Vect[5].pos.y = Vect[1].pos.y = ( TexVect[1].y - CenY ) * ExtendRate  + yf;

					Vect[4].pos.x = Vect[2].pos.x = ( TexVect[2].x - CenX ) * ExtendRateX + xf;	// グラフィック座標の補正 + 拡大計算
					Vect[4].pos.y = Vect[2].pos.y = ( TexVect[2].y - CenY ) * ExtendRate  + yf;

					Vect[3].pos.x =                 ( TexVect[3].x - CenX ) * ExtendRateX + xf;	// グラフィック座標の補正 + 拡大計算
					Vect[3].pos.y =                 ( TexVect[3].y - CenY ) * ExtendRate  + yf;

					*((DWORD *)&Vect[0].pos.z) =
					*((DWORD *)&Vect[1].pos.z) =
					*((DWORD *)&Vect[2].pos.z) =
					*((DWORD *)&Vect[3].pos.z) =
					*((DWORD *)&Vect[4].pos.z) =
					*((DWORD *)&Vect[5].pos.z) = drawz;

					if( GRH.UseAlphaChDrawShader )
					{
						Vect[0].sc_u =					( Vect[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[0].sc_v =					( Vect[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
						Vect[3].sc_u =					( Vect[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[3].sc_v =					( Vect[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
						Vect[5].sc_u = Vect[1].sc_u =	( Vect[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[5].sc_v = Vect[1].sc_v =	( Vect[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
						Vect[4].sc_u = Vect[2].sc_u =	( Vect[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						Vect[4].sc_v = Vect[2].sc_v =	( Vect[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					}

					// テクスチャーを描画する
					ADD4VERTEX_TEX

					i ++ ;
					if( i >= DrawTexNum ) break ;

					// 描画するテクスチャーのセット
					DrawTex ++ ;
					SetTextureHardware( DrawTex->Tex->Texture ) ;
					RefreshBlendStateHardware() ;
				}
			}
		}
		break ;
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawModiGraph
static int  DrawModiGraphHardware( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, bool SimpleDrawFlag )
{
	if( x1 == x3 && x2 == x4 && y1 == y2 && y3 == y4 ) return DrawExtendGraphHardware( x1, y1, x4, y4, ( float )x1, ( float )y1, ( float )x4, ( float )y4, Image2, BlendImage2, TransFlag, TRUE ) ; 

	// もしブレンドテクスチャを使用せず、旧型関数を使用するフラグも立っていなければ
	// 内部分割を行う描画関数を使用する
	if( GRH.UseOldDrawModiGraphCodeFlag == FALSE && GBASE.BlendGraph <= 0 )
		return DrawModiGraphFHardware( (float)x1, (float)y1, (float)x2, (float)y2, (float)x3, (float)y3, (float)x4, (float)y4, Image2, BlendImage2, TransFlag, SimpleDrawFlag ) ;

	VERTEX_2D VectData[ 4 ], VectBuf, *Vect ;
	VERTEX_BLENDTEX_2D VectDataB[ 4 ], VectBufB, *VectB ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	IMAGEDATA2_HARD_DRAW *BlendDrawTex = NULL ;
	IMAGEDATA2_HARD_VERT *TexVect ;
	IMAGEDATA2_HARD_VERT *BlendTexVect ;
	float GraphSizeX, GraphSizeY ;
	float XBuf, YBuf ;
	int DrawTexNum ;
	unsigned char *VectType ;
	int i, j ; 
	int BlendGraphNoIncFlag ;
	float Reverse0, Reverse1 ;
	float ExRate1X1, ExRate1Y1, ExRate2X1, ExRate2Y1 ;
	float ExRate1X2, ExRate1Y2, ExRate2X2, ExRate2Y2 ;
	int DiffuseColor ;
	float  xf1, yf1, xf4, yf4;
	DWORD drawz ;
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// バッファにたまった頂点を書き出す
	RenderVertexHardware() ;

	// 描画の準備
	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
	Flag = TransFlag | DRAWPREP_VECTORINT ;
	DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )

	GraphSizeX = ( float )Image2->Width ;  GraphSizeY = ( float )Image2->Height ;
	ExRate1X1 = ( x2 - x1 ) /  GraphSizeX ;  ExRate1X2 = ( x3 - x1 ) /  GraphSizeY ;
	ExRate1Y1 = ( y3 - y1 ) /  GraphSizeY ;  ExRate1Y2 = ( y2 - y1 ) /  GraphSizeX ;
	ExRate2X1 = ( x3 - x4 ) / -GraphSizeX ;  ExRate2X2 = ( x2 - x4 ) / -GraphSizeY ;
	ExRate2Y1 = ( y2 - y4 ) / -GraphSizeY ;  ExRate2Y2 = ( y3 - y4 ) / -GraphSizeX ;
	xf1 = (float)x1 - 0.5F ; yf1 = (float)y1 - 0.5F ;
	xf4 = (float)x4 - 0.5F ; yf4 = (float)y4 - 0.5F ; 

	// 頂点データを取得（今のところ色情報のセットのみ）
	DiffuseColor = GRH.DiffuseColor ;

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 描画情報の数をセット
	DrawTexNum = Image2->Hard.DrawNum ;

	// 描画情報の数がブレンド画像と異なっていたら０番目のテクスチャだけを使用する
	BlendGraphNoIncFlag = FALSE ;
	if( BlendImage2 != NULL && BlendImage2->Hard.DrawNum != Image2->Hard.DrawNum )
	{
		BlendGraphNoIncFlag = TRUE ;
	}

	// 描画情報配列のアドレスをセットしておく
	DrawTex = Image2->Hard.Draw ;
	if( BlendImage2 != NULL )
	{
		BlendDrawTex = BlendImage2->Hard.Draw ;
	}

	// 頂点タイプによって処理を分岐
	switch( GRH.VertexType )
	{
	case VERTEXTYPE_BLENDTEX :	// ブレンドテクスチャを使用する
		// FVF設定
		SETFVF( VERTEXFVF_BLENDTEX_2D )

		// テクスチャーの数だけ繰り返す
		for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
		{
			// 描画するテクスチャーのセット
			if( GRH.RenderTexture != DrawTex->Tex->Texture || GRH.BlendTexture != BlendDrawTex->Tex->Texture )
			{
				if( GRH.RenderTexture != DrawTex->Tex->Texture  )
					SetTextureHardware( DrawTex->Tex->Texture ) ;
				if( GRH.BlendTexture != BlendDrawTex->Tex->Texture )
					SetBlendTextureHardware( BlendDrawTex->Tex->Texture, BlendDrawTex->Tex->TexWidth, BlendDrawTex->Tex->TexHeight );
				RefreshBlendStateHardware() ;
			}

			// 頂点データをセットする
			VectDataB[0].specular =
			VectDataB[1].specular =
			VectDataB[2].specular =
			VectDataB[3].specular = 0xffffffff ;

			VectDataB[0].color =
			VectDataB[1].color =
			VectDataB[2].color =
			VectDataB[3].color = (DWORD)DiffuseColor ;

			*((DWORD *)&VectDataB[0].pos.z) =
			*((DWORD *)&VectDataB[1].pos.z) =
			*((DWORD *)&VectDataB[2].pos.z) =
			*((DWORD *)&VectDataB[3].pos.z) = drawz ;

			VectDataB[0].rhw =
			VectDataB[1].rhw =
			VectDataB[2].rhw =
			VectDataB[3].rhw = 1.0F ;

			VectType = DrawTex->VertType ;
			VectB = VectDataB ;
			TexVect = DrawTex->Vertex ;
			BlendTexVect = BlendDrawTex->Vertex ;

			for( j = 0 ; j < 4 ; j ++, VectB ++, TexVect ++ )
			{
				// 頂点座標の算出
				if( *VectType ++ )
				{
					// 三角の上側
					VectB->pos.x = ( TexVect->x * ExRate1X1 ) + ( TexVect->y * ExRate1X2 ) + xf1 ;
					VectB->pos.y = ( TexVect->y * ExRate1Y1 ) + ( TexVect->x * ExRate1Y2 ) + yf1 ;
				} 
				else
				{
					// 三角の下側
					XBuf = TexVect->x - GraphSizeX ;  YBuf = TexVect->y - GraphSizeY ;
					VectB->pos.x = ( XBuf * ExRate2X1 ) + ( YBuf * ExRate2X2 ) + xf4 ;
					VectB->pos.y = ( YBuf * ExRate2Y1 ) + ( XBuf * ExRate2Y2 ) + yf4 ;
				}

				VectB->u1 = ( TexVect->x - BlendTexVect->x + GBASE.BlendGraphX ) * GRH.InvBlendTextureWidth ;
				VectB->v1 = ( TexVect->y - BlendTexVect->y + GBASE.BlendGraphY ) * GRH.InvBlendTextureHeight ;

				VectB->u2 = TexVect->u ;
				VectB->v2 = TexVect->v ;
			}

			if( GRH.UseAlphaChDrawShader )
			{
				VectDataB[0].sc_u = ( VectDataB[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectDataB[0].sc_v = ( VectDataB[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectDataB[1].sc_u = ( VectDataB[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectDataB[1].sc_v = ( VectDataB[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectDataB[2].sc_u = ( VectDataB[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectDataB[2].sc_v = ( VectDataB[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectDataB[3].sc_u = ( VectDataB[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectDataB[3].sc_v = ( VectDataB[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			}

			// 反転判定処理
			Reverse0 =  ( VectDataB[ 1 ].pos.x - VectDataB[ 0 ].pos.x ) * ( VectDataB[ 2 ].pos.y - VectDataB[ 0 ].pos.y ) -
						( VectDataB[ 2 ].pos.x - VectDataB[ 0 ].pos.x ) * ( VectDataB[ 1 ].pos.y - VectDataB[ 0 ].pos.y ) ;
			Reverse1 = -( VectDataB[ 1 ].pos.x - VectDataB[ 3 ].pos.x ) * ( VectDataB[ 2 ].pos.y - VectDataB[ 3 ].pos.y ) +
						( VectDataB[ 1 ].pos.y - VectDataB[ 3 ].pos.y ) * ( VectDataB[ 2 ].pos.x - VectDataB[ 3 ].pos.x ) ;
			if( Reverse0 <= 0 && Reverse1 <= 0 )
			{
				VectBufB = VectDataB[ 1 ] ; VectDataB[ 1 ] = VectDataB[ 2 ] ; VectDataB[ 2 ] = VectBufB ;
			}

			// 描画選択
			if( Reverse0 * Reverse1 >= 0 )
			{
				// プリミティブの描画
				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_TRIANGLESTRIP, 2, VectDataB, sizeof( VERTEX_BLENDTEX_2D ) ) ;
			}
			else
			{
				// Ｘ方向反転時の補正
				if( Reverse0 < 0 ) 
				{
					VectBufB = VectDataB[ 1 ] ; VectDataB[ 1 ] = VectDataB[ 2 ] ; VectDataB[ 2 ] = VectBufB ;
				}

				// プリミティブの描画
				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_TRIANGLESTRIP, 2, VectDataB, sizeof( VERTEX_BLENDTEX_2D ) ) ;
	//			GRH.Direct3DDeviceObject->DrawPrimitive( D_D3DPT_TRIANGLESTRIP, VERTEXFVF_2D, VectData,     3, 0 ) ;
	//			GRH.Direct3DDeviceObject->DrawPrimitive( D_D3DPT_TRIANGLESTRIP, VERTEXFVF_2D, &VectData[1], 3, 0 ) ;
			}

			if( BlendGraphNoIncFlag == FALSE )
			{
				BlendDrawTex ++ ;
			}
		}
		break ;

	case VERTEXTYPE_TEX :	// ブレンドテクスチャを使用しない
		// FVF設定
		SETFVF( VERTEXFVF_2D )

		// テクスチャーの数だけ繰り返す
		for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
		{
			// 描画するテクスチャーのセット
			if( GRH.RenderTexture != DrawTex->Tex->Texture )
			{
				SetTextureHardware( DrawTex->Tex->Texture ) ;
				RefreshBlendStateHardware() ;
			}

			TexVect = DrawTex->Vertex ;

			// 頂点データをセットする
			VectData[ 0 ].pos.x = TexVect[ 0 ].x ;
			VectData[ 0 ].pos.y = TexVect[ 0 ].y ;
			VectData[ 1 ].pos.x = TexVect[ 1 ].x ;
			VectData[ 1 ].pos.y = TexVect[ 1 ].y ;
			VectData[ 2 ].pos.x = TexVect[ 2 ].x ;
			VectData[ 2 ].pos.y = TexVect[ 2 ].y ;
			VectData[ 3 ].pos.x = TexVect[ 3 ].x ;
			VectData[ 3 ].pos.y = TexVect[ 3 ].y ;

			VectData[ 0 ].u = TexVect[ 0 ].u ;
			VectData[ 0 ].v = TexVect[ 0 ].v ;
			VectData[ 1 ].u = TexVect[ 1 ].u ;
			VectData[ 1 ].v = TexVect[ 1 ].v ;
			VectData[ 2 ].u = TexVect[ 2 ].u ;
			VectData[ 2 ].v = TexVect[ 2 ].v ;
			VectData[ 3 ].u = TexVect[ 3 ].u ;
			VectData[ 3 ].v = TexVect[ 3 ].v ;

			VectData[0].color =
			VectData[1].color =
			VectData[2].color =
			VectData[3].color = DiffuseColor ;

			*((DWORD *)&VectData[0].pos.z) = 
			*((DWORD *)&VectData[1].pos.z) = 
			*((DWORD *)&VectData[2].pos.z) = 
			*((DWORD *)&VectData[3].pos.z) = drawz;

			VectType = DrawTex->VertType ;
			Vect = VectData ;

			for( j = 0 ; j < 4 ; j ++, Vect ++ )
			{
				// 頂点座標の算出
				if( *VectType ++ )
				{
					// 三角の上側
					XBuf = Vect->pos.x ;  YBuf = Vect->pos.y ;
					Vect->pos.x = ( XBuf * ExRate1X1 ) + ( YBuf * ExRate1X2 ) + xf1 ;
					Vect->pos.y = ( YBuf * ExRate1Y1 ) + ( XBuf * ExRate1Y2 ) + yf1 ;
				} 
				else
				{
					// 三角の下側
					XBuf = Vect->pos.x - GraphSizeX ;  YBuf = Vect->pos.y - GraphSizeY ;
					Vect->pos.x = ( XBuf * ExRate2X1 ) + ( YBuf * ExRate2X2 ) + xf4 ;
					Vect->pos.y = ( YBuf * ExRate2Y1 ) + ( XBuf * ExRate2Y2 ) + yf4 ;
				}
			}

			if( GRH.UseAlphaChDrawShader )
			{
				VectData[0].sc_u = ( VectData[0].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectData[0].sc_v = ( VectData[0].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectData[1].sc_u = ( VectData[1].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectData[1].sc_v = ( VectData[1].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectData[2].sc_u = ( VectData[2].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectData[2].sc_v = ( VectData[2].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				VectData[3].sc_u = ( VectData[3].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectData[3].sc_v = ( VectData[3].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			}

			// 反転判定処理
			Reverse0 =  ( VectData[ 1 ].pos.x - VectData[ 0 ].pos.x ) * ( VectData[ 2 ].pos.y - VectData[ 0 ].pos.y ) -
						( VectData[ 2 ].pos.x - VectData[ 0 ].pos.x ) * ( VectData[ 1 ].pos.y - VectData[ 0 ].pos.y ) ;
			Reverse1 = -( VectData[ 1 ].pos.x - VectData[ 3 ].pos.x ) * ( VectData[ 2 ].pos.y - VectData[ 3 ].pos.y ) +
						( VectData[ 1 ].pos.y - VectData[ 3 ].pos.y ) * ( VectData[ 2 ].pos.x - VectData[ 3 ].pos.x ) ;
			if( Reverse0 <= 0 && Reverse1 <= 0 )
			{
				VectBuf = VectData[ 1 ] ; VectData[ 1 ] = VectData[ 2 ] ; VectData[ 2 ] = VectBuf ;
			}

			// 描画選択
			if( Reverse0 * Reverse1 >= 0 )
			{
				// プリミティブの描画
				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_TRIANGLESTRIP, 2, VectData, sizeof( VERTEX_2D ) ) ;
			}
			else
			{
				// Ｘ方向反転時の補正
				if( Reverse0 < 0 ) 
				{
					VectBuf = VectData[ 1 ] ; VectData[ 1 ] = VectData[ 2 ] ; VectData[ 2 ] = VectBuf ;
				}

				// プリミティブの描画
				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_TRIANGLESTRIP, 2, VectData, sizeof( VERTEX_2D ) ) ;
	//			GRH.Direct3DDeviceObject->DrawPrimitive( D_D3DPT_TRIANGLESTRIP, VERTEXFVF_2D, VectData,     3, 0 ) ;
	//			GRH.Direct3DDeviceObject->DrawPrimitive( D_D3DPT_TRIANGLESTRIP, VERTEXFVF_2D, &VectData[1], 3, 0 ) ;
			}
		}
		break ;
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawModiGraphF
static int  DrawModiGraphFHardware( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag, bool SimpleDrawFlag )
{
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// もしブレンドテクスチャ付の場合は内部分割を行わない描画関数を使用する
	if( GBASE.BlendGraph > 0 ) return DrawModiGraphHardware( _FTOL( x1 ), _FTOL( y1 ), _FTOL( x2 ), _FTOL( y2 ), _FTOL( x3 ), _FTOL( y3 ), _FTOL( x4 ), _FTOL( y4 ), Image2, BlendImage2, TransFlag, SimpleDrawFlag ) ;

	// 描画の準備
	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
	Flag = TransFlag ;
	DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )

	// テクスチャーが１枚のみの場合は処理を分岐
	if( Image2->Hard.DrawNum == 1 )
	{
		// そのまま描画
		DrawModiTexHardware( x1, y1, x2, y2, x3, y3, x4, y4, &Image2->Hard.Draw[ 0 ], false ) ;
	}
	else
	{
		IMAGEDATA2_HARD_DRAW *DrawTex ;
		IMAGEDATA2_HARD_VERT *TexVect ;
		int DrawTexNum ;
		int i, j ;
		double xx1, yy1, xx2, yy2, xx3, yy3, xx4, yy4, xt1, yt1, xt2, yt2 ;
		double w, h, r ;
		float x[4], y[4], *xp, *yp ;

		xx1 = x2 - x1 ; xx2 = x4 - x3 ;
		yy1 = y2 - y1 ; yy2 = y4 - y3 ;

		xx3 = x3 - x1 ; xx4 = x4 - x2 ;
		yy3 = y3 - y1 ; yy4 = y4 - y2 ;
		
//		w = 1.0F / (float)Image2->Width ;
//		h = 1.0F / (float)Image2->Height ;
		w = 1.0F / (double)Image2->Width ;
		h = 1.0F / (double)Image2->Height ;

		// 描画情報の数をセット
		DrawTexNum = Image2->Hard.DrawNum ;

		// 描画情報配列のアドレスをセットしておく
		DrawTex = Image2->Hard.Draw ;

		// テクスチャーの数だけ繰り返す
		for( i = 0 ; i < DrawTexNum ; i ++, DrawTex ++ )
		{
			// テクスチャーのデータアドレスを取得
			TexVect = DrawTex->Vertex ;

			// 座標を算出
			xp = x ;
			yp = y ;
			for( j = 0 ; j < 4 ; j ++, TexVect ++ )
			{
				r = TexVect->y * h ;
				xt1 = x1 + xx3 * r ;	yt1 = y1 + yy3 * r ;
				xt2 = x2 + xx4 * r ;	yt2 = y2 + yy4 * r ;

				r = TexVect->x * w ;
				*xp++ = (float)( ( xt2 - xt1 ) * r + xt1 ) ;
				*yp++ = (float)( ( yt2 - yt1 ) * r + yt1 ) ;
			}

			// 描画
			DrawModiTexHardware( x[0], y[0], x[1], y[1], x[2], y[2], x[3], y[3], DrawTex, false ) ;
		}
	}

	// 終了
	return 0 ;
}

// テクスチャを変形して描画する
static void DrawModiTexHardware( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, IMAGEDATA2_HARD_DRAW *DrawTex, bool SimpleDrawFlag )
{
	IMAGEDATA2_HARD_VERT *TexVect ;
	VERTEX_2D *vec ; 
	VERTEX_2D VectBuf[2] ;
	float xx1, yy1, xx2, yy2, xx3, yy3, xx4, yy4/*, r1, r2, r3, r4*/ ;
//	float xtmp1, ytmp1, xtmp2, ytmp2 ;
	int c, f1, f2, DiffuseColor ;
	float Reverse0, Reverse1;
	DWORD drawz ;

	// 描画するテクスチャーのセット
	if( GRH.RenderTexture != DrawTex->Tex->Texture )
	{
		SetTextureHardware( DrawTex->Tex->Texture ) ;
		RefreshBlendStateHardware() ;
	}

	// 頂点データを取得（今のところ色情報のセットのみ）
	DiffuseColor = GRH.DiffuseColor ;

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	TexVect = DrawTex->Vertex ;

	// 反転判定用処理
	Reverse0 =  ( x2 - x1 ) * ( y3 - y1 ) - ( x3 - x1 ) * ( y2 - y1 ) ;
	Reverse1 = -( x2 - x4 ) * ( y3 - y4 ) + ( y2 - y4 ) * ( x3 - x4 ) ;

	if( SimpleDrawFlag ) goto R1 ;

	// 平行四辺形以上の変形が起きていなかったら普通の処理を実行
	f1 = f2 = c = 0 ;
	xx1 = x2 - x1 ; xx2 = x4 - x3 ;
	yy1 = y2 - y1 ; yy2 = y4 - y3 ;

	xx3 = x3 - x1 ; xx4 = x4 - x2 ;
	yy3 = y3 - y1 ; yy4 = y4 - y2 ;

	if( _FABS( xx1 - xx2 ) < 1.0F && _FABS( yy1 - yy2 ) < 1.0F ) c ++, f1 = 1 ;
	if( _FABS( xx3 - xx4 ) < 1.0F && _FABS( yy3 - yy4 ) < 1.0F ) c ++, f2 = 1 ;
	if( c == 2 ) goto R1 ;

/*
	// 台形か完全な自由四角形かを判定
	f1 = f2 = c = 0 ;
	r1 = _SQRT( xx1 * xx1 + yy1 * yy1 ) ;	xtmp1 = xx1 / r1 ;	ytmp1 = yy1 / r1 ;
	r2 = _SQRT( xx2 * xx2 + yy2 * yy2 ) ;	xtmp2 = xx2 / r2 ;	ytmp2 = yy2 / r2 ;
	if( _FABS( xtmp1 - xtmp2 ) < 0.001F && _FABS( ytmp1 - ytmp2 ) < 0.001F ) c ++, f1 = 1 ;
	
	r3 = _SQRT( xx3 * xx3 + yy3 * yy3 ) ;	xtmp1 = xx3 / r3 ;	ytmp1 = yy3 / r3 ;
	r4 = _SQRT( xx4 * xx4 + yy4 * yy4 ) ;	xtmp2 = xx4 / r4 ;	ytmp2 = yy4 / r4 ;
	if( _FABS( xtmp1 - xtmp2 ) < 0.001F && _FABS( ytmp1 - ytmp2 ) < 0.001F ) c ++, f2 = 1 ;
*/

	{
#define TDIVNUM		5
#define TDN			(1 + ( 1 << TDIVNUM ))
#define ADJUSTUV	(0.001f)
		int DivNum, tdn ;
		static VERTEX_2D VectData2[TDN * TDN] ;
		VERTEX_2D *v ;
		float xxx1, yyy1, xxx2, yyy2, xxx3, yyy3 ;
		float adx1, ady1, adx2, ady2, adx3, ady3, adtu, adtv, tu, tv ; 
		int i, j ;
		float adjust_u_l, adjust_u_r, adjust_v_t, adjust_v_b ;

		// 分割画像の場合隣の画像のピクセルが入らないための補正ＵＶ値を作成する
		{
			if( TexVect[ 0 ].u < 0.000001f )
			{
				adjust_u_l = 0.0f ;
			}
			else
			{
				adjust_u_l =  ( TexVect[ 3 ].u - TexVect[ 0 ].u ) / ( TexVect[ 3 ].x - TexVect[ 0 ].x ) * ADJUSTUV ;
			}

			if( TexVect[ 3 ].u > 0.99999f )
			{
				adjust_u_r = 0.0f ;
			}
			else
			{
				adjust_u_r = -( TexVect[ 3 ].u - TexVect[ 0 ].u ) / ( TexVect[ 3 ].x - TexVect[ 0 ].x ) * ADJUSTUV ;
			}

			if( TexVect[ 0 ].v < 0.000001f )
			{
				adjust_v_t = 0.0f ;
			}
			else
			{
				adjust_v_t =  ( TexVect[ 3 ].v - TexVect[ 0 ].v ) / ( TexVect[ 3 ].y - TexVect[ 0 ].y ) * ADJUSTUV ;
			}

			if( TexVect[ 3 ].v > 0.99999f )
			{
				adjust_v_b = 0.0f ;
			}
			else
			{
				adjust_v_b = -( TexVect[ 3 ].v - TexVect[ 0 ].v ) / ( TexVect[ 3 ].y - TexVect[ 0 ].y ) * ADJUSTUV ;
			}
		}

		// 分割数の算出
		{
			float v1x, v1y, v2x, v2y ;
			float rate ;
			const float Table[] = { 2.0F, 1.0F, 0.6F, 0.1F, 0.05F } ;

			v1x = x4 - x1 ;		v1y = y4 - y1 ;
			v2x = x3 - x2 ;		v2y = y3 - y2 ;
			rate = (float)( 
				( _SQRT( v1x * v1x + v1y * v1y ) + _SQRT( v2x * v2x + v2y * v2y ) ) /
				( ( _SQRT( (float)( GBASE.DrawSizeX * GBASE.DrawSizeX + 
						GBASE.DrawSizeY * GBASE.DrawSizeY ) ) * 2 ) ) ) ;
			tdn = 8 ;
			if( tdn < 8 ) tdn = 8 ;
			else if( tdn > TDN ) tdn = TDN ;
			for( DivNum = TDIVNUM ; DivNum > 0 && rate < Table[TDIVNUM - DivNum] ; DivNum -- ){}
		}

		// 自由四角形処理
		adx1 = xx3 / ( tdn - 1 ) ;	ady1 = yy3 / ( tdn - 1 ) ;
		adx2 = xx4 / ( tdn - 1 ) ;	ady2 = yy4 / ( tdn - 1 ) ;
		xxx1 = x1 ;		yyy1 = y1 ;
		xxx2 = x2 ;		yyy2 = y2 ;
		adtu = ( ( TexVect[3].u + adjust_u_r ) - ( TexVect[0].u + adjust_u_l ) ) / ( tdn - 1 ) ;
		adtv = ( ( TexVect[3].v + adjust_v_b ) - ( TexVect[0].v + adjust_v_t ) ) / ( tdn - 1 ) ;
		tv = TexVect[0].v + adjust_v_t ;
		v = VectData2 ;
		for( i = 0 ; i < tdn ; i ++, tv += adtv,
									 xxx1 += adx1, yyy1 += ady1,
									 xxx2 += adx2, yyy2 += ady2 )
		{
			adx3 = ( xxx2 - xxx1 ) / ( tdn - 1 ) ;
			ady3 = ( yyy2 - yyy1 ) / ( tdn - 1 ) ;

//			xxx3 = xxx1 - 0.5F ;	yyy3 = yyy1 - 0.5F ;
			xxx3 = xxx1 ;
			yyy3 = yyy1 ;
			tu = TexVect[0].u + adjust_u_l ;
			for( j = 0 ; j < tdn ; j ++, tu += adtu,
										 xxx3 += adx3, yyy3 += ady3, v ++ )
			{
				v->pos.x = (float)xxx3 ;
				v->pos.y = (float)yyy3 ;
				*((DWORD *)&v->pos.z) = drawz ;
				v->rhw   = 1.0F ;
				v->u     = (float)tu ;
				v->v     = (float)tv ;
				v->color = DiffuseColor ;
			}
		}

		if( GRH.UseAlphaChDrawShader )
		{
			int loop_num ;

			loop_num = tdn * tdn ;
			v = VectData2 ;
			for( i = 0 ; i < loop_num ; i ++, v ++ )
			{
				v->sc_u = ( v->pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				v->sc_v = ( v->pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			}
		}

		// 頂点追加処理
		SetPlaneVertexHardware( VectData2, tdn, tdn ) ;

#undef TDIVNUM
#undef TDN
	}

	return ;
		
R1 :
	// 普通に描画
	GETVERTEX_QUAD( vec )

	vec[0].color =
	vec[3].color = DiffuseColor ;

	vec[0].pos.x = x1 ;	
	vec[5].pos.x = vec[1].pos.x = x2 ;	
	vec[4].pos.x = vec[2].pos.x = x3 ;
	vec[3].pos.x = x4 ;
	
	vec[0].pos.y = y1 ;
	vec[5].pos.y = vec[1].pos.y = y2 ;
	vec[4].pos.y = vec[2].pos.y = y3 ;
	vec[3].pos.y = y4 ;

	vec[4].u = vec[2].u = vec[0].u = TexVect[0].u + 0.0625f / DrawTex->Tex->TexWidth ;
	vec[5].u = vec[3].u = vec[1].u = TexVect[1].u - 0.0625f / DrawTex->Tex->TexWidth ;
	vec[5].v = vec[1].v = vec[0].v = TexVect[0].v + 0.0625f / DrawTex->Tex->TexHeight ;
	vec[4].v = vec[3].v = vec[2].v = TexVect[2].v - 0.0625f / DrawTex->Tex->TexHeight ;

	if( GRH.UseAlphaChDrawShader )
	{
		vec[ 0 ].sc_u =					( vec[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		vec[ 0 ].sc_v =					( vec[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		vec[ 5 ].sc_u = vec[ 1 ].sc_u = ( vec[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		vec[ 5 ].sc_v = vec[ 1 ].sc_v = ( vec[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		vec[ 4 ].sc_u = vec[ 2 ].sc_u = ( vec[ 2 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		vec[ 4 ].sc_v = vec[ 2 ].sc_v = ( vec[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		vec[ 3 ].sc_u =					( vec[ 3 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		vec[ 3 ].sc_v =					( vec[ 3 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
	}

	*((DWORD *)&vec[0].pos.z) =
	*((DWORD *)&vec[1].pos.z) =
	*((DWORD *)&vec[2].pos.z) =
	*((DWORD *)&vec[3].pos.z) =
	*((DWORD *)&vec[4].pos.z) =
	*((DWORD *)&vec[5].pos.z) = drawz;

	if( Reverse0 <= 0  &&  Reverse1 <= 0 )
	{
		VectBuf[ 0 ] = vec[ 1 ] ;
		VectBuf[ 1 ] = vec[ 4 ] ;
		vec[ 1 ]     = vec[ 2 ] ;
		vec[ 4 ]     = vec[ 5 ] ;
		vec[ 2 ]     = VectBuf[ 0 ] ;
		vec[ 5 ]     = VectBuf[ 1 ] ;
	}

	ADD4VERTEX_TEX
}

// ハードウエアアクセラレータ使用版 DrawFillBox
static int DrawFillBoxHardware( int x1, int y1, int x2, int y2, int Color )
{
	VERTEX_NOTEX_2D *vec ;
	RECT drect ;
	int Red, Green, Blue, Flag ;
	DWORD drawz;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// 反転処理
	{
		int b ;

		if( x1 > x2 ){ b = x1 ; x1 = x2 ; x2 = b ; }
		if( y1 > y2 ){ b = y1 ; y1 = y2 ; y2 = b ; }
	}
	
	// クリッピング処理
	{
		drect.left   = x1 ;
		drect.right  = x2 ;
		drect.top    = y1 ;
		drect.bottom = y2 ;
		RectClipping( &drect, &GBASE.DrawArea ) ;
		if( drect.left == drect.right || drect.top == drect.bottom ) return 0 ;
	}

	// 描画の準備
	BeginScene() ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag ) ;

	// 色その他ステータスのセット
	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( ( 	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red 	) / 255 ) << 16 ) |
			( ( ( ( ( 	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green ) / 255 ) << 8 ) |
			( ( ( ( 	GRH.DiffuseColor & 0x000000ff )       ) * Blue 	) / 255 ) | 
			( 			GRH.DiffuseColor & 0xff000000 ) ;

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 頂点データのセット
	GETVERTEX_QUAD( vec )
	
	vec[0].color =
	vec[3].color = Color ;
	
	vec[4].pos.x = vec[2].pos.x = vec[0].pos.x = (float)drect.left   ;
	vec[5].pos.x = vec[3].pos.x = vec[1].pos.x = (float)drect.right  ;
	vec[5].pos.y = vec[1].pos.y = vec[0].pos.y = (float)drect.top    ;
	vec[4].pos.y = vec[3].pos.y = vec[2].pos.y = (float)drect.bottom ;

	if( GRH.UseAlphaChDrawShader )
	{
		vec[ 4 ].sc_u = vec[ 2 ].sc_u = vec[ 0 ].sc_u = ( vec[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		vec[ 5 ].sc_u = vec[ 3 ].sc_u = vec[ 1 ].sc_u = ( vec[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		vec[ 5 ].sc_v = vec[ 1 ].sc_v = vec[ 0 ].sc_v = ( vec[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		vec[ 4 ].sc_v = vec[ 3 ].sc_v = vec[ 2 ].sc_v = ( vec[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
	}

	*((DWORD *)&vec[0].pos.z) =
	*((DWORD *)&vec[1].pos.z) =
	*((DWORD *)&vec[2].pos.z) =
	*((DWORD *)&vec[3].pos.z) =
	*((DWORD *)&vec[4].pos.z) =
	*((DWORD *)&vec[5].pos.z) = drawz;

	// 頂点データの出力
	ADD4VERTEX_NOTEX

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawLineBox
static int DrawLineBoxHardware( int x1, int y1, int x2, int y2, int Color )
{
	VERTEX_NOTEX_2D *VectData ;
	int Red, Green, Blue ;
	float fx1, fx2, fy1, fy2 ;
	int Flag;
	DWORD drawz ;

//	RenderVertexHardware( D3D.Direct3DDeviceHandle ) ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// 描画の準備
	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
	if( GRH.RenderTexture != NULL ) SetTextureHardware( NULL ) ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag ) ;

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 色その他ステータスのセット
	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( (	GRH.DiffuseColor & 0xff0000 ) >> 16 ) * Red )	/ 255 ) << 16 ) |
			( ( ( ( (	GRH.DiffuseColor & 0x00ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
			( ( ( (		GRH.DiffuseColor & 0x0000ff )       ) * Blue )	/ 255 ) | 
			(			GRH.DiffuseColor & 0xff000000 ) ;

	// 反転処理
	{
		int bx, by ;

		if( x1 > x2 || y1 > y2 )
		{
			bx = x1 ; by = y1 ;
			x1 = x2 ; y1 = y2 ;
			x2 = bx ; y2 = by ;
		}
	}

	fx1 = (float)x1 ;
	fy1 = (float)y1 ;
	fx2 = (float)x2 ;
	fy2 = (float)y2 ;

	GETVERTEX_LINEBOX( VectData ) ;
	VectData[ 0].color = VectData[ 1].color = VectData[ 2].color = VectData[ 3].color = VectData[ 4].color = VectData[ 5].color =
	VectData[ 6].color = VectData[ 7].color = VectData[ 8].color = VectData[ 9].color = VectData[10].color = VectData[11].color =
	VectData[12].color = VectData[13].color = VectData[14].color = VectData[15].color = VectData[16].color = VectData[17].color =
	VectData[18].color = VectData[19].color = VectData[20].color = VectData[21].color = VectData[22].color = VectData[23].color = Color ;

	*((DWORD *)&VectData[ 0].pos.z) = *((DWORD *)&VectData[ 1].pos.z) = *((DWORD *)&VectData[ 2].pos.z) = *((DWORD *)&VectData[ 3].pos.z) = *((DWORD *)&VectData[ 4].pos.z) = *((DWORD *)&VectData[ 5].pos.z) =
	*((DWORD *)&VectData[ 6].pos.z) = *((DWORD *)&VectData[ 7].pos.z) = *((DWORD *)&VectData[ 8].pos.z) = *((DWORD *)&VectData[ 9].pos.z) = *((DWORD *)&VectData[10].pos.z) = *((DWORD *)&VectData[11].pos.z) =
	*((DWORD *)&VectData[12].pos.z) = *((DWORD *)&VectData[13].pos.z) = *((DWORD *)&VectData[14].pos.z) = *((DWORD *)&VectData[15].pos.z) = *((DWORD *)&VectData[16].pos.z) = *((DWORD *)&VectData[17].pos.z) =
	*((DWORD *)&VectData[18].pos.z) = *((DWORD *)&VectData[19].pos.z) = *((DWORD *)&VectData[20].pos.z) = *((DWORD *)&VectData[21].pos.z) = *((DWORD *)&VectData[22].pos.z) = *((DWORD *)&VectData[23].pos.z) = drawz;

	VectData[0].pos.x = fx1			; VectData[0].pos.y = fy1		 ;
	VectData[1].pos.x = fx2			; VectData[1].pos.y = fy1		 ;
	VectData[2].pos.x = fx1			; VectData[2].pos.y = fy1 + 1.0f ;

	VectData[3].pos.x = fx2			; VectData[3].pos.y = fy1 + 1.0f ;
	VectData[4].pos.x = fx1			; VectData[4].pos.y = fy1 + 1.0f ;
	VectData[5].pos.x = fx2			; VectData[5].pos.y = fy1		 ;

	if( GRH.UseAlphaChDrawShader )
	{
		VectData[ 0 ].sc_u = ( VectData[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 0 ].sc_v = ( VectData[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 1 ].sc_u = ( VectData[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 1 ].sc_v = ( VectData[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 2 ].sc_u = ( VectData[ 2 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 2 ].sc_v = ( VectData[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 3 ].sc_u = ( VectData[ 3 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 3 ].sc_v = ( VectData[ 3 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 4 ].sc_u = ( VectData[ 4 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 4 ].sc_v = ( VectData[ 4 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 5 ].sc_u = ( VectData[ 5 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 5 ].sc_v = ( VectData[ 5 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
	}

	VectData += 6 ;


	VectData[0].pos.x = fx2 - 1.0f	; VectData[0].pos.y = fy1 + 1.0f ;
	VectData[1].pos.x = fx2			; VectData[1].pos.y = fy1 + 1.0f ;
	VectData[2].pos.x = fx2	- 1.0f	; VectData[2].pos.y = fy2		 ;

	VectData[3].pos.x = fx2			; VectData[3].pos.y = fy2		 ;
	VectData[4].pos.x = fx2 - 1.0f	; VectData[4].pos.y = fy2		 ;
	VectData[5].pos.x = fx2			; VectData[5].pos.y = fy1 + 1.0f ;

	if( GRH.UseAlphaChDrawShader )
	{
		VectData[ 0 ].sc_u = ( VectData[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 0 ].sc_v = ( VectData[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 1 ].sc_u = ( VectData[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 1 ].sc_v = ( VectData[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 2 ].sc_u = ( VectData[ 2 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 2 ].sc_v = ( VectData[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 3 ].sc_u = ( VectData[ 3 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 3 ].sc_v = ( VectData[ 3 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 4 ].sc_u = ( VectData[ 4 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 4 ].sc_v = ( VectData[ 4 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 5 ].sc_u = ( VectData[ 5 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 5 ].sc_v = ( VectData[ 5 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
	}

	VectData += 6 ;


	VectData[0].pos.x = fx1			; VectData[0].pos.y = fy1 + 1.0f ;
	VectData[1].pos.x = fx1 + 1.0f	; VectData[1].pos.y = fy1 + 1.0f ;
	VectData[2].pos.x = fx1			; VectData[2].pos.y = fy2		 ;

	VectData[3].pos.x = fx1 + 1.0f	; VectData[3].pos.y = fy2		 ;
	VectData[4].pos.x = fx1			; VectData[4].pos.y = fy2		 ;
	VectData[5].pos.x = fx1 + 1.0f	; VectData[5].pos.y = fy1 + 1.0f ;

	if( GRH.UseAlphaChDrawShader )
	{
		VectData[ 0 ].sc_u = ( VectData[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 0 ].sc_v = ( VectData[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 1 ].sc_u = ( VectData[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 1 ].sc_v = ( VectData[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 2 ].sc_u = ( VectData[ 2 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 2 ].sc_v = ( VectData[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 3 ].sc_u = ( VectData[ 3 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 3 ].sc_v = ( VectData[ 3 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 4 ].sc_u = ( VectData[ 4 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 4 ].sc_v = ( VectData[ 4 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 5 ].sc_u = ( VectData[ 5 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 5 ].sc_v = ( VectData[ 5 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
	}

	VectData += 6 ;


	VectData[0].pos.x = fx1 + 1.0f	; VectData[0].pos.y = fy2 - 1.0f ;
	VectData[1].pos.x = fx2 - 1.0f	; VectData[1].pos.y = fy2 - 1.0f ;
	VectData[2].pos.x = fx1 + 1.0f	; VectData[2].pos.y = fy2		 ;

	VectData[3].pos.x = fx2 - 1.0f	; VectData[3].pos.y = fy2		 ;
	VectData[4].pos.x = fx1 + 1.0f	; VectData[4].pos.y = fy2		 ;
	VectData[5].pos.x = fx2 - 1.0f	; VectData[5].pos.y = fy2 - 1.0f ;

	if( GRH.UseAlphaChDrawShader )
	{
		VectData[ 0 ].sc_u = ( VectData[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 0 ].sc_v = ( VectData[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 1 ].sc_u = ( VectData[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 1 ].sc_v = ( VectData[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 2 ].sc_u = ( VectData[ 2 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 2 ].sc_v = ( VectData[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 3 ].sc_u = ( VectData[ 3 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 3 ].sc_v = ( VectData[ 3 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 4 ].sc_u = ( VectData[ 4 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 4 ].sc_v = ( VectData[ 4 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 5 ].sc_u = ( VectData[ 5 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 5 ].sc_v = ( VectData[ 5 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
	}

	VectData += 6 ;

	// 頂点の追加
	ADD4VERTEX_LINEBOX

/*
	fx1 = (float)x1 ;
	fy1 = (float)y1 ;
	fx2 = (float)( x2 - 1 ) ;
	fy2 = (float)( y2 - 1 ) ;

	GETVERTEX_LINEBOX( VectData ) ;
	VectData[0].color = 
	VectData[1].color = 
	VectData[2].color = 
	VectData[3].color = 
	VectData[4].color = 
	VectData[5].color = 
	VectData[6].color = 
	VectData[7].color = Color ;

	*((DWORD *)&VectData[0].pos.z) =
	*((DWORD *)&VectData[1].pos.z) =
	*((DWORD *)&VectData[2].pos.z) =
	*((DWORD *)&VectData[3].pos.z) =
	*((DWORD *)&VectData[4].pos.z) =
	*((DWORD *)&VectData[5].pos.z) =
	*((DWORD *)&VectData[6].pos.z) =
	*((DWORD *)&VectData[7].pos.z) = drawz;

	// 座標のセット
	VectData[0].pos.x = fx1			; VectData[0].pos.y = fy1		;
	VectData[1].pos.x = fx2 - 0.1F	; VectData[1].pos.y = fy1		;

	VectData[2].pos.x = fx2			; VectData[2].pos.y = fy1		;
	VectData[3].pos.x = fx2			; VectData[3].pos.y = fy2 - 0.1F ;

	VectData[4].pos.x = fx1			; VectData[4].pos.y = fy2		;
	VectData[5].pos.x = fx2 + 0.9F	; VectData[5].pos.y = fy2		;

	VectData[6].pos.x = fx1			; VectData[6].pos.y = fy1 + 1.0F ;
	VectData[7].pos.x = fx1			; VectData[7].pos.y = fy2 - 0.1F ;

	// 頂点の追加
	ADD4VERTEX_LINEBOX
*/

//	// 四角形の描画
//	Get3DDevice( D3D.Direct3DDeviceHandle )->DrawPrimitive( D_D3DPT_LINELIST, VERTEXFVF_NOTEX_2D, VectData, 2 * 4, 0 ) ;

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawChipMap
static int	DrawChipMapHardware( int Sx, int Sy, int XNum, int YNum, const int *MapData, int MapDataPitch, int /*ChipTypeNum*/, const int *ChipGrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int i, j ;
	int x, y, Width, Height ;
	const int *MP ;

	if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return -1 ;

	// 描画の準備
	if( GRAPHCHK( ChipGrHandle[ 0 ], Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;
	}

	Width = Image2->Width ;
	Height = Image2->Height ;

	// 普通に for 文でループ描画
	y = Sy ;
	MP = MapData ;
	for( i = 0 ; i < YNum ; i ++, y += Height )
	{
		x = Sx ;
		for( j = 0 ; j < XNum ; j ++, x += Width, MP ++ )
		{
			if( *MP == -1 ) continue ;

			if( GRAPHCHK( ChipGrHandle[ *MP ], Image2 ) )
				return -1 ;

			DrawGraphHardware( x, y, ( float )x, ( float )y, Image2, BlendImage2, TransFlag, TRUE ) ;
		}
		MP += MapDataPitch - XNum ;
	}

	// 終了
	return 0 ;
}

/*
x1,y1,x2,y2　画面中、タイル貼りしたい領域
Tx,Ty　　　　変位　　　　　　　　　　　　元画像中の、どこの座標からタイル貼りを開始するか。
ExtRate　　　画像の拡大率　　　　　　　　これを「1」にすると、元画像のままの大きさでタイル貼りする。
Angle　　　　画像の回転角度　　　　　　　これを「0」にすると、回転なしでタイル貼りする。
GrHandle　　 画像のハンドル
TransFlag　　透過フラグ
*/

// ハードウエアアクセラレータ使用版 DrawTile
static int	DrawTileHardware( int x1, int y1, int x2, int y2, int Tx, int Ty, double ExtRate, double Angle, IMAGEDATA2 *Image2, IMAGEDATA2 *BlendImage2, int TransFlag )
{
	double MaxLength ;
	float Width, Height, f, Sin, Cos, Sin2, Cos2 ;
	float CenX, CenY, x, y, BaseX, BaseY ;
	float xAddX, xAddY, yAddX, yAddY ;
	int temp, Num, i, j ;
	RECT DrawRect ;
	float FExtRate, FAngle ;

	FExtRate = (float)ExtRate ;
	FAngle = (float)Angle ;

	if( ExtRate <= 0.0 ) ExtRate = 0.0001 ;
	if( x1 > x2 ){ temp = x2 ; x2 = x1 ; x1 = temp ; }
	if( y1 > y2 ){ temp = y2 ; y2 = y1 ; y1 = temp ; }
	Tx %= Image2->Width ;
	Ty %= Image2->Height ;

	// 進む値を計算
	_SINCOS( FAngle, &Sin, &Cos ) ;
	xAddX = Image2->Width * Cos * FExtRate ;
	xAddY = Image2->Height * Sin * FExtRate ;

	_SINCOS( FAngle + DX_PI_F / 2.0F, &Sin2, &Cos2 ) ;
	yAddX = Image2->Width * Cos2 * FExtRate ;
	yAddY = Image2->Height * Sin2 * FExtRate ;

	// 描画幅を得る
	Width = (float)( x2 - x1 ) ;
	Height = (float)( y2 - y1 ) ;

	// 最大長を得る
	MaxLength = _SQRT( Width * Width + Height * Height ) ;

	// 描画個数を得る
	{
		int k ;

		k = Image2->Width > Image2->Height ? Image2->Height : Image2->Width ;
		Num = _DTOL( MaxLength / ( k * ExtRate ) + 2 ) ;
		if( Num % 2 == 0 ) Num ++ ;
	}

	// 描画中心点を得る
	CenX = x1 + Width / 2 ;
	CenY = y1 + Height / 2 ;

	// 描画可能範囲を変更する
	DrawRect = GBASE.DrawArea ;
	NS_SetDrawArea( x1, y1, x2, y2 ) ;

	// 描画開始座標を得る
	BaseX = ( -Tx - ( Num * Image2->Width  ) / 2 ) * FExtRate ;
	BaseY = ( -Ty - ( Num * Image2->Height ) / 2 ) * FExtRate ;

	f = BaseX * Cos - BaseY * Sin ;
	BaseY = BaseX * Sin + BaseY * Cos + CenY ;
	BaseX = f + CenX ;

	// 描画開始
	for( i = 0 ; i < Num ; i ++, BaseX += yAddX, BaseY += yAddY )
	{
		x = BaseX ;
		y = BaseY ;
		for( j = 0 ; j < Num ; j ++, x += xAddX, y += xAddY )
		{
			DrawModiGraphFHardware(
				x, y,
				x + xAddX, y + xAddY,
				x + yAddX, y + yAddY,
				x + xAddX + yAddX, y + xAddY + yAddY,
				Image2, BlendImage2, TransFlag, true ) ;
		}
	}

	// 描画可能範囲を元に戻す
	NS_SetDrawArea( DrawRect.left, DrawRect.top, DrawRect.right, DrawRect.bottom ) ;

	return 0 ;
}

static int DrawPrimitiveHardware( const VERTEX_3D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag )
{
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	// 描画フラグのセット
	Flag = TransFlag | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_FOG | DRAWPREP_3D | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;

	// 描画の準備
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// 描画
	SETFVF( VERTEXFVF_3D )
	GraphicsDevice_DrawPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, GETPRIMNUM( PrimitiveType, VertexNum ), Vertex, sizeof( VERTEX_3D ) ) ;

	// 終了
	return 0 ;
}

static int	DrawIndexedPrimitiveHardware( const VERTEX_3D *Vertex, int VertexNum, const WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag )
{
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_FOG | DRAWPREP_3D | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// 描画
	SETFVF( VERTEXFVF_3D )
	GraphicsDevice_DrawIndexedPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, 0, VertexNum, GETPRIMNUM( PrimitiveType, IndexNum ), Indices, D_D3DFMT_INDEX16, Vertex, sizeof( VERTEX_3D ) ) ;

	// 終了
	return 0 ;
}

static int DrawPrimitiveLightHardware( const VERTEX3D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag )
{
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_FOG | DRAWPREP_LIGHTING | DRAWPREP_SPECULAR | DRAWPREP_3D | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// 描画
	SETFVF( VERTEXFVF_3D_LIGHT )
	GraphicsDevice_DrawPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, GETPRIMNUM( PrimitiveType, VertexNum ), Vertex, sizeof( VERTEX3D ) ) ;

	// 終了
	return 0 ;
}

static int DrawIndexedPrimitiveLightHardware( const VERTEX3D *Vertex, int VertexNum, const WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag )
{
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_FOG | DRAWPREP_LIGHTING | DRAWPREP_SPECULAR | DRAWPREP_3D | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// 描画
	SETFVF( VERTEXFVF_3D_LIGHT )
	GraphicsDevice_DrawIndexedPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, 0, VertexNum, GETPRIMNUM( PrimitiveType, IndexNum ), Indices, D_D3DFMT_INDEX16, Vertex, sizeof( VERTEX3D ) ) ;

	// 終了
	return 0 ;
}

static int	DrawPrimitiveLight_UseVertexBufferHardware( 
	VERTEXBUFFERHANDLEDATA *VertexBuffer,
	int						PrimitiveType,
	int						StartVertex,
	int						UseVertexNum,
	IMAGEDATA2 *			Image2,
	int						TransFlag 
)
{
	int Flag ;
	int PrimitiveCount ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_FOG | DRAWPREP_LIGHTING | DRAWPREP_SPECULAR | DRAWPREP_3D | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// FVFのセットアップ
	switch( VertexBuffer->Type )
	{
	case DX_VERTEX_TYPE_NORMAL_3D:
		SETFVF( VERTEXFVF_3D_LIGHT )
		break;
	}

	// プリミティブの数を取得
	PrimitiveCount = GETPRIMNUM( PrimitiveType, UseVertexNum ) ;

	// 描画
	if( VertexBuffer->Direct3DBuffer != NULL )
	{
		GraphicsDevice_SetStreamSource(
			0,
			VertexBuffer->Direct3DBuffer,
			0,
			VertexBuffer->UnitSize ) ;

		GraphicsDevice_DrawPrimitive(
			( D_D3DPRIMITIVETYPE )PrimitiveType,
			StartVertex,
			PrimitiveCount ) ;
	}
	else
	{
		GraphicsDevice_DrawPrimitiveUP(
			( D_D3DPRIMITIVETYPE )PrimitiveType,
			PrimitiveCount,
			( BYTE * )VertexBuffer->Buffer + StartVertex * VertexBuffer->UnitSize,
			VertexBuffer->UnitSize ) ;
	}

	// 終了
	return 0 ;
}

static int DrawIndexedPrimitiveLight_UseVertexBufferHardware(
	VERTEXBUFFERHANDLEDATA *	VertexBuffer,
	INDEXBUFFERHANDLEDATA *		IndexBuffer,
	int							PrimitiveType,
	int							BaseVertex,
	int							StartVertex,
	int							UseVertexNum,
	int							StartIndex,
	int							UseIndexNum,
	IMAGEDATA2 *				Image2,
	int							TransFlag
)
{
	int Flag ;
	int PrimitiveCount ;
	D_D3DFORMAT IndexFormat ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_FOG | DRAWPREP_LIGHTING | DRAWPREP_SPECULAR | DRAWPREP_3D | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// FVFのセットアップ
	switch( VertexBuffer->Type )
	{
	case DX_VERTEX_TYPE_NORMAL_3D:
		SETFVF( VERTEXFVF_3D_LIGHT )
		break ;
	}

	// インデックスタイプをセット
	IndexFormat = D_D3DFMT_INDEX16 ;
	switch( IndexBuffer->Type )
	{
	case DX_INDEX_TYPE_16BIT:
		IndexFormat = D_D3DFMT_INDEX16 ;
		break ;

	case DX_INDEX_TYPE_32BIT:
		IndexFormat = D_D3DFMT_INDEX32 ;
		break ;
	}

	// プリミティブの数を取得
	PrimitiveCount = GETPRIMNUM( PrimitiveType, UseIndexNum ) ;

	// 描画
	if( VertexBuffer->Direct3DBuffer != NULL &&
		IndexBuffer->Direct3DBuffer  != NULL )
	{
		GraphicsDevice_SetStreamSource(
			0,
			VertexBuffer->Direct3DBuffer,
			0,
			VertexBuffer->UnitSize ) ;
		GraphicsDevice_SetIndices( IndexBuffer->Direct3DBuffer ) ;

		GraphicsDevice_DrawIndexedPrimitive(
			( D_D3DPRIMITIVETYPE )PrimitiveType,
			BaseVertex,
			StartVertex,
			UseVertexNum,
			StartIndex,
			PrimitiveCount ) ;
	}
	else
	{
		GraphicsDevice_DrawIndexedPrimitiveUP(
			( D_D3DPRIMITIVETYPE )PrimitiveType,
			StartVertex,
			UseVertexNum,
			PrimitiveCount,
			( BYTE * )IndexBuffer->Buffer + StartIndex * IndexBuffer->UnitSize,
			IndexFormat, 
			( BYTE * )VertexBuffer->Buffer + BaseVertex * VertexBuffer->UnitSize,
			VertexBuffer->UnitSize ) ;
	}

	// 終了
	return 0 ;
}

static int DrawPrimitive2DHardware( VERTEX_2D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag, int BillboardFlag, int Is3D, int TurnFlag, int TextureNo )
{
	int Flag ;
	int i ;
	VERTEX_2D *Vert ;
	int SmHandle ;
	SHADOWMAPDATA *ShadowMap ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	if( BillboardFlag == TRUE )
	{
		Flag = TransFlag | ( Is3D ? DRAWPREP_3D | DRAWPREP_FOG : 0 ) | DRAWPREP_TEXADDRESS ;
	}
	else
	{
		Flag = TransFlag | ( Is3D ? DRAWPREP_3D | DRAWPREP_FOG : 0 ) | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	}
	if( Image2 )
	{
		SmHandle = ( int )Image2 ;
		if( !SHADOWMAPCHK( SmHandle, ShadowMap ) )
		{
			if( GRH.DrawPrepAlwaysFlag != FALSE ||
				GRH.DrawPrepTexture != ShadowMap->Texture ||
				GRH.DrawPrepParamFlag != Flag )
			{
				DrawPreparation( ShadowMap->Texture, Flag ) ;
			}
		}
		else
		{
			DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ TextureNo ].Tex->Texture, Flag )
		}
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// ビルボードの場合はＵＶ値をサーフェスデータから取得する
	if( BillboardFlag == TRUE )
	{
		float tu1, tv1, tu2, tv2 ;
		int Num ;
		
		Vert = Vertex ;
		Num = VertexNum / 6 ;
		tu1 = Image2->Hard.Draw[ 0 ].Vertex[ 0 ].u ;
		tv1 = Image2->Hard.Draw[ 0 ].Vertex[ 0 ].v ;
		tu2 = Image2->Hard.Draw[ 0 ].Vertex[ 3 ].u ;
		tv2 = Image2->Hard.Draw[ 0 ].Vertex[ 3 ].v ;
		for( i = 0 ; i < Num ; i ++, Vert += 6 )
		{
			if( TurnFlag )
			{
				Vert[ 0 ].u = tu2 ;
				Vert[ 1 ].u = tu1 ;
				Vert[ 2 ].u = tu2 ;
				Vert[ 3 ].u = tu1 ;
			}
			else
			{
				Vert[ 0 ].u = tu1 ;
				Vert[ 1 ].u = tu2 ;
				Vert[ 2 ].u = tu1 ;
				Vert[ 3 ].u = tu2 ;
			}
			Vert[ 0 ].v = tv1 ;
			Vert[ 1 ].v = tv1 ;
			Vert[ 2 ].v = tv2 ;
			Vert[ 3 ].v = tv2 ;

			Vert[ 4 ].u = Vert[ 2 ].u ;
			Vert[ 4 ].v = Vert[ 2 ].v ;
			Vert[ 5 ].u = Vert[ 1 ].u ;
			Vert[ 5 ].v = Vert[ 1 ].v ;
		}
	}

	if( GRH.UseAlphaChDrawShader )
	{
		Vert = Vertex ;
		for( i = 0 ; i < VertexNum ; i ++, Vert ++ )
		{
			Vert->sc_u = ( Vert->pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			Vert->sc_v = ( Vert->pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		}
	}

	// 描画
	SETFVF( VERTEXFVF_2D )
	GraphicsDevice_DrawPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, GETPRIMNUM( PrimitiveType, VertexNum ), Vertex, sizeof( VERTEX_2D ) ) ;

	// 終了
	return 0 ;
}

static int	DrawIndexedPrimitive2DHardware( VERTEX_2D *Vertex, int VertexNum, WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag )
{
	int Flag ;
	int i ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	if( GRH.UseAlphaChDrawShader )
	{
		for( i = 0 ; i < VertexNum ; i ++ )
		{
			Vertex[ i ].sc_u = ( Vertex[ i ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			Vertex[ i ].sc_v = ( Vertex[ i ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		}
	}

	// 描画
	SETFVF( VERTEXFVF_2D )
	GraphicsDevice_DrawIndexedPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, 0, VertexNum, GETPRIMNUM( PrimitiveType, IndexNum ), Indices, D_D3DFMT_INDEX16, Vertex, sizeof( VERTEX_2D ) ) ;

	// 終了
	return 0 ;
}

static int DrawPrimitive2DUserHardware( const VERTEX2D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag, int Is3D, int TurnFlag, int TextureNo )
{
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | ( Is3D ? DRAWPREP_3D | DRAWPREP_FOG : 0 ) | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ TextureNo ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// 描画
	SETFVF( VERTEXFVF_2D_USER )
	GraphicsDevice_DrawPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, GETPRIMNUM( PrimitiveType, VertexNum ), Vertex, sizeof( VERTEX2D ) ) ;

	// 終了
	return 0 ;
}

static int DrawPrimitive2DUserHardware_Billboard( VERTEX2D *Vertex, int VertexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag, int Is3D, int TurnFlag, int TextureNo )
{
	int Flag ;
	int i ;
	VERTEX2D *Vert ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | ( Is3D ? DRAWPREP_3D | DRAWPREP_FOG : 0 ) | DRAWPREP_TEXADDRESS ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ TextureNo ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// ビルボードの場合はＵＶ値をサーフェスデータから取得する
	{
		float tu1, tv1, tu2, tv2 ;
		int Num ;
		
		Vert = Vertex ;
		Num = VertexNum / 6 ;
		tu1 = Image2->Hard.Draw[ 0 ].Vertex[ 0 ].u ;
		tv1 = Image2->Hard.Draw[ 0 ].Vertex[ 0 ].v ;
		tu2 = Image2->Hard.Draw[ 0 ].Vertex[ 3 ].u ;
		tv2 = Image2->Hard.Draw[ 0 ].Vertex[ 3 ].v ;
		for( i = 0 ; i < Num ; i ++, Vert += 6 )
		{
			if( TurnFlag )
			{
				Vert[ 0 ].u = tu2 ;
				Vert[ 1 ].u = tu1 ;
				Vert[ 2 ].u = tu2 ;
				Vert[ 3 ].u = tu1 ;
			}
			else
			{
				Vert[ 0 ].u = tu1 ;
				Vert[ 1 ].u = tu2 ;
				Vert[ 2 ].u = tu1 ;
				Vert[ 3 ].u = tu2 ;
			}
			Vert[ 0 ].v = tv1 ;
			Vert[ 1 ].v = tv1 ;
			Vert[ 2 ].v = tv2 ;
			Vert[ 3 ].v = tv2 ;

			Vert[ 4 ].u = Vert[ 2 ].u ;
			Vert[ 4 ].v = Vert[ 2 ].v ;
			Vert[ 5 ].u = Vert[ 1 ].u ;
			Vert[ 5 ].v = Vert[ 1 ].v ;
		}
	}

	// 描画
	SETFVF( VERTEXFVF_2D_USER )
	GraphicsDevice_DrawPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, GETPRIMNUM( PrimitiveType, VertexNum ), Vertex, sizeof( VERTEX2D ) ) ;

	// 終了
	return 0 ;
}

static int	DrawIndexedPrimitive2DUserHardware( const VERTEX2D *Vertex, int VertexNum, const WORD *Indices, int IndexNum, int PrimitiveType, IMAGEDATA2 *Image2, int TransFlag )
{
	int Flag ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	SetBlendTextureHardware( NULL ) ;

	Flag = TransFlag | DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE | DRAWPREP_DIFFUSERGB | DRAWPREP_DIFFUSEALPHA | DRAWPREP_TEXADDRESS | DRAWPREP_CULLING ;
	if( Image2 )
	{
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, Flag )
	}
	else
	{
		DRAWPREP_NOTEX( Flag )
	}

	// 描画
	SETFVF( VERTEXFVF_2D_USER )
	GraphicsDevice_DrawIndexedPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, 0, VertexNum, GETPRIMNUM( PrimitiveType, IndexNum ), Indices, D_D3DFMT_INDEX16, Vertex, sizeof( VERTEX2D ) ) ;

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawLine
static int	DrawLineHardware( int x1, int y1, int x2, int y2, int Color )
{
	VERTEX_NOTEX_2D *VectData ;
	int Red, Green, Blue, Flag ;
	DWORD drawz ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ; 

	if( x2 - x1 == 0 && y2 - y1 == 0 ) return 0 ; 

	// 描画の準備
	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
	if( GRH.RenderTexture != NULL ) SetTextureHardware( NULL ) ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 色をセット
	GETVERTEX_LINE( VectData ) ;
	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( (	GRH.DiffuseColor & 0xff0000 ) >> 16 ) * Red )	/ 255 ) << 16 ) |
			( ( ( ( (	GRH.DiffuseColor & 0x00ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
			( ( ( (		GRH.DiffuseColor & 0x0000ff )       ) * Blue )	/ 255 ) | 
			(			GRH.DiffuseColor & 0xff000000 ) ;
	VectData[ 0 ].color = Color ;
	VectData[ 1 ].color = Color ;
	*((DWORD *)&VectData[ 0 ].pos.z) = drawz;
	*((DWORD *)&VectData[ 1 ].pos.z) = drawz;

	// 座標をセット
	VectData[ 0 ].pos.x = ( float )( x1 ) ;
	VectData[ 0 ].pos.y = ( float )( y1 ) ;

	VectData[ 1 ].pos.x = ( float )( x2 ) ;
	VectData[ 1 ].pos.y = ( float )( y2 ) ;

	// 座標の補正
	if( x1 == x2 ) VectData[ 1 ].pos.y += y2 > y1 ? -0.1F : 0.1F ;
	if( y1 == y2 ) VectData[ 1 ].pos.x += x2 > x1 ? -0.1F : 0.1F ;

	if( GRH.UseAlphaChDrawShader )
	{
		VectData[ 0 ].sc_u = ( VectData[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 0 ].sc_v = ( VectData[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		VectData[ 1 ].sc_u = ( VectData[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData[ 1 ].sc_v = ( VectData[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
	}

	// 頂点の追加
	ADD4VERTEX_LINE

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawLine3D
static int	DrawLine3DHardware( VECTOR Pos1, VECTOR Pos2, int Color, int DrawFlag, RECT *DrawArea )
{
	VERTEX_NOTEX_3D *VectData ;
	int Red, Green, Blue, Flag ;

	if( DrawFlag )
	{
		if( GraphicsDevice_IsValid() == 0 ) return -1 ; 

		// 描画の準備
		if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
		if( GRH.RenderTexture != NULL ) SetTextureHardware( NULL ) ;

		Flag = DRAWPREP_DIFFUSERGB | DRAWPREP_3D | DRAWPREP_FOG ;
		DRAWPREP_NOTEX( Flag )

		GETVERTEX_LINE3D( VectData ) ;

		// 色をセット
		NS_GetColor2( Color, &Red, &Green, &Blue ) ;
		Color = ( ( ( ( (	GRH.DiffuseColor & 0xff0000 ) >> 16 ) * Red )	/ 255 ) << 16 ) |
				( ( ( ( (	GRH.DiffuseColor & 0x00ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
				( ( ( (		GRH.DiffuseColor & 0x0000ff )       ) * Blue )	/ 255 ) | 
				(			GRH.DiffuseColor & 0xff000000 ) ;
		*( ( int * )&VectData[ 0 ].b ) = Color ;
		*( ( int * )&VectData[ 1 ].b ) = Color ;

		// 座標をセット
		VectData[ 0 ].pos = Pos1 ;
		VectData[ 1 ].pos = Pos2 ;

		// 頂点の追加
		ADD4VERTEX_LINE3D
	}
	else
	{
		VERTEX_2D TempVect[ 2 ] ;
		float dleft, dright, dtop, dbottom ;

		dleft   = -100000000.0f ;
		dright  =  100000000.0f ;
		dtop    = -100000000.0f ;
		dbottom =  100000000.0f ;

		// スクリーン座標に変換
		TempVect[0].pos.x = Pos1.x * GBASE.BlendMatrix.m[0][0] + Pos1.y * GBASE.BlendMatrix.m[1][0] + Pos1.z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
		TempVect[0].pos.y = Pos1.x * GBASE.BlendMatrix.m[0][1] + Pos1.y * GBASE.BlendMatrix.m[1][1] + Pos1.z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
		TempVect[0].pos.z = Pos1.x * GBASE.BlendMatrix.m[0][2] + Pos1.y * GBASE.BlendMatrix.m[1][2] + Pos1.z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
		TempVect[0].rhw   = Pos1.x * GBASE.BlendMatrix.m[0][3] + Pos1.y * GBASE.BlendMatrix.m[1][3] + Pos1.z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

		TempVect[1].pos.x = Pos2.x * GBASE.BlendMatrix.m[0][0] + Pos2.y * GBASE.BlendMatrix.m[1][0] + Pos2.z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
		TempVect[1].pos.y = Pos2.x * GBASE.BlendMatrix.m[0][1] + Pos2.y * GBASE.BlendMatrix.m[1][1] + Pos2.z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
		TempVect[1].pos.z = Pos2.x * GBASE.BlendMatrix.m[0][2] + Pos2.y * GBASE.BlendMatrix.m[1][2] + Pos2.z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
		TempVect[1].rhw   = Pos2.x * GBASE.BlendMatrix.m[0][3] + Pos2.y * GBASE.BlendMatrix.m[1][3] + Pos2.z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

		TempVect[0].rhw = 1.0F / TempVect[0].rhw ;
		TempVect[0].pos.x *= TempVect[0].rhw ;
		TempVect[0].pos.y *= TempVect[0].rhw ;
		TempVect[0].pos.z *= TempVect[0].rhw ;

		TempVect[1].rhw = 1.0F / TempVect[1].rhw ;
		TempVect[1].pos.x *= TempVect[1].rhw ;
		TempVect[1].pos.y *= TempVect[1].rhw ;
		TempVect[1].pos.z *= TempVect[1].rhw ;

		if( dright  > TempVect[ 0 ].pos.x ) dright  = TempVect[ 0 ].pos.x ;
		if( dright  > TempVect[ 1 ].pos.x ) dright  = TempVect[ 1 ].pos.x ;

		if( dleft   < TempVect[ 0 ].pos.x ) dleft   = TempVect[ 0 ].pos.x ;
		if( dleft   < TempVect[ 1 ].pos.x ) dleft   = TempVect[ 1 ].pos.x ;

		if( dbottom > TempVect[ 0 ].pos.y ) dbottom = TempVect[ 0 ].pos.y ;
		if( dbottom > TempVect[ 1 ].pos.y ) dbottom = TempVect[ 1 ].pos.y ;

		if( dtop    < TempVect[ 0 ].pos.y ) dtop    = TempVect[ 0 ].pos.y ;
		if( dtop    < TempVect[ 1 ].pos.y ) dtop    = TempVect[ 1 ].pos.y ;

		DrawArea->left   = _FTOL( dleft   ) - 1 ;
		DrawArea->right  = _FTOL( dright  ) + 1 ;
		DrawArea->top    = _FTOL( dtop    ) - 1 ;
		DrawArea->bottom = _FTOL( dbottom ) + 1 ;
	}

	// 終了
	return 0 ;
}

#define DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK									\
	if( y1 >= DrawRect.top && y1 < DrawRect.bottom )							\
	{																			\
		if( ( CirclePos[ y1 ][ 4 ] & 1 ) == 0 || CirclePos[ y1 ][ 0 ] > x1 )	\
		{																		\
			CirclePos[ y1 ][ 4 ] |= 1 ;											\
			CirclePos[ y1 ][ 0 ] = x1 ;											\
		}																		\
	}

#define DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK									\
	if( y1 >= DrawRect.top && y1 < DrawRect.bottom )							\
	{																			\
		if( ( CirclePos[ y1 ][ 4 ] & 2 ) == 0 || CirclePos[ y1 ][ 1 ] < x1 )	\
		{																		\
			CirclePos[ y1 ][ 4 ] |= 2 ;											\
			CirclePos[ y1 ][ 1 ] = x1 ;											\
		}																		\
	}

#define DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK									\
	if( y1 >= DrawRect.top && y1 < DrawRect.bottom )							\
	{																			\
		if( ( CirclePos[ y1 ][ 4 ] & 4 ) == 0 || CirclePos[ y1 ][ 2 ] < x1 )	\
		{																		\
			CirclePos[ y1 ][ 4 ] |= 4 ;											\
			CirclePos[ y1 ][ 2 ] = x1 ;											\
		}																		\
	}

#define DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK									\
	if( y1 >= DrawRect.top && y1 < DrawRect.bottom )							\
	{																			\
		if( ( CirclePos[ y1 ][ 4 ] & 8 ) == 0 || CirclePos[ y1 ][ 3 ] > x1 )	\
		{																		\
			CirclePos[ y1 ][ 4 ] |= 8 ;											\
			CirclePos[ y1 ][ 3 ] = x1 ;											\
		}																		\
	}

// 線の幅付き円の描画用頂点を取得する関数
static int	GetCircle_ThicknessDrawPosition( int x, int y, int r, int Thickness, short ( *CirclePos )[ 5 ] )
{
	int rmax, rmin ;
	int x1, y1 ;
	int Dx, Dy, F ;
	RECT DrawRect ;

	DrawRect = GBASE.DrawArea ;

	// 各線の太さを算出
	rmax = r + Thickness / 2 ;
	rmin = r - Thickness / 2 ;
	if( rmax - rmin + 1 > Thickness )
	{
		rmin ++ ;
	}

	// 外側円の座標リスト作成
	{
		// 初期値セット
		Dx = rmax ; Dy = 0 ; F = -2 * rmax + 3 ;

		// 最初の点
		{
			x1 = -Dx + x ; y1 = Dy + y ;
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
			x1 = Dx + x ;  
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

			x1 = Dy + x ; y1 = Dx + y ;
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

			x1 = Dy + x ; y1 = -Dx + y;
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

			// 座標データを進める
			if( F >= 0 )
			{
				Dx -- ;
				F -= 4 * Dx ;
			}	

			Dy ++ ;
			F += 4 * Dy + 2 ;
		}

		while( Dx >= Dy )
		{
			x1 = -Dx + x ; y1 = Dy + y ;
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
			x1 = Dx + x ;  
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

			x1 = Dy + x ; y1 = Dx + y ;
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;
			x1 = -Dy + x ; 
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
		
			x1 = Dx + x ; y1 = -Dy + y;
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;
			x1 = -Dx + x ; 
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;

			x1 = Dy + x ; y1 = -Dx + y;
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;
			x1 = -Dy + x ; 
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;

			// 座標データを進める
			if( F >= 0 )
			{
				Dx -- ;
				F -= 4 * Dx ;
			}

			Dy ++ ;
			F += 4 * Dy + 2 ;
		}
	}

	// 内側円の座標リスト作成
	{
		// 初期値セット
		Dx = rmin ; Dy = 0 ; F = -2 * rmin + 3 ;

		// 最初の点
		{
			x1 = -Dx + x ; y1 = Dy + y ;
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
			x1 = Dx + x ;  
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

			x1 = Dy + x ; y1 = Dx + y ;
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

			x1 = Dy + x ; y1 = -Dx + y;
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

			// 座標データを進める
			if( F >= 0 )
			{
				Dx -- ;
				F -= 4 * Dx ;
			}	

			Dy ++ ;
			F += 4 * Dy + 2 ;
		}

		while( Dx >= Dy )
		{
			x1 = -Dx + x ; y1 = Dy + y ;
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
			x1 = Dx + x ;  
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

			x1 = Dy + x ; y1 = Dx + y ;
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;
			x1 = -Dy + x ; 
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
		
			x1 = Dx + x ; y1 = -Dy + y;
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;
			x1 = -Dx + x ; 
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;

			x1 = Dy + x ; y1 = -Dx + y;
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;
			x1 = -Dy + x ; 
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;

			// 座標データを進める
			if( F >= 0 )
			{
				Dx -- ;
				F -= 4 * Dx ;
			}

			Dy ++ ;
			F += 4 * Dy + 2 ;
		}
	}

	// 終了
	return 0 ;
}

// 線の幅付き楕円の描画用頂点を取得する関数
static int	GetOval_ThicknessDrawPosition( int x, int y, int rx, int ry, int Thickness, short ( *CirclePos )[ 5 ] )
{
	int x1, y1 ;
	int Dx, Dy, F, H, Df, yc, xc, rc, r ;
	int rxmax, rymax ;
	int rxmin, rymin ;
	RECT DrawRect ;

	DrawRect = GBASE.DrawArea ;

	// 各線の太さを算出
	rxmax = rx + Thickness / 2 ;
	rxmin = rx - Thickness / 2 ;
	if( rxmax - rxmin + 1 > Thickness )
	{
		rxmin ++ ;
	}
	rymax = ry + Thickness / 2 ;
	rymin = ry - Thickness / 2 ;
	if( rymax - rymin + 1 > Thickness )
	{
		rymin ++ ;
	}

	// 外側円の座標リスト作成
	{
		if( rxmax >= rymax )
		{
			// 初期値をセット
			rc = ( rxmax * rxmax ) / rymax ;

			xc = 0 ; yc = 0 ;
			r = rxmax ;
			Df = 2 ;
	
			Dx = r ;
			Dy = 0;
			F = -2 * r + 1 + 2 * 1;
			H = -4 * r + 2 + 1;

			// 最初の点を描く
			{
				x1 = -Dx + x ; y1 = Dy + y ;
				DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
				x1 = Dx + x ;  
				DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

				Df = 0 ;

				// 座標データを進める
				if( F < 0 )
				{
					yc += rymax ;
					if( yc >= rc )
					{
						Dy ++ ;
						yc -= rc ;
						Df = 1 ;
					}
					F += 4 * Dy + 2 ;
					H += 4 * Dy;
				}
				else
				{
					Df = 1 ;

					if( H>=0 )
					{
						Dx--;
						F -= 4 * Dx;
						H -= 4 * Dx - 2 ;
					}
					else
					{
						Dx--;	
						yc += rymax ;
						if( yc >= rc )
						{
							Dy ++ ;
							yc -= rc ;
							Df = 1 ;
						}
						F += 4 * Dy - 4 * Dx + 2 ;
						H += 4 * Dy - 4 * Dx + 2 ;
					}
				}
			}

			while( Dx > 0 )
			{
				if( Df )
				{
					x1 = -Dx + x ; y1 = Dy + y ;
					DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
					x1 = Dx + x ;  
					DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

					x1 = -Dx + x ; y1 = -Dy + y ;
					DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
					x1 = Dx + x ;  
					DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;
				}

				Df = 0 ;

				// 座標データを進める
				if( F < 0 )
				{
					yc += rymax ;
					if( yc >= rc )
					{
						Dy ++ ;
						yc -= rc ;
						Df = 1 ;
					}
					F += 4 * Dy + 2 ;
					H += 4 * Dy;
				}
				else
				{
					Df = 1 ;

					if( H>=0 )
					{
						Dx--;
						F -= 4 * Dx;
						H -= 4 * Dx - 2 ;
					}
					else
					{
						Dx--;	
						yc += rymax ;
						if( yc >= rc )
						{
							Dy ++ ;
							yc -= rc ;
							Df = 1 ;
						}
						F += 4 * Dy - 4 * Dx + 2 ;
						H += 4 * Dy - 4 * Dx + 2 ;
					}
				}
			}

			// 最後の点を描く
			x1 = Dx + x ; y1 = -Dy + y;
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

			x1 = -Dx + x ; y1 = Dy + y ;
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
		}
		else
		{
			// 初期値をセット
			rc = ( rymax * rymax ) / rxmax ;

			xc = 0 ; yc = 0 ;
			r = rxmax ;
			Df = 2 ;
	
			Dx = r ;
			Dy = 0;
			F = -2 * r + 1 + 2 * 1;
			H = -4 * r + 2 + 1;

			// 最初の点を描く
			{
				x1 = -Dx + x ; y1 = Dy + y ;
				DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
				x1 = Dx + x ;  
				DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

				Df = 0 ;

				// 座標データを進める
				if( F < 0 )
				{
					Df = 1 ;

					Dy ++ ;
					F += 4 * Dy + 2 ;
					H += 4 * Dy;
				}
				else
				{
					if( H>=0 )
					{
						xc += rxmax ;
						if( xc >= rc )
						{
							Dx--;
							xc -= rc ;
							Df = 1 ;
						}
						F -= 4 * Dx;
						H -= 4 * Dx - 2 ;
					}
					else
					{
						Df = 1 ;

						xc += rxmax ;
						if( xc >= rc )
						{
							Dx--;
							xc -= rc ;
						}

						Dy ++ ;
						F += 4 * Dy - 4 * Dx + 2 ;
						H += 4 * Dy - 4 * Dx + 2 ;
					}
				}
			}

			while( Dx > 0 )
			{
				if( Df )
				{
					x1 = -Dx + x ; y1 = Dy + y ;
					DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
					x1 = Dx + x ;  
					DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

					x1 = -Dx + x ; y1 = -Dy + y ;
					DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
					x1 = Dx + x ;  
					DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;
				}

				Df = 0 ;

				// 座標データを進める
				if( F < 0 )
				{
					Df = 1 ;

					Dy ++ ;
					F += 4 * Dy + 2 ;
					H += 4 * Dy;
				}
				else
				{
					if( H>=0 )
					{
						xc += rxmax ;
						if( xc >= rc )
						{
							Dx--;
							xc -= rc ;
							Df = 1 ;
						}
						F -= 4 * Dx;
						H -= 4 * Dx - 2 ;
					}
					else
					{
						Df = 1 ;

						xc += rxmax ;
						if( xc >= rc )
						{
							Dx--;
							xc -= rc ;
						}

						Dy ++ ;
						F += 4 * Dy - 4 * Dx + 2 ;
						H += 4 * Dy - 4 * Dx + 2 ;
					}
				}
			}

			// 最後の点を描く
			x1 = Dx + x ; y1 = -Dy + y;
			DX_CIRCLE_THICKNESS_R_MAX_RIGHT_CHECK ;

			x1 = -Dx + x ; y1 = Dy + y ;
			DX_CIRCLE_THICKNESS_R_MAX_LEFT_CHECK ;
		}
	}

	// 内側円の座標リスト作成
	{
		if( rxmin >= rymin )
		{
			// 初期値をセット
			rc = ( rxmin * rxmin ) / rymin ;

			xc = 0 ; yc = 0 ;
			r = rxmin ;
			Df = 2 ;
	
			Dx = r ;
			Dy = 0;
			F = -2 * r + 1 + 2 * 1;
			H = -4 * r + 2 + 1;

			// 最初の点を描く
			{
				x1 = -Dx + x ; y1 = Dy + y ;
				DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
				x1 = Dx + x ;  
				DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

				Df = 0 ;

				// 座標データを進める
				if( F < 0 )
				{
					yc += rymin ;
					if( yc >= rc )
					{
						Dy ++ ;
						yc -= rc ;
						Df = 1 ;
					}
					F += 4 * Dy + 2 ;
					H += 4 * Dy;
				}
				else
				{
					Df = 1 ;

					if( H>=0 )
					{
						Dx--;
						F -= 4 * Dx;
						H -= 4 * Dx - 2 ;
					}
					else
					{
						Dx--;	
						yc += rymin ;
						if( yc >= rc )
						{
							Dy ++ ;
							yc -= rc ;
							Df = 1 ;
						}
						F += 4 * Dy - 4 * Dx + 2 ;
						H += 4 * Dy - 4 * Dx + 2 ;
					}
				}
			}

			while( Dx > 0 )
			{
				if( Df )
				{
					x1 = -Dx + x ; y1 = Dy + y ;
					DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
					x1 = Dx + x ;  
					DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

					x1 = -Dx + x ; y1 = -Dy + y ;
					DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
					x1 = Dx + x ;  
					DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;
				}

				Df = 0 ;

				// 座標データを進める
				if( F < 0 )
				{
					yc += rymin ;
					if( yc >= rc )
					{
						Dy ++ ;
						yc -= rc ;
						Df = 1 ;
					}
					F += 4 * Dy + 2 ;
					H += 4 * Dy;
				}
				else
				{
					Df = 1 ;

					if( H>=0 )
					{
						Dx--;
						F -= 4 * Dx;
						H -= 4 * Dx - 2 ;
					}
					else
					{
						Dx--;	
						yc += rymin ;
						if( yc >= rc )
						{
							Dy ++ ;
							yc -= rc ;
							Df = 1 ;
						}
						F += 4 * Dy - 4 * Dx + 2 ;
						H += 4 * Dy - 4 * Dx + 2 ;
					}
				}
			}

			// 最後の点を描く
			x1 = Dx + x ; y1 = -Dy + y;
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

			x1 = -Dx + x ; y1 = Dy + y ;
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
		}
		else
		{
			// 初期値をセット
			rc = ( rymin * rymin ) / rxmin ;

			xc = 0 ; yc = 0 ;
			r = rxmin ;
			Df = 2 ;
	
			Dx = r ;
			Dy = 0;
			F = -2 * r + 1 + 2 * 1;
			H = -4 * r + 2 + 1;

			// 最初の点を描く
			{
				x1 = -Dx + x ; y1 = Dy + y ;
				DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
				x1 = Dx + x ;  
				DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

				Df = 0 ;

				// 座標データを進める
				if( F < 0 )
				{
					Df = 1 ;

					Dy ++ ;
					F += 4 * Dy + 2 ;
					H += 4 * Dy;
				}
				else
				{
					if( H>=0 )
					{
						xc += rxmin ;
						if( xc >= rc )
						{
							Dx--;
							xc -= rc ;
							Df = 1 ;
						}
						F -= 4 * Dx;
						H -= 4 * Dx - 2 ;
					}
					else
					{
						Df = 1 ;

						xc += rxmin ;
						if( xc >= rc )
						{
							Dx--;
							xc -= rc ;
						}

						Dy ++ ;
						F += 4 * Dy - 4 * Dx + 2 ;
						H += 4 * Dy - 4 * Dx + 2 ;
					}
				}
			}

			while( Dx > 0 )
			{
				if( Df )
				{
					x1 = -Dx + x ; y1 = Dy + y ;
					DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
					x1 = Dx + x ;  
					DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

					x1 = -Dx + x ; y1 = -Dy + y ;
					DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
					x1 = Dx + x ;  
					DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;
				}

				Df = 0 ;

				// 座標データを進める
				if( F < 0 )
				{
					Df = 1 ;

					Dy ++ ;
					F += 4 * Dy + 2 ;
					H += 4 * Dy;
				}
				else
				{
					if( H>=0 )
					{
						xc += rxmin ;
						if( xc >= rc )
						{
							Dx--;
							xc -= rc ;
							Df = 1 ;
						}
						F -= 4 * Dx;
						H -= 4 * Dx - 2 ;
					}
					else
					{
						Df = 1 ;

						xc += rxmin ;
						if( xc >= rc )
						{
							Dx--;
							xc -= rc ;
						}

						Dy ++ ;
						F += 4 * Dy - 4 * Dx + 2 ;
						H += 4 * Dy - 4 * Dx + 2 ;
					}
				}
			}

			// 最後の点を描く
			x1 = Dx + x ; y1 = -Dy + y;
			DX_CIRCLE_THICKNESS_R_MIN_RIGHT_CHECK ;

			x1 = -Dx + x ; y1 = Dy + y ;
			DX_CIRCLE_THICKNESS_R_MIN_LEFT_CHECK ;
		}
	}

	// 終了
	return 0 ;
}


#define CIRCLE_VERTEX_NUM			(2000)

#define DX_3D_CIRCLE_THICKNESS												\
	if( x1 < DrawRect.left      ) x1 = DrawRect.left ;						\
	if( x2 > DrawRect.right - 1 ) x2 = DrawRect.right - 1 ;					\
																			\
	VectBuf[ VectNum ].pos.x  = ( float )x1 ;								\
	VectBuf[ VectNum ].pos.y  = y1f ;										\
	VectBuf[ VectNum ].color = Color ;										\
	VectBuf[ VectNum ].rhw   = 1.0f ;										\
	*((DWORD *)&VectBuf[ VectNum ].pos.z) = drawz ;							\
	VectNum ++ ;															\
																			\
	VectBuf[ VectNum ].pos.x =  ( float )( x2 + 1 ) ;						\
	VectBuf[ VectNum ].pos.y =  y1f ;										\
	VectBuf[ VectNum ].color = Color ;										\
	VectBuf[ VectNum ].rhw   = 1.0f ;										\
	*((DWORD *)&VectBuf[ VectNum ].pos.z) = drawz ;							\
	VectNum  ++ ;															\
																			\
	if( VectNum >= CIRCLE_VERTEX_NUM )										\
	{																		\
		if( GRH.UseAlphaChDrawShader )										\
		{																	\
			for( j = 0 ; j < VectNum ; j ++ )								\
			{																\
				VectBuf[ j ].sc_u = ( VectBuf[ j ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;\
				VectBuf[ j ].sc_v = ( VectBuf[ j ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;\
			}																\
		}																	\
		GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINELIST, VectNum / 2, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;\
		VectNum = 0 ;														\
	}																		

// ハードウエアアクセラレータ使用版 DrawCircle( 太さ指定あり )
static int	DrawCircle_ThicknessHardware( int x, int y, int r, int Color, int Thickness )
{
	VERTEX_NOTEX_2D *VectBuf ;
	int VectNum ;
	short ( *CirclePos )[ 5 ] ;
	int Red, Green, Blue, Flag ;
	RECT DrawRect ;
	DWORD drawz ;
	int i ;
	int j ;
	int x1, x2 ;
	float y1f ;

	// 太さが２以下だったら何もせず終了
	if( Thickness < 2 )
	{
		return -1 ;
	}

	RenderVertexHardware() ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ; 

	// 描画用メモリの確保
	if( AllocCommonBuffer( 0, sizeof( VERTEX_NOTEX_2D ) * CIRCLE_VERTEX_NUM ) < 0 )
	{
		return -1 ;
	}
	VectBuf = ( VERTEX_NOTEX_2D * )GRH.CommonBuffer[ 0 ] ;

	// 描画の準備
	BeginScene() ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 補正
	DrawRect = GBASE.DrawArea ;

	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red )		/ 255 ) << 16 ) |
			( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
			( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue )	/ 255 ) | 
			(			GRH.DiffuseColor & 0xff000000 ) ;

	// FVF の変更
	SETFVF( VERTEXFVF_NOTEX_2D )

	// 円の座標を代入するバッファを取得
	if( AllocCommonBuffer( 1, sizeof( short ) * 5 * DrawRect.bottom ) < 0 )
	{
		return -1 ;
	}
	CirclePos = ( short (*)[ 5 ] )GRH.CommonBuffer[ 1 ] ;
	_MEMSET( CirclePos, 0, sizeof( short ) * 5 * DrawRect.bottom ) ;

	// 円の座標リスト作成
	GetCircle_ThicknessDrawPosition( x, y, r, Thickness, CirclePos ) ;

	// 描画処理
	VectNum = 0 ;
	for( i = DrawRect.top ; i < DrawRect.bottom ; i ++ )
	{
		if( CirclePos[ i ][ 4 ] == 0 )
		{
			continue ;
		}

		y1f = ( float )i ;

		if( ( CirclePos[ i ][ 4 ] & ( 4 | 8 ) ) == 0 || CirclePos[ i ][ 2 ] >= CirclePos[ i ][ 3 ] )
		{
			x1 = CirclePos[ i ][ 0 ] ;
			x2 = CirclePos[ i ][ 1 ] ;
			DX_3D_CIRCLE_THICKNESS
		}
		else
		{
			x1 = CirclePos[ i ][ 0 ] ;
			x2 = CirclePos[ i ][ 2 ] ;
			DX_3D_CIRCLE_THICKNESS

			x1 = CirclePos[ i ][ 3 ] ;
			x2 = CirclePos[ i ][ 1 ] ;
			DX_3D_CIRCLE_THICKNESS
		}
	}
	if( VectNum )
	{
		if( GRH.UseAlphaChDrawShader )
		{
			for( j = 0 ; j < VectNum ; j ++ )
			{
				VectBuf[ j ].sc_u = ( VectBuf[ j ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectBuf[ j ].sc_v = ( VectBuf[ j ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			}
		}

		GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINELIST, VectNum / 2, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawOval( 太さ指定あり )
static int	DrawOval_ThicknessHardware( int x, int y, int rx, int ry, int Color, int Thickness )
{
	VERTEX_NOTEX_2D *VectBuf ;
	int VectNum ;
	short ( *CirclePos )[ 5 ] ;
	int Red, Green, Blue, Flag ;
	RECT DrawRect ;
	DWORD drawz ;
	int i ;
	int j ;
	int x1, x2 ;
	float y1f ;

	// 太さが２以下だったら何もせず終了
	if( Thickness < 2 )
	{
		return -1 ;
	}

	RenderVertexHardware() ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ; 

	// 描画用メモリの確保
	if( AllocCommonBuffer( 0, sizeof( VERTEX_NOTEX_2D ) * CIRCLE_VERTEX_NUM ) < 0 )
	{
		return -1 ;
	}
	VectBuf = ( VERTEX_NOTEX_2D * )GRH.CommonBuffer[ 0 ] ;

	// 描画の準備
	BeginScene() ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 補正
	DrawRect = GBASE.DrawArea ;

	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red )		/ 255 ) << 16 ) |
			( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
			( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue )	/ 255 ) | 
			(			GRH.DiffuseColor & 0xff000000 ) ;

	// FVF の変更
	SETFVF( VERTEXFVF_NOTEX_2D )

	// 円の座標を代入するバッファを取得
	if( AllocCommonBuffer( 1, sizeof( short ) * 5 * DrawRect.bottom ) < 0 )
	{
		return -1 ;
	}
	CirclePos = ( short (*)[ 5 ] )GRH.CommonBuffer[ 1 ] ;
	_MEMSET( CirclePos, 0, sizeof( short ) * 5 * DrawRect.bottom ) ;

	// 楕円の座標リスト作成
	GetOval_ThicknessDrawPosition( x, y, rx, ry, Thickness, CirclePos ) ;

	// 描画処理
	VectNum = 0 ;
	for( i = DrawRect.top ; i < DrawRect.bottom ; i ++ )
	{
		if( CirclePos[ i ][ 4 ] == 0 )
		{
			continue ;
		}

		y1f = ( float )i ;

		if( ( CirclePos[ i ][ 4 ] & ( 4 | 8 ) ) == 0 || CirclePos[ i ][ 2 ] >= CirclePos[ i ][ 3 ] )
		{
			x1 = CirclePos[ i ][ 0 ] ;
			x2 = CirclePos[ i ][ 1 ] ;
			DX_3D_CIRCLE_THICKNESS
		}
		else
		{
			x1 = CirclePos[ i ][ 0 ] ;
			x2 = CirclePos[ i ][ 2 ] ;
			DX_3D_CIRCLE_THICKNESS

			x1 = CirclePos[ i ][ 3 ] ;
			x2 = CirclePos[ i ][ 1 ] ;
			DX_3D_CIRCLE_THICKNESS
		}
	}
	if( VectNum )
	{
		if( GRH.UseAlphaChDrawShader )
		{
			for( j = 0 ; j < VectNum ; j ++ )
			{
				VectBuf[ j ].sc_u = ( VectBuf[ j ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
				VectBuf[ j ].sc_v = ( VectBuf[ j ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			}
		}

		GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINELIST, VectNum / 2, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;
	}

	// 終了
	return 0 ;
}


#define DX_3D_CIRCLE																\
			if( !( ( x2 < DrawRect.left ) || ( x1 >= DrawRect.right  ) ||				\
			       ( y1 < DrawRect.top  ) || ( y1 >= DrawRect.bottom ) || LineDrawBuf[ y1 ] ) )			\
			{																			\
				if( x1 < DrawRect.left ) x1 = DrawRect.left ;							\
				if( x2 > DrawRect.right - 1 ) x2 = DrawRect.right - 1 ;					\
																						\
				VectBuf[ VectNum ].pos.x  = ( float )x1 ;								\
				VectBuf[ VectNum ].pos.y  = ( float )y1 ;								\
				VectBuf[ VectNum ].color = Color ;										\
				VectBuf[ VectNum ].rhw   = 1.0f ;										\
				*((DWORD *)&VectBuf[ VectNum ].pos.z) = drawz ;							\
				VectNum ++ ;															\
				LineDrawBuf[y1] = TRUE ;												\
																						\
				VectBuf[ VectNum ].pos.x =  ( float )( x2 + 1 );						\
				VectBuf[ VectNum ].pos.y =  ( float )y1 ;								\
				VectBuf[ VectNum ].color = Color ;										\
				VectBuf[ VectNum ].rhw   = 1.0f ;										\
				*((DWORD *)&VectBuf[ VectNum ].pos.z) = drawz ;							\
				VectNum  ++ ;															\
																						\
				if( VectNum >= CIRCLE_VERTEX_NUM )										\
				{																		\
					if( GRH.UseAlphaChDrawShader )										\
					{																	\
						for( i = 0 ; i < VectNum ; i ++ )								\
						{																\
							VectBuf[ i ].sc_u = ( VectBuf[ i ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;\
							VectBuf[ i ].sc_v = ( VectBuf[ i ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;\
						}																\
					}																	\
					GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINELIST, VectNum / 2, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;\
					VectNum = 0 ;														\
				}																		\
			}

#define DX_3D_CIRCLE_PSET															\
			if( !( ( ( unsigned int )( x1 ) >= ( unsigned int )( DrawRect.right ) ) ||	\
				( y1 < DrawRect.top ) || ( y1 >= DrawRect.bottom ) ) )					\
			{																			\
				VectBuf[ VectNum ].pos.x  = ( float )x1 ;								\
				VectBuf[ VectNum ].pos.y  = ( float )y1 ;								\
				VectBuf[ VectNum ].color = Color ;										\
				VectBuf[ VectNum ].rhw   = 1.0f ;										\
				*((DWORD *)&VectBuf[ VectNum ].pos.z) = drawz ;							\
				VectNum ++ ;															\
																						\
				if( VectNum >= CIRCLE_VERTEX_NUM )										\
				{																		\
					if( GRH.UseAlphaChDrawShader )										\
					{																	\
						for( i = 0 ; i < VectNum ; i ++ )								\
						{																\
							VectBuf[ i ].sc_u = ( VectBuf[ i ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;\
							VectBuf[ i ].sc_v = ( VectBuf[ i ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;\
						}																\
					}																	\
					GraphicsDevice_DrawPrimitiveUP( D_D3DPT_POINTLIST, VectNum, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;\
					VectNum = 0 ;														\
				}																		\
			}

// ハードウエアアクセラレータ使用版 DrawCircle
static int	DrawCircleHardware( int x, int y, int r, int Color, int FillFlag )
{
	VERTEX_NOTEX_2D *VectBuf ;
	int VectNum ;
	BYTE *LineDrawBuf ;
	int Red, Green, Blue, Flag ;
	RECT DrawRect ;
	DWORD drawz;

	RenderVertexHardware() ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ; 

	// 描画用メモリの確保
	if( AllocCommonBuffer( 0, sizeof( VERTEX_NOTEX_2D ) * CIRCLE_VERTEX_NUM ) < 0 )
	{
		return -1 ;
	}
	VectBuf = ( VERTEX_NOTEX_2D * )GRH.CommonBuffer[ 0 ] ;

	// 描画の準備
	BeginScene() ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 補正
	DrawRect = GBASE.DrawArea ;

	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red )		/ 255 ) << 16 ) |
			( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
			( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue )	/ 255 ) | 
			(			GRH.DiffuseColor & 0xff000000 ) ;

	// FVF の変更
	SETFVF( VERTEXFVF_NOTEX_2D )

	// 描画処理
	{
		int Dx, Dy, F, i, j ;
		int x1, x2, y1 ;

		// 初期値セット
		Dx = r ; Dy = 0 ; F = -2 * r + 3 ;
		VectNum = 0 ;

		j = 0 ;
		// 描画開始
		if( FillFlag )
		{
			if( AllocCommonBuffer( 1, DrawRect.bottom ) < 0 )
			{
				return DxLib_Error( DXSTRING( _T( "メモリの確保に失敗しました in G_D3D_DrawCircle" ) ) ) ;
			}
			LineDrawBuf = ( BYTE * )GRH.CommonBuffer[ 1 ] ;
			_MEMSET( LineDrawBuf, 0, DrawRect.bottom ) ;

			// 最初のラインを描く
			{
				x2 = Dx + x ; x1 = -Dx + x ; y1 = Dy + y ;
				DX_3D_CIRCLE ;

				// 座標データを進める
				if( F >= 0 )
				{
					x2 = Dy + x ; x1 = -Dy + x ; y1 = Dx + y ;
					DX_3D_CIRCLE ;
					x2 = Dy + x ; x1 = -Dy + x ; y1 = -Dx + y;
					DX_3D_CIRCLE ;

					Dx -- ;
					F -= 4 * Dx ;
				}	

				Dy ++ ;
				F += 4 * Dy + 2 ;
			}

			while( Dx >= Dy )
			{
				x2 = Dx + x ; x1 = -Dx + x ; y1 = Dy + y ;
				DX_3D_CIRCLE ;
				x2 = Dx + x ; x1 = -Dx + x ; y1 = -Dy + y;
				DX_3D_CIRCLE ;

				// 座標データを進める
				if( F >= 0 )
				{
					x2 = Dy + x ; x1 = -Dy + x ; y1 = Dx + y ;
					DX_3D_CIRCLE ;
					x2 = Dy + x ; x1 = -Dy + x ; y1 = -Dx + y;
					DX_3D_CIRCLE ;

					Dx -- ;
					F -= 4 * Dx ;
				}

				Dy ++ ;
				F += 4 * Dy + 2 ;
			}
			if( VectNum )
			{
				if( GRH.UseAlphaChDrawShader )
				{
					for( i = 0 ; i < VectNum ; i ++ )
					{
						VectBuf[ i ].sc_u = ( VectBuf[ i ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						VectBuf[ i ].sc_v = ( VectBuf[ i ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					}
				}

				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINELIST, VectNum / 2, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;
			}
		}
		else
		{
			// 最初の点を描く
			{
				x1 = -Dx + x ; y1 = Dy + y ;
				DX_3D_CIRCLE_PSET ;
				x1 = Dx + x ;  
				DX_3D_CIRCLE_PSET ;

				x1 = Dy + x ; y1 = Dx + y ;
				DX_3D_CIRCLE_PSET ;

				x1 = Dy + x ; y1 = -Dx + y;
				DX_3D_CIRCLE_PSET ;

				// 座標データを進める
				if( F >= 0 )
				{
					Dx -- ;
					F -= 4 * Dx ;
				}	

				Dy ++ ;
				F += 4 * Dy + 2 ;
			}

			while( Dx >= Dy )
			{
				x1 = -Dx + x ; y1 = Dy + y ;
				DX_3D_CIRCLE_PSET ;
				x1 = Dx + x ;  
				DX_3D_CIRCLE_PSET ;

				x1 = Dy + x ; y1 = Dx + y ;
				DX_3D_CIRCLE_PSET ;
				x1 = -Dy + x ; 
				DX_3D_CIRCLE_PSET ;
			
				x1 = Dx + x ; y1 = -Dy + y;
				DX_3D_CIRCLE_PSET ;
				x1 = -Dx + x ; 
				DX_3D_CIRCLE_PSET ;

				x1 = Dy + x ; y1 = -Dx + y;
				DX_3D_CIRCLE_PSET ;
				x1 = -Dy + x ; 
				DX_3D_CIRCLE_PSET ;

				// 座標データを進める
				if( F >= 0 )
				{
					Dx -- ;
					F -= 4 * Dx ;
				}

				Dy ++ ;
				F += 4 * Dy + 2 ;
			}
			if( VectNum )
			{
				if( GRH.UseAlphaChDrawShader )
				{
					for( i = 0 ; i < VectNum ; i ++ )
					{
						VectBuf[ i ].sc_u = ( VectBuf[ i ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						VectBuf[ i ].sc_v = ( VectBuf[ i ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					}
				}

				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_POINTLIST, VectNum, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;
			}
		}
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawOval
static int	DrawOvalHardware( int x, int y, int rx, int ry, int Color, int FillFlag )
{
	VERTEX_NOTEX_2D *VectBuf ;
	int VectNum ;
	BYTE *LineDrawBuf ;
//	VERTEX_NOTEX_2D *VectData ;
//	int i, j, r2 ;
//	float xd, x2, y2 ;
//	float d, yd ;
	int Red, Green, Blue, Flag ;
	RECT DrawRect ;
	DWORD drawz;

	RenderVertexHardware() ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ; 
	if( !rx || !ry ) return -1 ;

	// 描画用メモリの確保
	if( AllocCommonBuffer( 0, sizeof( VERTEX_NOTEX_2D ) * CIRCLE_VERTEX_NUM ) < 0 )
	{
		return -1 ;
	}
	VectBuf = ( VERTEX_NOTEX_2D * )GRH.CommonBuffer[ 0 ] ;

	// 描画の準備
	BeginScene() ;
	SetTextureHardware( NULL ) ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// 補正
	if( rx < 0 ) rx *= -1 ;
	if( ry < 0 ) ry *= -1 ;
	DrawRect = GBASE.DrawArea ;

	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red )		/ 255 ) << 16 ) |
			( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
			( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue )	/ 255 ) | 
			(			GRH.DiffuseColor & 0xff000000 ) ;

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// FVF の変更
	SETFVF( VERTEXFVF_NOTEX_2D )

	VectNum = 0 ;

	// 描画処理
	{
		int Dx, Dy, F, H, j, i ;
		int x1, x2, y1, Df ;
		int yc, xc, rc, r ;

		j = 0 ;
		// 描画開始
		if( FillFlag )
		{
			if( AllocCommonBuffer( 1, DrawRect.bottom ) < 0 )
			{
				return DxLib_Error( DXSTRING( _T( "メモリの確保に失敗しました in G_D3D_DrawCircle" ) ) ) ;
			}
			LineDrawBuf = ( BYTE * )GRH.CommonBuffer[ 1 ] ;
			_MEMSET( LineDrawBuf, 0, DrawRect.bottom ) ;

			if( rx >= ry )
			{
				// 初期値をセット
				rc = ( rx * rx ) / ry ;

				xc = 0 ; yc = 0 ;
				r = rx ;
				Df = 1 ;
		
				Dx = r ;
				Dy = 0;
				F = -2 * r + 1 + 2 * 1;
				H = -4 * r + 2 + 1;

				// 最初の線を描く
				{
					x1 = -Dx + x ; x2 = Dx + x ; y1 = Dy + y ;
					DX_3D_CIRCLE ;

					Df = 0 ;

					// 座標データを進める
					if( F < 0 )
					{
						yc += ry ;
						if( yc >= rc )
						{
							Dy ++ ;
							yc -= rc ;
							Df = 1 ;
						}
						F += 4 * Dy + 2 ;
						H += 4 * Dy;
					}
					else
					{
						Df = 1 ;

						if( H>=0 )
						{
							Dx--;
							F -= 4 * Dx;
							H -= 4 * Dx - 2 ;
						}
						else
						{
							Dx--;	
							yc += ry ;
							if( yc >= rc )
							{
								Dy ++ ;
								yc -= rc ;
								Df = 1 ;
							}
							F += 4 * Dy - 4 * Dx + 2 ;
							H += 4 * Dy - 4 * Dx + 2 ;
						}
					}
				}

				while( Dx > 0 )
				{
					if( Df )
					{
						x1 = -Dx + x ; x2 = Dx + x ; y1 = Dy + y ;
						DX_3D_CIRCLE ;

						y1 = -Dy + y ;
						DX_3D_CIRCLE ;
					}

					Df = 0 ;

					// 座標データを進める
					if( F < 0 )
					{
						yc += ry ;
						if( yc >= rc )
						{
							Dy ++ ;
							yc -= rc ;
							Df = 1 ;
						}
						F += 4 * Dy + 2 ;
						H += 4 * Dy;
					}
					else
					{
						if( H>=0 )
						{
							Dx--;
							F -= 4 * Dx;
							H -= 4 * Dx - 2 ;
						}
						else
						{
							Dx--;	
							yc += ry ;
							if( yc >= rc )
							{
								Dy ++ ;
								yc -= rc ;
								Df = 1 ;
							}
							F += 4 * Dy - 4 * Dx + 2 ;
							H += 4 * Dy - 4 * Dx + 2 ;
						}
					}
				}

				// 最後の線を描く
				x1 = -Dx + x ; x2 = Dx + x ; y1 = -Dy + y;
				DX_3D_CIRCLE ;
			}
			else
			{
				// 初期値をセット
				rc = ( ry * ry ) / rx ;

				xc = 0 ; yc = 0 ;
				r = rx ;
				Df = 2 ;
		
				Dx = r ;
				Dy = 0;
				F = -2 * r + 1 + 2 * 1;
				H = -4 * r + 2 + 1;

				// 最初の線を描く
				{
					x1 = -Dx + x ; x2 = Dx + x ; y1 = Dy + y ;
					DX_3D_CIRCLE ;

					Df = 0 ;

					// 座標データを進める
					if( F < 0 )
					{
						Df = 1 ;

						Dy ++ ;
						F += 4 * Dy + 2 ;
						H += 4 * Dy;
					}
					else
					{
						if( H>=0 )
						{
							xc += rx ;
							if( xc >= rc )
							{
								Dx--;
								xc -= rc ;
							}
							F -= 4 * Dx;
							H -= 4 * Dx - 2 ;
						}
						else
						{
							Df = 1 ;

							xc += rx ;
							if( xc >= rc )
							{
								Dx--;
								xc -= rc ;
							}

							Dy ++ ;
							F += 4 * Dy - 4 * Dx + 2 ;
							H += 4 * Dy - 4 * Dx + 2 ;
						}
					}
				}

				while( Dx > 0 )
				{
					if( Df )
					{
						x1 = -Dx + x ; x2 = Dx + x ; y1 = Dy + y ;
						DX_3D_CIRCLE ;

						y1 = -Dy + y ;
						DX_3D_CIRCLE ;
					}

					Df = 0 ;

					// 座標データを進める
					if( F < 0 )
					{
						Df = 1 ;

						Dy ++ ;
						F += 4 * Dy + 2 ;
						H += 4 * Dy;
					}
					else
					{
						if( H>=0 )
						{
							xc += rx ;
							if( xc >= rc )
							{
								Dx--;
								xc -= rc ;
							}
							F -= 4 * Dx;
							H -= 4 * Dx - 2 ;
						}
						else
						{
							Df = 1 ;

							xc += rx ;
							if( xc >= rc )
							{
								Dx--;
								xc -= rc ;
							}

							Dy ++ ;
							F += 4 * Dy - 4 * Dx + 2 ;
							H += 4 * Dy - 4 * Dx + 2 ;
						}
					}
				}

				// 最後の線を描く
				x1 = -Dx + x ; x2 = Dx + x ; y1 = -Dy + y;
				DX_3D_CIRCLE ;
			}
			if( VectNum )
			{
				if( GRH.UseAlphaChDrawShader )
				{
					for( i = 0 ; i < VectNum ; i ++ )
					{
						VectBuf[ i ].sc_u = ( VectBuf[ i ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						VectBuf[ i ].sc_v = ( VectBuf[ i ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					}
				}
				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINELIST, VectNum / 2, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;
			}
		}
		else
		{
			if( rx >= ry )
			{
				// 初期値をセット
				rc = ( rx * rx ) / ry ;

				xc = 0 ; yc = 0 ;
				r = rx ;
				Df = 2 ;
		
				Dx = r ;
				Dy = 0;
				F = -2 * r + 1 + 2 * 1;
				H = -4 * r + 2 + 1;

				// 最初の点を描く
				{
					x1 = -Dx + x ; y1 = Dy + y ;
					DX_3D_CIRCLE_PSET ;
					x1 = Dx + x ;  
					DX_3D_CIRCLE_PSET ;

					Df = 0 ;

					// 座標データを進める
					if( F < 0 )
					{
						yc += ry ;
						if( yc >= rc )
						{
							Dy ++ ;
							yc -= rc ;
							Df = 1 ;
						}
						F += 4 * Dy + 2 ;
						H += 4 * Dy;
					}
					else
					{
						Df = 1 ;

						if( H>=0 )
						{
							Dx--;
							F -= 4 * Dx;
							H -= 4 * Dx - 2 ;
						}
						else
						{
							Dx--;	
							yc += ry ;
							if( yc >= rc )
							{
								Dy ++ ;
								yc -= rc ;
								Df = 1 ;
							}
							F += 4 * Dy - 4 * Dx + 2 ;
							H += 4 * Dy - 4 * Dx + 2 ;
						}
					}
				}

				while( Dx > 0 )
				{
					if( Df )
					{
						x1 = -Dx + x ; y1 = Dy + y ;
						DX_3D_CIRCLE_PSET ;
						x1 = Dx + x ;  
						DX_3D_CIRCLE_PSET ;

						x1 = -Dx + x ; y1 = -Dy + y ;
						DX_3D_CIRCLE_PSET ;
						x1 = Dx + x ;  
						DX_3D_CIRCLE_PSET ;
					}

					Df = 0 ;

					// 座標データを進める
					if( F < 0 )
					{
						yc += ry ;
						if( yc >= rc )
						{
							Dy ++ ;
							yc -= rc ;
							Df = 1 ;
						}
						F += 4 * Dy + 2 ;
						H += 4 * Dy;
					}
					else
					{
						Df = 1 ;

						if( H>=0 )
						{
							Dx--;
							F -= 4 * Dx;
							H -= 4 * Dx - 2 ;
						}
						else
						{
							Dx--;	
							yc += ry ;
							if( yc >= rc )
							{
								Dy ++ ;
								yc -= rc ;
								Df = 1 ;
							}
							F += 4 * Dy - 4 * Dx + 2 ;
							H += 4 * Dy - 4 * Dx + 2 ;
						}
					}
				}

				// 最後の点を描く
				x1 = Dx + x ; y1 = -Dy + y;
				DX_3D_CIRCLE_PSET ;

				x1 = -Dx + x ; y1 = Dy + y ;
				DX_3D_CIRCLE_PSET ;
			}
			else
			{
				// 初期値をセット
				rc = ( ry * ry ) / rx ;

				xc = 0 ; yc = 0 ;
				r = rx ;
				Df = 2 ;
		
				Dx = r ;
				Dy = 0;
				F = -2 * r + 1 + 2 * 1;
				H = -4 * r + 2 + 1;

				// 最初の点を描く
				{
					x1 = -Dx + x ; y1 = Dy + y ;
					DX_3D_CIRCLE_PSET ;
					x1 = Dx + x ;  
					DX_3D_CIRCLE_PSET ;

					Df = 0 ;

					// 座標データを進める
					if( F < 0 )
					{
						Df = 1 ;

						Dy ++ ;
						F += 4 * Dy + 2 ;
						H += 4 * Dy;
					}
					else
					{
						if( H>=0 )
						{
							xc += rx ;
							if( xc >= rc )
							{
								Dx--;
								xc -= rc ;
								Df = 1 ;
							}
							F -= 4 * Dx;
							H -= 4 * Dx - 2 ;
						}
						else
						{
							Df = 1 ;

							xc += rx ;
							if( xc >= rc )
							{
								Dx--;
								xc -= rc ;
							}

							Dy ++ ;
							F += 4 * Dy - 4 * Dx + 2 ;
							H += 4 * Dy - 4 * Dx + 2 ;
						}
					}
				}

				while( Dx > 0 )
				{
					if( Df )
					{
						x1 = -Dx + x ; y1 = Dy + y ;
						DX_3D_CIRCLE_PSET ;
						x1 = Dx + x ;  
						DX_3D_CIRCLE_PSET ;

						x1 = -Dx + x ; y1 = -Dy + y ;
						DX_3D_CIRCLE_PSET ;
						x1 = Dx + x ;  
						DX_3D_CIRCLE_PSET ;
					}

					Df = 0 ;

					// 座標データを進める
					if( F < 0 )
					{
						Df = 1 ;

						Dy ++ ;
						F += 4 * Dy + 2 ;
						H += 4 * Dy;
					}
					else
					{
						if( H>=0 )
						{
							xc += rx ;
							if( xc >= rc )
							{
								Dx--;
								xc -= rc ;
								Df = 1 ;
							}
							F -= 4 * Dx;
							H -= 4 * Dx - 2 ;
						}
						else
						{
							Df = 1 ;

							xc += rx ;
							if( xc >= rc )
							{
								Dx--;
								xc -= rc ;
							}

							Dy ++ ;
							F += 4 * Dy - 4 * Dx + 2 ;
							H += 4 * Dy - 4 * Dx + 2 ;
						}
					}
				}

				// 最後の点を描く
				x1 = Dx + x ; y1 = -Dy + y;
				DX_3D_CIRCLE_PSET ;

				x1 = -Dx + x ; y1 = Dy + y ;
				DX_3D_CIRCLE_PSET ;
			}
			if( VectNum )
			{
				if( GRH.UseAlphaChDrawShader )
				{
					for( i = 0 ; i < VectNum ; i ++ )
					{
						VectBuf[ i ].sc_u = ( VectBuf[ i ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
						VectBuf[ i ].sc_v = ( VectBuf[ i ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					}
				}
				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_POINTLIST, VectNum, VectBuf, sizeof( VERTEX_NOTEX_2D ) ) ;
			}
		}
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawTriangle3D
static int	DrawTriangle3DHardware( VECTOR Pos1, VECTOR Pos2, VECTOR Pos3, int Color, int FillFlag, int DrawFlag, RECT *DrawArea )
{
	VERTEX_NOTEX_3D *vec ; 
	int Red, Green, Blue ;
	int Flag ;

	if( DrawFlag )
	{
		if( GraphicsDevice_IsValid() == 0 ) return -1 ;

		// 描画の準備
		if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
		if( GRH.RenderTexture != NULL ) SetTextureHardware( NULL ) ;

		Flag = DRAWPREP_DIFFUSERGB | DRAWPREP_3D | DRAWPREP_FOG | DRAWPREP_CULLING ;
		DRAWPREP_NOTEX( Flag )

		// 色その他ステータスのセット
		NS_GetColor2( Color, &Red, &Green, &Blue ) ;
		Color = ( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red )		/ 255 ) << 16 ) |
				( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
				( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue )	/ 255 ) | 
				(			GRH.DiffuseColor & 0xff000000 ) ;

		// ラインかどうかで処理を分岐
		if( FillFlag )
		{
			GETVERTEX_TRIANGLE3D( vec ) ;

			*( ( DWORD * )&vec[ 0 ].b ) =
			*( ( DWORD * )&vec[ 1 ].b ) =
			*( ( DWORD * )&vec[ 2 ].b ) = ( DWORD )Color ;
			vec[ 0 ].pos = Pos1 ;
			vec[ 1 ].pos = Pos2 ;
			vec[ 2 ].pos = Pos3 ;

			ADD3VERTEX_NOTEX3D
		}
		else
		{
			GETVERTEX_LINETRIANGLE3D( vec )

			*( ( DWORD * )&vec[ 0 ].b ) =
			*( ( DWORD * )&vec[ 1 ].b ) =
			*( ( DWORD * )&vec[ 2 ].b ) =
			*( ( DWORD * )&vec[ 3 ].b ) =
			*( ( DWORD * )&vec[ 4 ].b ) =
			*( ( DWORD * )&vec[ 5 ].b ) = ( DWORD )Color ;

			vec[ 0 ].pos = Pos1 ;
			vec[ 1 ].pos = Pos2 ;
			vec[ 2 ].pos = Pos2 ;
			vec[ 3 ].pos = Pos3 ;
			vec[ 4 ].pos = Pos3 ;
			vec[ 5 ].pos = Pos1 ;

			ADD4VERTEX_LINETRIANGLE3D
		}
	}
	else
	{
		VERTEX_2D TempVect[ 3 ] ;
		float dleft, dright, dtop, dbottom ;

		dleft   =  100000000.0f ;
		dright  = -100000000.0f ;
		dtop    =  100000000.0f ;
		dbottom = -100000000.0f ;

		// スクリーン座標に変換
		TempVect[0].pos.x = Pos1.x * GBASE.BlendMatrix.m[0][0] + Pos1.y * GBASE.BlendMatrix.m[1][0] + Pos1.z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
		TempVect[0].pos.y = Pos1.x * GBASE.BlendMatrix.m[0][1] + Pos1.y * GBASE.BlendMatrix.m[1][1] + Pos1.z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
		TempVect[0].pos.z = Pos1.x * GBASE.BlendMatrix.m[0][2] + Pos1.y * GBASE.BlendMatrix.m[1][2] + Pos1.z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
		TempVect[0].rhw   = Pos1.x * GBASE.BlendMatrix.m[0][3] + Pos1.y * GBASE.BlendMatrix.m[1][3] + Pos1.z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

		TempVect[1].pos.x = Pos2.x * GBASE.BlendMatrix.m[0][0] + Pos2.y * GBASE.BlendMatrix.m[1][0] + Pos2.z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
		TempVect[1].pos.y = Pos2.x * GBASE.BlendMatrix.m[0][1] + Pos2.y * GBASE.BlendMatrix.m[1][1] + Pos2.z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
		TempVect[1].pos.z = Pos2.x * GBASE.BlendMatrix.m[0][2] + Pos2.y * GBASE.BlendMatrix.m[1][2] + Pos2.z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
		TempVect[1].rhw   = Pos2.x * GBASE.BlendMatrix.m[0][3] + Pos2.y * GBASE.BlendMatrix.m[1][3] + Pos2.z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

		TempVect[2].pos.x = Pos3.x * GBASE.BlendMatrix.m[0][0] + Pos3.y * GBASE.BlendMatrix.m[1][0] + Pos3.z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
		TempVect[2].pos.y = Pos3.x * GBASE.BlendMatrix.m[0][1] + Pos3.y * GBASE.BlendMatrix.m[1][1] + Pos3.z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
		TempVect[2].pos.z = Pos3.x * GBASE.BlendMatrix.m[0][2] + Pos3.y * GBASE.BlendMatrix.m[1][2] + Pos3.z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
		TempVect[2].rhw   = Pos3.x * GBASE.BlendMatrix.m[0][3] + Pos3.y * GBASE.BlendMatrix.m[1][3] + Pos3.z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

		TempVect[0].rhw = 1.0F / TempVect[0].rhw ;
		TempVect[0].pos.x *= TempVect[0].rhw ;
		TempVect[0].pos.y *= TempVect[0].rhw ;
		TempVect[0].pos.z *= TempVect[0].rhw ;

		TempVect[1].rhw = 1.0F / TempVect[1].rhw ;
		TempVect[1].pos.x *= TempVect[1].rhw ;
		TempVect[1].pos.y *= TempVect[1].rhw ;
		TempVect[1].pos.z *= TempVect[1].rhw ;

		TempVect[2].rhw = 1.0F / TempVect[2].rhw ;
		TempVect[2].pos.x *= TempVect[2].rhw ;
		TempVect[2].pos.y *= TempVect[2].rhw ;
		TempVect[2].pos.z *= TempVect[2].rhw ;

		if( dright  < TempVect[ 0 ].pos.x ) dright  = TempVect[ 0 ].pos.x ;
		if( dright  < TempVect[ 1 ].pos.x ) dright  = TempVect[ 1 ].pos.x ;
		if( dright  < TempVect[ 2 ].pos.x ) dright  = TempVect[ 2 ].pos.x ;

		if( dleft   > TempVect[ 0 ].pos.x ) dleft   = TempVect[ 0 ].pos.x ;
		if( dleft   > TempVect[ 1 ].pos.x ) dleft   = TempVect[ 1 ].pos.x ;
		if( dleft   > TempVect[ 2 ].pos.x ) dleft   = TempVect[ 2 ].pos.x ;

		if( dbottom < TempVect[ 0 ].pos.y ) dbottom = TempVect[ 0 ].pos.y ;
		if( dbottom < TempVect[ 1 ].pos.y ) dbottom = TempVect[ 1 ].pos.y ;
		if( dbottom < TempVect[ 2 ].pos.y ) dbottom = TempVect[ 2 ].pos.y ;

		if( dtop    > TempVect[ 0 ].pos.y ) dtop    = TempVect[ 0 ].pos.y ;
		if( dtop    > TempVect[ 1 ].pos.y ) dtop    = TempVect[ 1 ].pos.y ;
		if( dtop    > TempVect[ 2 ].pos.y ) dtop    = TempVect[ 2 ].pos.y ;

		DrawArea->left   = _FTOL( dleft   ) - 1 ;
		DrawArea->right  = _FTOL( dright  ) + 1 ;
		DrawArea->top    = _FTOL( dtop    ) - 1 ;
		DrawArea->bottom = _FTOL( dbottom ) + 1 ;
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawTriangle
static int	DrawTriangleHardware( int x1, int y1, int x2, int y2, int x3, int y3, int Color, int FillFlag )
{
	VERTEX_NOTEX_2D *vec ; 
	int Red, Green, Blue ;
	int Flag ;
	int sx1, sx2, sy1, sy2 ;
	DWORD drawz;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	BeginScene() ;
	SetTextureHardware( NULL ) ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 色その他ステータスのセット
	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red )		/ 255 ) << 16 ) |
			( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
			( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue )	/ 255 ) | 
			(			GRH.DiffuseColor & 0xff000000 ) ;

	// ラインかどうかで処理を分岐
	if( FillFlag )
	{
		GETVERTEX_TRIANGLE( vec ) ;

		vec[ 0 ].color = Color ;

		vec[ 0 ].pos.x = ( float )x1 ; vec[ 0 ].pos.y = ( float )y1 ;

		// カリングが有効になっている場合はカリングされないようにする
		switch( GBASE.CullMode )
		{
		case 0 :	// カリングなし
			vec[ 1 ].pos.x = ( float )x2 ; vec[ 1 ].pos.y = ( float )y2 ;
			vec[ 2 ].pos.x = ( float )x3 ; vec[ 2 ].pos.y = ( float )y3 ;
			break ;

		case 1 :	// 左回りカリング
			sx1 = x2 - x1 ;		sy1 = y2 - y1 ;
			sx2 = x3 - x1 ;		sy2 = y3 - y1 ;
			if( sx1 * sy2 - sy1 * sx2 > 0 )
			{
				vec[ 1 ].pos.x = ( float )x2 ; vec[ 1 ].pos.y = ( float )y2 ;
				vec[ 2 ].pos.x = ( float )x3 ; vec[ 2 ].pos.y = ( float )y3 ;
			}
			else
			{
				vec[ 1 ].pos.x = ( float )x3 ; vec[ 1 ].pos.y = ( float )y3 ;
				vec[ 2 ].pos.x = ( float )x2 ; vec[ 2 ].pos.y = ( float )y2 ;
			}
			break ;

		case 2 :	// 右回りカリング
			sx1 = x2 - x1 ;		sy1 = y2 - y1 ;
			sx2 = x3 - x1 ;		sy2 = y3 - y1 ;
			if( sx1 * sy2 - sy1 * sx2 < 0 )
			{
				vec[ 1 ].pos.x = ( float )x2 ; vec[ 1 ].pos.y = ( float )y2 ;
				vec[ 2 ].pos.x = ( float )x3 ; vec[ 2 ].pos.y = ( float )y3 ;
			}
			else
			{
				vec[ 1 ].pos.x = ( float )x3 ; vec[ 1 ].pos.y = ( float )y3 ;
				vec[ 2 ].pos.x = ( float )x2 ; vec[ 2 ].pos.y = ( float )y2 ;
			}
			break ;
		}

		*( ( DWORD * )&vec[ 0 ].pos.z ) =
		*( ( DWORD * )&vec[ 1 ].pos.z ) =
		*( ( DWORD * )&vec[ 2 ].pos.z ) = drawz ;

		if( GRH.UseAlphaChDrawShader )
		{
			vec[ 0 ].sc_u = ( vec[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 0 ].sc_v = ( vec[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			vec[ 1 ].sc_u = ( vec[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 1 ].sc_v = ( vec[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			vec[ 2 ].sc_u = ( vec[ 2 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 2 ].sc_v = ( vec[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		}

		ADD3VERTEX_NOTEX
	}
	else
	{
		GETVERTEX_LINETRIANGLE( vec )

		vec[ 0 ].color =
		vec[ 1 ].color =
		vec[ 2 ].color =
		vec[ 3 ].color =
		vec[ 4 ].color =
		vec[ 5 ].color = Color ;

		vec[ 0 ].pos.x = ( float )x1 ; vec[ 0 ].pos.y = ( float )y1 ;
		vec[ 1 ].pos.x = ( float )x2 ; vec[ 1 ].pos.y = ( float )y2 ;
		vec[ 2 ].pos.x = ( float )x2 ; vec[ 2 ].pos.y = ( float )y2 ;
		vec[ 3 ].pos.x = ( float )x3 ; vec[ 3 ].pos.y = ( float )y3 ;
		vec[ 4 ].pos.x = ( float )x3 ; vec[ 4 ].pos.y = ( float )y3 ;
		vec[ 5 ].pos.x = ( float )x1 ; vec[ 5 ].pos.y = ( float )y1 ;
		*( ( DWORD * )&vec[ 0 ].pos.z ) =
		*( ( DWORD * )&vec[ 1 ].pos.z ) =
		*( ( DWORD * )&vec[ 2 ].pos.z ) =
		*( ( DWORD * )&vec[ 3 ].pos.z ) =
		*( ( DWORD * )&vec[ 4 ].pos.z ) =
		*( ( DWORD * )&vec[ 5 ].pos.z ) = drawz ;

		if( GRH.UseAlphaChDrawShader )
		{
			vec[ 0 ].sc_u = ( vec[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 0 ].sc_v = ( vec[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			vec[ 1 ].sc_u = ( vec[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 1 ].sc_v = ( vec[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			vec[ 2 ].sc_u = ( vec[ 2 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 2 ].sc_v = ( vec[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			vec[ 3 ].sc_u = ( vec[ 3 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 3 ].sc_v = ( vec[ 3 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			vec[ 4 ].sc_u = ( vec[ 4 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 4 ].sc_v = ( vec[ 4 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			vec[ 5 ].sc_u = ( vec[ 5 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			vec[ 5 ].sc_v = ( vec[ 5 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		}

		ADD4VERTEX_LINETRIANGLE
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawQuadrangle
static int DrawQuadrangleHardware( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int Color, int FillFlag )
{
	VERTEX_NOTEX_2D VectData[ 5 ], *Vect ; 
	int Red, Green, Blue ;
	int i, Flag ;
	DWORD drawz;

	RenderVertexHardware() ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	// 描画の準備
	BeginScene() ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// 色その他ステータスのセット
	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	Color = ( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red )		/ 255 ) << 16 ) |
			( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8 ) |
			( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue )	/ 255 ) | 
			(			GRH.DiffuseColor & 0xff000000 ) ;
	Vect = VectData ;
	for( i = 0 ; i < 5 ; i ++, Vect ++ )
	{
		Vect->color = Color ;
		Vect->rhw   = 1.0f ;
		*((DWORD *)&Vect->pos.z) = drawz ;
	}

	// FVF のセット
	SETFVF( VERTEXFVF_NOTEX_2D )

	// 塗りつぶしかどうかで処理を分岐
	if( FillFlag )
	{
		// 塗りつぶしの場合
		VectData[ 0 ].pos.x = ( float )x1 ; VectData[ 0 ].pos.y = ( float )y1 ;
		VectData[ 1 ].pos.x = ( float )x2 ; VectData[ 1 ].pos.y = ( float )y2 ;
		VectData[ 2 ].pos.x = ( float )x4 ; VectData[ 2 ].pos.y = ( float )y4 ;
		VectData[ 3 ].pos.x = ( float )x3 ; VectData[ 3 ].pos.y = ( float )y3 ;

		if( GRH.UseAlphaChDrawShader )
		{
			VectData[ 0 ].sc_u = ( VectData[ 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			VectData[ 0 ].sc_v = ( VectData[ 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			VectData[ 1 ].sc_u = ( VectData[ 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			VectData[ 1 ].sc_v = ( VectData[ 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			VectData[ 2 ].sc_u = ( VectData[ 2 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			VectData[ 2 ].sc_v = ( VectData[ 2 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
			VectData[ 3 ].sc_u = ( VectData[ 3 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
			VectData[ 3 ].sc_v = ( VectData[ 3 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
		}

		// 反転処理判定
		{
			double Reverse0, Reverse1 ;
			VERTEX_NOTEX_2D VectTemp ;

			Reverse0 =  ( VectData[ 1 ].pos.x - VectData[ 0 ].pos.x ) * ( VectData[ 2 ].pos.y - VectData[ 0 ].pos.y ) -
					    ( VectData[ 2 ].pos.x - VectData[ 0 ].pos.x ) * ( VectData[ 1 ].pos.y - VectData[ 0 ].pos.y ) ;
			Reverse1 = -( VectData[ 1 ].pos.x - VectData[ 3 ].pos.x ) * ( VectData[ 2 ].pos.y - VectData[ 3 ].pos.y ) +
						( VectData[ 1 ].pos.y - VectData[ 3 ].pos.y ) * ( VectData[ 2 ].pos.x - VectData[ 3 ].pos.x ) ;
			if( Reverse0 <= 0 && Reverse1 <= 0 )
			{
				VectTemp = VectData[ 1 ] ; VectData[ 1 ] = VectData[ 2 ] ; VectData[ 2 ] = VectTemp ;
			}

			if( Reverse0 * Reverse1 >= 0 )
			{
				// プリミティブの描画
				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_TRIANGLESTRIP, 2, VectData, sizeof( VERTEX_NOTEX_2D ) ) ;
			}
			else
			{
				// Ｘ方向反転時の補正
				if( Reverse0 < 0 ) 
				{
					VectTemp = VectData[ 1 ] ; VectData[ 1 ] = VectData[ 2 ] ; VectData[ 2 ] = VectTemp ;
				}

				// プリミティブの描画
				GraphicsDevice_DrawPrimitiveUP( D_D3DPT_TRIANGLESTRIP, 2, VectData, sizeof( VERTEX_NOTEX_2D ) ) ;
			}
		}
	}
	else
	{
		// 塗りつぶしでは無い場合
		VectData[ 0 ].pos.x = ( float )x1 ; VectData[ 0 ].pos.y = ( float )y1 ;
		VectData[ 1 ].pos.x = ( float )x2 ; VectData[ 1 ].pos.y = ( float )y2 ;
		VectData[ 2 ].pos.x = ( float )x3 ; VectData[ 2 ].pos.y = ( float )y3 ;
		VectData[ 3 ].pos.x = ( float )x4 ; VectData[ 3 ].pos.y = ( float )y4 ;
		VectData[ 4 ].pos.x = ( float )x1 ; VectData[ 4 ].pos.y = ( float )y1 ;

		// プリミティブの描画
		GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINESTRIP, 4, VectData, sizeof( VERTEX_NOTEX_2D ) ) ;
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawPixel3D
static int DrawPixel3DHardware( VECTOR Pos, int Color, int DrawFlag, RECT *DrawArea )
{
	VERTEX_NOTEX_3D *VectData ; 
	int Red, Green, Blue ;
	int Flag ;

	if( DrawFlag )
	{
		if( GraphicsDevice_IsValid() == 0 ) return -1 ;

		// 描画の準備
		if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
		if( GRH.RenderTexture != NULL ) SetTextureHardware( NULL ) ;

		Flag = DRAWPREP_DIFFUSERGB | DRAWPREP_3D | DRAWPREP_FOG ;
		DRAWPREP_NOTEX( Flag )

		// 色その他ステータスのセット
		GETVERTEX_POINT3D( VectData ) ;

		NS_GetColor2( Color, &Red, &Green, &Blue ) ;
		if( GRH.DiffuseColor == 0xffffffff )
		{
			*( ( DWORD * )&VectData->b ) = ( DWORD )( 0xff000000 | ( Red << 16 ) | ( Green << 8 ) | Blue ) ;
		}
		else
		{
			*( ( DWORD * )&VectData->b ) =	( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red   )	/ 255 ) << 16 ) |
											( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8  ) |
											( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue  )	/ 255 ) | 
											(			GRH.DiffuseColor & 0xff000000 ) ;
		}

		// 座標のセット
		VectData->pos = Pos ;

		// 頂点の追加
		ADD4VERTEX_POINT3D
	}
	else
	{
		VERTEX_2D TempVect ;

		// スクリーン座標に変換
		TempVect.pos.x = Pos.x * GBASE.BlendMatrix.m[0][0] + Pos.y * GBASE.BlendMatrix.m[1][0] + Pos.z * GBASE.BlendMatrix.m[2][0] + GBASE.BlendMatrix.m[3][0]  ;
		TempVect.pos.y = Pos.x * GBASE.BlendMatrix.m[0][1] + Pos.y * GBASE.BlendMatrix.m[1][1] + Pos.z * GBASE.BlendMatrix.m[2][1] + GBASE.BlendMatrix.m[3][1]  ;
		TempVect.pos.z = Pos.x * GBASE.BlendMatrix.m[0][2] + Pos.y * GBASE.BlendMatrix.m[1][2] + Pos.z * GBASE.BlendMatrix.m[2][2] + GBASE.BlendMatrix.m[3][2]  ;
		TempVect.rhw   = Pos.x * GBASE.BlendMatrix.m[0][3] + Pos.y * GBASE.BlendMatrix.m[1][3] + Pos.z * GBASE.BlendMatrix.m[2][3] + GBASE.BlendMatrix.m[3][3]  ;

		TempVect.rhw = 1.0F / TempVect.rhw ;
		TempVect.pos.x *= TempVect.rhw ;
		TempVect.pos.y *= TempVect.rhw ;
		TempVect.pos.z *= TempVect.rhw ;

		DrawArea->left   = _FTOL( TempVect.pos.x ) - 1 ;
		DrawArea->right  = _FTOL( TempVect.pos.x ) + 1 ;
		DrawArea->top    = _FTOL( TempVect.pos.y ) - 1 ;
		DrawArea->bottom = _FTOL( TempVect.pos.y ) + 1 ;
	}

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawPixel
static int	DrawPixelHardware( int x, int y, int Color )
{
	VERTEX_NOTEX_2D *VectData ;
	int Red, Green, Blue, Flag ;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ; 

	// 描画の準備
	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// 色その他ステータスのセット
	GETVERTEX_POINT( VectData ) ;

	if( GRH.DiffuseColor == 0xffffffff )
	{
		NS_GetColor2( Color, &Red, &Green, &Blue ) ;
		VectData->color = 0xff000000 | ( Red << 16 ) | ( Green << 8 ) | Blue ;
	}
	else
	{
		NS_GetColor2( Color, &Red, &Green, &Blue ) ;
		VectData->color =	( ( ( ( (	GRH.DiffuseColor & 0x00ff0000 ) >> 16 ) * Red   )	/ 255 ) << 16 ) |
							( ( ( ( (	GRH.DiffuseColor & 0x0000ff00 ) >> 8  ) * Green )	/ 255 ) << 8  ) |
							( ( ( (		GRH.DiffuseColor & 0x000000ff )       ) * Blue  )	/ 255 ) | 
							(			GRH.DiffuseColor & 0xff000000 ) ;
	}

	// 座標のセット
	VectData->pos.x = ( float )x ;
	VectData->pos.y = ( float )y ;
	VectData->pos.z = GBASE.DrawZ;

	if( GRH.UseAlphaChDrawShader )
	{
		VectData->sc_u = ( VectData->pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
		VectData->sc_v = ( VectData->pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
	}

	// 頂点の追加
	ADD4VERTEX_POINT

	// 終了
	return 0 ;
}

// ハードウエアアクセラレータ使用版 DrawPixelSet
#define SetDrawNum (1000)
static int	DrawPixelSetHardware( const POINTDATA *PointData, int Num )
{
	int i, j, k ;
	static VERTEX_NOTEX_2D VectData[ SetDrawNum ], *Vect ;
	COLORDATA ColorData ;
	int MaxRed, MaxGreen, MaxBlue ; 
	int Color, Flag ;
	DWORD drawz;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	RenderVertexHardware() ;

	// 描画の準備
	BeginScene() ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// ベクトル基本ステータスを取得
	ColorData = *( ( COLORDATA * )NS_GetDispColorData() ) ;
	
	MaxRed		= ( 1 << ColorData.RedWidth	) - 1 ; 
	MaxGreen	= ( 1 << ColorData.GreenWidth ) - 1 ;
	MaxBlue		= ( 1 << ColorData.BlueWidth ) - 1 ; 

	j = 0 ;
	Vect = VectData ;

	// FVF のセット
	SETFVF( VERTEXFVF_NOTEX_2D )

	for( i = 0 ; i < Num ; i ++, PointData ++ )
	{
		// 色その他ステータスのセット
		Color = PointData->color ;
		Vect->color = ( PointData->pal << 24 ) |
						( ( ( ( ( ( Color & ColorData.RedMask	) >> ColorData.RedLoc	) << 8 ) - 1 ) / MaxRed		) << 16 ) |
						( ( ( ( ( ( Color & ColorData.GreenMask	) >> ColorData.GreenLoc	) << 8 ) - 1 ) / MaxGreen	) << 8 ) |
						( ( ( ( ( ( Color & ColorData.BlueMask	) >> ColorData.BlueLoc	) << 8 ) - 1 ) / MaxBlue	) ) ; 
		Vect->rhw	= 1.0f ;
		*((DWORD *)&Vect->pos.z) = drawz ;

		// 座標のセット＆ウインドウ直接描画時補正
		Vect->pos.x = ( float )PointData->x ;
		Vect->pos.y = ( float )PointData->y ;

		j ++ ;
		Vect ++ ;
		if( j == SetDrawNum )
		{
			if( GRH.UseAlphaChDrawShader )
			{
				for( k = 0 ; k < j ; k ++ )
				{
					VectData[ k ].sc_u = ( VectData[ k ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectData[ k ].sc_v = ( VectData[ k ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}
			}

			// 描画
			GraphicsDevice_DrawPrimitiveUP( D_D3DPT_POINTLIST, j, VectData, sizeof( VERTEX_NOTEX_2D ) ) ;
			j = 0 ;
			Vect = VectData ;
		}
	}

	if( j != 0 )
	{
		// 描画
		GraphicsDevice_DrawPrimitiveUP( D_D3DPT_POINTLIST, j, VectData, sizeof( VERTEX_NOTEX_2D ) ) ;
	}

	// 終了
	return 0;
}

// ハードウエアアクセラレータ使用版 DrawLineSet
static int	DrawLineSetHardware( const LINEDATA *LineData, int Num )
{
	int i, j, k, l ;
	static VERTEX_NOTEX_2D VectData[ SetDrawNum ], *Vect ;
	COLORDATA ColorData ;
	int MaxRed, MaxGreen, MaxBlue ; 
	int Color, Flag ;
	DWORD drawz;

	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	RenderVertexHardware() ;

	// 描画の準備
	BeginScene() ;
	Flag = DRAWPREP_DIFFUSERGB ;
	DRAWPREP_NOTEX( Flag )

	// Ｚバッファに書き込むＺ値をセットする
	drawz = *((DWORD *)&GBASE.DrawZ);

	// ベクトル基本ステータスを取得
	ColorData = *( ( COLORDATA * )NS_GetDispColorData() ) ;
	
	MaxRed		= ( 1 << ColorData.RedWidth	) - 1 ; 
	MaxGreen	= ( 1 << ColorData.GreenWidth ) - 1 ;
	MaxBlue		= ( 1 << ColorData.BlueWidth ) - 1 ; 

	j = 0 ;
	Vect = VectData ;

	// FVF の設定
	SETFVF( VERTEXFVF_NOTEX_2D )

	for( i = 0 ; i < Num ; i ++, LineData ++ )
	{
		// 色その他ステータスのセット
		Color = LineData->color ;
		Vect[0].color = ( LineData->pal << 24 ) |
						( ( ( ( ( ( Color & ColorData.RedMask	) >> ColorData.RedLoc	) << 8 ) - 1 ) / MaxRed		) << 16 ) |
						( ( ( ( ( ( Color & ColorData.GreenMask	) >> ColorData.GreenLoc	) << 8 ) - 1 ) / MaxGreen	) << 8 ) |
						( ( ( ( ( ( Color & ColorData.BlueMask	) >> ColorData.BlueLoc	) << 8 ) - 1 ) / MaxBlue	) ) ; 
		Vect[1].color = Vect[0].color ;
		Vect[0].rhw	  =
		Vect[1].rhw   = 1.0f ;
		*((DWORD *)&Vect[0].pos.z) =
		*((DWORD *)&Vect[1].pos.z) = drawz;
 
		// 座標のセット＆ウインドウ直接描画時補正
		Vect[0].pos.x = ( float )LineData->x1 ;
		Vect[0].pos.y = ( float )LineData->y1 ;
		Vect[1].pos.x = ( float )LineData->x2 ;
		Vect[1].pos.y = ( float )LineData->y2 ;

		j ++ ;
		Vect += 2 ;
		if( j * 2 == SetDrawNum )
		{
			if( GRH.UseAlphaChDrawShader )
			{
				l = 0 ;
				for( k = 0 ; k < j ; k ++, l += 2 )
				{
					VectData[ l + 0 ].sc_u = ( VectData[ l + 0 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectData[ l + 0 ].sc_v = ( VectData[ l + 0 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
					VectData[ l + 1 ].sc_u = ( VectData[ l + 1 ].pos.x + 0.5f ) * GRH.RenderTargetTextureInvWidth ;
					VectData[ l + 1 ].sc_v = ( VectData[ l + 1 ].pos.y + 0.5f ) * GRH.RenderTargetTextureInvHeight ;
				}
			}

			// 描画
			GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINELIST, j, VectData, sizeof( VERTEX_NOTEX_2D ) ) ;
			j = 0 ;
			Vect = VectData ;
		}
	}

	if( j != 0 )
	{
		// 描画
		GraphicsDevice_DrawPrimitiveUP( D_D3DPT_LINELIST, j, VectData, sizeof( VERTEX_NOTEX_2D ) ) ;
	}

	// 終了
	return 0;
}

// ソフトウエアレンダリング版 DrawGraph
static int  DrawGraphSoftware( int x, int y, IMAGEDATA2 *Image2, int TransFlag )
{
	DrawMemImg( GRS.TargetMemImg, &Image2->Soft.MemImg, x, y, TransFlag, GRS.BlendMemImg ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawExtendGraph
static int  DrawExtendGraphSoftware( int x1, int y1, int x2, int y2, IMAGEDATA2 *Image2, int TransFlag )
{
	RECT Rect ;

	Rect.left   = x1 ;
	Rect.top    = y1 ;
	Rect.right  = x2 ;
	Rect.bottom = y2 ;

	DrawEnlargeMemImg( GRS.TargetMemImg, &Image2->Soft.MemImg, &Rect, TransFlag, GRS.BlendMemImg ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawRotaGraph
static int  DrawRotaGraphSoftware( float x, float y, double ExRate, double Angle, IMAGEDATA2 *Image2, int TransFlag, int TurnFlag )
{
	DrawRotationMemImg( GRS.TargetMemImg, &Image2->Soft.MemImg,
		_FTOL( x ), _FTOL( y ), ( float )Angle, ( float )ExRate, TransFlag, TurnFlag, GRS.BlendMemImg ) ;

	// 終了
	return 0 ;
}

static int	DrawPolySoftware( DX_POINTDATA *p, IMAGEDATA2 *Image2, int TransFlag, int Color )
{
	DrawBasicPolygonMemImg( GRS.TargetMemImg, Image2 ? &Image2->Soft.MemImg : NULL, 
							p, TransFlag, GRS.BlendMemImg, Color ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawModiGraph
static int  DrawModiGraphSoftware( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, IMAGEDATA2 *Image2, int TransFlag )
{
	DX_POINTDATA p[4] ;

	p[0].x = x1 ;		p[0].y = y1 ;		p[0].u = 0 ;				p[0].v = 0 ;
	p[1].x = x2 ;		p[1].y = y2 ;		p[1].u = Image2->Width ;	p[1].v = 0 ;
	p[2].x = x3 ;		p[2].y = y3 ;		p[2].u = 0 ;				p[2].v = Image2->Height ;
	p[3].x = x4 ;		p[3].y = y4 ;		p[3].u = Image2->Width ;	p[3].v = Image2->Height ;

	DrawPolySoftware( &p[0], Image2, TransFlag, 0 ) ;
	DrawPolySoftware( &p[1], Image2, TransFlag, 0 ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawModiGraphF
static int  DrawModiGraphFSoftware( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, IMAGEDATA2 *Image2, int TransFlag )
{
	return DrawModiGraphSoftware( _FTOL( x1 ), _FTOL( y1 ), _FTOL( x2 ), _FTOL( y2 ), _FTOL( x3 ), _FTOL( y3 ), _FTOL( x4 ), _FTOL( y4 ), Image2, TransFlag ) ;
}

// ソフトウエアレンダリング版 DrawFillBox
static int  DrawFillBoxSoftware( int x1, int y1, int x2, int y2, int Color )
{
	RECT DestRect ;

	DestRect.left   = x1 ;
	DestRect.top    = y1 ;
	DestRect.right  = x2 ;
	DestRect.bottom = y2 ;

	DrawFillBoxMemImg( GRS.TargetMemImg, &DestRect, Color ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawLine
static int	DrawLineSoftware( int x1, int y1, int x2, int y2, int Color )
{
	DrawLineMemImg( GRS.TargetMemImg, x1, y1, x2, y2, Color ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawLineBox
static int  DrawLineBoxSoftware( int x1, int y1, int x2, int y2, int Color )
{
	LINEDATA Line[4] ;

	Line[0].x1 = x1 ;		Line[0].y1 = y1 ;		Line[0].x2 = x2 - 1 ;	Line[0].y2 = y1 ;
	Line[1].x1 = x2 - 1 ;	Line[1].y1 = y1 ;		Line[1].x2 = x2 - 1 ;	Line[1].y2 = y2 - 1 ;
	Line[2].x1 = x2 - 1 ;	Line[2].y1 = y2 - 1 ;	Line[2].x2 = x1 ;		Line[2].y2 = y2 - 1 ;
	Line[3].x1 = x1 ;		Line[3].y1 = y2 - 1 ;	Line[3].x2 = x1 ;		Line[3].y2 = y1 ;
	Line[3].color = Line[2].color = Line[1].color = Line[0].color = Color ;
	Line[3].pal   = Line[2].pal   = Line[1].pal   = Line[0].pal   = GBASE.BlendParam ;

	return DrawLineSetSoftware( Line, 4 ) ;
}

// ソフトウエアレンダリング版 DrawCircle( 太さ指定あり )
static int	DrawCircle_ThicknessSoftware( int x, int y, int r, int Color, int Thickness )
{
	int i ;
	RECT DrawRect ;
	short ( *CirclePos )[ 5 ] ;
	int x1, x2, y1 ;

	DrawRect = GBASE.DrawArea ;

	// 円の座標を代入するバッファを取得
	if( AllocCommonBuffer( 1, sizeof( short ) * 5 * DrawRect.bottom ) < 0 )
	{
		return -1 ;
	}
	CirclePos = ( short (*)[ 5 ] )GRH.CommonBuffer[ 1 ] ;
	_MEMSET( CirclePos, 0, sizeof( short ) * 5 * DrawRect.bottom ) ;

	// 円の座標リスト作成
	GetCircle_ThicknessDrawPosition( x, y, r, Thickness, CirclePos ) ;

	// 描画処理
	for( i = DrawRect.top ; i < DrawRect.bottom ; i ++ )
	{
		if( CirclePos[ i ][ 4 ] == 0 )
		{
			continue ;
		}

		y1 = i ;

		if( ( CirclePos[ i ][ 4 ] & ( 4 | 8 ) ) == 0 || CirclePos[ i ][ 2 ] >= CirclePos[ i ][ 3 ] )
		{
			x1 = CirclePos[ i ][ 0 ] ;
			x2 = CirclePos[ i ][ 1 ] ;
			DrawLineMemImg( GRS.TargetMemImg, x1, y1, x2 + 1, y1, Color ) ;
		}
		else
		{
			x1 = CirclePos[ i ][ 0 ] ;
			x2 = CirclePos[ i ][ 2 ] ;
			DrawLineMemImg( GRS.TargetMemImg, x1, y1, x2 + 1, y1, Color ) ;

			x1 = CirclePos[ i ][ 3 ] ;
			x2 = CirclePos[ i ][ 1 ] ;
			DrawLineMemImg( GRS.TargetMemImg, x1, y1, x2 + 1, y1, Color ) ;
		}
	}

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawOval( 太さ指定あり )
static int	DrawOval_ThicknessSoftware( int x, int y, int rx, int ry, int Color, int Thickness )
{
	int i ;
	RECT DrawRect ;
	short ( *CirclePos )[ 5 ] ;
	int x1, x2, y1 ;

	DrawRect = GBASE.DrawArea ;

	// 円の座標を代入するバッファを取得
	if( AllocCommonBuffer( 1, sizeof( short ) * 5 * DrawRect.bottom ) < 0 )
	{
		return -1 ;
	}
	CirclePos = ( short (*)[ 5 ] )GRH.CommonBuffer[ 1 ] ;
	_MEMSET( CirclePos, 0, sizeof( short ) * 5 * DrawRect.bottom ) ;

	// 円の座標リスト作成
	GetOval_ThicknessDrawPosition( x, y, rx, ry, Thickness, CirclePos ) ;

	// 描画処理
	for( i = DrawRect.top ; i < DrawRect.bottom ; i ++ )
	{
		if( CirclePos[ i ][ 4 ] == 0 )
		{
			continue ;
		}

		y1 = i ;

		if( ( CirclePos[ i ][ 4 ] & ( 4 | 8 ) ) == 0 || CirclePos[ i ][ 2 ] >= CirclePos[ i ][ 3 ] )
		{
			x1 = CirclePos[ i ][ 0 ] ;
			x2 = CirclePos[ i ][ 1 ] ;
			DrawLineMemImg( GRS.TargetMemImg, x1, y1, x2 + 1, y1, Color ) ;
		}
		else
		{
			x1 = CirclePos[ i ][ 0 ] ;
			x2 = CirclePos[ i ][ 2 ] ;
			DrawLineMemImg( GRS.TargetMemImg, x1, y1, x2 + 1, y1, Color ) ;

			x1 = CirclePos[ i ][ 3 ] ;
			x2 = CirclePos[ i ][ 1 ] ;
			DrawLineMemImg( GRS.TargetMemImg, x1, y1, x2 + 1, y1, Color ) ;
		}
	}

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawCircle
static int	DrawCircleSoftware( int x, int y, int r, int Color, int FillFlag )
{
	DrawCircleMemImg( GRS.TargetMemImg, x, y, r, Color, FillFlag ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawOval
static int	DrawOvalSoftware( int x, int y, int rx, int ry, int Color, int FillFlag )
{
	DrawOvalMemImg( GRS.TargetMemImg, x, y, rx, ry, Color, FillFlag ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawTriangle
static int	DrawTriangleSoftware( int x1, int y1, int x2, int y2, int x3, int y3, int Color, int FillFlag )
{
	// 塗りつぶしかそうでないかで処理を分岐
	if( FillFlag == TRUE )
	{
		// 塗りつぶしの場合
		DX_POINTDATA p[3] ;

		p[0].x = x1 ;		p[0].y = y1 ;
		p[1].x = x2 ;		p[1].y = y2 ;
		p[2].x = x3 ;		p[2].y = y3 ;
	
		return DrawPolySoftware( p, NULL, FALSE, Color ) ;
	}
	else
	{
		LINEDATA Line[3] ;
		
		Line[0].x1 = x1 ;	Line[0].y1 = y1 ;	Line[0].x2 = x2 ;	Line[0].y2 = y2 ;
		Line[1].x1 = x2 ;	Line[1].y1 = y2 ;	Line[1].x2 = x3 ;	Line[1].y2 = y3 ;
		Line[2].x1 = x3 ;	Line[2].y1 = y3 ;	Line[2].x2 = x1 ;	Line[2].y2 = y1 ;
		Line[2].color = Line[1].color = Line[0].color = Color ;
		Line[2].pal   = Line[1].pal   = Line[0].pal   = GBASE.BlendParam ;
		return DrawLineSetSoftware( Line, 3 ) ;
	}
}

// ソフトウエアレンダリング版 DrawQuadrangle
static int	DrawQuadrangleSoftware( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int Color, int FillFlag )
{
	// 塗りつぶしかそうでないかで処理を分岐
	if( FillFlag == TRUE )
	{
		// 塗りつぶしの場合

		DX_POINTDATA p[3] ;

		p[0].x = x1 ;		p[0].y = y1 ;
		p[1].x = x2 ;		p[1].y = y2 ;
		p[2].x = x4 ;		p[2].y = y4 ;
		DrawPolySoftware( p, NULL, FALSE, Color ) ;

		p[0].x = x3 ;		p[0].y = y3 ;
		p[1].x = x4 ;		p[1].y = y4 ;
		p[2].x = x2 ;		p[2].y = y2 ;
		return DrawPolySoftware( p, NULL, FALSE, Color ) ;
	}
	else
	{
		LINEDATA Line[4] ;
		
		Line[0].x1 = x1 ;	Line[0].y1 = y1 ;	Line[0].x2 = x2 ;	Line[0].y2 = y2 ;
		Line[1].x1 = x2 ;	Line[1].y1 = y2 ;	Line[1].x2 = x3 ;	Line[1].y2 = y3 ;
		Line[2].x1 = x3 ;	Line[2].y1 = y3 ;	Line[2].x2 = x4 ;	Line[2].y2 = y4 ;
		Line[3].x1 = x4 ;	Line[3].y1 = y4 ;	Line[3].x2 = x1 ;	Line[3].y2 = y1 ;
		Line[3].color = Line[2].color = Line[1].color = Line[0].color = Color ;
		Line[3].pal   = Line[2].pal   = Line[1].pal   = Line[0].pal   = GBASE.BlendParam ;
		return DrawLineSetSoftware( Line, 4 ) ;
	}
}


// ソフトウエアレンダリング版 DrawPixel
static int	DrawPixelSoftware( int x, int y, int Color )
{
	DrawPixelMemImg( GRS.TargetMemImg, x, y, Color ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawChipMap
static int	DrawChipMapSoftware( int Sx, int Sy, int XNum, int YNum, const int *MapData, int MapDataPitch, int /*ChipTypeNum*/, const int *ChipGrHandle, int TransFlag )
{
	int x, y, i, j, Width, Height, Pitch2 ;
	const int *MP ;
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( ChipGrHandle[ 0 ], Image2 ) )
		return -1 ;

	Width = Image2->Width ;
	Height = Image2->Height ;

	Pitch2 = MapDataPitch - XNum ;

	// 普通に for 文でループ描画
	y = Sy ;
	MP = MapData ;
	for( i = 0 ; i < YNum ; i ++, y += Height )
	{
		x = Sx ;
		for( j = 0 ; j < XNum ; j ++, x += Width, MP ++ )
		{
			if( *MP == -1 ) continue ;

			if( GRAPHCHK( ChipGrHandle[ *MP ], Image2 ) )
				return -1 ;

			DrawGraphSoftware( x, y, Image2, TransFlag ) ;
		}
		MP += Pitch2 ;
	}

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawTile
static int	DrawTileSoftware( int x1, int y1, int x2, int y2, int Tx, int Ty, double ExtRate, double Angle, IMAGEDATA2 *Image2, int TransFlag )
{
	double MaxLength ;
	float Width, Height, f, Sin, Cos ;
	float CenX, CenY, x, y, BaseX, BaseY ;
	float xAddX, xAddY, yAddX, yAddY ;
	int temp, Num, i, j ;
	RECT DrawRect ;
	float FAngle, FExtRate, Sin2, Cos2 ;

	FAngle = ( float )Angle ;
	FExtRate = ( float )ExtRate ;

	if( ExtRate <= 0.0 ) ExtRate = 0.0001 ;
	if( x1 > x2 ){ temp = x2 ; x2 = x1 ; x1 = temp ; }
	if( y1 > y2 ){ temp = y2 ; y2 = y1 ; y1 = temp ; }
	Tx %= Image2->Width ;
	Ty %= Image2->Height ;

	_SINCOS( FAngle, &Sin, &Cos ) ;
//	Sin = (float)sin( Angle ) ;
//	Cos = (float)cos( Angle ) ;

	// 進む値を計算
	xAddX = Image2->Width * Cos * FExtRate ;
	xAddY = Image2->Width * Sin * FExtRate ;

	_SINCOS( FAngle + DX_PI_F / 2.0F, &Sin2, &Cos2 ) ;
	yAddX = Image2->Height * Cos2 * FExtRate ;
	yAddY = Image2->Height * Sin2 * FExtRate ;

	// 描画幅を得る
	Width = (float)( x2 - x1 ) ;
	Height = (float)( y2 - y1 ) ;

	// 最大長を得る
	MaxLength = _SQRT( Width * Width + Height * Height ) ;

	// 描画個数を得る
	{
		int k ;

		k = Image2->Width > Image2->Height ? Image2->Height : Image2->Width ;
		Num = _DTOL( MaxLength / ( k * ExtRate ) + 2 ) ;
		if( Num % 2 == 0 ) Num ++ ;
	}

	// 描画中心点を得る
	CenX = x1 + Width / 2 ;
	CenY = y1 + Height / 2 ;

	// 描画可能範囲を変更する
	DrawRect = GBASE.DrawArea ;
	NS_SetDrawArea( x1, y1, x2, y2 ) ;

	// 描画開始座標を得る
	BaseX = ( -Tx - ( Num * Image2->Width  ) / 2 ) * FExtRate ;
	BaseY = ( -Ty - ( Num * Image2->Height ) / 2 ) * FExtRate ;

	f = BaseX * Cos - BaseY * Sin ;
	BaseY = BaseX * Sin + BaseY * Cos + CenY ;
	BaseX = f + CenX ;

	// 描画開始
	for( i = 0 ; i < Num ; i ++, BaseX += yAddX, BaseY += yAddY )
	{
		x = BaseX ;
		y = BaseY ;
		for( j = 0 ; j < Num ; j ++, x += xAddX, y += xAddY )
		{
			if( Angle == 0.0 )
			{
				if( ExtRate == 0.0 )
				{
					DrawGraphSoftware( _FTOL( x ), _FTOL( y ), Image2, TransFlag ) ;
				}
				else
				{
					DrawExtendGraphSoftware( _FTOL( x ), _FTOL( y ),
											 _FTOL( x + xAddX ),
											 _FTOL( y + yAddY ), Image2, TransFlag ) ;
				}
			}
			else
			{
				DrawModiGraphSoftware( _FTOL( x ), _FTOL( y ),
								_FTOL( x + xAddX ), _FTOL( y + xAddY ),
								_FTOL( x + yAddX ), _FTOL( y + yAddY ),
								_FTOL( x + xAddX + yAddX ), _FTOL( y + xAddY + yAddY ),
								Image2, TransFlag ) ;
			}
		}
	}

	// 描画可能範囲を元に戻す
	NS_SetDrawArea( DrawRect.left, DrawRect.top, DrawRect.right, DrawRect.bottom ) ;

	return 0 ;
}

// ソフトウエアレンダリング版 DrawPixelSet
static int	DrawPixelSetSoftware( const POINTDATA *PointData, int Num )
{
	DrawPixelSetMemImg( GRS.TargetMemImg, PointData, Num ) ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリング版 DrawLineSet
static int	DrawLineSetSoftware( const LINEDATA *LineData, int Num )
{
	DrawLineSetMemImg( GRS.TargetMemImg, LineData, Num ) ;

	// 終了
	return 0 ;
}

// デバイスロスト発生時に削除するフラグが立っているグラフィックを削除する
static int DeleteDeviceLostDeleteGraph( void )
{
	int i ;
	IMAGEDATA2 *Image2 ;

	if( HandleManageArray[ DX_HANDLETYPE_GRAPH ].InitializeFlag )
	{
		for( i = HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMin ; i <= HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMax ; i ++ )
		{
			Image2 = ( IMAGEDATA2 * )HandleManageArray[ DX_HANDLETYPE_GRAPH ].Handle[ i ] ;

			if( Image2 == NULL ) continue ;
			if( Image2->Orig == NULL ) continue ;
			if( Image2->DeviceLostDeleteFlag == FALSE ) continue ;

			SubHandle( Image2->HandleInfo.Handle ) ;
		}
	}

	// 終了
	return 0 ;
}

// サブバックバッファを使用する準備を行う( 0:成功  -1:失敗 )
static int SetupSubBackBuffer()
{
	// 既にサブバックバッファが作成されている場合は何もしない
	if( GRH.SubBackBufferSurface != NULL ) return 0 ;

	// 描画情報を吐き出しておく
	RenderVertexHardware() ;
	EndScene() ;

	// サブバックバッファの作成
	if( CreateSubBackBufferSurface() == -1 )
		return -1 ;

	// 本バックバッファの内容を転送
	GraphicsDevice_StretchRect( GRH.BackBufferSurface, NULL, GRH.SubBackBufferSurface, NULL, D_D3DTEXF_NONE ) ;

	// レンダリングターゲットの変更
	GRH.InitializeFlag = TRUE ;
	SetRenderTargetHardware( GRH.SubBackBufferSurface ) ;
	GRH.InitializeFlag = FALSE ;

	// 終了
	return 0 ;
}

// SetDrawBright の引数が一つ版
extern void FASTCALL SetDrawBrightToOneParam( DWORD Bright )
{
	Bright &= 0xffffff ;
	if( GBASE.bDrawBright == Bright ) return ;

	// 輝度を保存
	GBASE.bDrawBright = Bright ;
	SetMemImgDrawBright( Bright ) ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// Direct3D に設定を反映
	if( GRA2.ValidHardWare )
	{
		// ディフューズカラーの更新
		GRH.DiffuseColor = GetDiffuseColor() ;
	}
}

// 補助関数
extern void FASTCALL BlendModeSub_Pre( RECT *DrawRect )
{
	DWORD Bright, Cr, BlendParam ;

	Cr = NS_GetColor( 255,255,255 ) ;
	Bright = GBASE.bDrawBright ;
	BlendParam = GBASE.BlendParam ;

	SetDrawBrightToOneParam( 0xffffff ) ;
	NS_SetDrawBlendMode( DX_BLENDMODE_SUB, 255 ) ;

	DrawFillBoxHardware( DrawRect->left, DrawRect->top, DrawRect->right, DrawRect->bottom, Cr ) ;

	SetDrawBrightToOneParam( Bright ) ;
	NS_SetDrawBlendMode( DX_BLENDMODE_SUB2, BlendParam ) ;
}

extern void FASTCALL BlendModeSub_Post( RECT *DrawRect )
{
	DWORD Bright, Cr, BlendParam ;

	Cr = NS_GetColor( 255,255,255 ) ;
	Bright = GBASE.bDrawBright ;
	BlendParam = GBASE.BlendParam ;

	SetDrawBrightToOneParam( 0xffffff ) ;
	NS_SetDrawBlendMode( DX_BLENDMODE_SUB, 255 ) ; 
	
	DrawFillBoxHardware( DrawRect->left, DrawRect->top, DrawRect->right, DrawRect->bottom, Cr ) ;

	SetDrawBrightToOneParam( Bright ) ;
	NS_SetDrawBlendMode( DX_BLENDMODE_SUB, BlendParam ) ;
}

extern void FASTCALL AlphaChDraw_Pre( RECT *DrawRect )
{
	RenderVertexHardware() ;
	GraphicsDevice_StretchRect( GRH.RenderTargetSurface, DrawRect, GRH.RenderTargetCopySurface, DrawRect, D_D3DTEXF_NONE ) ;
}

extern int GetWorkTexture( int IsFloatType, DWORD TexSizeW, DWORD TexSizeH, DWORD HandleIndex )
{
	IMAGEDATA2 *Image ;
	DWORD TexSizeBig ;
	DWORD NPow ;
	int TexSize ;

	TexSizeBig = TexSizeW > TexSizeH ? TexSizeW : TexSizeH ;
	for( NPow = 0 ; ( DWORD )( 1 << NPow ) < TexSizeBig ; NPow ++ ){}
	TexSize = ( int )( 1 << NPow ) ;

	if( GRAPHCHK( GRH.WorkDrawValidGrHandle[ IsFloatType ][ NPow ][ HandleIndex ], Image ) )
	{
		SETUP_GRAPHHANDLE_GPARAM GParam ;

		InitSetupGraphHandleGParam_Normal_DrawValid_NoneZBuffer( &GParam, 32, TRUE ) ;
		GParam.DrawValidFloatTypeGraphCreateFlag = IsFloatType ;

		GRH.WorkDrawValidGrHandle[ IsFloatType ][ NPow ][ HandleIndex ] = MakeGraph_UseGParam( &GParam, TexSize, TexSize, FALSE, FALSE ) ;
		if( GRH.WorkDrawValidGrHandle[ IsFloatType ][ NPow ][ HandleIndex ] < 0 )
		{
			DXST_ERRORLOGFMT_ADD(( _T( "作業用描画可能テクスチャの作成に失敗しました Size:%dx%d" ), TexSize, TexSize )) ;
			return -1 ;
		}
	}

	return GRH.WorkDrawValidGrHandle[ IsFloatType ][ NPow ][ HandleIndex ] ;
}

extern int SetUseAutoMipMap( int UseFlag, int MaxLevel )
{
	if( UseFlag == TRUE )
	{
		GRH.MipMapCount = MaxLevel ;
	}
	else
	{
		GRH.MipMapCount = 0 ;
	}

	// 終了
	return 0 ;
}

// 指定のテクスチャーサイズを上手く分割する
static int ListUpTexSize( int Size, short *SizeList, int NotDivFlag, int Pow2Flag, int MaxTextureSize )
{
	int DivNum ;
	int TexSize, GraphSize, MaxTexSize ;

	// 最大サイズをセット
	MaxTexSize = MaxTextureSize != 0 ? MaxTextureSize : GRH.MaxTextureSize ;

	// ２のｎ乗ではなくて良い場合は指定のサイズが最大テクスチャサイズ以下だったらそのまま返す
	if( Pow2Flag == FALSE && ( GRH.TextureSizePow2 == FALSE || GRH.TextureSizeNonPow2Conditional ) )
	{
		if( Size <= MaxTexSize )
		{
			if( SizeList ) SizeList[ 0 ] = ( short )Size ;
			return 1 ;
		}
	}

	// 分割を行う最小サイズのテクスチャより小さい場合は最小サイズをセットして１を返す
	if( MIN_TEXTURE_SIZE >= Size )
	{
		if( SizeList ) SizeList[ 0 ] = MIN_TEXTURE_SIZE ;
		return 1 ;
	}

	// １番最初のテクスチャーは指定サイズに収まる出きるだけ大きいテクスチャーにする
	DivNum = 0 ;
	TexSize = MaxTexSize ;
	while( TexSize > MIN_TEXTURE_SIZE )
	{
		if( TexSize <= Size ) break ;
		TexSize >>= 1 ;
	}

	// 分割を行わない場合は一枚で収められる場合は収めて終了
	if( NotDivFlag != FALSE )
	{
		if( ( TexSize << 1 ) <= MaxTexSize )
		{
			if( TexSize < Size ) TexSize <<= 1 ;
			if( SizeList ) SizeList[ 0 ] = ( short )TexSize ;
			return 1 ;
		}
	}
	else
	// 分割を行う指定の場合でも作成する画像のサイズが
	// 画面と同じかそれよりも小さく、且つユーザー指定のサイズが無い場合は
	// なるべく分割を行わない
	if( MaxTextureSize == 0 )
	{
		if( Size <= GRA2.MainScreenSizeX )
		{
			if( ( TexSize << 1 ) <= MaxTexSize )
			{
				if( TexSize < Size ) TexSize <<= 1 ;
				if( SizeList ) SizeList[ 0 ] = ( short )TexSize ;
				return 1 ;
			}
		}
	}

	// 分割処理
	GraphSize = Size ;
	for(;;)
	{
		if( SizeList ) SizeList[ DivNum ] = ( short )TexSize ;
		GraphSize -= TexSize ;

		if( GraphSize <= 0 ) break ;

		// もう一つテクスチャーを作るよりサイズを２倍にしたほうがいい場合を判定
		if( ( GraphSize > TexSize * 3 / 4 ) && ( TexSize < MaxTexSize ) )
		{
			if( SizeList ) SizeList[ DivNum ] = ( short )( TexSize << 1 ) ;
			break ;
		}
		else
		{
			// テクスチャーのサイズを残りグラフィックサイズに合わせて補正する
			if( GraphSize < TexSize )
			{
				while( GraphSize < TexSize  &&  TexSize > MIN_TEXTURE_SIZE )
				{
					TexSize = TexSize >> 1 ;
				}
				DivNum ++ ; 
				continue ;
			}
		}
		DivNum ++ ;
	}

	// 最後のサイズが、もし最後の一つ前のサイズと等しい場合は
	// 最後の一つ前のサイズを２倍にして分割情報を一つ減らす
	if( DivNum > 0 && SizeList[ DivNum - 1 ] == SizeList[ DivNum ] &&
		( SizeList[ DivNum - 1 ] << 1 ) <= MaxTexSize )
	{
		DivNum -- ;
		SizeList[ DivNum ] <<= 1 ;
	}

	// 分割数を返す
	return DivNum + 1 ;
}

// グラフィックスシステムの初期化
extern int InitializeGraphics2( void )
{
	// 既に初期化済みの場合は何もしない
	if( GRA2.InitializeFlag == TRUE ) return 0 ;

	// 画面の設定を初期化
	if( GRA2.MainScreenSizeX == 0 || GRA2.MainScreenSizeY == 0 )
	{
		SetMainScreenSize( DEFAULT_SCREEN_SIZE_X, DEFAULT_SCREEN_SIZE_Y ) ;
	}

	if( GRA2.MainScreenColorBitDepth == 0 )
	{
		GRA2.MainScreenColorBitDepth = DEFAULT_COLOR_BITDEPTH ;
		SetMemImgDefaultColorType( 0 ) ;
	}

#ifdef __WINDOWS__
	if( GRA2.MainScreenSizeX == 320 && GRA2.MainScreenSizeY == 240 && NS_GetWindowModeFlag() == FALSE )
	{
		GRH.FullScreenEmulation320x240 = TRUE ;
		SetMainScreenSize( 640, 480 ) ;
	}
#endif // __WINDOWS__

	// シェーダー定数情報を初期化
	InitializeShaderConstantInfoSet( &GRH.ShaderConstantInfo ) ;
	SetUseShaderContantInfoState( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTSET_MASK_LIB ) ;

	// DirectX の初期化
	if( InitializeDirectX() == -1 )
		goto ERR ;

	// グラフィックハンドル管理情報の初期化
	InitializeHandleManage( DX_HANDLETYPE_GRAPH, sizeof( IMAGEDATA2 ), MAX_IMAGE_NUM, InitializeGraphHandle, TerminateGraphHandle, DXSTRING( _T( "グラフィック" ) ) ) ;

	// シェーダーハンドル管理情報の初期化
	InitializeHandleManage( DX_HANDLETYPE_SHADER, sizeof( SHADERHANDLEDATA ), MAX_SHADER_NUM, InitializeShaderHandle, TerminateShaderHandle, DXSTRING( _T( "シェーダー" ) ) ) ;

	// 頂点バッファハンドル管理情報の初期化
	InitializeHandleManage( DX_HANDLETYPE_VERTEX_BUFFER, sizeof( VERTEXBUFFERHANDLEDATA ), MAX_VERTEX_BUFFER_NUM, InitializeVertexBufferHandle, TerminateVertexBufferHandle, DXSTRING( _T( "頂点バッファ" ) ) ) ;

	// インデックスバッファハンドル管理情報の初期化
	InitializeHandleManage( DX_HANDLETYPE_INDEX_BUFFER, sizeof( INDEXBUFFERHANDLEDATA ), MAX_INDEX_BUFFER_NUM, InitializeIndexBufferHandle, TerminateIndexBufferHandle, DXSTRING( _T( "インデックスバッファ" ) ) ) ;

	// シャドウマップハンドル管理情報の初期化
	InitializeHandleManage( DX_HANDLETYPE_SHADOWMAP, sizeof( SHADOWMAPDATA ), MAX_SHADOWMAP_NUM, InitializeShadowMapHandle, TerminateShadowMapHandle, DXSTRING( _T( "シャドウマップ" ) ) ) ;

	// 初期化済みフラグを立てる
	GRA2.InitializeFlag = TRUE ;

	// ハードウエアアクセラレータが使用できる場合
	// ハードウエアアクセラレータ周りの初期化を行う
	if( GRA2.ValidHardWare == TRUE )
	{
		InitializeHardware() ;
	}
	else
	// それ以外の場合はソフトウエアレンダリング周りの初期化を行う
	{
		InitializeSoftware() ;
	}

	// グラフィック描画基本データの初期化
	InitializeGraphicsBase() ;

	// MEMIMG の初期化
	InitializeMemImgManage() ;

#ifndef DX_NON_FONT
	// フォントの初期化を行う
	InitFontManage() ;
#endif

#ifndef DX_NON_MASK
	// マスク処理の初期化
	InitializeMask() ;
#endif

	// デバイスの設定をリフレッシュ
	RefreshRenderStateHardware() ;

#ifndef DX_NON_FILTER
	// ピクセルシェーダーを使用する場合は出力先をテクスチャとして使用できるかどうかのチェックを行う
	GRH.ValidRenderTargetInputTexture = FALSE ;
	if( GRA2.ValidHardWare == TRUE && GRH.UseShader == TRUE )
	{
		int TempScreen ;
		BASEIMAGE TempInImage ;
		BASEIMAGE TempOutImage ;
		BASEIMAGE TempScreenImage ;
		RECT LockRect ;
		int i, j, s, count ;
		int r, g, b, a ;
		const int rgb[ 4 * 3 ] =
		{
			204, 168,  80,
			128, 100, 245,
			 66, 222, 143,
			 34, 255,  78,
		} ;
		SETUP_GRAPHHANDLE_GPARAM GParam ;

		InitSetupGraphHandleGParam( &GParam ) ;
		GParam.DrawValidImageCreateFlag = TRUE ;
		GParam.DrawValidAlphaImageCreateFlag = FALSE ;
		GParam.CubeMapTextureCreateFlag = FALSE ;
		TempScreen = MakeGraph_UseGParam( &GParam, 8, 8, FALSE, FALSE ) ;
		NS_CreateXRGB8ColorBaseImage( 8, 8, &TempInImage ) ;
		NS_CreateXRGB8ColorBaseImage( 8, 8, &TempOutImage ) ;

		j = 0 ;
		for( i = 0 ; i < 4 ; i ++, j += 3 )
		{
			NS_SetPixelBaseImage( &TempInImage, i, i, rgb[ j + 0 ], rgb[ j + 1 ], rgb[ j + 2 ], 255 ) ;
		}

		NS_BltBmpOrGraphImageToGraph( NULL, NULL, NULL, FALSE, &TempInImage, NULL, 0, 0, TempScreen ) ;
		GRH.ValidRenderTargetInputTexture = TRUE ;
		NS_GraphFilter( TempScreen, DX_GRAPH_FILTER_INVERT ) ;
		GRH.ValidRenderTargetInputTexture = FALSE ;
		LockRect.left   = 0 ;
		LockRect.top    = 0 ;
		LockRect.right  = 8 ;
		LockRect.bottom = 8 ;
		if( LockDrawScreenBuffer( &LockRect, &TempScreenImage, TempScreen, 0, TRUE, 0 ) != -1 )
		{
			NS_BltBaseImage( 0, 0, &TempScreenImage, &TempOutImage ) ;
			UnlockDrawScreenBuffer() ;

			count = 0 ;
			j = 0 ;
			for( i = 0 ; i < 4 ; i ++, j += 3 )
			{
				NS_GetPixelBaseImage( &TempOutImage, i, i, &r, &g, &b, &a ) ;
				s = r - ( 255 - rgb[ j + 0 ] ) ; if( s >= -1 && s <= 1 ) count ++ ;
				s = g - ( 255 - rgb[ j + 1 ] ) ; if( s >= -1 && s <= 1 ) count ++ ;
				s = b - ( 255 - rgb[ j + 2 ] ) ; if( s >= -1 && s <= 1 ) count ++ ;
			}
			if( count == 4 * 3 )
			{
				GRH.ValidRenderTargetInputTexture = TRUE ;
			}
		}
		NS_DeleteGraph( TempScreen ) ;
		NS_ReleaseBaseImage( &TempInImage ) ;
		NS_ReleaseBaseImage( &TempOutImage ) ;
	}
#endif // DX_NON_FILTER

	// 終了
	return 0 ;

	// エラー処理
ERR:
	TerminateGraphics2() ;

	return -1;
}

// グラフィックシステムの後始末
extern int TerminateGraphics2( void )
{
#ifndef DX_NON_FONT
	// フォントキャッシュの管理系を終了
	TermFontManage() ;
#endif

	// 既に後始末済みの場合は何もしない
	if( GRA2.InitializeFlag == FALSE ) return 0 ;

#ifndef DX_NON_MASK
	// マスク処理の後始末
	TerminateMask() ;
#endif

#ifndef DX_NON_MODEL
	// すべてのモデルを削除
	NS_MV1InitModel() ;
	MV1InitModelBase() ;
#endif

	// 全ての画像を削除
	NS_InitGraph() ;

	// すべての頂点データとインデックスデータを削除
	NS_InitVertexBuffer() ;
	NS_InitIndexBuffer() ;

	// 全てのシェーダーを削除
	NS_InitShader() ;

	// ライトを全て削除
	NS_DeleteLightHandleAll() ;
	NS_DeleteLightHandle( GBASE.Light.DefaultHandle ) ;
	GBASE.Light.DefaultHandle = -1 ;

	// DirectX の後始末
	TerminateDirectX() ;

	// ソフトウエアレンダリング機能の後始末
	TerminateSoftware() ;

	// シェーダーコードの後始末
	ShaderCodeTerminate() ;

	// 頂点を一時的に保存するメモリ領域の解放
	if( GBASE.TempVertexBuffer )
	{
		DXFREE( GBASE.TempVertexBuffer ) ;
		GBASE.TempVertexBuffer = NULL ;
		GBASE.TempVertexBufferSize = 0 ;
	}

	// シャドウマップハンドル管理情報の後始末
	TerminateHandleManage( DX_HANDLETYPE_SHADOWMAP ) ;

	// 頂点バッファハンドル管理情報の後始末
	TerminateHandleManage( DX_HANDLETYPE_VERTEX_BUFFER ) ;

	// インデックスバッファハンドル管理情報の後始末
	TerminateHandleManage( DX_HANDLETYPE_INDEX_BUFFER ) ;

	// シェーダーハンドル管理情報の後始末
	TerminateHandleManage( DX_HANDLETYPE_SHADER ) ;

	// グラフィックハンドル管理情報の後始末
	TerminateHandleManage( DX_HANDLETYPE_GRAPH ) ;

	// 汎用バッファの解放
	TerminateCommonBuffer() ;

	// 初期化済みフラグを倒す
	GRA2.InitializeFlag = FALSE ;

	// 終了
	return 0 ;
}





// 指定のグラフィックデータを削除する
extern	int NS_DeleteGraph( int GrHandle, int )
{
	return SubHandle( GrHandle ) ;
}

// 指定のグラフィックハンドルと、同じグラフィックデータから派生しているグラフィックハンドル( DerivationGraph で派生したハンドル、LoadDivGraph 読み込んで作成された複数のハンドル )を一度に削除する
extern	int NS_DeleteSharingGraph( int GrHandle )
{
	IMAGEDATA2_ORIG *Orig ;
	IMAGEDATA2 *Image2, **TmpImage2 ;
	bool BreakFlag ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	// 同じグラフィックデータから派生しているハンドルを全て削除する
	Orig = Image2->Orig ;
	BreakFlag = false ;
	for( TmpImage2 = ( IMAGEDATA2 ** )&HandleManageArray[ DX_HANDLETYPE_GRAPH ].Handle[ HandleManageArray[ DX_HANDLETYPE_GRAPH ].AreaMin ] ; ; TmpImage2 ++ )
	{
		if( *TmpImage2 == NULL ) continue ;

		if( ( *TmpImage2 )->Orig == Orig )
		{
			BreakFlag = Orig->RefCount == 1 ;
			NS_DeleteGraph( ( *TmpImage2 )->HandleInfo.Handle ) ;
			if( BreakFlag ) break ;
		}
	}

	// 終了
	return 0 ;
}

// 有効なグラフィックの数を取得する
extern	int NS_GetGraphNum( void )
{
	return HandleManageArray[ DX_HANDLETYPE_GRAPH ].Num ;
}

// 解放時に立てるフラグのポインタをセットする
extern	int NS_SetGraphLostFlag( int GrHandle, int *LostFlag )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	Image2->LostFlag = LostFlag ;
	if( LostFlag != NULL ) *LostFlag = FALSE ;

	// 終了
	return 0 ;
}

// 画像データの初期化
extern	int NS_InitGraph( int )
{
	int Result ;

	// グラフィックハンドルを全て削除
	Result = AllHandleSub( DX_HANDLETYPE_GRAPH ) ;

	// シャドウマップハンドルも全て削除
	Result = AllHandleSub( DX_HANDLETYPE_SHADOWMAP ) ;

	// システムメモリテクスチャの解放
	ReleaseSysMemTextureAll() ;

	// システムメモリサーフェスの解放
	ReleaseSysMemSurfaceAll() ;

	// 終了
	return Result ;
}


// 画像データの転送
extern	int NS_BltBmpToGraph( const COLORDATA *BmpColorData, HBITMAP RgbBmp, HBITMAP AlphaBmp, int CopyPointX, int CopyPointY, int GrHandle )
{
	return NS_BltBmpOrGraphImageToGraph( BmpColorData, RgbBmp, AlphaBmp,
											TRUE, NULL, NULL,
											CopyPointX, CopyPointY, GrHandle ) ;
}

// 分割画像へのＢＭＰの転送
extern	int NS_BltBmpToDivGraph( const COLORDATA *BmpColorData, HBITMAP RgbBmp, HBITMAP AlphaBmp, int AllNum, int XNum, int YNum, int Width, int Height, const int *GrHandle, int ReverseFlag )
{
	return NS_BltBmpOrGraphImageToDivGraph( BmpColorData, RgbBmp, AlphaBmp,
												TRUE, NULL, NULL,
												AllNum, XNum, YNum, Width, Height, GrHandle, ReverseFlag ) ;
}



// BltBmpOrGraphImageToGraph の内部関数
extern int BltBmpOrGraphImageToGraphBase(
	const COLORDATA *SrcColorData,
	HBITMAP RgbBmp,
	HBITMAP AlphaBmp,
	int BmpFlag,
	const BASEIMAGE *RgbImage,
	const BASEIMAGE *AlphaImage,
	int CopyPointX,
	int CopyPointY,
	int GrHandle,
	int UseTransColorConvAlpha,
	int ASyncThread
)
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_ORIG *Orig ;
	RECT SrcRect ;

	if( GRA2.InitializeFlag == FALSE ) return -1 ;

	// エラー判定
	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
			return -1 ;
	}
	else
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
	}
	Orig = Image2->Orig ;

	// 転送元矩形の準備
	SrcRect.left   = CopyPointX ;
	SrcRect.top    = CopyPointY ;
	SrcRect.right  = CopyPointX + Image2->Width ;
	SrcRect.bottom = CopyPointY + Image2->Height ;

	// 使用する領域を保存
	Image2->UseBaseX = SrcRect.left ;
	Image2->UseBaseY = SrcRect.top ; 

	// 画像の転送
	return BltBmpOrBaseImageToGraph3(
				SrcColorData,
				RgbBmp,
				AlphaBmp,
				&SrcRect,
				0,
				0,
				GrHandle,
				BmpFlag,
				RgbImage,
				AlphaImage,
				Orig->FormatDesc.BlendGraphFlag,
				UseTransColorConvAlpha,
				FALSE,
				ASyncThread
			) ;
}

// ＢＭＰ か GraphImage を画像に転送
extern int NS_BltBmpOrGraphImageToGraph(
	const COLORDATA *BmpColorData,
	HBITMAP RgbBmp,
	HBITMAP AlphaBmp,
	int BmpFlag,
	const BASEIMAGE *RgbImage,
	const BASEIMAGE *AlphaImage,
	int CopyPointX,
	int CopyPointY,
	int GrHandle )
{
	int Result ;

	Result = BltBmpOrGraphImageToGraphBase( 
				BmpColorData,
				RgbBmp,
				AlphaBmp,
				BmpFlag,
				RgbImage,
				AlphaImage,
				CopyPointX,
				CopyPointY,
				GrHandle,
				GBASE.NotUseTransColor ? FALSE : TRUE
			) ;

	if( Result == 0 )
	{
		if( BmpFlag )
		{
			SetGraphBaseInfo( GrHandle, NULL, BmpColorData, RgbBmp, AlphaBmp, NULL, 0, NULL, 0, NULL, NULL, FALSE, -1, FALSE ) ;
		}
		else
		{
			SetGraphBaseInfo( GrHandle, NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, RgbImage, AlphaImage, FALSE, -1, FALSE ) ;
		}
	}

	return Result ;
}

// BltBmpOrGraphImageToGraph2 の内部関数
extern int BltBmpOrGraphImageToGraph2Base(
	const COLORDATA *BmpColorData,
	HBITMAP RgbBmp,
	HBITMAP AlphaBmp,
	int BmpFlag,
	const BASEIMAGE *RgbImage,
	const BASEIMAGE *AlphaImage,
	const RECT *SrcRect,
	int DestX,
	int DestY,
	int GrHandle )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_ORIG *Orig ;

	if( GRA2.InitializeFlag == FALSE ) return -1 ;

	// エラー判定
	if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
		return -1 ;
	Orig = Image2->Orig ;

	// 使用する領域を保存
	if( SrcRect == NULL )
	{
		Image2->UseBaseX = 0 ;
		Image2->UseBaseY = 0 ; 
	}
	else
	{
		Image2->UseBaseX = SrcRect->left - DestX ;
		Image2->UseBaseY = SrcRect->top  - DestY ; 
	}

	// 画像の転送
	return BltBmpOrBaseImageToGraph3(
				BmpColorData,
				RgbBmp,
				AlphaBmp,
				SrcRect,
				DestX,
				DestY,
				GrHandle,
				BmpFlag,
				RgbImage,
				AlphaImage, 
				Orig->FormatDesc.BlendGraphFlag,
				GBASE.NotUseTransColor ? FALSE : TRUE ) ;
}

// ＢＭＰ か GraphImage を画像に転送
extern	int NS_BltBmpOrGraphImageToGraph2(
	const COLORDATA *BmpColorData,
	HBITMAP RgbBmp,
	HBITMAP AlphaBmp,
	int BmpFlag,
	const BASEIMAGE *RgbImage,
	const BASEIMAGE *AlphaImage,
	const RECT *SrcRect,
	int DestX,
	int DestY,
	int GrHandle )
{
	// 画像の転送
	return BltBmpOrGraphImageToGraph2Base(
				BmpColorData,
				RgbBmp,
				AlphaBmp,
				BmpFlag,
				RgbImage,
				AlphaImage,
				SrcRect,
				DestX,
				DestY,
				GrHandle ) ;
}

// BltBmpOrGraphImageToDivGraph の内部関数
extern int BltBmpOrGraphImageToDivGraphBase(
	const COLORDATA *BmpColorData,
	HBITMAP RgbBmp,
	HBITMAP AlphaBmp,
	int BmpFlag,
	const BASEIMAGE *RgbImage,
	const BASEIMAGE *AlphaImage,
	int AllNum,
	int XNum,
	int /*YNum*/,
	int Width,
	int Height,
	const int *GrHandle,
	int ReverseFlag,
	int UseTransColorConvAlpha,
	int ASyncThread
)
{
	IMAGEDATA2 *Image2, *DivImage2 ;
	IMAGEDATA2_ORIG *Orig ;
	RECT Rect ;
	int i, Count, x, y ;

	if( GRA2.InitializeFlag == FALSE ) return -1 ;

	// エラー判定
	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( GrHandle[ 0 ], Image2 ) )
			return -1 ;
	}
	else
	{
		if( GRAPHCHK( GrHandle[ 0 ], Image2 ) )
			return -1 ;
	}
	Orig = Image2->Orig ;

	// 最初の画像にファイル情報をセット
	Image2->UseBaseX = 0 ;
	Image2->UseBaseY = 0 ;

	// ファイルに情報をセットしながらすべての画像が同じ
	// オリジナル画像を使用しているか調べる
	Count = 1 ;
	x = 0 ;
	y = 0 ;
	for( i = 1 ; i < AllNum ; i ++ )
	{
		// 画像情報のアドレスを取得
		if( ASyncThread )
		{
			if( GRAPHCHK_ASYNC( GrHandle[ i ], DivImage2 ) )
				return -1 ;
		}
		else
		{
			if( GRAPHCHK( GrHandle[ i ], DivImage2 ) )
				return -1 ;
		}

		// 同じオリジナル画像を使用しているかどうか調べる
		if( DivImage2->Orig == Orig ) Count ++ ;

		// ファイル情報をセット
		DivImage2->UseBaseX = ReverseFlag ? ( ( XNum - 1 ) - x ) * Width : x * Width ;
		DivImage2->UseBaseY = y * Height ;
		x ++ ;
		if( x == XNum )
		{
			x = 0 ;
			y ++ ;
		}
	}

	// すべてのグラフィックハンドルが同じオリジナル画像を
	// 使用しているかどうかで処理を分岐
	if( AllNum == Count )
	{
		// 同じオリジナル画像を使用している場合

		// オリジナル画像を最初のグラフィックハンドルに転送
		Rect.left   = 0 ;
		Rect.right  = Image2->Orig->Width ;
		Rect.top    = 0 ;
		Rect.bottom = Image2->Orig->Height ;
		BltBmpOrBaseImageToGraph3(
			BmpColorData,
			RgbBmp, AlphaBmp,
			&Rect,
			0, 0,
			GrHandle[ 0 ],
			BmpFlag,
			RgbImage, AlphaImage,
			Orig->FormatDesc.BlendGraphFlag,
			UseTransColorConvAlpha,
			TRUE,
			ASyncThread
		) ;
	}
	else
	{
		// 同じオリジナル画像を使用していない場合

		// すべてのグラフィックハンドルに個別に転送する
		for( i = 0 ; i < AllNum ; i ++ )
		{
			// 画像情報のアドレスを取得
			if( ASyncThread )
			{
				if( GRAPHCHK_ASYNC( GrHandle[ i ], DivImage2 ) )
					return -1 ;
			}
			else
			{
				if( GRAPHCHK( GrHandle[ i ], DivImage2 ) )
					return -1 ;
			}

			// 転送元矩形のセット
			Rect.left = DivImage2->UseBaseX ;
			Rect.top  = DivImage2->UseBaseY ;
			Rect.right = Rect.left + DivImage2->Width ;
			Rect.bottom = Rect.top + DivImage2->Height ;

			// 画像を転送
			BltBmpOrBaseImageToGraph3(
				BmpColorData,
				RgbBmp, AlphaBmp,
				&Rect,
				0, 0,
				GrHandle[ i ],
				BmpFlag,
				RgbImage, AlphaImage,
				Orig->FormatDesc.BlendGraphFlag,
				UseTransColorConvAlpha,
				FALSE,
				ASyncThread
			) ;
		}
	}

	// 終了
	return 0 ;
}

// 分割画像への ＢＭＰ か GraphImage の転送
extern	int NS_BltBmpOrGraphImageToDivGraph(
	const COLORDATA *BmpColorData,
	HBITMAP RgbBmp,
	HBITMAP AlphaBmp,
	int BmpFlag,
	const BASEIMAGE *RgbImage,
	const BASEIMAGE *AlphaImage,
	int AllNum,
	int XNum,
	int YNum,
	int Width,
	int Height,
	const int *GrHandle,
	int ReverseFlag )
{
	int Result ;
	int i ;

	if( GRA2.InitializeFlag == FALSE ) return -1 ;

	// 転送処理
	Result = BltBmpOrGraphImageToDivGraphBase( BmpColorData, RgbBmp, AlphaBmp, BmpFlag, RgbImage, AlphaImage, AllNum, XNum, YNum, Width, Height, GrHandle, ReverseFlag, GBASE.NotUseTransColor ? FALSE : TRUE, FALSE ) ;

	// 最初の画像にファイル情報をセット
	if( BmpFlag )
	{
		SetGraphBaseInfo( GrHandle[ 0 ], NULL, BmpColorData, RgbBmp, AlphaBmp, NULL, 0, NULL, 0, NULL, NULL, FALSE, -1, FALSE ) ;
	}
	else
	{
		SetGraphBaseInfo( GrHandle[ 0 ], NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, RgbImage, AlphaImage, FALSE, -1, FALSE ) ;
	}
	for( i = 1 ; i < AllNum ; i ++ )
	{
		SetGraphBaseInfo( GrHandle[ i ], NULL, NULL, NULL, NULL, NULL, 0, NULL, 0, NULL, NULL, FALSE, GrHandle[ 0 ], FALSE ) ;
	}

	// 終了
	return Result ;
}






#ifndef DX_NON_MOVIE

extern int LoadBmpToGraph_OpenMovie_UseGParam(
	LOADGRAPH_GPARAM *GParam,
	int GrHandle,
	const TCHAR *GraphName,
	int TextureFlag,
	int SurfaceMode,
	int ASyncThread
)
{
	int MovieHandle ;
	int Width, Height ;
	MOVIEGRAPH *Movie;
	IMAGEDATA2 *Image2 ;

	// ムービーグラフィックとして扱おうとしてみる
	MovieHandle = OpenMovie_UseGParam( &GParam->OpenMovieGParam, GraphName, &Width, &Height, SurfaceMode, ASyncThread ) ;
	if( MovieHandle < 0 )
	{
		DXST_ERRORLOGFMT_ADD(( _T( "右記のグラフィックファイルのロードに失敗しました：%s \n" ), GraphName )) ;
		return -1 ;
	}

	Movie = GetMovieData( MovieHandle );

	// 画面のカラービットデプスと対応するようにセット、及びＶＲＡＭ未使用セット
	GParam->CreateGraphGParam.InitHandleGParam.CreateImageColorBitDepth = NS_GetColorBitDepth() ;
	GParam->CreateGraphGParam.InitHandleGParam.AlphaChannelImageCreateFlag = Movie->A8R8G8B8Flag && Movie->TheoraFlag == FALSE && Movie->pMovieImage->ImageType == 1 ;
	GParam->CreateGraphGParam.InitHandleGParam.CreateImageChannelBitDepth = 0 ;
	GParam->CreateGraphGParam.InitHandleGParam.NotUseDivFlag = TRUE ;
	GParam->CreateGraphGParam.InitHandleGParam.AlphaTestImageCreateFlag = FALSE ;
	GParam->CreateGraphGParam.InitHandleGParam.CubeMapTextureCreateFlag = FALSE ;
	GParam->CreateGraphGParam.InitHandleGParam.UseManagedTextureFlag = FALSE ;
#ifndef DX_NON_OGGTHEORA
	if( Movie->TheoraFlag && Movie->RightAlpha == FALSE )
	{
		GParam->CreateGraphGParam.InitHandleGParam.DrawValidImageCreateFlag = TRUE ;
	}
#endif

	// 読みこんだビットマップのサイズのグラフィックデータを作成する
	// 右側半分をαチャンネルとして扱う場合はαチャンネル付き画像にする
	if( SetupGraphHandle_UseGParam(
			&GParam->CreateGraphGParam.InitHandleGParam,
			GrHandle,
			Movie->RightAlpha ? Width / 2 : Width,
			Height,
			TextureFlag,
			Movie->RightAlpha || GParam->CreateGraphGParam.InitHandleGParam.AlphaChannelImageCreateFlag,
			FALSE,
			DX_BASEIMAGE_FORMAT_NORMAL,
			-1,
			ASyncThread
		) == -1 )
	{
		DXST_ERRORLOGFMT_ADD(( _T( "右記のグラフィックファイルの格納用グラフィック領域の作成に失敗しました：%s" ), GraphName )) ;
		return -1 ;
	}

	Image2 = GetGraphData2( GrHandle, ASyncThread ) ;
	if( Image2 )
	{
		// ムービーのハンドルをセット
		Image2->MovieHandle = MovieHandle ;

		// コールバック関数をセット
		SetCallbackMovie( MovieHandle, ( void (*)( MOVIEGRAPH *, void * ) )UpdateGraphMovie, ( void * )( DWORD_PTR )GrHandle ) ;
	}

	// 正常終了
	return 0 ;
}

#endif


// ファイルから読み込んだ画像情報を再度読み込む
extern	int NS_ReloadFileGraphAll( void )
{
	DefaultRestoreGraphFunction() ;

	// 終了
	return 0 ;
}






// 图形绘制相关函数

// 画面の状態を初期化する(ClearDrawScreenの旧名称)
extern int NS_ClsDrawScreen( void )
{
	return NS_ClearDrawScreen() ;
}

// 画面のＺバッファの状態を初期化する
extern int NS_ClearDrawScreenZBuffer( const RECT *ClearRect )
{
	// チェック
	if( ClearRect && ( ClearRect->left < 0 || ClearRect->top < 0 ) )
		ClearRect = NULL ;

	// ハードウエア機能を使っているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// ハードウエアの機能を使っている場合

		if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return 0 ;

		// 描画の終了
		RenderVertexHardware() ;
		EndScene() ;

		// Ｚバッファが存在する場合はＺバッファも初期化する
		if( GRH.ZBufferSurface )
		{
			D_D3DVIEWPORT9 Viewport ;
			D_D3DRECT D3DRect ;

			// ビューポートをサーフェス全体にする
			_MEMSET( &Viewport, 0, sizeof( Viewport ) ) ;
			Viewport.X		= 0 ;
			Viewport.Y		= 0 ;
			Viewport.Width	= GBASE.DrawSizeX ;
			Viewport.Height	= GBASE.DrawSizeY ;
			Viewport.MinZ	= 0.0f ;
			Viewport.MaxZ	= 1.0f ;
			SetViewportHardware( &Viewport ) ;

			// クリア
			if( ClearRect )
			{
				D3DRect.x1 = ClearRect->left ;
				D3DRect.y1 = ClearRect->top ;
				D3DRect.x2 = ClearRect->right ;
				D3DRect.y2 = ClearRect->bottom ;
				GraphicsDevice_Clear( 1, &D3DRect, D_D3DCLEAR_ZBUFFER, 0, 1.0f, 0 ) ;
			}
			else
			{
				GraphicsDevice_Clear( 0, NULL, D_D3DCLEAR_ZBUFFER, 0, 1.0f, 0 ) ;
			}

			// ビューポートの範囲を元に戻す
			Viewport.X		= GBASE.DrawArea.left ;
			Viewport.Y		= GBASE.DrawArea.top ;
			Viewport.Width	= GBASE.DrawArea.right  - GBASE.DrawArea.left ;
			Viewport.Height	= GBASE.DrawArea.bottom - GBASE.DrawArea.top  ;
			SetViewportHardware( &Viewport ) ;
		}
	}
	else
	{
		// ソフトウエアレンダリングの場合は何もしない
	}

	// 終了
	return 0 ;
}

// 画面の状態を初期化する
extern	int NS_ClearDrawScreen( const RECT *ClearRect )
{
//	HRESULT hr ;
//	RECT Rect ;
	IMAGEDATA2 *Image2 = NULL ;
	SHADOWMAPDATA *ShadowMap = NULL ;

	// フルスクリーンマスク処理を行っている場合はマスク描画の結果を反映させる
	MASK_FULLSCREEN_MASKUPDATE

	// チェック
	if( ClearRect && ( ClearRect->left < 0 || ClearRect->top < 0 ) )
		ClearRect = NULL ;

	// 描画先画像の画像情報を取得
	SHADOWMAPCHK( GBASE.TargetScreen[ 0 ], ShadowMap ) ;
	GRAPHCHKFULL( GBASE.TargetScreen[ 0 ], Image2 ) ;

	// ハードウエア機能を使っているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		D_D3DRECT D3DRect ;
		D_D3DVIEWPORT9 Viewport ;
		DWORD ClearColor ;
//		HRESULT hr ;

		// ハードウエアの機能を使っている場合
		DX_DIRECT3DSURFACE9 *TargetSurface ;
		D_D3DFORMAT TargetFormat ;

		if( GraphicsDevice_IsValid() == 0 || GRH.FlipSkipFlag ) return 0 ;

		// 描画の終了
		RenderVertexHardware() ;
		EndScene() ;

		// シャドウマップが使用されている場合はシャドウマップを初期化
		if( ShadowMap )
		{
			TargetSurface = ShadowMap->Surface ;
			TargetFormat = GRH.TextureFormat[ ShadowMap->ColorFormat ] ;
		}
		else
		// 描画可能画像が使用されている場合は描画可能画像を初期化
		if( Image2 )
		{
			TargetSurface = Image2->Orig->Hard.Tex[ 0 ].Surface[ GBASE.TargetScreenSurface[ 0 ] ] ;
			TargetFormat = GRH.TextureFormat[ Image2->Orig->ColorFormat ] ;
		}
		else
		// サブバックバッファが有効になっている場合はサブバックバッファを初期化
		{
			TargetSurface = GRH.SubBackBufferSurface ? GRH.SubBackBufferSurface : GRH.BackBufferSurface ;
			TargetFormat = GRH.ScreenFormat ;
		}

		// 描画対象サーフェスを変更する
#ifndef DX_NON_MASK
		if( MASKD.MaskValidFlag && MASKD.MaskScreenSurface )
		{
			SetRenderTargetHardware( TargetSurface ) ;
		}
#endif

		// ビューポートをサーフェス全体にする
		_MEMSET( &Viewport, 0, sizeof( Viewport ) ) ;
		Viewport.X		= 0 ;
		Viewport.Y		= 0 ;
		Viewport.Width	= GBASE.DrawSizeX ;
		Viewport.Height	= GBASE.DrawSizeY ;
		Viewport.MinZ	= 0.0f ;
		Viewport.MaxZ	= 1.0f ;
		SetViewportHardware( &Viewport ) ;

		// パラメータをセット
		if( ClearRect )
		{
			D3DRect.x1 = ClearRect->left ;
			D3DRect.y1 = ClearRect->top ;
			D3DRect.x2 = ClearRect->right ;
			D3DRect.y2 = ClearRect->bottom ;
		}

//		GraphicsDevice_ColorFill( TargetSurface, NULL, NS_GetColor3( GetD3DFormatColorData( TargetFormat ), GRA2.BackgroundRed, GRA2.BackgroundGreen, GRA2.BackgroundBlue, 0 ) ) ;
//		hr = GraphicsDevice_ColorFill( TargetSurface, ClearRect, ( GRA2.BackgroundRed << 16 ) | ( GRA2.BackgroundGreen << 8 ) | GRA2.BackgroundBlue ) ;
		ClearColor = ( GRA2.BackgroundRed << 16 ) | ( GRA2.BackgroundGreen << 8 ) | GRA2.BackgroundBlue ;
		if( ClearRect )
		{
			GraphicsDevice_Clear( 1, &D3DRect, D_D3DCLEAR_TARGET, ClearColor, 1.0f, 0 ) ;
		}
		else
		{
			GraphicsDevice_Clear( 0, NULL, D_D3DCLEAR_TARGET, ClearColor, 1.0f, 0 ) ;
		}

		// Ｚバッファが存在する場合はＺバッファも初期化する
		if( GRH.ZBufferSurface )
		{
			// クリア
			if( ClearRect )
			{
				GraphicsDevice_Clear( 1, &D3DRect, D_D3DCLEAR_ZBUFFER, 0, 1.0f, 0 ) ;
			}
			else
			{
				GraphicsDevice_Clear( 0, NULL, D_D3DCLEAR_ZBUFFER, 0, 1.0f, 0 ) ;
			}
		}

		// 描画対象サーフェスを元に戻す
#ifndef DX_NON_MASK
		if( MASKD.MaskValidFlag && MASKD.MaskScreenSurface )
		{
			SetRenderTargetHardware( MASKD.MaskScreenSurface ) ;
		}
#endif

		// ビューポートの範囲を元に戻す
		Viewport.X		= GBASE.DrawArea.left ;
		Viewport.Y		= GBASE.DrawArea.top ;
		Viewport.Width	= GBASE.DrawArea.right  - GBASE.DrawArea.left ;
		Viewport.Height	= GBASE.DrawArea.bottom - GBASE.DrawArea.top  ;
		SetViewportHardware( &Viewport ) ;
	}
	else
	{
		// ソフトウエアレンダリングの場合
		MEMIMG *ClearTarget ;

		// 描画可能画像の場合はその画像をクリア
		ClearTarget = Image2 ? &Image2->Soft.MemImg : &GRS.MainBufferMemImg ;
		ClearMemImg( ClearTarget, ClearRect, NS_GetColor3( ClearTarget->Base->ColorDataP, GRA2.BackgroundRed, GRA2.BackgroundGreen, GRA2.BackgroundBlue, 0 ) ) ;
	}

	// 終了
	return 0 ;
}

// メインウインドウのバックグラウンドカラーを設定する
extern int NS_SetBackgroundColor( int Red, int Green, int Blue )
{
	// 色の保存
	GRA2.BackgroundRed   = Red;
	GRA2.BackgroundGreen = Green;
	GRA2.BackgroundBlue  = Blue;

	// バックグラウンドカラーが有効かどうかのフラグを立てる
	GRA2.EnableBackgroundColor = TRUE;

	// 終了
	return 0;
}

// ＢＭＰファイルを読みこんで画面に描画する
extern	int NS_LoadGraphScreen( int x, int y, const TCHAR *GraphName, int TransFlag )
{
	int GrHandle ;
	LOADGRAPH_GPARAM GParam ;
	
	if( GBASE.NotDrawFlag ) return 0 ;

	// グラフィックを読みこむ
	InitLoadGraphGParam( &GParam ) ;
	GrHandle = LoadBmpToGraph_UseGParam( &GParam, FALSE, -1, GraphName, TRUE, FALSE, DX_MOVIESURFACE_NORMAL, FALSE ) ;
	if( GrHandle < 0 ) return -1 ;

	// グラフィックの描画
	NS_DrawGraph( x, y, GrHandle, TransFlag ) ;

	// グラフィックの削除
	NS_DeleteGraph( GrHandle ) ;

	// 終了
	return 0 ;
}

// グラフィックの描画
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, x, y, x + Image2->Width, y + Image2->Height )\
	DRAWRECT_DRAWAREA_CLIP
extern	int NS_DrawGraph( int x, int y, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret ;

	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE ) return -1 ;

	// 非描画設定がされている場合は何もせず終了
	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF( 
		DrawGraphHardware( x, y, ( float )x, ( float )y, Image2, BlendImage2, TransFlag, TRUE ),
		DrawGraphSoftware( x, y,                         Image2,              TransFlag       ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

// グラフィックの描画
extern	int NS_DrawGraphF( float xf, float yf, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret = -1 ;
	int x, y ;

	x = _FTOL( xf ) ;
	y = _FTOL( yf ) ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF(
		DrawGraphHardware( x, y, xf, yf, Image2, BlendImage2, TransFlag, FALSE ),
		DrawGraphSoftware( x, y,         Image2,              TransFlag        ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}
#undef SETDRAWRECTCODE

// グラフィックの拡大縮小描画
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, x1, y1, x2, y2 ) ;\
	if( x1 > x2 ){ GRH.DrawRect.left = x2 ; GRH.DrawRect.right = x1; }\
	if( y1 > y2 ){ GRH.DrawRect.top = y2 ; GRH.DrawRect.bottom = y1; }\
	DRAWRECT_DRAWAREA_CLIP

extern	int NS_DrawExtendGraph( int x1, int y1, int x2, int y2, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret = -1 ;
	
	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// テクスチャの場合とそれ以外で処理を分岐
	DRAW_DEF(
		DrawExtendGraphHardware( x1, y1, x2, y2, (float)x1, (float)y1, (float)x2, (float)y2, Image2, BlendImage2, TransFlag, TRUE ),
		DrawExtendGraphSoftware( x1, y1, x2, y2,                                             Image2,              TransFlag       ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

// グラフィックの拡大縮小描画
extern	int NS_DrawExtendGraphF( float x1f, float y1f, float x2f, float y2f, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret = -1 ;
	int x1, y1, x2, y2 ;
	
	x1 = _FTOL( x1f ) ;
	y1 = _FTOL( y1f ) ;
	x2 = _FTOL( x2f ) ;
	y2 = _FTOL( y2f ) ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF(
		DrawExtendGraphHardware( x1, y1, x2, y2, x1f, y1f, x2f, y2f, Image2, BlendImage2, TransFlag, FALSE ),
		DrawExtendGraphSoftware( x1, y1, x2, y2,                     Image2,              TransFlag        ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE


// グラフィックの回転描画
#define SETDRAWRECTCODE\
	int Width, Height ;\
	int i ;\
	float SinF, CosF ;\
	double xb, Lx, Ly ;\
	double px[4], py[4] ;\
	double Sin, Cos ;\
	double MaxMin[4] ; /* 0:MinX 1:MinY 2:MaxX 3:MaxY */\
\
	Lx = x ; Ly = y ;\
\
	_SINCOS( (float)Angle, &SinF, &CosF ) ;\
	Sin = (double)SinF ;\
	Cos = (double)CosF ;\
\
	Width = Image2->Width / 2 ;\
	Height = Image2->Height / 2 ;\
\
	px[0] = -Width ;				py[0] = -Height ;\
	px[1] = Image2->Width - Width ;	py[1] = -Height ;\
	px[2] = -Width ;				py[2] = Image2->Height - Height ;\
	px[3] = Image2->Width - Width ;	py[3] = Image2->Height - Height ;\
\
	xb = px[0] ;\
	px[0] = ( xb * Cos - py[0] * Sin ) * ExRate + Lx ;\
	py[0] = ( xb * Sin + py[0] * Cos ) * ExRate + Ly ;\
	MaxMin[0] = px[0] ;\
	MaxMin[1] = py[0] ;\
	MaxMin[2] = px[0] ;\
	MaxMin[3] = py[0] ;\
	for( i = 1 ; i < 4 ; i ++ )\
	{\
		xb = px[i] ;\
		px[i] = ( xb * Cos - py[i] * Sin ) * ExRate + Lx ;\
		py[i] = ( xb * Sin + py[i] * Cos ) * ExRate + Ly ;\
\
		if( MaxMin[0] > px[i] ) MaxMin[0] = px[i];\
		if( MaxMin[2] < px[i] ) MaxMin[2] = px[i];\
		if( MaxMin[1] > py[i] ) MaxMin[1] = py[i];\
		if( MaxMin[3] < py[i] ) MaxMin[3] = py[i];\
	}\
\
	MaxMin[0] -= 5.0F ; MaxMin[1] -= 5.0F ;\
	MaxMin[2] += 5.0F ; MaxMin[3] += 5.0F ; \
\
	_DTOL4( MaxMin, (int *)&GRH.DrawRect ) ;\
	DRAWRECT_DRAWAREA_CLIP

extern	int NS_DrawRotaGraph( int x, int y, double ExRate, double Angle, int GrHandle, int TransFlag, int TurnFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret = -1 ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF(
		DrawRotaGraphHardware( x, y, (float)x, (float)y, ExRate, Angle, Image2, BlendImage2, TransFlag, TurnFlag, TRUE ),
		DrawRotaGraphSoftware(       (float)x, (float)y, ExRate, Angle, Image2,              TransFlag, TurnFlag       ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

// グラフィックの回転描画
extern	int NS_DrawRotaGraphF( float xf, float yf, double ExRate, double Angle, int GrHandle, int TransFlag, int TurnFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret = -1 ;
	int x, y ;
	
	x = _FTOL( xf ) ;
	y = _FTOL( yf ) ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF(
		DrawRotaGraphHardware( x, y, xf, yf, ExRate, Angle, Image2, BlendImage2, TransFlag, TurnFlag, FALSE ),
		DrawRotaGraphSoftware(       xf, yf, ExRate, Angle, Image2,              TransFlag, TurnFlag        ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// グラフィックの回転描画２
extern	int NS_DrawRotaGraph2( int x, int y, int cx, int cy, double ExtRate, double Angle, int GrHandle, int TransFlag, int TurnFlag )
{
	int w, h ;

	NS_GetGraphSize( GrHandle, &w,&h ) ;

	if( Angle == 0.0 && ExtRate == 1.0 )
	{
		if( TurnFlag )	return NS_DrawTurnGraph( x - cx, y - cy, GrHandle, TransFlag ) ;
		else			return NS_DrawGraph( x - cx, y - cy, GrHandle, TransFlag ) ;
	}
	else
	{
		return NS_DrawRotaGraph2F( ( float )x, ( float )y, ( float )cx, ( float )cy, ExtRate, Angle, GrHandle, TransFlag, TurnFlag ) ;
	}
}

// グラフィックの回転描画２
extern	int NS_DrawRotaGraph2F( float xf, float yf, float cxf, float cyf, double ExtRate, double Angle, int GrHandle, int TransFlag, int TurnFlag )
{
#if 1
	int w, h ;

	NS_GetGraphSize( GrHandle, &w,&h ) ;

	if( Angle == 0.0 )
	{
		if( ExtRate == 1.0 )
		{
			if( TurnFlag )	return NS_DrawTurnGraphF( xf - cxf, yf - cyf, GrHandle, TransFlag ) ;
			else			return NS_DrawGraphF( xf - cxf, yf - cyf, GrHandle, TransFlag ) ;
		}
		else
		{
			float numF[ 4 ] ;

			numF[ 0 ] = xf - ( cxf * ( float )ExtRate ) ;
			numF[ 1 ] = yf - ( cyf * ( float )ExtRate ) ;
			numF[ 2 ] = numF[ 0 ] + ( w * ( float )ExtRate ) ;
			numF[ 3 ] = numF[ 1 ] + ( h * ( float )ExtRate ) ;
			if( TurnFlag )
			{
				float d ;

				d = numF[ 0 ] ; numF[ 0 ] = numF[ 2 ] ; numF[ 2 ] = d ;
			}
			return NS_DrawExtendGraphF( numF[0], numF[1],
										numF[2], numF[3],
										 GrHandle, TransFlag ) ;
		}
	}
	else
	{
		float dcx, dcy ;
		float Sin, Cos ;
		float bcx, bcy ;

		bcx = ( -cxf + ( float )w * 0.5F ) * ( float )ExtRate ;
		bcy = ( -cyf + ( float )h * 0.5F ) * ( float )ExtRate ;

		_SINCOS( ( float )Angle, &Sin, &Cos ) ;
		dcx = bcx * Cos - bcy * Sin ;
		dcy = bcx * Sin + bcy * Cos ;

		return NS_DrawRotaGraphF( xf + dcx, yf + dcy, ExtRate, Angle, GrHandle, TransFlag, TurnFlag ) ; 
	}
#else
/*
	double xx[4],yy[4];
	int xxi[4], yyi[4] ;
	int w, h, i, Result ;
	double xb, yb, xd, yd ;
	double Sin, Cos ;
	float SinF, CosF ;

	NS_GetGraphSize( GrHandle, &w,&h ) ;

	xx[0] = (   - cx )	* ExtRate ;	yy[0] = (   - cy )	* ExtRate ;
	xx[1] = ( w - cx )	* ExtRate ;	yy[1] = yy[0] ;
	xx[2] = xx[0] ;					yy[2] = ( h - cy )	* ExtRate ;
	xx[3] = xx[1] ;					yy[3] = yy[2] ;

	_SINCOS( (float)Angle, &SinF, &CosF ) ;
	Sin = (double)SinF ;
	Cos = (double)CosF ;
//	Sin = sin( Angle ) ;
//	Cos = cos( Angle ) ;
	xd = (double)x ;
	yd = (double)y ;
	for( i = 0 ; i < 4 ; i ++ )
	{
		xb = xx[i] * Cos - yy[i] * Sin ;
		yb = xx[i] * Sin + yy[i] * Cos ;
		xx[i] = xb + xd ;
		yy[i] = yb + yd ;
	}

	if( TurnFlag )
	{
		double d ;

		d = xx[0] ; xx[0] = xx[1] ; xx[1] = d ;
		d = xx[2] ; xx[2] = xx[3] ; xx[3] = d ;
		d = yy[0] ; yy[0] = yy[1] ; yy[1] = d ;
		d = yy[2] ; yy[2] = yy[3] ; yy[3] = d ;
	}

	_DTOL4( xx, xxi ) ;
	_DTOL4( yy, yyi ) ;
	Result = NS_DrawModiGraph( xxi[0],yyi[0], xxi[1],yyi[1], xxi[3],yyi[3], xxi[2],yyi[2], GrHandle, TransFlag ) ;

	return Result ;
*/
#endif
}

// グラフィックの回転描画３
extern	int NS_DrawRotaGraph3( int x, int y, int cx, int cy, double ExtRateX, double ExtRateY, double Angle, int GrHandle, int TransFlag, int TurnFlag )
{
	if( Angle == 0.0 && ExtRateX == 1.0 && ExtRateY == 1.0 )
	{
		int w, h ;

		NS_GetGraphSize( GrHandle, &w,&h ) ;

		if( TurnFlag )	return NS_DrawTurnGraph( x - cx, y - cy, GrHandle, TransFlag ) ;
		else			return NS_DrawGraph( x - cx, y - cy, GrHandle, TransFlag ) ;
	}
	else
	{
		return NS_DrawRotaGraph3F( ( float )x, ( float )y, ( float )cx, ( float )cy, ExtRateX, ExtRateY, Angle, GrHandle, TransFlag, TurnFlag ) ;
	}
}

// グラフィックの回転描画３
extern	int NS_DrawRotaGraph3F( float xf, float yf, float cxf, float cyf, double ExtRateX, double ExtRateY, double Angle, int GrHandle, int TransFlag, int TurnFlag )
{
	int w, h ;

	NS_GetGraphSize( GrHandle, &w,&h ) ;

	if( Angle == 0.0 )
	{
		if( ExtRateX == 1.0 && ExtRateY == 1.0 )
		{
			if( TurnFlag )	return NS_DrawTurnGraphF( xf - cxf, yf - cyf, GrHandle, TransFlag ) ;
			else			return NS_DrawGraphF( xf - cxf, yf - cyf, GrHandle, TransFlag ) ;
		}
		else
		{
			float numF[ 4 ] ;

			numF[ 0 ] = xf - ( cxf * ( float )ExtRateX ) ;
			numF[ 1 ] = yf - ( cyf * ( float )ExtRateY ) ;
			numF[ 2 ] = numF[ 0 ] + ( w * ( float )ExtRateX ) ;
			numF[ 3 ] = numF[ 1 ] + ( h * ( float )ExtRateY ) ;
			if( TurnFlag )
			{
				float d ;

				d = numF[ 0 ] ; numF[ 0 ] = numF[ 2 ] ; numF[ 2 ] = d ;
			}
			return NS_DrawExtendGraphF( numF[0], numF[1],
										numF[2], numF[3],
										 GrHandle, TransFlag ) ;
		}
	}
	else
	{
		if( ExtRateX == 1.0 && ExtRateY == 1.0 )
		{
			float dcx, dcy ;
			float Sin, Cos ;
			float bcx, bcy ;

			bcx = ( -cxf + ( float )w * 0.5F ) ;
			bcy = ( -cyf + ( float )h * 0.5F ) ;

			_SINCOS( ( float )Angle, &Sin, &Cos ) ;
			dcx = bcx * Cos - bcy * Sin ;
			dcy = bcx * Sin + bcy * Cos ;

			return NS_DrawRotaGraphF( xf + dcx, yf + dcy, 1.0, Angle, GrHandle, TransFlag, TurnFlag ) ; 
		}
		else
		{
			float xx[ 4 ], yy[ 4 ] ;
			int w, h, i ;
			float SinF, CosF ;
			float xb, yb ;

			NS_GetGraphSize( GrHandle, &w,&h ) ;

			xx[0] = (   - cxf )	* ( float )ExtRateX ;	yy[0] = (   - cyf )	* ( float )ExtRateY ;
			xx[1] = ( w - cxf )	* ( float )ExtRateX ;	yy[1] = yy[0] ;
			xx[2] = xx[0] ;								yy[2] = ( h - cyf )	* ( float )ExtRateY ;
			xx[3] = xx[1] ;								yy[3] = yy[2] ;

			_SINCOS( ( float )Angle, &SinF, &CosF ) ;
			for( i = 0 ; i < 4 ; i ++ )
			{
				xb = xx[ i ] * CosF - yy[ i ] * SinF ;
				yb = xx[ i ] * SinF + yy[ i ] * CosF ;
				xx[ i ] = xb + xf ;
				yy[ i ] = yb + yf ;
			}

			if( TurnFlag )
			{
				float d ;

				d = xx[ 0 ] ; xx[ 0 ] = xx[ 1 ] ; xx[ 1 ] = d ;
				d = xx[ 2 ] ; xx[ 2 ] = xx[ 3 ] ; xx[ 3 ] = d ;
				d = yy[ 0 ] ; yy[ 0 ] = yy[ 1 ] ; yy[ 1 ] = d ;
				d = yy[ 2 ] ; yy[ 2 ] = yy[ 3 ] ; yy[ 3 ] = d ;
			}

			return DrawModiGraphFBase( xx[0], yy[0], xx[1], yy[1], xx[3], yy[3], xx[2], yy[2], GrHandle, TransFlag, true ) ;
		}
	}
}

#define SETDRAWRECTCODE\
	int x[ 4 ], y[ 4 ], MaxX, MaxY, MinX, MinY ;\
	int i, ix, iy ;\
\
	x[ 0 ] = x1 ; x[ 1 ] = x2 ; x[ 2 ] = x3 ; x[ 3 ] = x4 ;\
	y[ 0 ] = y1 ; y[ 1 ] = y2 ; y[ 2 ] = y3 ; y[ 3 ] = y4 ;\
\
	MaxX = 0 ; MaxY = 0 ;\
	MinX = 0xffffff ; MinY = 0xffffff ;\
\
	for( i = 0 ; i < 4 ; i ++ )\
	{\
		ix = x[ i ] ; iy = y[ i ] ;\
		if( ix > MaxX ) MaxX = ix ; if( iy > MaxY ) MaxY = iy ;\
		if( ix < MinX ) MinX = ix ; if( iy < MinY ) MinY = iy ;\
	}\
\
	SETRECT( GRH.DrawRect, MinX, MinY, MaxX, MaxY ) ;\
	DRAWRECT_DRAWAREA_CLIP

static int DrawModiGraphBase( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int GrHandle, int TransFlag, bool SimpleDrawFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret = -1 ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF(
		DrawModiGraphHardware( x1, y1, x2, y2, x4, y4, x3, y3, Image2, BlendImage2, TransFlag, SimpleDrawFlag ),
		DrawModiGraphSoftware( x1, y1, x2, y2, x4, y4, x3, y3, Image2,              TransFlag                 ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// 画像の自由変形描画
extern	int NS_DrawModiGraph( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int GrHandle, int TransFlag )
{
	return DrawModiGraphBase( x1, y1, x2, y2, x3, y3, x4, y4, GrHandle, TransFlag, false ) ;
}

#define SETDRAWRECTCODE\
	int x[4], y[4], MaxX, MaxY, MinX, MinY ;\
	int i, ix, iy ;\
\
	x[ 0 ] = _FTOL( x1 ) ; x[ 1 ] = _FTOL( x2 ) ; x[ 2 ] = _FTOL( x3 ) ; x[ 3 ] = _FTOL( x4 ) ;\
	y[ 0 ] = _FTOL( y1 ) ; y[ 1 ] = _FTOL( y2 ) ; y[ 2 ] = _FTOL( y3 ) ; y[ 3 ] = _FTOL( y4 ) ;\
\
	MaxX = 0 ; MaxY = 0 ;\
	MinX = 0xffffff ; MinY = 0xffffff ;\
\
	for( i = 0 ; i < 4 ; i ++ )\
	{\
		ix = x[ i ] ; iy = y[ i ] ;\
		if( ix > MaxX ) MaxX = ix ; if( iy > MaxY ) MaxY = iy ;\
		if( ix < MinX ) MinX = ix ; if( iy < MinY ) MinY = iy ;\
	}\
\
	SETRECT( GRH.DrawRect, MinX, MinY, MaxX, MaxY ) ;

static int DrawModiGraphFBase( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, int GrHandle, int TransFlag, bool SimpleDrawFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret = -1 ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF(
		DrawModiGraphFHardware( x1, y1, x2, y2, x4, y4, x3, y3, Image2, BlendImage2, TransFlag, SimpleDrawFlag ),
		DrawModiGraphFSoftware( x1, y1, x2, y2, x4, y4, x3, y3, Image2,              TransFlag                 ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// 画像の自由変形描画( float 版 )
extern	int NS_DrawModiGraphF( float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, int GrHandle, int TransFlag )
{
	return DrawModiGraphFBase( x1, y1, x2, y2, x3, y3, x4, y4, GrHandle, TransFlag, false ) ;
}

// 画像の左右反転描画
extern	int NS_DrawTurnGraph( int x, int y, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	return NS_DrawExtendGraph( Image2->Width + x, y, x, y + Image2->Height, GrHandle, TransFlag ) ;
}

// 画像の左右反転描画
extern	int NS_DrawTurnGraphF( float xf, float yf, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	return NS_DrawExtendGraphF( Image2->Width + xf, yf, xf, yf + Image2->Height, GrHandle, TransFlag ) ;
}

// チップグラフィックを使ったマップ描画
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, Sx, Sy, Sx + XNum * Image2->Width , Sy + YNum * Image2->Height )\
	DRAWRECT_DRAWAREA_CLIP
extern	int NS_DrawChipMap( int Sx, int Sy, int XNum, int YNum, const int *MapData, int ChipTypeNum, int MapDataPitch, const int *ChipGrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret = -1 ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( ChipGrHandle[0], Image2 ) )
		return -1 ;

	// 描画
	DRAW_DEF(
		DrawChipMapHardware( Sx, Sy, XNum, YNum, MapData, MapDataPitch, ChipTypeNum, ChipGrHandle, TransFlag ),
		DrawChipMapSoftware( Sx, Sy, XNum, YNum, MapData, MapDataPitch, ChipTypeNum, ChipGrHandle, TransFlag ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}
#undef SETDRAWRECTCODE

// チップグラフィックを使ったマップ描画
// int MapWidth, MapHeight : マップデータ全体の幅と高さ
// int *MapData : マップデータが格納されたアドレス
// int ChipTypeNum : マップに使うチップの種類の数
// int *ChipGrHandle : チップのグラフィック配列のアドレス
// int TransFlag : 透過色処理の有無
// int MapDrawX, MapDrawY : 描画するマップの起点となる左上座標
// int MapDrawWidth, MapDrawHeight : 起点座標から描画するマップの幅と高さ
// int ScreenX, ScreenY : マップを描画する画面上の座標
extern	int NS_DrawChipMap( int MapWidth, int MapHeight, const int *MapData, int ChipTypeNum, const int *ChipGrHandle, int TransFlag, int MapDrawPointX, int MapDrawPointY, int MapDrawWidth, int MapDrawHeight, int ScreenX, int ScreenY )
{
	int Width, Height ;
	int Result ;
	
	// チップグラフィックのサイズを得る
	NS_GetGraphSize( ChipGrHandle[0], &Width, &Height ) ;

	// マップ情報がはみ出る場合の補正処理
	if( MapDrawPointX + MapDrawWidth > MapWidth ) 
		MapDrawWidth -= ( MapDrawPointX + MapDrawWidth ) - MapWidth ;

	if( MapDrawPointY + MapDrawHeight > MapHeight ) 
		MapDrawHeight -= ( MapDrawPointY + MapDrawHeight ) - MapHeight ; 

	if( MapDrawPointX < 0 )
	{
		ScreenX = -MapDrawPointX * Width ;
		MapDrawWidth += MapDrawPointX ; 
		MapDrawPointX = 0 ;
	}
	if( MapDrawPointY < 0 )
	{
		ScreenY = -MapDrawPointY * Height ;
		MapDrawHeight += MapDrawPointY ; 
		MapDrawPointY = 0 ;
	}

	// マップを描く
	Result = NS_DrawChipMap( ScreenX, ScreenY, MapDrawWidth, MapDrawHeight,
							 MapData + MapDrawPointX + MapDrawPointY * MapWidth, MapWidth, ChipTypeNum, ChipGrHandle, TransFlag ) ;
						 
	return Result ;
}

// グラフィックを指定領域にタイル状に描画する
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, x1, y1, x2, y2 )\
	DRAWRECT_DRAWAREA_CLIP
extern	int NS_DrawTile( int x1, int y1, int x2, int y2, int Tx, int Ty, double ExtRate, double Angle, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret = -1 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	if( x1 == x2 || y1 == y2 ) return 0 ;

	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;
	}

	// 描画
	DRAW_DEF(
		DrawTileHardware( x1, y1, x2, y2, Tx, Ty, ExtRate, Angle, Image2, BlendImage2, TransFlag ),
		DrawTileSoftware( x1, y1, x2, y2, Tx, Ty, ExtRate, Angle, Image2,              TransFlag ),
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}
#undef SETDRAWRECTCODE

// グラフィックの指定矩形部分のみを描画
extern	int NS_DrawRectGraph( int DestX, int DestY, int SrcX, int SrcY, int Width, int Height, int GraphHandle, int TransFlag, int TurnFlag )
{
	RECT MotoDrawRect ;
	RECTF MotoDrawRectF ;
	int hr ;

	// サイズ判定
	if( Width <= 0 || Height <= 0 )
		return -1 ;

	// 指定矩形だけしか描画出来ないようにする
	MotoDrawRect = GBASE.DrawArea ;
	MotoDrawRectF = GBASE.DrawAreaF ;
	SETRECT( GBASE.DrawArea, DestX, DestY, DestX + Width, DestY + Height ) ;
	RectClipping( &GBASE.DrawArea, &MotoDrawRect ) ;
	SetMemImgDrawArea( &GBASE.DrawArea ) ;
	GBASE.DrawAreaF.left   = ( float )GBASE.DrawArea.left ;
	GBASE.DrawAreaF.top    = ( float )GBASE.DrawArea.top ;
	GBASE.DrawAreaF.right  = ( float )GBASE.DrawArea.right ;
	GBASE.DrawAreaF.bottom = ( float )GBASE.DrawArea.bottom ;

	// グラフィックの描画
	if( TurnFlag )
	{
		IMAGEDATA2 *Image2 ;

		// エラー判定
		if( GRAPHCHK( GraphHandle, Image2 ) )
			return -1 ;

		hr = NS_DrawTurnGraph( DestX - ( Image2->Width - SrcX - Width ), DestY - SrcY, GraphHandle, TransFlag ) ;
	}
	else
	{
		hr = NS_DrawGraph( DestX - SrcX, DestY - SrcY, GraphHandle, TransFlag ) ;
	}

	// 描画矩形を元に戻す
	GBASE.DrawArea = MotoDrawRect ;
	SetMemImgDrawArea( &MotoDrawRect ) ;
	GBASE.DrawAreaF = MotoDrawRectF ;

	// 終了
	return hr ;
}

// グラフィックの指定矩形部分のみを拡大描画
extern	int NS_DrawRectExtendGraph( int DestX1, int DestY1, int DestX2, int DestY2, int SrcX, int SrcY, int SrcWidth, int SrcHeight, int GraphHandle, int TransFlag )
{
	RECT MotoDrawRect ;
	RECTF MotoDrawRectF ;
	int hr, tmp ;
	int x1, y1, x2, y2 ;	
	bool RevX, RevY ;
	int DestWidth, DestHeight ;
	double exX, exY ;
	IMAGEDATA2 *Image2 ;

	// サイズ判定
	if( SrcWidth <= 0 || SrcHeight <= 0 )
		return -1 ;
	
	// エラー判定
	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	// 反転判定
	{
		if( DestX2 < DestX1 )
		{
			RevX = true ;
			tmp = DestX1 ; DestX1 = DestX2 ; DestX2 = tmp ;
		}
		else
		{
			RevX = false ;
		}
		
		if( DestY2 < DestY1 )
		{
			RevY = true ;
			tmp = DestY1 ; DestY1 = DestY2 ; DestY2 = tmp ;
		}
		else
		{
			RevY = false ;
		}
	}

	// 指定矩形だけしか描画出来ないようにする
	MotoDrawRect = GBASE.DrawArea ;
	MotoDrawRectF = GBASE.DrawAreaF ;
	SETRECT( GBASE.DrawArea, DestX1, DestY1, DestX2, DestY2 ) ;
	RectClipping( &GBASE.DrawArea, &MotoDrawRect ) ;
	SetMemImgDrawArea( &GBASE.DrawArea ) ;
	GBASE.DrawAreaF.left   = (float)GBASE.DrawArea.left ;
	GBASE.DrawAreaF.top    = (float)GBASE.DrawArea.top ;
	GBASE.DrawAreaF.right  = (float)GBASE.DrawArea.right ;
	GBASE.DrawAreaF.bottom = (float)GBASE.DrawArea.bottom ;

	// グラフィックの描画
	{
		DestWidth = DestX2 - DestX1 ;
		DestHeight = DestY2 - DestY1 ;
		exX = (double)DestWidth / SrcWidth ;
		exY = (double)DestHeight / SrcHeight ;
		if( RevX == true )
		{
			x1 = DestX2 + _DTOL( SrcX * exX ) ;
			x2 = DestX2 - _DTOL( ( Image2->Width - SrcX ) * exX ) ;
		}
		else
		{
			x1 = DestX1 - _DTOL( SrcX * exX ) ;
			x2 = DestX1 + _DTOL( ( Image2->Width - SrcX ) * exX ) ;
		}

		if( RevY == true )
		{
			y1 = DestY2 + _DTOL( SrcY * exY ) ;
			y2 = DestY2 - _DTOL( ( Image2->Height - SrcY ) * exY ) ;
		}
		else
		{
			y1 = DestY1 - _DTOL( SrcY * exY ) ;
			y2 = DestY1 + _DTOL( ( Image2->Height - SrcY ) * exY ) ;
		}
		hr = NS_DrawExtendGraph( x1, y1, x2, y2, GraphHandle, TransFlag ) ;
	}

	// 描画矩形を元に戻す
	GBASE.DrawArea = MotoDrawRect ;
	SetMemImgDrawArea( &MotoDrawRect ) ;
	GBASE.DrawAreaF = MotoDrawRectF ;

	// 終了
	return hr ;
}




// ２Ｄポリゴンを描画する
#define SETDRAWRECTCODE\
	float MinX, MinY, MaxX, MaxY ;\
	const VERTEX *Vert ;\
\
	MinX =  100000000.0F ;\
	MinY =  100000000.0F ;\
	MaxX = -100000000.0F ;\
	MaxY = -100000000.0F ;\
	Vert = Vertex ;\
	for( i = 0 ; i < VertexNum ; i ++, Vert ++ )\
	{\
		if( Vert->x - 1.0F < MinX ) MinX = Vert->x - 1.0F ;\
		if( Vert->x + 1.0F > MaxX ) MaxX = Vert->x + 1.0F ;\
\
		if( Vert->y - 1.0F < MinY ) MinY = Vert->y - 1.0F ;\
		if( Vert->y + 1.0F > MaxY ) MaxY = Vert->y + 1.0F ;\
	}\
\
	GRH.DrawRect.left   = _FTOL( MinX ) ;\
	GRH.DrawRect.top    = _FTOL( MinY ) ;\
	GRH.DrawRect.right  = _FTOL( MaxX ) ;\
	GRH.DrawRect.bottom = _FTOL( MaxY ) ;\
	DRAWRECT_DRAWAREA_CLIP

extern	int NS_DrawPolygonBase( const VERTEX *Vertex, int VertexNum, int PrimitiveType, int GrHandle, int TransFlag, int UVScaling )
{
	IMAGEDATA2 *Image2 ;
	VERTEX_2D *TransVert = NULL ;
	VERTEX_2D *DestP ;
	int Ret, i, Flag ;
	float UPos = 0.0f, VPos = 0.0f, UScale = 1.0f, VScale = 1.0f ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;

		Flag = Image2->Orig->FormatDesc.TextureFlag ;

		// 画像のサイズが最初から２のｎ乗だったらＵＶ補正はしない
		if( UVScaling )
		{
			if( Image2->Orig->FormatDesc.TextureFlag == FALSE ||
				( Image2->Hard.DrawNum == 1 && 
				  Image2->Hard.Draw->Tex->TexWidth  == Image2->Hard.Draw->Width &&
				  Image2->Hard.Draw->Tex->TexHeight == Image2->Hard.Draw->Height ) )
			{
				UVScaling = FALSE ;
			}
		}
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
		UVScaling = FALSE ;
	}

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// UVスケーリングを行う場合はここでデータを算出する
	if( UVScaling )
	{
		UPos = ( float )Image2->Hard.Draw->UsePosX  / Image2->Hard.Draw->Tex->TexWidth ;
		VPos = ( float )Image2->Hard.Draw->UsePosY  / Image2->Hard.Draw->Tex->TexHeight ;
		UScale = ( float )Image2->Hard.Draw->Width  / Image2->Hard.Draw->Tex->TexWidth ;
		VScale = ( float )Image2->Hard.Draw->Height / Image2->Hard.Draw->Tex->TexHeight ;
	}

	// 頂点の出力先を確保する
	TransVert = ( VERTEX_2D * )DXALLOC( sizeof( VERTEX_2D ) * VertexNum ) ;
	if( TransVert == NULL ) return -1 ;

	// 頂点変換を行う
	if( GBASE.DrawBright.Red != 255 || GBASE.DrawBright.Green != 255 || GBASE.DrawBright.Blue != 255 ||
		( GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendParam != 255 ) )
	{
		DWORD *RedTable, *GreenTable, *BlueTable, *AlphaTable ;

		// テーブルを用意する
		RedTable   = MemImgManage.RateTable[GBASE.DrawBright.Red] ;
		GreenTable = MemImgManage.RateTable[GBASE.DrawBright.Green] ;
		BlueTable  = MemImgManage.RateTable[GBASE.DrawBright.Blue] ;
		AlphaTable = MemImgManage.RateTable[GBASE.BlendParam] ;
		if( GBASE.BlendMode == DX_BLENDMODE_NOBLEND ) AlphaTable = MemImgManage.RateTable[255] ;

		// 頂点変換する
		if( UVScaling )
		{
			DestP = TransVert ;
			for( i = 0 ; i < VertexNum ; i ++, DestP ++, Vertex ++ )
			{
				DestP->pos.x = Vertex->x ;
				DestP->pos.y = Vertex->y ;
				DestP->pos.z = GBASE.DrawZ ;
				DestP->rhw = 1.0F ;
				((BYTE *)&DestP->color)[0] = (BYTE)BlueTable [Vertex->b] ;
				((BYTE *)&DestP->color)[1] = (BYTE)GreenTable[Vertex->g] ;
				((BYTE *)&DestP->color)[2] = (BYTE)RedTable  [Vertex->r] ;
				((BYTE *)&DestP->color)[3] = (BYTE)AlphaTable[Vertex->a] ;
				DestP->u = Vertex->u * UScale + UPos ;
				DestP->v = Vertex->v * VScale + VPos ;
			}
		}
		else
		{
			DestP = TransVert ;
			for( i = 0 ; i < VertexNum ; i ++, DestP ++, Vertex ++ )
			{
				DestP->pos.x = Vertex->x ;
				DestP->pos.y = Vertex->y ;
				DestP->pos.z = GBASE.DrawZ ;
				DestP->rhw = 1.0F ;
				((BYTE *)&DestP->color)[0] = (BYTE)BlueTable [Vertex->b] ;
				((BYTE *)&DestP->color)[1] = (BYTE)GreenTable[Vertex->g] ;
				((BYTE *)&DestP->color)[2] = (BYTE)RedTable  [Vertex->r] ;
				((BYTE *)&DestP->color)[3] = (BYTE)AlphaTable[Vertex->a] ;
				DestP->u = Vertex->u ;
				DestP->v = Vertex->v ;
			}
		}
	}
	else
	{
		// 頂点変換する
		if( UVScaling )
		{
			DestP = TransVert ;
			for( i = 0 ; i < VertexNum ; i ++, DestP ++, Vertex ++ )
			{
				DestP->pos.x = Vertex->x ;
				DestP->pos.y = Vertex->y ;
				DestP->pos.z = GBASE.DrawZ ;
				DestP->rhw = 1.0F ;
				DestP->color = *( ( DWORD * )&Vertex->b ) ;
				DestP->u = Vertex->u * UScale + UPos ;
				DestP->v = Vertex->v * VScale + VPos ;
			}
		}
		else
		{
			DestP = TransVert ;
			for( i = 0 ; i < VertexNum ; i ++, DestP ++, Vertex ++ )
			{
				DestP->pos.x = Vertex->x ;
				DestP->pos.y = Vertex->y ;
				DestP->pos.z = GBASE.DrawZ ;
				DestP->rhw = 1.0F ;
				DestP->color = *( ( DWORD * )&Vertex->b ) ;
				DestP->u = Vertex->u ;
				DestP->v = Vertex->v ;
			}
		}
	}

	DRAW_DEF(
		DrawPrimitive2DHardware( TransVert, VertexNum, PrimitiveType, Image2, TransFlag, FALSE, FALSE, FALSE, 0 ),
		0,
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	if( TransVert != NULL )
	{
		DXFREE( TransVert ) ;
		TransVert = NULL ;
	}

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// ２Ｄポリゴンを描画する
extern	int NS_DrawPolygon( const VERTEX *Vertex, int PolygonNum, int GrHandle, int TransFlag, int UVScaling )
{
	return NS_DrawPolygonBase( Vertex, PolygonNum * 3, DX_PRIMTYPE_TRIANGLELIST, GrHandle, TransFlag,  UVScaling ) ;
}

// ３Ｄポリゴンを描画する
extern	int NS_DrawPolygon3DBase( const VERTEX_3D *Vertex, int VertexNum, int PrimitiveType, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret, i, Flag ;
	const VERTEX_3D *UseVertex ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 色の変換が必要な場合はここで処理する
	if( GBASE.DrawBright.Red   != 255 ||
		GBASE.DrawBright.Green != 255 ||
		GBASE.DrawBright.Blue  != 255 ||
		( GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendParam != 255 ) )
	{
		DWORD *RedTable, *GreenTable, *BlueTable, *AlphaTable ;
		const VERTEX_3D *sv ;
		VERTEX_3D *dv ;
		int Size ;

		// テーブルを用意する
		RedTable   = MemImgManage.RateTable[GBASE.DrawBright.Red] ;
		GreenTable = MemImgManage.RateTable[GBASE.DrawBright.Green] ;
		BlueTable  = MemImgManage.RateTable[GBASE.DrawBright.Blue] ;
		AlphaTable = MemImgManage.RateTable[GBASE.BlendParam] ;
		if( GBASE.BlendMode == DX_BLENDMODE_NOBLEND ) AlphaTable = MemImgManage.RateTable[255] ;

		// 頂点データを格納するメモリ領域が足りない場合は確保する
		Size = sizeof( VERTEX_3D ) * VertexNum ;
		if( GBASE.TempVertexBufferSize < Size )
		{
			if( GBASE.TempVertexBuffer )
			{
				DXFREE( GBASE.TempVertexBuffer ) ;
				GBASE.TempVertexBufferSize = 0 ;
			}
			GBASE.TempVertexBuffer = DXALLOC( Size ) ;
			if( GBASE.TempVertexBuffer == NULL )
				return -1 ;
			GBASE.TempVertexBufferSize = Size ;
		}

		// 一時バッファに変換しながら転送
		sv = Vertex;
		dv = ( VERTEX_3D * )GBASE.TempVertexBuffer ;
		for( i = 0 ; i < VertexNum ; i ++, sv ++, dv ++ )
		{
			dv->pos = sv->pos ;
			dv->u = sv->u ;
			dv->v = sv->v ;
			dv->b = ( BYTE )BlueTable [ sv->b ] ;
			dv->g = ( BYTE )GreenTable[ sv->g ] ;
			dv->r = ( BYTE )RedTable  [ sv->r ] ;
			dv->a = ( BYTE )AlphaTable[ sv->a ] ;
		}
		UseVertex = ( VERTEX_3D * )GBASE.TempVertexBuffer ;
	}
	else
	{
		UseVertex = Vertex ;
	}
	
	DRAW_DEF(
		DrawPrimitiveHardware( UseVertex, VertexNum, PrimitiveType, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// ３Ｄポリゴンを描画する(インデックス)
extern	int NS_DrawPolygonIndexed3DBase( const VERTEX_3D *Vertex, int VertexNum, const unsigned short *Indices, int IndexNum, int PrimitiveType, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret, i, Flag ;
	const VERTEX_3D *UseVertex ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 色の変換が必要な場合はここで処理する
	if( GBASE.DrawBright.Red   != 255 ||
		GBASE.DrawBright.Green != 255 ||
		GBASE.DrawBright.Blue  != 255 ||
		( GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendParam != 255 ) )
	{
		DWORD *RedTable, *GreenTable, *BlueTable, *AlphaTable ;
		const VERTEX_3D *sv ;
		VERTEX_3D *dv ;
		int Size ;

		// テーブルを用意する
		RedTable   = MemImgManage.RateTable[GBASE.DrawBright.Red] ;
		GreenTable = MemImgManage.RateTable[GBASE.DrawBright.Green] ;
		BlueTable  = MemImgManage.RateTable[GBASE.DrawBright.Blue] ;
		AlphaTable = MemImgManage.RateTable[GBASE.BlendParam] ;
		if( GBASE.BlendMode == DX_BLENDMODE_NOBLEND ) AlphaTable = MemImgManage.RateTable[255] ;

		// 頂点データを格納するメモリ領域が足りない場合は確保する
		Size = sizeof( VERTEX_3D ) * VertexNum ;
		if( GBASE.TempVertexBufferSize < Size )
		{
			if( GBASE.TempVertexBuffer )
			{
				DXFREE( GBASE.TempVertexBuffer ) ;
				GBASE.TempVertexBufferSize = 0 ;
			}
			GBASE.TempVertexBuffer = DXALLOC( Size ) ;
			if( GBASE.TempVertexBuffer == NULL )
				return -1 ;
			GBASE.TempVertexBufferSize = Size ;
		}

		// 一時バッファに変換しながら転送
		sv = Vertex;
		dv = ( VERTEX_3D * )GBASE.TempVertexBuffer ;
		for( i = 0 ; i < VertexNum ; i ++, sv ++, dv ++ )
		{
			dv->pos = sv->pos ;
			dv->u = sv->u ;
			dv->v = sv->v ;
			dv->b = ( BYTE )BlueTable [ sv->b ] ;
			dv->g = ( BYTE )GreenTable[ sv->g ] ;
			dv->r = ( BYTE )RedTable  [ sv->r ] ;
			dv->a = ( BYTE )AlphaTable[ sv->a ] ;
		}
		UseVertex = ( VERTEX_3D * )GBASE.TempVertexBuffer ;
	}
	else
	{
		UseVertex = Vertex ;
	}
	
	DRAW_DEF(
		DrawIndexedPrimitiveHardware( UseVertex, VertexNum, Indices, IndexNum, PrimitiveType, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// ３Ｄポリゴンを描画する
extern	int NS_DrawPolygon3D( const VERTEX_3D *Vertex, int PolygonNum, int GrHandle, int TransFlag )
{
	return NS_DrawPolygon3DBase( Vertex, PolygonNum * 3, DX_PRIMTYPE_TRIANGLELIST, GrHandle, TransFlag ) ;
}

// ２Ｄポリゴンを描画する
extern int NS_DrawPolygon2D( const VERTEX2D *Vertex, int PolygonNum, int GrHandle, int TransFlag )
{
	return NS_DrawPrimitive2D( Vertex, PolygonNum * 3, DX_PRIMTYPE_TRIANGLELIST, GrHandle, TransFlag ) ;
}

// ２Ｄプリミティブを描画する
extern int NS_DrawPrimitive2D( const VERTEX2D *Vertex, int VertexNum, int PrimitiveType, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret, i, Flag ;
	const VERTEX2D *UseVertex ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 色の変換が必要な場合はここで処理する
	if( GBASE.DrawBright.Red   != 255 ||
		GBASE.DrawBright.Green != 255 ||
		GBASE.DrawBright.Blue  != 255 ||
		( GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendParam != 255 ) )
	{
		DWORD *RedTable, *GreenTable, *BlueTable, *AlphaTable ;
		const VERTEX2D *sv ;
		VERTEX2D *dv ;
		int Size ;

		// テーブルを用意する
		RedTable   = MemImgManage.RateTable[GBASE.DrawBright.Red] ;
		GreenTable = MemImgManage.RateTable[GBASE.DrawBright.Green] ;
		BlueTable  = MemImgManage.RateTable[GBASE.DrawBright.Blue] ;
		AlphaTable = MemImgManage.RateTable[GBASE.BlendParam] ;
		if( GBASE.BlendMode == DX_BLENDMODE_NOBLEND ) AlphaTable = MemImgManage.RateTable[255] ;

		// 頂点データを格納するメモリ領域が足りない場合は確保する
		Size = sizeof( VERTEX2D ) * VertexNum ;
		if( GBASE.TempVertexBufferSize < Size )
		{
			if( GBASE.TempVertexBuffer )
			{
				DXFREE( GBASE.TempVertexBuffer ) ;
				GBASE.TempVertexBufferSize = 0 ;
			}
			GBASE.TempVertexBuffer = DXALLOC( Size ) ;
			if( GBASE.TempVertexBuffer == NULL )
				return -1 ;
			GBASE.TempVertexBufferSize = Size ;
		}

		// 一時バッファに変換しながら転送
		sv = Vertex;
		dv = ( VERTEX2D * )GBASE.TempVertexBuffer ;
		for( i = 0 ; i < VertexNum ; i ++, sv ++, dv ++ )
		{
			dv->pos = sv->pos ;
			dv->rhw = sv->rhw ;
			dv->dif.b = ( BYTE )BlueTable [ sv->dif.b ] ;
			dv->dif.g = ( BYTE )GreenTable[ sv->dif.g ] ;
			dv->dif.r = ( BYTE )RedTable  [ sv->dif.r ] ;
			dv->dif.a = ( BYTE )AlphaTable[ sv->dif.a ] ;
			dv->u = sv->u ;
			dv->v = sv->v ;
		}
		UseVertex = ( VERTEX2D * )GBASE.TempVertexBuffer ;
	}
	else
	{
		UseVertex = Vertex ;
	}
	
	DRAW_DEF(
		DrawPrimitive2DUserHardware( UseVertex, VertexNum, PrimitiveType, Image2, TransFlag, FALSE, FALSE, 0 ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// ２Ｄポリゴンを描画する( 頂点インデックスを使用 )
extern int NS_DrawPolygonIndexed2D( const VERTEX2D  *Vertex, int VertexNum, const unsigned short *Indices, int PolygonNum, int GrHandle, int TransFlag )
{
	return NS_DrawPrimitiveIndexed2D( Vertex, VertexNum, Indices, PolygonNum * 3, DX_PRIMTYPE_TRIANGLELIST, GrHandle, TransFlag ) ;
}

// ２Ｄプリミティブを描画する(インデックス)
extern int NS_DrawPrimitiveIndexed2D( const VERTEX2D *Vertex, int VertexNum, const unsigned short *Indices, int IndexNum, int PrimitiveType, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret, i, Flag ;
	const VERTEX2D *UseVertex ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 色の変換が必要な場合はここで処理する
	if( GBASE.DrawBright.Red   != 255 ||
		GBASE.DrawBright.Green != 255 ||
		GBASE.DrawBright.Blue  != 255 ||
		( GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendParam != 255 ) )
	{
		DWORD *RedTable, *GreenTable, *BlueTable, *AlphaTable ;
		const VERTEX2D *sv ;
		VERTEX2D *dv ;
		int Size ;

		// テーブルを用意する
		RedTable   = MemImgManage.RateTable[GBASE.DrawBright.Red] ;
		GreenTable = MemImgManage.RateTable[GBASE.DrawBright.Green] ;
		BlueTable  = MemImgManage.RateTable[GBASE.DrawBright.Blue] ;
		AlphaTable = MemImgManage.RateTable[GBASE.BlendParam] ;
		if( GBASE.BlendMode == DX_BLENDMODE_NOBLEND ) AlphaTable = MemImgManage.RateTable[255] ;

		// 頂点データを格納するメモリ領域が足りない場合は確保する
		Size = sizeof( VERTEX2D ) * VertexNum ;
		if( GBASE.TempVertexBufferSize < Size )
		{
			if( GBASE.TempVertexBuffer )
			{
				DXFREE( GBASE.TempVertexBuffer ) ;
				GBASE.TempVertexBufferSize = 0 ;
			}
			GBASE.TempVertexBuffer = DXALLOC( Size ) ;
			if( GBASE.TempVertexBuffer == NULL )
				return -1 ;
			GBASE.TempVertexBufferSize = Size ;
		}

		// 一時バッファに変換しながら転送
		sv = Vertex;
		dv = ( VERTEX2D * )GBASE.TempVertexBuffer ;
		for( i = 0 ; i < VertexNum ; i ++, sv ++, dv ++ )
		{
			dv->pos = sv->pos ;
			dv->rhw = sv->rhw ;
			dv->dif.b = ( BYTE )BlueTable [ sv->dif.b ] ;
			dv->dif.g = ( BYTE )GreenTable[ sv->dif.g ] ;
			dv->dif.r = ( BYTE )RedTable  [ sv->dif.r ] ;
			dv->dif.a = ( BYTE )AlphaTable[ sv->dif.a ] ;
			dv->u = sv->u ;
			dv->v = sv->v ;
		}
		UseVertex = ( VERTEX2D * )GBASE.TempVertexBuffer ;
	}
	else
	{
		UseVertex = Vertex ;
	}
	
	DRAW_DEF(
		DrawIndexedPrimitive2DUserHardware( UseVertex, VertexNum, Indices, IndexNum, PrimitiveType, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// ３Ｄポリゴンを描画する
extern int NS_DrawPrimitive3D( const VERTEX3D *Vertex, int VertexNum, int PrimitiveType, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret, i, Flag ;
	const VERTEX3D *UseVertex ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 色の変換が必要な場合はここで処理する
	if( GBASE.DrawBright.Red   != 255 ||
		GBASE.DrawBright.Green != 255 ||
		GBASE.DrawBright.Blue  != 255 ||
		( GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendParam != 255 ) )
	{
		DWORD *RedTable, *GreenTable, *BlueTable, *AlphaTable ;
		const VERTEX3D *sv ;
		VERTEX3D *dv ;
		int Size ;

		// テーブルを用意する
		RedTable   = MemImgManage.RateTable[GBASE.DrawBright.Red] ;
		GreenTable = MemImgManage.RateTable[GBASE.DrawBright.Green] ;
		BlueTable  = MemImgManage.RateTable[GBASE.DrawBright.Blue] ;
		AlphaTable = MemImgManage.RateTable[GBASE.BlendParam] ;
		if( GBASE.BlendMode == DX_BLENDMODE_NOBLEND ) AlphaTable = MemImgManage.RateTable[255] ;

		// 頂点データを格納するメモリ領域が足りない場合は確保する
		Size = sizeof( VERTEX3D ) * VertexNum ;
		if( GBASE.TempVertexBufferSize < Size )
		{
			if( GBASE.TempVertexBuffer )
			{
				DXFREE( GBASE.TempVertexBuffer ) ;
				GBASE.TempVertexBufferSize = 0 ;
			}
			GBASE.TempVertexBuffer = DXALLOC( Size ) ;
			if( GBASE.TempVertexBuffer == NULL )
				return -1 ;
			GBASE.TempVertexBufferSize = Size ;
		}

		// 一時バッファに変換しながら転送
		sv = Vertex;
		dv = ( VERTEX3D * )GBASE.TempVertexBuffer ;
		for( i = 0 ; i < VertexNum ; i ++, sv ++, dv ++ )
		{
			dv->pos = sv->pos ;
			dv->norm = sv->norm ;
			dv->dif.b = ( BYTE )BlueTable [ sv->dif.b ] ;
			dv->dif.g = ( BYTE )GreenTable[ sv->dif.g ] ;
			dv->dif.r = ( BYTE )RedTable  [ sv->dif.r ] ;
			dv->dif.a = ( BYTE )AlphaTable[ sv->dif.a ] ;
			dv->spc.b = ( BYTE )BlueTable [ sv->spc.b ] ;
			dv->spc.g = ( BYTE )GreenTable[ sv->spc.g ] ;
			dv->spc.r = ( BYTE )RedTable  [ sv->spc.r ] ;
			dv->spc.a = ( BYTE )AlphaTable[ sv->spc.a ] ;
			dv->u = sv->u ;
			dv->v = sv->v ;
			dv->su = sv->su ;
			dv->sv = sv->sv ;
		}
		UseVertex = ( VERTEX3D * )GBASE.TempVertexBuffer ;
	}
	else
	{
		UseVertex = Vertex ;
	}
	
	DRAW_DEF(
		DrawPrimitiveLightHardware( UseVertex, VertexNum, PrimitiveType, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// ３Ｄポリゴンを描画する(インデックス)
extern int NS_DrawPrimitiveIndexed3D( const VERTEX3D *Vertex, int VertexNum, const unsigned short *Indices, int IndexNum, int PrimitiveType, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret, i, Flag ;
	const VERTEX3D *UseVertex ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 色の変換が必要な場合はここで処理する
	if( GBASE.DrawBright.Red   != 255 ||
		GBASE.DrawBright.Green != 255 ||
		GBASE.DrawBright.Blue  != 255 ||
		( GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendParam != 255 ) )
	{
		DWORD *RedTable, *GreenTable, *BlueTable, *AlphaTable ;
		const VERTEX3D *sv ;
		VERTEX3D *dv ;
		int Size ;

		// テーブルを用意する
		RedTable   = MemImgManage.RateTable[GBASE.DrawBright.Red] ;
		GreenTable = MemImgManage.RateTable[GBASE.DrawBright.Green] ;
		BlueTable  = MemImgManage.RateTable[GBASE.DrawBright.Blue] ;
		AlphaTable = MemImgManage.RateTable[GBASE.BlendParam] ;
		if( GBASE.BlendMode == DX_BLENDMODE_NOBLEND ) AlphaTable = MemImgManage.RateTable[255] ;

		// 頂点データを格納するメモリ領域が足りない場合は確保する
		Size = sizeof( VERTEX3D ) * VertexNum ;
		if( GBASE.TempVertexBufferSize < Size )
		{
			if( GBASE.TempVertexBuffer )
			{
				DXFREE( GBASE.TempVertexBuffer ) ;
				GBASE.TempVertexBufferSize = 0 ;
			}
			GBASE.TempVertexBuffer = DXALLOC( Size ) ;
			if( GBASE.TempVertexBuffer == NULL )
				return -1 ;
			GBASE.TempVertexBufferSize = Size ;
		}

		// 一時バッファに変換しながら転送
		sv = Vertex;
		dv = ( VERTEX3D * )GBASE.TempVertexBuffer ;
		for( i = 0 ; i < VertexNum ; i ++, sv ++, dv ++ )
		{
			dv->pos = sv->pos ;
			dv->norm = sv->norm ;
			dv->dif.b = ( BYTE )BlueTable [ sv->dif.b ] ;
			dv->dif.g = ( BYTE )GreenTable[ sv->dif.g ] ;
			dv->dif.r = ( BYTE )RedTable  [ sv->dif.r ] ;
			dv->dif.a = ( BYTE )AlphaTable[ sv->dif.a ] ;
			dv->spc.b = ( BYTE )BlueTable [ sv->spc.b ] ;
			dv->spc.g = ( BYTE )GreenTable[ sv->spc.g ] ;
			dv->spc.r = ( BYTE )RedTable  [ sv->spc.r ] ;
			dv->spc.a = ( BYTE )AlphaTable[ sv->spc.a ] ;
			dv->u = sv->u ;
			dv->v = sv->v ;
			dv->su = sv->su ;
			dv->sv = sv->sv ;
		}
		UseVertex = ( VERTEX3D * )GBASE.TempVertexBuffer ;
	}
	else
	{
		UseVertex = Vertex ;
	}
	
	DRAW_DEF(
		DrawIndexedPrimitiveLightHardware( UseVertex, VertexNum, Indices, IndexNum, PrimitiveType, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// 頂点バッファを使用して３Ｄプリミティブを描画する
extern int NS_DrawPrimitive3D_UseVertexBuffer( int VertexBufHandle, int PrimitiveType  /* DX_PRIMTYPE_TRIANGLELIST 等 */, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	int Ret, Flag ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}
	VertexBuffer = NULL ;
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	DRAW_DEF(
		DrawPrimitiveLight_UseVertexBufferHardware( VertexBuffer, PrimitiveType, 0, VertexBuffer->Num, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// 頂点バッファを使用して３Ｄプリミティブを描画する
extern int NS_DrawPrimitive3D_UseVertexBuffer2( int VertexBufHandle, int PrimitiveType  /* DX_PRIMTYPE_TRIANGLELIST 等 */, int StartVertex, int UseVertexNum, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	int Ret, Flag ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}
	VertexBuffer = NULL ;
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	DRAW_DEF(
		DrawPrimitiveLight_UseVertexBufferHardware( VertexBuffer, PrimitiveType, StartVertex, UseVertexNum, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// 頂点バッファとインデックスバッファを使用して３Ｄプリミティブを描画する
extern int NS_DrawPrimitiveIndexed3D_UseVertexBuffer( int VertexBufHandle, int IndexBufHandle, int PrimitiveType  /* DX_PRIMTYPE_TRIANGLELIST 等 */, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	INDEXBUFFERHANDLEDATA *IndexBuffer ;
	int Ret, Flag ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}
	VertexBuffer = NULL ;
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;
	if( INDEXBUFFERCHK( IndexBufHandle, IndexBuffer ) )
		return -1 ;

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	DRAW_DEF(
		DrawIndexedPrimitiveLight_UseVertexBufferHardware( VertexBuffer, IndexBuffer, PrimitiveType, 0, 0, VertexBuffer->Num, 0, IndexBuffer->Num, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}

// 頂点バッファとインデックスバッファを使用して３Ｄプリミティブを描画する
extern int NS_DrawPrimitiveIndexed3D_UseVertexBuffer2( int VertexBufHandle, int IndexBufHandle, int PrimitiveType  /* DX_PRIMTYPE_TRIANGLELIST 等 */, int BaseVertex, int StartVertex, int UseVertexNum, int StartIndex, int UseIndexNum, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	INDEXBUFFERHANDLEDATA *IndexBuffer ;
	int Ret, Flag ;

	Ret = -1;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	Image2 = NULL ;
	if( GrHandle != DX_NONE_GRAPH )
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		Flag = Image2->Orig->FormatDesc.TextureFlag ;
	}
	else
	{
		Flag = GRA2.ValidHardWare ;
	}
	VertexBuffer = NULL ;
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;
	if( INDEXBUFFERCHK( IndexBufHandle, IndexBuffer ) )
		return -1 ;

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	DRAW_DEF(
		DrawIndexedPrimitiveLight_UseVertexBufferHardware( VertexBuffer, IndexBuffer, PrimitiveType, BaseVertex, StartVertex, UseVertexNum, StartIndex, UseIndexNum, Image2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	return Ret ;
}



// ３Ｄポリゴンを描画する
extern int NS_DrawPolygon3D( const VERTEX3D *Vertex, int PolygonNum, int GrHandle, int TransFlag )
{
	return NS_DrawPrimitive3D( Vertex, PolygonNum * 3, DX_PRIMTYPE_TRIANGLELIST, GrHandle, TransFlag ) ;
}

// ３Ｄポリゴンを描画する(インデックス)
extern int NS_DrawPolygonIndexed3D( const VERTEX3D *Vertex, int VertexNum, const unsigned short *Indices, int PolygonNum, int GrHandle, int TransFlag )
{
	return NS_DrawPrimitiveIndexed3D( Vertex, VertexNum, Indices, PolygonNum * 3, DX_PRIMTYPE_TRIANGLELIST, GrHandle, TransFlag ) ;
}

// 頂点バッファを使用して３Ｄポリゴンを描画する
extern int NS_DrawPolygon3D_UseVertexBuffer( int VertexBufHandle, int GrHandle, int TransFlag )
{
	return NS_DrawPrimitive3D_UseVertexBuffer( VertexBufHandle, DX_PRIMTYPE_TRIANGLELIST, GrHandle, TransFlag ) ;
}

// 頂点バッファとインデックスバッファを使用して３Ｄポリゴンを描画する
extern int NS_DrawPolygonIndexed3D_UseVertexBuffer( int VertexBufHandle, int IndexBufHandle, int GrHandle, int TransFlag )
{
	return NS_DrawPrimitiveIndexed3D_UseVertexBuffer( VertexBufHandle, IndexBufHandle, DX_PRIMTYPE_TRIANGLELIST, GrHandle, TransFlag ) ;
}

// 補助関数

// グラフィックの３Ｄ描画
#define SETDRAWRECTCODE\
	float MinX, MinY, MaxX, MaxY ;\
\
	MinX =  100000000.0F ;\
	MinY =  100000000.0F ;\
	MaxX = -100000000.0F ;\
	MaxY = -100000000.0F ;\
	for( i = 0 ; i < 4 ; i ++ )\
	{\
		if( TransVert[i].pos.x - 1.0F < MinX ) MinX = TransVert[i].pos.x - 1.0F ;\
		if( TransVert[i].pos.x + 1.0F > MaxX ) MaxX = TransVert[i].pos.x + 1.0F ;\
\
		if( TransVert[i].pos.y - 1.0F < MinY ) MinY = TransVert[i].pos.y - 1.0F ;\
		if( TransVert[i].pos.y + 1.0F > MaxY ) MaxY = TransVert[i].pos.y + 1.0F ;\
	}\
\
	GRH.DrawRect.left   = _FTOL( MinX ) ;\
	GRH.DrawRect.top    = _FTOL( MinY ) ;\
	GRH.DrawRect.right  = _FTOL( MaxX ) ;\
	GRH.DrawRect.bottom = _FTOL( MaxY ) ;\
	DRAWRECT_DRAWAREA_CLIP

extern	int NS_DrawGraph3D( float x, float y, float z, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret = -1, i ;
	VERTEX_2D TransVert[6] ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 座標変換を行う
	{
		MATRIX *TransMatrix ;

		TransMatrix = &GBASE.BlendMatrix ;

		// 頂点情報をセットする
		{
			VECTOR SrcVec[4], Pos ;
			VERTEX_2D DestVec[4] ;
			float SizeX, SizeY ;
			
			// ビルボードの４頂点を得る
			SizeX = ( float )Image2->Width  * 0.5F ;
			SizeY = ( float )Image2->Height * 0.5F ;
			Pos.x = x ;	Pos.y = y ;	Pos.z = z ;
			SrcVec[0].x = -SizeX ;	SrcVec[0].y =  SizeY ;	SrcVec[0].z = 0.0F ;
			SrcVec[1].x =  SizeX ;	SrcVec[1].y =  SizeY ;	SrcVec[1].z = 0.0F ;
			SrcVec[2].x = -SizeX ;	SrcVec[2].y = -SizeY ;	SrcVec[2].z = 0.0F ;
			SrcVec[3].x =  SizeX ;	SrcVec[3].y = -SizeY ;	SrcVec[3].z = 0.0F ;

			// 座標変換
			for( i = 0 ; i < 4 ; i ++ )
			{
				// ビルボード座標をワールド座標へ変換
				_VectorTransformToBillboard( &SrcVec[i], &Pos ) ;

				// スクリーン座標に変換
				DestVec[i].rhw = 1.0F ;
				VectorTransform4( &DestVec[i].pos,  &DestVec[i].rhw,
									      &SrcVec[i],  &DestVec[i].rhw, TransMatrix ) ;
				DestVec[i].rhw = 1.0F / DestVec[i].rhw ;
				DestVec[i].pos.x *= DestVec[i].rhw ;
				DestVec[i].pos.y *= DestVec[i].rhw ;
				DestVec[i].pos.z *= DestVec[i].rhw ;
			}
									            
			// 頂点情報のセット
			TransVert[0].pos = DestVec[0].pos ;
			TransVert[1].pos = DestVec[1].pos ;
			TransVert[2].pos = DestVec[2].pos ;
			TransVert[3].pos = DestVec[3].pos ;
			TransVert[0].rhw = DestVec[0].rhw ;
			TransVert[1].rhw = DestVec[1].rhw ;
			TransVert[2].rhw = DestVec[2].rhw ;
			TransVert[3].rhw = DestVec[3].rhw ;

			((BYTE *)&TransVert[0].color)[0] = (BYTE)GBASE.DrawBright.Blue ;
			((BYTE *)&TransVert[0].color)[1] = (BYTE)GBASE.DrawBright.Green ;
			((BYTE *)&TransVert[0].color)[2] = (BYTE)GBASE.DrawBright.Red ;
			((BYTE *)&TransVert[0].color)[3] = (BYTE)GBASE.BlendParam ;
			TransVert[1].color =
			TransVert[2].color =
			TransVert[3].color = TransVert[0].color ;

			TransVert[0].u = 0.0F ;	TransVert[0].v = 0.0F ;
			TransVert[1].u = 1.0F ;	TransVert[1].v = 0.0F ;
			TransVert[2].u = 0.0F ;	TransVert[2].v = 1.0F ;
			TransVert[3].u = 1.0F ;	TransVert[3].v = 1.0F ;

			TransVert[4] = TransVert[2] ;
			TransVert[5] = TransVert[1] ;
		}
	}

	// 描画
	DRAW_DEF(
		DrawPrimitive2DHardware( TransVert, 6, DX_PRIMTYPE_TRIANGLELIST, Image2, TransFlag, TRUE, TRUE, FALSE, 0 ),
		0,
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

// グラフィックの拡大３Ｄ描画
extern	int NS_DrawExtendGraph3D( float x, float y, float z, double ExRateX, double ExRateY, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret = -1, i ;
	VERTEX_2D TransVert[6] ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 座標変換を行う
	{
		MATRIX *TransMatrix ;

		TransMatrix = &GBASE.BlendMatrix ;

		// 頂点情報をセットする
		{
			VECTOR SrcVec[4], Pos ;
			VERTEX_2D DestVec[4] ;
			float SizeX, SizeY ;
			
			// ビルボードの４頂点を得る
			SizeX = ( float )Image2->Width  * ( float )ExRateX * 0.5F ;
			SizeY = ( float )Image2->Height * ( float )ExRateY * 0.5F ;
			Pos.x = x ;	Pos.y = y ;	Pos.z = z ;
			SrcVec[0].x = -SizeX ;	SrcVec[0].y =  SizeY ;	SrcVec[0].z = 0.0F ;
			SrcVec[1].x =  SizeX ;	SrcVec[1].y =  SizeY ;	SrcVec[1].z = 0.0F ;
			SrcVec[2].x = -SizeX ;	SrcVec[2].y = -SizeY ;	SrcVec[2].z = 0.0F ;
			SrcVec[3].x =  SizeX ;	SrcVec[3].y = -SizeY ;	SrcVec[3].z = 0.0F ;

			// 座標変換
			for( i = 0 ; i < 4 ; i ++ )
			{
				// ビルボード座標をワールド座標へ変換
				_VectorTransformToBillboard( &SrcVec[i], &Pos ) ;

				// スクリーン座標に変換
				DestVec[i].rhw = 1.0F ;
				VectorTransform4( &DestVec[i].pos,  &DestVec[i].rhw,
									      &SrcVec[i],  &DestVec[i].rhw, TransMatrix ) ;
				DestVec[i].rhw = 1.0F / DestVec[i].rhw ;
				DestVec[i].pos.x *= DestVec[i].rhw ;
				DestVec[i].pos.y *= DestVec[i].rhw ;
				DestVec[i].pos.z *= DestVec[i].rhw ;
			}
									            
			// 頂点情報のセット
			TransVert[0].pos = DestVec[0].pos ;
			TransVert[1].pos = DestVec[1].pos ;
			TransVert[2].pos = DestVec[2].pos ;
			TransVert[3].pos = DestVec[3].pos ;
			TransVert[0].rhw = DestVec[0].rhw ;
			TransVert[1].rhw = DestVec[1].rhw ;
			TransVert[2].rhw = DestVec[2].rhw ;
			TransVert[3].rhw = DestVec[3].rhw ;

			((BYTE *)&TransVert[0].color)[0] = (BYTE)GBASE.DrawBright.Blue ;
			((BYTE *)&TransVert[0].color)[1] = (BYTE)GBASE.DrawBright.Green ;
			((BYTE *)&TransVert[0].color)[2] = (BYTE)GBASE.DrawBright.Red ;
			((BYTE *)&TransVert[0].color)[3] = (BYTE)GBASE.BlendParam ;
			TransVert[1].color =
			TransVert[2].color =
			TransVert[3].color = TransVert[0].color ;

			TransVert[0].u = 0.0F ;	TransVert[0].v = 0.0F ;
			TransVert[1].u = 1.0F ;	TransVert[1].v = 0.0F ;
			TransVert[2].u = 0.0F ;	TransVert[2].v = 1.0F ;
			TransVert[3].u = 1.0F ;	TransVert[3].v = 1.0F ;

			TransVert[4] = TransVert[2] ;
			TransVert[5] = TransVert[1] ;
		}
	}

	// 描画
	DRAW_DEF(
		DrawPrimitive2DHardware( TransVert, 6, DX_PRIMTYPE_TRIANGLELIST, Image2, TransFlag, TRUE, TRUE, FALSE, 0 ),
		0,
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

// グラフィックの回転３Ｄ描画
extern	int NS_DrawRotaGraph3D( float x, float y, float z, double ExRate, double Angle, int GrHandle, int TransFlag, int TurnFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret = -1, i ;
	VERTEX_2D TransVert[6] ;
	float Sin, Cos ;
	float ExtendRate = ( float )ExRate ; 
	float ExtendRateX ;
	float XBuf, YBuf ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 座標変換を行う
	{
		MATRIX *TransMatrix ;

		TransMatrix = &GBASE.BlendMatrix ;

		// 頂点情報をセットする
		{
			VECTOR SrcVec[4], Pos ;
			VERTEX_2D DestVec[4], VectBuf ;
			float SizeX, SizeY ;

			// 反転を考慮した横方向の拡大率をセット
			ExtendRateX = ( ( TurnFlag == TRUE ) ? -1.0f : 1.0f ) * ExtendRate ;

			// ビルボードの４頂点を得る
			{
				SizeX = Image2->Width  * 0.5F * ExtendRateX ;
				SizeY = Image2->Height * 0.5F * ExtendRate  ;
				Pos.x = x ;	Pos.y = y ;	Pos.z = z ;
				SrcVec[0].x = -SizeX ;	SrcVec[0].y =  SizeY ;	SrcVec[0].z = 0.0F ;
				SrcVec[1].x =  SizeX ;	SrcVec[1].y =  SizeY ;	SrcVec[1].z = 0.0F ;
				SrcVec[2].x = -SizeX ;	SrcVec[2].y = -SizeY ;	SrcVec[2].z = 0.0F ;
				SrcVec[3].x =  SizeX ;	SrcVec[3].y = -SizeY ;	SrcVec[3].z = 0.0F ;

				// 回転
				_SINCOS( (float)Angle, &Sin, &Cos ) ;
				for( i = 0 ; i < 4 ; i ++ )
				{
					XBuf = SrcVec[i].x ;
					YBuf = SrcVec[i].y ;

					SrcVec[i].x = XBuf * Cos - YBuf * Sin ;	
					SrcVec[i].y = XBuf * Sin + YBuf * Cos ;
				}
			}

			// 座標変換
			for( i = 0 ; i < 4 ; i ++ )
			{
				// ビルボード座標をワールド座標へ変換
				_VectorTransformToBillboard( &SrcVec[i], &Pos ) ;

				// スクリーン座標に変換
				DestVec[i].rhw = 1.0F ;
				VectorTransform4( &DestVec[i].pos,  &DestVec[i].rhw,
									      &SrcVec[i],  &DestVec[i].rhw, TransMatrix ) ;
				DestVec[i].rhw = 1.0F / DestVec[i].rhw ;
				DestVec[i].pos.x *= DestVec[i].rhw ;
				DestVec[i].pos.y *= DestVec[i].rhw ;
				DestVec[i].pos.z *= DestVec[i].rhw ;
			}
									            
			// 頂点情報のセット
			TransVert[0].pos = DestVec[0].pos ;
			TransVert[1].pos = DestVec[1].pos ;
			TransVert[2].pos = DestVec[2].pos ;
			TransVert[3].pos = DestVec[3].pos ;
			TransVert[0].rhw = DestVec[0].rhw ;
			TransVert[1].rhw = DestVec[1].rhw ;
			TransVert[2].rhw = DestVec[2].rhw ;
			TransVert[3].rhw = DestVec[3].rhw ;

			((BYTE *)&TransVert[0].color)[0] = (BYTE)GBASE.DrawBright.Blue ;
			((BYTE *)&TransVert[0].color)[1] = (BYTE)GBASE.DrawBright.Green ;
			((BYTE *)&TransVert[0].color)[2] = (BYTE)GBASE.DrawBright.Red ;
			((BYTE *)&TransVert[0].color)[3] = (BYTE)GBASE.BlendParam ;
			TransVert[1].color =
			TransVert[2].color =
			TransVert[3].color = TransVert[0].color ;

			TransVert[0].u = 0.0F ;	TransVert[0].v = 0.0F ;
			TransVert[1].u = 1.0F ;	TransVert[1].v = 0.0F ;
			TransVert[2].u = 0.0F ;	TransVert[2].v = 1.0F ;
			TransVert[3].u = 1.0F ;	TransVert[3].v = 1.0F ;

			TransVert[4] = TransVert[2] ;
			TransVert[5] = TransVert[1] ;

			// 反転処理
			if( TurnFlag == TRUE )
			{
				VectBuf = TransVert[ 1 ] ; TransVert[ 1 ] = TransVert[ 2 ] ; TransVert[ 2 ] = VectBuf ;
			}

			TransVert[4] = TransVert[2] ;
			TransVert[5] = TransVert[1] ;
		}
	}

	// 描画
	DRAW_DEF(
		DrawPrimitive2DHardware( TransVert, 6, DX_PRIMTYPE_TRIANGLELIST, Image2, TransFlag, TRUE, TRUE, FALSE, 0 ),
		0,
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

// グラフィックの回転３Ｄ描画(回転中心指定型)
extern	int NS_DrawRota2Graph3D( float x, float y, float z, float cx, float cy, double ExtRateX, double ExtRateY, double Angle, int GrHandle, int TransFlag, int TurnFlag )
{
	IMAGEDATA2 *Image2 ;
	int Ret = -1, i ;
	VERTEX_2D TransVert[6] ;
	float Sin, Cos ;
	float ExtendRateX = ( float )ExtRateX ; 
	float ExtendRateY = ( float )ExtRateY ; 
	float XBuf, YBuf ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

#ifndef DX_NON_MOVIE
	if( GrHandle != DX_NONE_GRAPH )
		UpdateMovie( Image2->MovieHandle ) ;
#endif

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 座標変換を行う
	{
		MATRIX *TransMatrix ;

		TransMatrix = &GBASE.BlendMatrix ;

		// 頂点情報をセットする
		{
			VECTOR SrcVec[4], Pos ;
			VERTEX_2D DestVec[4], VectBuf ;
			float SizeX, SizeY ;
			
			// ビルボードの４頂点を得る
			{
				SizeX = (float)Image2->Width ;
				SizeY = (float)Image2->Height ;
				Pos.x = x ;	Pos.y = y ;	Pos.z = z ;
				if( TurnFlag == TRUE )
				{
					SrcVec[0].x = ( -cx + SizeX ) * ExtendRateX ;	SrcVec[0].y = ( -cy + SizeY ) * ExtendRateY ;	SrcVec[0].z = 0.0F ;
					SrcVec[1].x = -cx             * ExtendRateX ;	SrcVec[1].y = ( -cy + SizeY ) * ExtendRateY ;	SrcVec[1].z = 0.0F ;
					SrcVec[2].x = ( -cx + SizeX ) * ExtendRateX ;	SrcVec[2].y = -cy             * ExtendRateY ;	SrcVec[2].z = 0.0F ;
					SrcVec[3].x = -cx             * ExtendRateX ;	SrcVec[3].y = -cy             * ExtendRateY ;	SrcVec[3].z = 0.0F ;
				}
				else
				{
					SrcVec[0].x = -cx             * ExtendRateX ;	SrcVec[0].y = ( -cy + SizeY ) * ExtendRateY ;	SrcVec[0].z = 0.0F ;
					SrcVec[1].x = ( -cx + SizeX ) * ExtendRateX ;	SrcVec[1].y = ( -cy + SizeY ) * ExtendRateY ;	SrcVec[1].z = 0.0F ;
					SrcVec[2].x = -cx             * ExtendRateX ;	SrcVec[2].y = -cy             * ExtendRateY ;	SrcVec[2].z = 0.0F ;
					SrcVec[3].x = ( -cx + SizeX ) * ExtendRateX ;	SrcVec[3].y = -cy             * ExtendRateY ;	SrcVec[3].z = 0.0F ;
				}

				// 回転
				_SINCOS( (float)Angle, &Sin, &Cos ) ;
				for( i = 0 ; i < 4 ; i ++ )
				{
					XBuf = SrcVec[i].x ;
					YBuf = SrcVec[i].y ;

					SrcVec[i].x = XBuf * Cos - YBuf * Sin ;	
					SrcVec[i].y = XBuf * Sin + YBuf * Cos ;
				}
			}

			// 座標変換
			for( i = 0 ; i < 4 ; i ++ )
			{
				// ビルボード座標をワールド座標へ変換
				_VectorTransformToBillboard( &SrcVec[i], &Pos ) ;

				// スクリーン座標に変換
				DestVec[i].rhw = 1.0F ;
				VectorTransform4( &DestVec[i].pos,  &DestVec[i].rhw,
									      &SrcVec[i],  &DestVec[i].rhw, TransMatrix ) ;
				DestVec[i].rhw = 1.0F / DestVec[i].rhw ;
				DestVec[i].pos.x *= DestVec[i].rhw ;
				DestVec[i].pos.y *= DestVec[i].rhw ;
				DestVec[i].pos.z *= DestVec[i].rhw ;
			}
									            
			// 頂点情報のセット
			TransVert[0].pos = DestVec[0].pos ;
			TransVert[1].pos = DestVec[1].pos ;
			TransVert[2].pos = DestVec[2].pos ;
			TransVert[3].pos = DestVec[3].pos ;
			TransVert[0].rhw = DestVec[0].rhw ;
			TransVert[1].rhw = DestVec[1].rhw ;
			TransVert[2].rhw = DestVec[2].rhw ;
			TransVert[3].rhw = DestVec[3].rhw ;

			((BYTE *)&TransVert[0].color)[0] = (BYTE)GBASE.DrawBright.Blue ;
			((BYTE *)&TransVert[0].color)[1] = (BYTE)GBASE.DrawBright.Green ;
			((BYTE *)&TransVert[0].color)[2] = (BYTE)GBASE.DrawBright.Red ;
			((BYTE *)&TransVert[0].color)[3] = (BYTE)GBASE.BlendParam ;
			TransVert[1].color =
			TransVert[2].color =
			TransVert[3].color = TransVert[0].color ;

			TransVert[0].u = 0.0F ;	TransVert[0].v = 0.0F ;
			TransVert[1].u = 1.0F ;	TransVert[1].v = 0.0F ;
			TransVert[2].u = 0.0F ;	TransVert[2].v = 1.0F ;
			TransVert[3].u = 1.0F ;	TransVert[3].v = 1.0F ;

			TransVert[4] = TransVert[2] ;
			TransVert[5] = TransVert[1] ;

			// 反転処理
			if( TurnFlag == TRUE )
			{
				VectBuf = TransVert[ 1 ] ; TransVert[ 1 ] = TransVert[ 2 ] ; TransVert[ 2 ] = VectBuf ;
			}

			TransVert[4] = TransVert[2] ;
			TransVert[5] = TransVert[1] ;
		}
	}

	// 描画
	DRAW_DEF(
		DrawPrimitive2DHardware( TransVert, 6, DX_PRIMTYPE_TRIANGLELIST, Image2, TransFlag, TRUE, TRUE, FALSE, 0 ),
		0,
		SETDRAWRECTCODE,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// グラフィックの自由変形３Ｄ描画
extern int NS_DrawModiBillboard3D( VECTOR Pos, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, int GrHandle, int TransFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret ;

	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE ) return -1 ;

	// 非描画設定がされている場合は何もせず終了
	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF(
		DrawModiBillboard3DHardware( Pos, x1, y1, x2, y2, x3, y3, x4, y4, Image2, BlendImage2, TransFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}

// ３Ｄ空間上にグラフィックを描画
extern int NS_DrawBillboard3D( VECTOR Pos, float cx, float cy, float Size, float Angle, int GrHandle, int TransFlag, int TurnFlag )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *BlendImage2 ;
	int Ret ;

	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE ) return -1 ;

	// 非描画設定がされている場合は何もせず終了
	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;
	BlendImage2 = NULL ;
	if( GBASE.BlendGraph > 0 )
	{
		GRAPHCHK( GBASE.BlendGraph, BlendImage2 ) ;

		// ブレンドテクスチャを使用する場合、描画画像よりも小さかったらエラー
		if( CheckBlendGraphSize( Image2 ) ) return -1 ;
	}

#ifndef DX_NON_MOVIE
	if( Image2->MovieHandle != -1 )
		UpdateMovie( Image2->MovieHandle, FALSE ) ;
#endif

	// 描画
	DRAW_DEF(
		DrawBillboard3DHardware( Pos, cx, cy, Size, Angle, Image2, BlendImage2, TransFlag, TurnFlag ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Image2->Orig->FormatDesc.TextureFlag
	)

	// 終了
	return Ret ;
}


// ３Ｄの三角形を描画する
extern int NS_DrawTriangle3D( VECTOR Pos1, VECTOR Pos2, VECTOR Pos3, int Color, int FillFlag )
{
	int Ret ;
	int Flag ;

	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE ) return -1 ;

	// 非描画設定がされている場合は何もせず終了
	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// ブレンドテクスチャは使用できない
	if( GBASE.BlendGraph > 0 )
		return -1 ;

	Flag = GRA2.ValidHardWare ;

	// 描画
	DRAW_DEF(
		DrawTriangle3DHardware( Pos1, Pos2, Pos3, Color, FillFlag, TRUE, NULL ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}


// ３Ｄの点を描画する
extern int NS_DrawPixel3D( VECTOR Pos, int Color )
{
	int Ret ;
	int Flag ;

	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE ) return -1 ;

	// 非描画設定がされている場合は何もせず終了
	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ブレンドテクスチャは使用できない
	if( GBASE.BlendGraph > 0 )
		return -1 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	Flag = GRA2.ValidHardWare ;

	// 描画
	DRAW_DEF(
		DrawPixel3DHardware( Pos, Color, TRUE, NULL ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}

// ３Ｄの線分を描画する
extern int NS_DrawLine3D( VECTOR Pos1, VECTOR Pos2, int Color )
{
	int Ret ;
	int Flag ;

	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE ) return -1 ;

	// 非描画設定がされている場合は何もせず終了
	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	// ブレンドテクスチャは使用できない
	if( GBASE.BlendGraph > 0 )
		return -1 ;

	Flag = GRA2.ValidHardWare ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// 描画
	DRAW_DEF(
		DrawLine3DHardware( Pos1, Pos2, Color, TRUE, NULL ),
		0,
		GRH.DrawRect = GBASE.DrawArea ;,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}

// FillGraph のグローバル変数にアクセスしないバージョン
extern int FillGraph_UseGParam(
	int GrHandle,
	int Red,
	int Green,
	int Blue,
	int Alpha,
	int ASyncThread
)
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_ORIG *Orig ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	int i ;
	DWORD Code ;
	RECT Rect ;

	// エラー判定
	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
			return -1 ;
	}
	else
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
	}
	Orig = Image2->Orig ;

	// 値の補正
	if( Red   < 0 ) Red   = 0 ; else if( Red   > 255 ) Red   = 255 ;
	if( Green < 0 ) Green = 0 ; else if( Green > 255 ) Green = 255 ;
	if( Blue  < 0 ) Blue  = 0 ; else if( Blue  > 255 ) Blue  = 255 ;
	if( Alpha < 0 ) Alpha = 0 ; else if( Alpha > 255 ) Alpha = 255 ;

	// テクスチャかどうかで処理を分岐
	if( Image2->Orig->FormatDesc.TextureFlag )
	{
		// テクスチャの場合

		// デバイスが無かったらエラー
		if( GraphicsDevice_IsValid() == 0 ) return -1 ;

		// カラーコードの作成
		Code = ( Alpha << 24 ) | ( Red << 16 ) | ( Green << 8 ) | ( Blue << 0 ) ;

		// 描画情報の数だけ繰り返し
		if( Image2->Orig->FormatDesc.DrawValidFlag )
		{
			DrawTex = Image2->Hard.Draw ;
			for( i = 0 ; i < Image2->Hard.DrawNum ; i ++, DrawTex ++ )
			{
				// 使用域を指定色で塗りつぶし
				Rect.left = DrawTex->UsePosX ;
				Rect.top  = DrawTex->UsePosY ;
				Rect.right = DrawTex->UsePosX + DrawTex->Width ;
				Rect.bottom = DrawTex->UsePosY + DrawTex->Height ;
				GraphicsDevice_ColorFill_ASync( DrawTex->Tex->Surface[ 0 ], &Rect, Code, ASyncThread ) ;
			}
		}
		else
		{
			BASEIMAGE TempImage ;

			if( NS_CreateARGB8ColorBaseImage( Image2->Width, Image2->Height, &TempImage ) == 0 )
			{
				NS_FillBaseImage( &TempImage, Red, Green, Blue, Alpha ) ;
				NS_BltBmpOrGraphImageToGraph( NULL, NULL, NULL, FALSE, &TempImage, NULL, 0, 0, GrHandle ) ;
				NS_ReleaseBaseImage( &TempImage ) ;
			}
		}
	}
	else
	{
		// テクスチャではない場合

		// DrawFillBoxMemImg で塗りつぶす
		Rect.left   = 0 ;
		Rect.top    = 0 ;
		Rect.right  = Image2->Width ;
		Rect.bottom = Image2->Height ;
		DrawFillBoxMemImg( &Image2->Soft.MemImg, &Rect, NS_GetColor( Red, Green, Blue ) ) ; 
	}

	// 終了
	return 0 ;
}

// グラフィックを特定の色で塗りつぶす
extern	int NS_FillGraph( int GrHandle, int Red, int Green, int Blue, int Alpha )
{
	return FillGraph_UseGParam( GrHandle, Red, Green, Blue, Alpha, FALSE ) ;
}

// 太さ指定付き線の描画
static int DrawLine_Thickness( int x1, int y1, int x2, int y2, int Color, int Thickness )
{
	VERTEX vert[4];
	VECTOR v, p1, p2;
	int r, g, b;
	float f;

	if( Thickness <= 0 || Thickness == 1 )
	{
		return NS_DrawLine( x1, y1, x2, y2, Color, 1 ) ;
	}
	else
	{
		if( x1 == x2 && Thickness % 2 == 1 )
		{
			int x ;

			x = x1 - Thickness / 2 ;
			return NS_DrawBox( x, y1, x + Thickness, y2, Color, TRUE ) ;
		}
		else
		if( y1 == y2 && Thickness % 2 == 1 )
		{
			int y ;

			y = y1 - Thickness / 2 ;
			return NS_DrawBox( x1, y, x2, y + Thickness, Color, TRUE ) ;
		}
	}

	if( GRA2.ValidHardWare )
	{
		p1.x = (float)x1;
		p1.y = (float)y1;
		p2.x = (float)x2;
		p2.y = (float)y2;

		v.x = (    p2.y - p1.y   );
		v.y = ( -( p2.x - p1.x ) );
		f = ( 1.0f / _SQRT( v.x * v.x + v.y * v.y ) ) * ( (float)Thickness / 2.0f );
		v.x *= f;
		v.y *= f;

		NS_GetColor2( Color, &r, &g, &b );
		vert[0].u = 0.0f;
		vert[0].v = 0.0f;
		vert[0].r = (unsigned char)r;
		vert[0].g = (unsigned char)g;
		vert[0].b = (unsigned char)b;
		vert[0].a = (unsigned char)255;
		vert[1] =
		vert[2] =
		vert[3] = vert[0];

		vert[0].x = p1.x + v.x;
		vert[0].y = p1.y + v.y;
		vert[1].x = p2.x + v.x;
		vert[1].y = p2.y + v.y;
		vert[2].x = p1.x - v.x;
		vert[2].y = p1.y - v.y;
		vert[3].x = p2.x - v.x;
		vert[3].y = p2.y - v.y;

		NS_DrawPolygonBase( vert, 4, DX_PRIMTYPE_TRIANGLESTRIP, DX_NONE_GRAPH, FALSE );
	}
	else
	{
		v.x = ( float )(    y2 - y1   );
		v.y = ( float )( -( x2 - x1 ) );
		f = ( 1.0f / _SQRT( v.x * v.x + v.y * v.y ) ) * ( (float)Thickness / 2.0f ) ;
		v.x *= f ;
		v.y *= f ;

		DrawQuadrangleSoftware( 
			_FTOL( x1 + v.x ),
			_FTOL( y1 + v.y ),
			_FTOL( x2 + v.x ),
			_FTOL( y2 + v.y ),
			_FTOL( x2 - v.x ),
			_FTOL( y2 - v.y ),
			_FTOL( x1 - v.x ),
			_FTOL( y1 - v.y ), Color, TRUE ) ;
	}

	// 終了
	return 0;
}

// 線を描画
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, x1, y1, x2, y2 ) ;\
	if( x1 > x2 ){ GRH.DrawRect.left = x2 ; GRH.DrawRect.right  = x1; }\
	if( y1 > y2 ){ GRH.DrawRect.top  = y2 ; GRH.DrawRect.bottom = y1; }\
	GRH.DrawRect.left   -= Thickness ;\
	GRH.DrawRect.top    -= Thickness ;\
	GRH.DrawRect.right  += 1 + Thickness ;\
	GRH.DrawRect.bottom += 1 + Thickness ;\
	DRAWRECT_DRAWAREA_CLIP

extern	int NS_DrawLine( int x1, int y1, int x2, int y2, int Color, int Thickness )
{
	int Ret = -1 ;
	int Flag ;

	// 太さが１以上の場合は太さ指定付き線描画を行う
	if( Thickness > 1 )
		return DrawLine_Thickness( x1, y1, x2, y2, Color, Thickness ) ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	DRAW_DEF(
		DrawLineHardware( x1, y1, x2, y2, Color ),
		DrawLineSoftware( x1, y1, x2, y2, Color ),
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// 四角形の描画
extern	int NS_DrawBox( int x1, int y1, int x2, int y2, int Color, int FillFlag )
{
	int Ret ;
	
	if( FillFlag )	Ret = NS_DrawFillBox( x1, y1, x2, y2, Color ) ;
	else			Ret = NS_DrawLineBox( x1, y1, x2, y2, Color ) ;

	// 終了
	return Ret ;
}

// 中身のある四角を描画
#define SETDRAWRECTCODE\
	if( x1 < x2 ){ GRH.DrawRect.left = x1 ; GRH.DrawRect.right = x2; }\
	if( y1 < y2 ){ GRH.DrawRect.top = y1 ; GRH.DrawRect.bottom = y2; }\
\
	SETRECT( GRH.DrawRect, x1, y1, x2, y2 ) ;\
	DRAWRECT_DRAWAREA_CLIP

extern	int NS_DrawFillBox( int x1, int y1, int x2, int y2, int Color )
{
	int Ret = -1 ;
	int Flag ;
	
	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;
	
	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	// 描画
	DRAW_DEF(
		DrawFillBoxHardware( x1, y1, x2, y2, Color ),
		DrawFillBoxSoftware( x1, y1, x2, y2, Color ),
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}

// 四角形の描画 
extern	int NS_DrawLineBox( int x1, int y1, int x2, int y2, int Color )
{
	int Ret = -1 ;
	int Flag ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;
	
	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	// 描画
	DRAW_DEF(
		DrawLineBoxHardware( x1, y1, x2, y2, Color ),
		DrawLineBoxSoftware( x1, y1, x2, y2, Color ),
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// 円を描く
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, x - r - 1, y - r - 1, x + r + 1, y + r + 1 )\
	DRAWRECT_DRAWAREA_CLIP
extern	int NS_DrawCircle( int x, int y, int r, int Color, int FillFlag, int Thickness )
{
	int Ret = -1 ;
	int Flag ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;
	
	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	if( r < 0 ) return 0 ;

	// 描画
	if( Thickness == 1 )
	{
		DRAW_DEF(
			DrawCircleHardware( x, y, r, Color, FillFlag ),
			DrawCircleSoftware( x, y, r, Color, FillFlag ),
			SETDRAWRECTCODE,
			Ret,
			Flag
		)
	}
	else
	{
		DRAW_DEF(
			DrawCircle_ThicknessHardware( x, y, r, Color, Thickness ),
			DrawCircle_ThicknessSoftware( x, y, r, Color, Thickness ),
			SETDRAWRECTCODE,
			Ret,
			Flag
		)
	}

	// 終了
	return Ret ;
}
#undef SETDRAWRECTCODE

// 楕円を描く
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, x - rx - 1, y - ry - 1, x + rx + 1, y + ry + 1 )\
	DRAWRECT_DRAWAREA_CLIP
extern	int NS_DrawOval( int x, int y, int rx, int ry, int Color, int FillFlag, int Thickness )
{
	int Ret = -1 ;
	int Flag ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	if( rx < 0 || ry < 0 ) return 0 ;

	// 描画
	if( Thickness == 1 )
	{
		DRAW_DEF(
			DrawOvalHardware( x, y, rx, ry, Color, FillFlag ),
			DrawOvalSoftware( x, y, rx, ry, Color, FillFlag ),
			SETDRAWRECTCODE,
			Ret,
			Flag
		)
	}
	else
	{
		DRAW_DEF(
			DrawOval_ThicknessHardware( x, y, rx, ry, Color, Thickness ),
			DrawOval_ThicknessSoftware( x, y, rx, ry, Color, Thickness ),
			SETDRAWRECTCODE,
			Ret,
			Flag
		)
	}

	// 終了
	return Ret ;
}
#undef SETDRAWRECTCODE

// 三角形の描画
#define SETDRAWRECTCODE\
	int x[ 3 ], y[ 3 ], MaxX, MaxY, MinX, MinY ;\
	int i, ix, iy ;\
\
	x[ 0 ] = x1 ; x[ 1 ] = x2 ; x[ 2 ] = x3 ;\
	y[ 0 ] = y1 ; y[ 1 ] = y2 ; y[ 2 ] = y3 ;\
\
	MaxX = 0 ; MaxY = 0 ;\
	MinX = 0xffffff ; MinY = 0xffffff ;\
\
	for( i = 0 ; i < 3 ; i ++ )\
	{\
		ix = x[ i ] ; iy = y[ i ] ;\
		if( ix > MaxX ) MaxX = ix ; if( iy > MaxY ) MaxY = iy ;\
		if( ix < MinX ) MinX = ix ; if( iy < MinY ) MinY = iy ;\
	}\
\
	SETRECT( GRH.DrawRect, MinX, MinY, MaxX, MaxY ) ;\
	DRAWRECT_DRAWAREA_CLIP

extern	int NS_DrawTriangle( int x1, int y1, int x2, int y2, int x3, int y3, int Color, int FillFlag )
{
	int Ret = -1 ;
	int Flag ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;
	
	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	// 描画
	DRAW_DEF(
		DrawTriangleHardware( x1, y1, x2, y2, x3, y3, Color, FillFlag ),
		DrawTriangleSoftware( x1, y1, x2, y2, x3, y3, Color, FillFlag ),
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// 四角形の描画
#define SETDRAWRECTCODE\
	int x[ 4 ], y[ 4 ], MaxX, MaxY, MinX, MinY ;\
	int i, ix, iy ;\
\
	x[ 0 ] = x1 ; x[ 1 ] = x2 ; x[ 2 ] = x3 ; x[ 3 ] = x4 ;\
	y[ 0 ] = y1 ; y[ 1 ] = y2 ; y[ 2 ] = y3 ; y[ 3 ] = y4 ;\
\
	MaxX = 0 ; MaxY = 0 ;\
	MinX = 0xffffff ; MinY = 0xffffff ;\
\
	for( i = 0 ; i < 4 ; i ++ )\
	{\
		ix = x[ i ] ; iy = y[ i ] ;\
		if( ix > MaxX ) MaxX = ix ; if( iy > MaxY ) MaxY = iy ;\
		if( ix < MinX ) MinX = ix ; if( iy < MinY ) MinY = iy ;\
	}\
\
	SETRECT( GRH.DrawRect, MinX, MinY, MaxX, MaxY ) ;\
	DRAWRECT_DRAWAREA_CLIP

extern	int NS_DrawQuadrangle( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4, int Color, int FillFlag )
{
	int Ret = -1 ;
	int Flag ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;
	
	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	// 描画
	DRAW_DEF(
		DrawQuadrangleHardware( x1, y1, x2, y2, x3, y3, x4, y4, Color, FillFlag ),
		DrawQuadrangleSoftware( x1, y1, x2, y2, x3, y3, x4, y4, Color, FillFlag ),
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}

#undef SETDRAWRECTCODE

// 点を描画する
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, x, y, x + 1, y + 1 )\
	DRAWRECT_DRAWAREA_CLIP
extern 	int NS_DrawPixel( int x, int y, int Color )
{
	int Ret = -1 ;
	int Flag ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;
	
	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	// 描画
//	if( GBASE.NotUseBasicGraphDraw3DDeviceMethodFlag ) Flag = FALSE ;
	DRAW_DEF(
		DrawPixelHardware( x, y, Color ),
		DrawPixelSoftware( x, y, Color ),
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}
#undef SETDRAWRECTCODE

// 点の集合を描く
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, 0, 0, GBASE.DrawSizeX, GBASE.DrawSizeY )\
	DRAWRECT_DRAWAREA_CLIP
extern 	int NS_DrawPixelSet( const POINTDATA *PointData, int Num )
{
	int Ret = -1 ;
	int Flag ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;

	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	// 描画
	DRAW_DEF(
		DrawPixelSetHardware( PointData, Num  ),
		DrawPixelSetSoftware( PointData, Num  ),
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}
#undef SETDRAWRECTCODE

// 線の集合を描く
#define SETDRAWRECTCODE\
	SETRECT( GRH.DrawRect, 0, 0, GBASE.DrawSizeX, GBASE.DrawSizeY )\
	DRAWRECT_DRAWAREA_CLIP
extern	int NS_DrawLineSet( const LINEDATA *LineData, int Num )
{
	int Ret = -1 ;
	int Flag ;

	if( GBASE.NotDrawFlag || GBASE.NotDrawFlagInSetDrawArea )
		return 0 ;
	
	Flag = GRA2.ValidHardWare ;

	CheckActiveState() ;

	// 描画
	DRAW_DEF(
		DrawLineSetHardware( LineData, Num ),
		DrawLineSetSoftware( LineData, Num ),
		SETDRAWRECTCODE,
		Ret,
		Flag
	)

	// 終了
	return Ret ;
}
#undef SETDRAWRECTCODE












// 頂点バッファ関係関数

// 頂点バッファハンドルのセットアップを行う
extern int SetupVertexBufferHandle( int VertexBufHandle, int VertexNum, int VertexType /* DX_VERTEX_TYPE_NORMAL_3D 等 */ )
{
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	int VertexSize ;
	int FVF ;

	// エラー判定
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;

	// 対応していないタイプの場合はエラー
	switch( VertexType )
	{
	case DX_VERTEX_TYPE_NORMAL_3D :
		VertexSize = sizeof( VERTEX3D ) ;
		FVF = VERTEXFVF_3D_LIGHT ;
		break ;

	case DX_VERTEX_TYPE_SHADER_3D :
		VertexSize = sizeof( VERTEX3DSHADER ) ;

		// シェーダーが使えない場合は失敗
		if( GRH.UseShader == FALSE )
			return -1 ;

		FVF = VERTEXFVF_3D_LIGHT ;
		break ;

	default :
		DXST_ERRORLOG_ADD( _T( "頂点タイプの値が不正です\n" ) ) ;
		return -1 ;
	}

	// 頂点処理をハードウエアで処理する場合のみ Direct3D9VertexBuffer を作成する
	if( GRH.VertexHardwareProcess || GRH.ValidVertexShader )
	{
		// 頂点バッファを作成する
		if( GraphicsDevice_CreateVertexBuffer_ASync( 
				VertexSize * VertexNum,
				D_D3DUSAGE_WRITEONLY,
				FVF,
				D_D3DPOOL_DEFAULT,
				&VertexBuffer->Direct3DBuffer
			) < 0 )
		{
			DXST_ERRORLOG_ADD( _T( "頂点バッファの作成に失敗しました\n" ) ) ;
			return -1 ;
		}
	}

	// データ領域を確保する
	if( ReallocHandle( VertexBufHandle, sizeof( VERTEXBUFFERHANDLEDATA ) + VertexSize * VertexNum + 32 ) < 0 )
	{
		DXST_ERRORLOG_ADD( _T( "メモリの確保に失敗しました" ) ) ;
		return -1 ;
	}
	VertexBuffer = ( VERTEXBUFFERHANDLEDATA * )GetHandleInfo( VertexBufHandle ) ;

	// システムメモリ上の頂点データを保存するアドレスをセット
	VertexBuffer->Buffer = ( void * )( ( ( DWORD_PTR )VertexBuffer + sizeof( VERTEXBUFFERHANDLEDATA ) + 31 ) / 32 * 32 ) ;

	// タイプを保存
	VertexBuffer->Type = VertexType ;

	// 頂点データ一つ辺りのバイト数を保存
	VertexBuffer->UnitSize = VertexSize ;

	// 頂点数を保存
	VertexBuffer->Num = VertexNum ;

	// 正常終了
	return 0 ;
}

// 頂点バッファハンドルの初期化
extern int InitializeVertexBufferHandle( HANDLEINFO * )
{
	// 不需要特别处理
	return 0 ;
}

// 頂点バッファハンドルの後始末
extern int TerminateVertexBufferHandle( HANDLEINFO *HandleInfo )
{
	VERTEXBUFFERHANDLEDATA *VertexBuffer = ( VERTEXBUFFERHANDLEDATA * )HandleInfo ;

	// 頂点バッファの解放
	if( VertexBuffer->Direct3DBuffer )
	{
		Graphics_ObjectRelease( VertexBuffer->Direct3DBuffer ) ;
		VertexBuffer->Direct3DBuffer = NULL ;
	}

	// 終了
	return 0 ;
}

// 頂点バッファを作成する( -1:エラー  0以上:頂点バッファハンドル )
extern int NS_CreateVertexBuffer( int VertexNum, int VertexType /* DX_VERTEX_TYPE_NORMAL_3D 等 */ )
{
	int NewHandle ;

	// 新しいハンドルを作成する
	NewHandle = AddHandle( DX_HANDLETYPE_VERTEX_BUFFER ) ;
	if( NewHandle < 0 )
		return -1 ;

	// ハンドルのセットアップ
	if( SetupVertexBufferHandle( NewHandle, VertexNum, VertexType ) < 0 )
	{
		SubHandle( NewHandle ) ;
		return -1 ;
	}

	// 返回句柄
	return NewHandle ;
}

// 頂点バッファを削除する
extern int NS_DeleteVertexBuffer( int VertexBufHandle )
{
	return SubHandle( VertexBufHandle ) ;
}

// すべての頂点バッファを削除する
extern int NS_InitVertexBuffer()
{
	return AllHandleSub( DX_HANDLETYPE_VERTEX_BUFFER ) ;
}

// 頂点バッファに頂点データを転送する
extern int NS_SetVertexBufferData( int SetIndex, const void *VertexData, int VertexNum, int VertexBufHandle )
{
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	void *pBuffer ;

	// エラー判定
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;

	// エラーチェック
	if( VertexBuffer->Num < SetIndex + VertexNum || SetIndex < 0 )
		return -1 ;

	// Direct3DVertexBuffer9 がある場合は頂点バッファに転送
	if( VertexBuffer->Direct3DBuffer )
	{
		// バッファのロック
		if( GraphicsVertexBuffer_Lock(
				VertexBuffer->Direct3DBuffer, 
				SetIndex * VertexBuffer->UnitSize,
				VertexNum * VertexBuffer->UnitSize,
				&pBuffer,
				0 ) != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "頂点バッファのロックに失敗しました\n" ) ) ;
			return -1 ;
		}

		// バッファへデータを転送
		_MEMCPY( pBuffer, VertexData, VertexNum * VertexBuffer->UnitSize ) ;

		// バッファのアンロック
		GraphicsVertexBuffer_Unlock( VertexBuffer->Direct3DBuffer ) ;
	}

	// システムメモリのバッファへも転送
	_MEMCPY( ( BYTE * )VertexBuffer->Buffer + SetIndex * VertexBuffer->UnitSize, VertexData, VertexNum * VertexBuffer->UnitSize ) ;

	// 終了
	return 0 ;
}

// インデックスバッファハンドルのセットアップを行う
extern int SetupIndexBufferHandle( int IndexBufHandle, int IndexNum, int IndexType /* DX_INDEX_TYPE_16BIT 等 */ )
{
	INDEXBUFFERHANDLEDATA *IndexBuffer ;
	int IndexSize ;
	D_D3DFORMAT Format ;

	// エラー判定
	if( INDEXBUFFERCHK( IndexBufHandle, IndexBuffer ) )
		return -1 ;

	// 対応していないタイプの場合はエラー
	switch( IndexType )
	{
	case DX_INDEX_TYPE_16BIT :
		IndexSize = sizeof( WORD ) ;
		Format = D_D3DFMT_INDEX16 ;
		break ;

	case DX_INDEX_TYPE_32BIT :
		IndexSize = sizeof( DWORD ) ;
		Format = D_D3DFMT_INDEX32 ;
		break ;

	default :
		DXST_ERRORLOG_ADD( _T( "インデックスタイプの値が不正です\n" ) ) ;
		return -1 ;
	}

	// 頂点処理をハードウエアで処理する場合のみ Direct3D9IndexBuffer を作成する
	if( GRH.VertexHardwareProcess || GRH.ValidVertexShader )
	{
		// インデックスバッファを作成する
		if( GraphicsDevice_CreateIndexBuffer_ASync( 
				IndexSize * IndexNum,
				D_D3DUSAGE_WRITEONLY,
				Format,
				D_D3DPOOL_DEFAULT,
				&IndexBuffer->Direct3DBuffer
			) < 0 )
		{
			DXST_ERRORLOG_ADD( _T( "インデックスバッファの作成に失敗しました\n" ) ) ;
			return -1 ;
		}
	}

	// データ領域を確保する
	if( ReallocHandle( IndexBufHandle, sizeof( INDEXBUFFERHANDLEDATA ) + IndexSize * IndexNum + 32 ) < 0 )
	{
		DXST_ERRORLOG_ADD( _T( "メモリの確保に失敗しました" ) ) ;
		return -1 ;
	}
	IndexBuffer = ( INDEXBUFFERHANDLEDATA * )GetHandleInfo( IndexBufHandle ) ;

	// システムメモリ上のインデックスデータを保存するアドレスをセット
	IndexBuffer->Buffer = ( void * )( ( ( DWORD_PTR )IndexBuffer + sizeof( INDEXBUFFERHANDLEDATA ) + 31 ) / 32 * 32 ) ;

	// タイプを保存
	IndexBuffer->Type = IndexType ;

	// インデックスデータ一つ辺りのバイト数を保存
	IndexBuffer->UnitSize = IndexSize ;

	// インデックス数を保存
	IndexBuffer->Num = IndexNum ;

	// 正常終了
	return 0 ;
}

// インデックスバッファハンドルの初期化
extern int InitializeIndexBufferHandle( HANDLEINFO * )
{
	// 不需要特别处理
	return 0 ;
}

// インデックスバッファハンドルの後始末
extern int TerminateIndexBufferHandle( HANDLEINFO *HandleInfo )
{
	INDEXBUFFERHANDLEDATA *IndexBuffer = ( INDEXBUFFERHANDLEDATA * )HandleInfo ;

	// インデックスバッファの解放
	if( IndexBuffer->Direct3DBuffer )
	{
		Graphics_ObjectRelease( IndexBuffer->Direct3DBuffer ) ;
		IndexBuffer->Direct3DBuffer = NULL ;
	}

	// 終了
	return 0 ;
}

// シェーダー定数使用領域情報を初期化する
extern int InitializeShaderConstantUseArea( SHADERCONSTANT_USEAREA *UseArea, int TotalSize )
{
	_MEMSET( UseArea, 0, sizeof( SHADERCONSTANT_USEAREA ) ) ;

	// 管理する領域のサイズを設定
	UseArea->TotalSize = TotalSize ;

	// 終了
	return 0 ;
}

// シェーダー定数使用領域情報を変更する
extern int SetShaderConstantUseArea( SHADERCONSTANT_USEAREA *UseArea, int IsUse, int Index, int Num )
{
	SHADERCONST_ONE_USEAREA *OneArea ;
	int i ;
	int j ;
	int StartIndex ;
	int EndPlusOneIndex ;
	int Bottom ;
	int NoHit ;

	// 変更個数が０だったら何もしない
	if( Num == 0 )
		return 0 ;

	StartIndex = Index ;
	EndPlusOneIndex = Index + Num ;

	// 全く引っかかってないかを調べる
	Bottom = TRUE ;
	NoHit = FALSE ;
	OneArea = UseArea->AreaInfo ;
	i = 0 ;
	while( i < UseArea->AreaInfoNum && OneArea->Start > EndPlusOneIndex )
	{
		i ++ ;
		OneArea ++ ;
	}
	if( i != UseArea->AreaInfoNum )
	{
		Bottom = FALSE ;

		// 引っかかるところまでアドレスを進める
		OneArea = UseArea->AreaInfo ;
		i = 0 ;
		while( i < UseArea->AreaInfoNum && OneArea->EndPlusOne <= StartIndex )
		{
			i ++ ;
			OneArea ++ ;
		}

		// 既存の範囲に触れているかをチェック
		if( OneArea->Start > EndPlusOneIndex )
		{
			NoHit = TRUE ;
		}
	}

	// 使用領域が増えるのかどうかで処理を分岐
	if( IsUse == FALSE )
	{
		// 減る場合

		// 一つも引っかからなかったら終了
		if( i == UseArea->AreaInfoNum || NoHit )
			return 0 ;

		// 最初に引っかかった範囲内に収まる場合は範囲情報の数が増える
		if( OneArea->Start      < StartIndex &&
			OneArea->EndPlusOne > EndPlusOneIndex )
		{
			_MEMMOVE( OneArea + 1, OneArea, sizeof( SHADERCONST_ONE_USEAREA ) * ( UseArea->AreaInfoNum - i ) ) ;
			OneArea[ 0 ].EndPlusOne = ( WORD )StartIndex ;
			OneArea[ 1 ].Start = ( WORD )EndPlusOneIndex ;
			UseArea->AreaInfoNum ++ ;
			return 0 ;
		}

		// 最初に引っかかった範囲内の開始位置と等しくない場合はサイズを調整
		if( OneArea->Start < StartIndex )
		{
			OneArea->EndPlusOne = ( WORD )StartIndex ;
			OneArea ++ ;
			i ++ ;
		}

		// 丸々含まれてしまう範囲の数を調べる
		j = 0 ;
		while( i < UseArea->AreaInfoNum && OneArea[ j ].EndPlusOne <= EndPlusOneIndex )
		{
			j ++ ;
			i ++ ;
		}

		// 丸々含まれてしまう範囲情報を削除
		if( j > 0 && UseArea->AreaInfoNum - i > 0 )
		{
			_MEMMOVE( OneArea, OneArea + j, sizeof( SHADERCONST_ONE_USEAREA ) * ( UseArea->AreaInfoNum - i ) ) ;
		}
		UseArea->AreaInfoNum -= j ;

		// 残りがある場合で範囲が被っている場合は範囲の開始位置をずらす
		if( UseArea->AreaInfoNum > 0 && OneArea->Start < EndPlusOneIndex )
		{
			OneArea->Start = ( WORD )EndPlusOneIndex ;
		}
	}
	else
	{
		// 増える場合

		// 一つも引っかからなかったら範囲情報を追加
		if( i == UseArea->AreaInfoNum )
		{
			// もし一つ前の範囲と接していたら一つ前の範囲情報を広げる
			if( i > 0 && OneArea[ -1 ].EndPlusOne == StartIndex )
			{
				OneArea[ -1 ].EndPlusOne = ( WORD )EndPlusOneIndex ;
			}
			else
			{
				if( Bottom )
				{
					OneArea = UseArea->AreaInfo ;
					_MEMMOVE( OneArea + 1, OneArea, sizeof( SHADERCONST_ONE_USEAREA ) * UseArea->AreaInfoNum ) ;
				}
				OneArea->Start = ( WORD )StartIndex ;
				OneArea->EndPlusOne = ( WORD )EndPlusOneIndex ;
				UseArea->AreaInfoNum ++ ;
			}

			return 0 ;
		}
		if( NoHit )
		{
			// もし一つ前の範囲と接していたら一つ前の範囲情報を広げる
			if( i > 0 && OneArea[ -1 ].EndPlusOne == StartIndex )
			{
				OneArea[ -1 ].EndPlusOne = ( WORD )EndPlusOneIndex ;
			}
			else
			{
				_MEMMOVE( OneArea + 1, OneArea, sizeof( SHADERCONST_ONE_USEAREA ) * ( UseArea->AreaInfoNum - i ) ) ;
				OneArea->Start = ( WORD )StartIndex ;
				OneArea->EndPlusOne = ( WORD )EndPlusOneIndex ;
				UseArea->AreaInfoNum ++ ;
			}
			return 0 ;
		}

		// 最初の一つ前の範囲情報と接していた場合は対象を一つ前の範囲情報にする
		if( i > 0 && OneArea[ -1 ].EndPlusOne == StartIndex )
		{
			OneArea -- ;
			i -- ;
		}

		// 最初に引っかかった範囲情報の開始位置より開始位置が低かったら広げる
		if( OneArea->Start > StartIndex )
		{
			OneArea->Start = ( WORD )StartIndex ;
		}

		// 最初に引っかかった範囲情報に収まる場合はここで終了
		if( OneArea->EndPlusOne >= EndPlusOneIndex )
			return 0 ;

		// 収まらない場合は範囲を広げる
		OneArea->EndPlusOne = ( WORD )EndPlusOneIndex ;
		StartIndex = OneArea->Start ;

		// 以降の範囲情報で丸々被っている範囲の数を調べる
		OneArea ++ ;
		i ++ ;
		j = 0 ;
		while( i < UseArea->AreaInfoNum && OneArea[ j ].EndPlusOne <= EndPlusOneIndex )
		{
			j ++ ;
			i ++ ;
		}

		// 残りがある場合で範囲が被っていたら範囲を追加して削除
		if( i < UseArea->AreaInfoNum && OneArea[ j ].Start <= EndPlusOneIndex )
		{
			OneArea[ -1 ].EndPlusOne = OneArea[ j ].EndPlusOne ;
			j ++ ;
			i ++ ;
		}

		// 範囲情報を削除
		if( j > 0 && UseArea->AreaInfoNum - i > 0 )
		{
			_MEMMOVE( OneArea, OneArea + j, sizeof( SHADERCONST_ONE_USEAREA ) * ( UseArea->AreaInfoNum - i ) ) ;
		}
		UseArea->AreaInfoNum -= j ;
	}

	// 終了
	return 0 ;
}

// シェーダー定数使用領域情報から使用マップを作成する
extern int CreateUseAreaMap( SHADERCONSTANT_USEAREA *UseArea, BYTE *Map, BYTE SetNumber )
{
	int i, j ;
	SHADERCONST_ONE_USEAREA *AInfo ;

	AInfo = UseArea->AreaInfo ;
	for( i = 0 ; i < UseArea->AreaInfoNum ; i ++, AInfo ++ )
	{
		for( j = AInfo->Start ; j < AInfo->EndPlusOne ; j ++ )
		{
			Map[ j ] = SetNumber ;
		}
	}

	// 終了
	return 0 ;
}

// インデックスバッファを作成する( -1:エラー　0以上：インデックスバッファハンドル )
extern int NS_CreateIndexBuffer( int IndexNum, int IndexType /* DX_INDEX_TYPE_16BIT 等 */  )
{
	int NewHandle ;

	// 新しいハンドルを作成する
	NewHandle = AddHandle( DX_HANDLETYPE_INDEX_BUFFER ) ;
	if( NewHandle < 0 )
		return -1 ;

	// ハンドルのセットアップ
	if( SetupIndexBufferHandle( NewHandle, IndexNum, IndexType ) < 0 )
	{
		SubHandle( NewHandle ) ;
		return -1 ;
	}

	// 返回句柄
	return NewHandle ;
}

// インデックスバッファを削除する
extern int NS_DeleteIndexBuffer( int IndexBufHandle )
{
	return SubHandle( IndexBufHandle ) ;
}

// すべてのインデックスバッファを削除する
extern int NS_InitIndexBuffer()
{
	return AllHandleSub( DX_HANDLETYPE_INDEX_BUFFER ) ;
}

// インデックスバッファにインデックスデータを転送する
extern int NS_SetIndexBufferData( int SetIndex, const void *IndexData, int IndexNum, int IndexBufHandle )
{
	INDEXBUFFERHANDLEDATA *IndexBuffer ;
	void *pBuffer ;

	// エラー判定
	if( INDEXBUFFERCHK( IndexBufHandle, IndexBuffer ) )
		return -1 ;

	// エラーチェック
	if( IndexBuffer->Num < SetIndex + IndexNum || SetIndex < 0 )
		return -1 ;

	// Direct3DIndexBuffer9 があったらデータを転送
	if( IndexBuffer->Direct3DBuffer )
	{
		// バッファのロック
		if( GraphicsIndexBuffer_Lock(
				IndexBuffer->Direct3DBuffer, 
				SetIndex * IndexBuffer->UnitSize,
				IndexNum * IndexBuffer->UnitSize,
				&pBuffer,
				0 ) != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "インデックスバッファのロックに失敗しました\n" ) ) ;
			return -1 ;
		}

		// バッファへデータを転送
		_MEMCPY( pBuffer, IndexData, IndexNum * IndexBuffer->UnitSize ) ;

		// バッファのアンロック
		GraphicsIndexBuffer_Unlock( IndexBuffer->Direct3DBuffer ) ;
	}

	// システムメモリのバッファへも転送
	_MEMCPY( ( BYTE * )IndexBuffer->Buffer + SetIndex * IndexBuffer->UnitSize, IndexData, IndexNum * IndexBuffer->UnitSize ) ;

	// 終了
	return 0 ;
}

// グラフィックスデバイスが対応している一度に描画できるプリミティブの最大数を取得する
extern int NS_GetMaxPrimitiveCount( void )
{
	return GRH.MaxPrimitiveCount ;
}

// グラフィックスデバイスが対応している一度に使用することのできる最大頂点数を取得する
extern int NS_GetMaxVertexIndex( void )
{
	return GRH.DeviceCaps.MaxVertexIndex ;
}














// シェーダー関係関数

// シェーダーハンドルを作成する
extern int CreateShaderHandle( void )
{
	if( GRA2.InitializeFlag == FALSE )
		return -1 ;

	// シェーダが使えない場合は失敗
	if( GRH.UseShader == FALSE )
		return -1 ;

	return AddHandle( DX_HANDLETYPE_SHADER ) ;
}

// CreateShader の実処理関数
static int CreateShader_Static(
	int ShaderHandle,
	int IsVertexShader,
	void *Image,
	int ImageSize,
	int ImageAfterFree,
	int ASyncThread
)
{
	SHADERHANDLEDATA *pShader ;
	DX_DIRECT3DPIXELSHADER9 *PixelShader = NULL ;
	DX_DIRECT3DVERTEXSHADER9 *VertexShader = NULL ;

	// エラー判定
	if( ASyncThread )
	{
		if( SHADERCHK_ASYNC( ShaderHandle, pShader ) )
			return -1 ;
	}
	else
	{
		if( SHADERCHK( ShaderHandle, pShader ) )
			return -1 ;
	}

	// シェーダーを作成する
	if( IsVertexShader )
	{
		if( GraphicsDevice_CreateVertexShader_ASync( ( DWORD * )Image, &VertexShader, ASyncThread ) != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "頂点シェーダーの作成に失敗しました\n" ) ) ;
			goto ERR ;
		}
	}
	else
	{
		if( GraphicsDevice_CreatePixelShader_ASync( ( DWORD * )Image, &PixelShader, ASyncThread ) != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "頂点シェーダーの作成に失敗しました\n" ) ) ;
			goto ERR ;
		}
	}

	// バイナリイメージを保存するメモリ領域の確保
	pShader->FunctionCode = DXCALLOC( ImageSize ) ;
	if( pShader->FunctionCode == NULL )
	{
		DXST_ERRORLOG_ADD( _T( "メモリの確保に失敗しました" ) ) ;
		goto ERR ;
	}

	// バイナリイメージを保存する
	_MEMCPY( pShader->FunctionCode, Image, ImageSize ) ;

	// 頂点シェーダーかどうかを保存する
	pShader->IsVertexShader = IsVertexShader ? TRUE : FALSE ;

	// 補助情報があるかどうかを調べる
	if( ( ( BYTE * )pShader->FunctionCode )[ 4 ] == 0xfe && ( ( BYTE * )pShader->FunctionCode )[ 5 ] == 0xff )
	{
		// ある場合

		// 定数情報配列のアドレスを保存する
		pShader->ConstantInfo = ( D_D3DXSHADER_CONSTANTINFO * )( ( BYTE * )pShader->FunctionCode + 0x28 ) ;

		// 定数の数を保存する
		pShader->ConstantNum = *( ( DWORD * )( ( BYTE * )pShader->FunctionCode + 0x18 ) ) ;
	}
	else
	{
		// 無い場合

		// 定数情報配列のアドレスを初期化する
		pShader->ConstantInfo = NULL ;

		// 情報としてアクセスできる定数は０個
		pShader->ConstantNum = 0 ;
	}

	// シェーダーのアドレスを保存
	if( IsVertexShader )
	{
		pShader->VertexShader = VertexShader ;
	}
	else
	{
		pShader->PixelShader = PixelShader ;
	}

	// 処理後に解放すべしのフラグが立っていたら解放する
	if( ImageAfterFree )
	{
		DXFREE( Image ) ;
	}

	// 正常終了
	return 0 ;

ERR :
	if( VertexShader )
	{
		Graphics_ObjectRelease_ASync( VertexShader, ASyncThread ) ;
	}

	if( PixelShader )
	{
		Graphics_ObjectRelease_ASync( PixelShader, ASyncThread ) ;
	}

	// 処理後に解放すべしのフラグが立っていたら解放する
	if( ImageAfterFree )
	{
		DXFREE( Image ) ;
	}

	return -1 ;
}

#ifndef DX_NON_ASYNCLOAD

// CreateShader の非同期読み込みスレッドから呼ばれる関数
static void CreateShader_ASync( ASYNCLOADDATA_COMMON *AParam )
{
	int ShaderHandle ;
	int IsVertexShader ;
	void *Image ;
	int ImageSize ;
	int ImageAfterFree ;
	int Addr ;
	int Result ;

	Addr = 0 ;
	ShaderHandle = GetASyncLoadParamInt( AParam->Data, &Addr ) ;
	IsVertexShader = GetASyncLoadParamInt( AParam->Data, &Addr ) ;
	Image = GetASyncLoadParamVoidP( AParam->Data, &Addr ) ;
	ImageSize = GetASyncLoadParamInt( AParam->Data, &Addr ) ;
	ImageAfterFree = GetASyncLoadParamInt( AParam->Data, &Addr ) ;

	Result = CreateShader_Static( ShaderHandle, IsVertexShader, Image, ImageSize, ImageAfterFree, TRUE ) ;
	DecASyncLoadCount( ShaderHandle ) ;
	if( Result < 0 )
	{
		NS_DeleteShader( ShaderHandle ) ;
	}
}

#endif // DX_NON_ASYNCLOAD

// シェーダーハンドルを作成する
extern int CreateShader_UseGParam(
	int IsVertexShader,
	void *Image,
	int ImageSize,
	int ImageAfterFree,
	int ASyncLoadFlag,
	int ASyncThread
)
{
	int ShaderHandle = -1 ;

	// シェーダが使えない場合は失敗
	if( GraphicsDevice_IsValid() == 0 || GRH.UseShader == FALSE )
		return -1 ;

	ShaderHandle = CreateShaderHandle() ;
	if( ShaderHandle == -1 )
		goto ERR ;

#ifndef DX_NON_ASYNCLOAD
	if( ASyncLoadFlag && ASyncThread == FALSE )
	{
		ASYNCLOADDATA_COMMON *AParam = NULL ;
		int Addr ;

		// パラメータに必要なメモリのサイズを算出
		Addr = 0 ;
		AddASyncLoadParamInt( NULL, &Addr, ShaderHandle ) ;
		AddASyncLoadParamInt( NULL, &Addr, IsVertexShader ) ;
		AddASyncLoadParamConstVoidP( NULL, &Addr, Image ) ;
		AddASyncLoadParamInt( NULL, &Addr, ImageSize ) ;
		AddASyncLoadParamInt( NULL, &Addr, ImageAfterFree ) ;

		// メモリの確保
		AParam = AllocASyncLoadDataMemory( Addr ) ;
		if( AParam == NULL )
			goto ERR ;

		// 処理に必要な情報をセット
		AParam->ProcessFunction = CreateShader_ASync ;
		Addr = 0 ;
		AddASyncLoadParamInt( AParam->Data, &Addr, ShaderHandle ) ;
		AddASyncLoadParamInt( AParam->Data, &Addr, IsVertexShader ) ;
		AddASyncLoadParamConstVoidP( AParam->Data, &Addr, Image ) ;
		AddASyncLoadParamInt( AParam->Data, &Addr, ImageSize ) ;
		AddASyncLoadParamInt( AParam->Data, &Addr, ImageAfterFree ) ;

		// データを追加
		if( AddASyncLoadData( AParam ) < 0 )
		{
			DXFREE( AParam ) ;
			AParam = NULL ;
			goto ERR ;
		}

		// 非同期読み込みカウントをインクリメント
		IncASyncLoadCount( ShaderHandle, AParam->Index ) ;
	}
	else
#endif // DX_NON_ASYNCLOAD
	{
		if( CreateShader_Static( ShaderHandle, IsVertexShader, Image, ImageSize, ImageAfterFree, ASyncThread ) < 0 )
			goto ERR ;
	}

	// 返回句柄
	return ShaderHandle ;

ERR :
	NS_DeleteShader( ShaderHandle ) ;
	ShaderHandle = -1 ;

	// 終了
	return -1 ;
}

// シェーダーハンドルの初期化
extern int InitializeShaderHandle( HANDLEINFO * )
{
	// 特に何もすることなし
	return 0 ;
}

// シェーダーハンドルの後始末
extern int TerminateShaderHandle( HANDLEINFO *HandleInfo )
{
	SHADERHANDLEDATA *Shader = ( SHADERHANDLEDATA * )HandleInfo ;

	// 使用するシェーダーとしてセットされていたら外す
	if( GRH.UserShaderRenderInfo.SetVertexShaderHandle == HandleInfo->Handle )
	{
		NS_SetUseVertexShader( -1 ) ;
	}
	if( GRH.UserShaderRenderInfo.SetPixelShaderHandle == HandleInfo->Handle )
	{
		NS_SetUsePixelShader( -1 ) ;
	}

	// シェーダーのバイナリデータを解放
	if( Shader->FunctionCode != NULL )
	{
		DXFREE( Shader->FunctionCode ) ;
		Shader->FunctionCode = NULL ;
	}

	// シェーダーの解放
	if( Shader->IsVertexShader )
	{
		if( Shader->VertexShader )
		{
			Graphics_ObjectRelease( Shader->VertexShader ) ;
			Shader->VertexShader = NULL ;
		}
	}
	else
	{
		if( Shader->PixelShader )
		{
			Graphics_ObjectRelease( Shader->PixelShader ) ;
			Shader->PixelShader = NULL ;
		}
	}

	// 終了
	return 0 ;
}

// 使用できるシェーダーのバージョンを取得する( 0=使えない  200=シェーダーモデル２．０が使用可能  300=シェーダーモデル３．０が使用可能 )
extern int NS_GetValidShaderVersion( void )
{
	D_D3DCAPS9 DevCaps ;

	// シェーダが使えない場合は０を返す
	if( GraphicsDevice_IsValid() != 0 && GRH.UseShader == FALSE )
		return 0 ;

	// 能力を取得
	Graphics_GetDeviceCaps( GRH.ValidAdapterNumber ? GRH.UseAdapterNumber : D_D3DADAPTER_DEFAULT, D_D3DDEVTYPE_HAL, &DevCaps ) ;

	if( ( DevCaps.VertexShaderVersion & 0xffff ) < 0x200 &&
		( DevCaps.PixelShaderVersion  & 0xffff ) < 0x200 )
	{
		return 0 ;
	}
	else
	if( ( DevCaps.VertexShaderVersion & 0xffff ) >= 0x300 &&
		( DevCaps.PixelShaderVersion  & 0xffff ) >= 0x300 )
	{
		return 300 ;
	}
	else
	{
		return 200 ;
	}
}

// LoadShader の実処理関数
static int LoadShader_Static( int ShaderHandle, int IsVertexShader, const TCHAR *FileName, int ASyncThread )
{
	SHADERHANDLEDATA *pShader ;
	DWORD_PTR fp ;
	LONGLONG size ;
	void *buffer ;

	// エラー判定
	if( ASyncThread )
	{
		if( SHADERCHK_ASYNC( ShaderHandle, pShader ) )
			return -1 ;
	}
	else
	{
		if( SHADERCHK( ShaderHandle, pShader ) )
			return -1 ;
	}

	fp = FOPEN( FileName ) ;
	if( fp == 0 ) return -1 ;
	FSEEK( fp, 0, SEEK_END ) ;
	size = FTELL( fp ) ;
	FSEEK( fp, 0, SEEK_SET ) ;
	buffer = DXALLOC( ( size_t )size ) ;
	if( buffer == NULL )
	{
		DXST_ERRORLOG_ADD( _T( "シェーダーのバイナリデータを格納するメモリ領域の確保に失敗しました\n" ) ) ;
		return -1 ;
	}
	FREAD( buffer, size, 1, fp ) ;
	FCLOSE( fp ) ;

	return CreateShader_Static( ShaderHandle, IsVertexShader, buffer, ( int )size, TRUE, ASyncThread ) ;
}

#ifndef DX_NON_ASYNCLOAD

// LoadShader の非同期読み込みスレッドから呼ばれる関数
static void LoadShader_ASync( ASYNCLOADDATA_COMMON *AParam )
{
	int ShaderHandle ;
	int IsVertexShader ;
	const TCHAR *FileName ;
	int Addr ;
	int Result ;

	Addr = 0 ;
	ShaderHandle = GetASyncLoadParamInt( AParam->Data, &Addr ) ;
	IsVertexShader = GetASyncLoadParamInt( AParam->Data, &Addr ) ;
	FileName = GetASyncLoadParamString( AParam->Data, &Addr ) ;

	Result = LoadShader_Static( ShaderHandle, IsVertexShader, FileName, TRUE ) ;
	DecASyncLoadCount( ShaderHandle ) ;
	if( Result < 0 )
	{
		NS_DeleteShader( ShaderHandle ) ;
	}
}

#endif // DX_NON_ASYNCLOAD

// シェーダーバイナリをファイルから読み込む
extern int LoadShader_UseGParam( int IsVertexShader, const TCHAR *FileName, int ASyncLoadFlag )
{
	int ShaderHandle = -1 ;

	// シェーダが使えない場合は失敗
	if( GraphicsDevice_IsValid() == 0 || GRH.UseShader == FALSE )
		return -1 ;

	ShaderHandle = CreateShaderHandle() ;
	if( ShaderHandle == -1 )
		goto ERR ;

#ifndef DX_NON_ASYNCLOAD
	if( ASyncLoadFlag )
	{
		ASYNCLOADDATA_COMMON *AParam = NULL ;
		int Addr ;
		TCHAR FullPath[ 1024 ] ;

		ConvertFullPathT_( FileName, FullPath ) ;

		// パラメータに必要なメモリのサイズを算出
		Addr = 0 ;
		AddASyncLoadParamInt( NULL, &Addr, ShaderHandle ) ;
		AddASyncLoadParamInt( NULL, &Addr, IsVertexShader ) ;
		AddASyncLoadParamString( NULL, &Addr, FullPath ) ;

		// メモリの確保
		AParam = AllocASyncLoadDataMemory( Addr ) ;
		if( AParam == NULL )
			goto ERR ;

		// 処理に必要な情報をセット
		AParam->ProcessFunction = LoadShader_ASync ;
		Addr = 0 ;
		AddASyncLoadParamInt( AParam->Data, &Addr, ShaderHandle ) ;
		AddASyncLoadParamInt( AParam->Data, &Addr, IsVertexShader ) ;
		AddASyncLoadParamString( AParam->Data, &Addr, FullPath ) ;

		// データを追加
		if( AddASyncLoadData( AParam ) < 0 )
		{
			DXFREE( AParam ) ;
			AParam = NULL ;
			goto ERR ;
		}

		// 非同期読み込みカウントをインクリメント
		IncASyncLoadCount( ShaderHandle, AParam->Index ) ;
	}
	else
#endif // DX_NON_ASYNCLOAD
	{
		if( LoadShader_Static( ShaderHandle, IsVertexShader, FileName, FALSE ) < 0 )
			goto ERR ;
	}

	// 返回句柄
	return ShaderHandle ;

ERR :
	NS_DeleteShader( ShaderHandle ) ;
	ShaderHandle = -1 ;

	// 終了
	return -1 ;
}

// 頂点シェーダーバイナリをファイルから読み込み頂点シェーダーハンドルを作成する( 戻り値 -1:エラー  -1以外:シェーダーハンドル )
extern int NS_LoadVertexShader( const TCHAR *FileName )
{
	return LoadShader_UseGParam( TRUE, FileName, GetASyncLoadFlag() ) ;
}

// メモリ空間上に存在する頂点シェーダーバイナリから頂点シェーダーハンドルを作成する( 戻り値 -1:エラー  -1以外:シェーダーハンドル )
extern int NS_LoadVertexShaderFromMem( const void *ImageAddress, int ImageSize )
{
	return CreateShader_UseGParam( TRUE, ( void * )ImageAddress, ImageSize, FALSE, GetASyncLoadFlag() ) ;
}

// ピクセルシェーダーバイナリをファイルから読み込みピクセルシェーダーハンドルを作成する( 戻り値 -1:エラー  -1以外:シェーダーハンドル )
extern int NS_LoadPixelShader( const TCHAR *FileName )
{
	return LoadShader_UseGParam( FALSE, FileName, GetASyncLoadFlag() ) ;
}

// メモリ空間上に存在するピクセルシェーダーバイナリからピクセルシェーダーハンドルを作成する( 戻り値 -1:エラー  -1以外:シェーダーハンドル )
extern int NS_LoadPixelShaderFromMem( const void *ImageAddress, int ImageSize )
{
	return CreateShader_UseGParam( FALSE, ( void * )ImageAddress, ImageSize, FALSE, GetASyncLoadFlag() ) ;
}

// シェーダーハンドルの削除
extern int NS_DeleteShader( int ShaderHandle )
{
	return SubHandle( ShaderHandle ) ;
}

// シェーダーハンドルを全て削除する
extern int NS_InitShader( void )
{
	if( GRA2.InitializeFlag == FALSE ) return 0 ;

	return AllHandleSub( DX_HANDLETYPE_SHADER ) ;
}


// シェーダーの定数情報を得る
extern	D_D3DXSHADER_CONSTANTINFO *GetShaderConstInfo( SHADERHANDLEDATA *Shader, const TCHAR *ConstantName )
{
	D_D3DXSHADER_CONSTANTINFO *Info ;
	int i ;

	// 指定の名前を持つ定数を捜す
	Info = Shader->ConstantInfo ;

#ifdef UNICODE
	char ConstantNameA[ 512 ] ;

	WCharToMBChar( CP_ACP, ( DXWCHAR * )ConstantName, ConstantNameA, 512 ) ;
	for( i = 0 ; i < Shader->ConstantNum ; i ++, Info ++ )
	{
		if( _STRCMP( ConstantNameA, ( char * )Shader->FunctionCode + Info->Name + 12 ) == 0 )
			break ;
	}

#else

	for( i = 0 ; i < Shader->ConstantNum ; i ++, Info ++ )
	{
		if( _STRCMP( ConstantName, ( char * )Shader->FunctionCode + Info->Name + 12 ) == 0 )
			break ;
	}

#endif

	if( i == Shader->ConstantNum )
		return NULL ;

	// 情報を返す
	return Info ;
}

// 指定の名前を持つ定数が使用するシェーダー定数の番号を取得する
extern	int			NS_GetConstIndexToShader( const TCHAR *ConstantName, int ShaderHandle )
{
	SHADERHANDLEDATA *Shader ;
	D_D3DXSHADER_CONSTANTINFO *Info ;

	// エラー判定
	if( SHADERCHK( ShaderHandle, Shader ) )
		return -1 ;

	// 指定の名前を持つ定数を捜す
	Info = GetShaderConstInfo( Shader, ConstantName ) ;

	// 無かったらエラー
	if( Info == NULL )
		return -1 ;

	// 使用しているレジスタ番号を返す
	return ( int )Info->RegisterIndex ;
}

// 指定の名前を持つ定数が使用するシェーダー定数の数を取得する
extern int NS_GetConstCountToShader( const TCHAR *ConstantName, int ShaderHandle )
{
	SHADERHANDLEDATA *Shader ;
	D_D3DXSHADER_CONSTANTINFO *Info ;

	// エラー判定
	if( SHADERCHK( ShaderHandle, Shader ) )
		return -1 ;

	// 指定の名前を持つ定数を捜す
	Info = GetShaderConstInfo( Shader, ConstantName ) ;

	// 無かったらエラー
	if( Info == NULL )
		return -1 ;

	// 使用しているレジスタ数を返す
	return ( int )Info->RegisterCount ;
}

// 指定の名前を持つ浮動小数点定数のデフォルトパラメータが格納されているメモリアドレスを取得する
extern	const FLOAT4 *NS_GetConstDefaultParamFToShader( const TCHAR *ConstantName, int ShaderHandle )
{
	SHADERHANDLEDATA *Shader ;
	D_D3DXSHADER_CONSTANTINFO *Info ;

	// エラー判定
	if( SHADERCHK( ShaderHandle, Shader ) )
		return NULL ;


	// 指定の名前を持つ定数を捜す
	Info = GetShaderConstInfo( Shader, ConstantName ) ;

	// 無かったらエラー
	if( Info == NULL )
		return NULL ;

	// あってもデフォルトパラメータが無い場合はエラー
	if( Info->DefaultValue == 0 )
		return NULL ;

	// デフォルトパラメータのある位置を返す
	return ( FLOAT4 * )( ( char * )Shader->FunctionCode + Info->DefaultValue + 12 ) ;
}

// 頂点シェーダーの float 型定数を設定する
extern int NS_SetVSConstSF( int ConstantIndex, float Param )
{
	FLOAT4 ParamF4 ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 256 )
		return -1 ;

	// 定数更新
	ParamF4.x = Param ;
	ParamF4.y = Param ;
	ParamF4.z = Param ;
	ParamF4.w = Param ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, &ParamF4, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの float 型定数を設定する
extern int NS_SetVSConstF( int ConstantIndex, FLOAT4 Param )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 256 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, &Param, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの float 型定数に行列を設定する
extern	int			NS_SetVSConstFMtx( int ConstantIndex, MATRIX Param )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + 4 > 256 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ( FLOAT4 * )&Param, 4, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの float 型定数に転置した行列を設定する
extern	int			NS_SetVSConstFMtxT( int ConstantIndex, MATRIX Param )
{
	MATRIX Transpose ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + 4 > 256 )
		return -1 ;

	// 定数更新
	CreateTransposeMatrix( &Transpose, &Param ) ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ( FLOAT4 * )&Transpose, 4, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの int 型定数を設定する
extern	int			NS_SetVSConstSI( int ConstantIndex, int Param )
{
	INT4 ParamI4 ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 16 )
		return -1 ;

	// 定数更新
	ParamI4.x = Param ;
	ParamI4.y = Param ;
	ParamI4.z = Param ;
	ParamI4.w = Param ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, &ParamI4, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの int 型定数を設定する
extern	int			NS_SetVSConstI( int ConstantIndex, INT4 Param )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 16 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, &Param, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの BOOL 型定数を設定する
extern	int			NS_SetVSConstB( int ConstantIndex, BOOL Param )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 16 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_BOOL, DX_SHADERCONSTANTSET_USER, ConstantIndex, &Param, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの float 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetVSConstSFArray( int ConstantIndex, const float *ParamArray, int ParamNum )
{
	FLOAT4 ParamArrayF4[ 256 ] ;
	int i ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 256 )
		return -1 ;

	// 配列にデータをセット
	for( i = 0 ; i < ParamNum ; i ++ )
	{
		ParamArrayF4[ i ].x = ParamArray[ i ] ;
		ParamArrayF4[ i ].y = ParamArray[ i ] ;
		ParamArrayF4[ i ].z = ParamArray[ i ] ;
		ParamArrayF4[ i ].w = ParamArray[ i ] ;
	}

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArrayF4, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの float 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetVSConstFArray( int ConstantIndex, const FLOAT4 *ParamArray, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 256 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArray, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの float 型定数に行列を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetVSConstFMtxArray( int ConstantIndex, const MATRIX *ParamArray, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum * 4 > 256 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArray, ParamNum * 4, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの float 型定数に転置した行列を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetVSConstFMtxTArray( int ConstantIndex, const MATRIX *ParamArray, int ParamNum )
{
	MATRIX Transpose[ 256 / 4 ] ;
	int i ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum * 4 > 256 )
		return -1 ;

	// 定数更新
	for( i = 0 ; i < ParamNum ; i ++ )
	{
		Transpose[ i ].m[ 0 ][ 0 ] = ParamArray[ i ].m[ 0 ][ 0 ] ;
		Transpose[ i ].m[ 1 ][ 0 ] = ParamArray[ i ].m[ 0 ][ 1 ] ;
		Transpose[ i ].m[ 2 ][ 0 ] = ParamArray[ i ].m[ 0 ][ 2 ] ;
		Transpose[ i ].m[ 3 ][ 0 ] = ParamArray[ i ].m[ 0 ][ 3 ] ;

		Transpose[ i ].m[ 0 ][ 1 ] = ParamArray[ i ].m[ 1 ][ 0 ] ;
		Transpose[ i ].m[ 1 ][ 1 ] = ParamArray[ i ].m[ 1 ][ 1 ] ;
		Transpose[ i ].m[ 2 ][ 1 ] = ParamArray[ i ].m[ 1 ][ 2 ] ;
		Transpose[ i ].m[ 3 ][ 1 ] = ParamArray[ i ].m[ 1 ][ 3 ] ;

		Transpose[ i ].m[ 0 ][ 2 ] = ParamArray[ i ].m[ 2 ][ 0 ] ;
		Transpose[ i ].m[ 1 ][ 2 ] = ParamArray[ i ].m[ 2 ][ 1 ] ;
		Transpose[ i ].m[ 2 ][ 2 ] = ParamArray[ i ].m[ 2 ][ 2 ] ;
		Transpose[ i ].m[ 3 ][ 2 ] = ParamArray[ i ].m[ 2 ][ 3 ] ;

		Transpose[ i ].m[ 0 ][ 3 ] = ParamArray[ i ].m[ 3 ][ 0 ] ;
		Transpose[ i ].m[ 1 ][ 3 ] = ParamArray[ i ].m[ 3 ][ 1 ] ;
		Transpose[ i ].m[ 2 ][ 3 ] = ParamArray[ i ].m[ 3 ][ 2 ] ;
		Transpose[ i ].m[ 3 ][ 3 ] = ParamArray[ i ].m[ 3 ][ 3 ] ;
	}
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, Transpose, ParamNum * 4, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの int 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetVSConstSIArray( int ConstantIndex, const int *ParamArray, int ParamNum )
{
	INT4 ParamArrayI4[ 16 ] ;
	int i ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 配列のセット
	for( i = 0 ; i < ParamNum ; i ++ )
	{
		ParamArrayI4[ i ].x = ParamArray[ i ] ;
		ParamArrayI4[ i ].y = ParamArray[ i ] ;
		ParamArrayI4[ i ].z = ParamArray[ i ] ;
		ParamArrayI4[ i ].w = ParamArray[ i ] ;
	}

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArrayI4, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの int 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetVSConstIArray( int ConstantIndex, const INT4 *ParamArray, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArray, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの BOOL 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetVSConstBArray( int ConstantIndex, const BOOL *ParamArray, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_BOOL, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArray, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの float 型定数の設定をリセットする
extern	int			NS_ResetVSConstF( int ConstantIndex, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 256 )
		return -1 ;

	// 定数リセット
	ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamNum ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの int 型定数の設定をリセットする
extern	int			NS_ResetVSConstI( int ConstantIndex, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 定数リセット
	ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamNum ) ;

	// 終了
	return 0 ;
}

// 頂点シェーダーの BOOL 型定数の設定をリセットする
extern	int			NS_ResetVSConstB( int ConstantIndex, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 定数リセット
	ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_VS_BOOL, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamNum ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数を設定する
extern	int			NS_SetPSConstSF( int ConstantIndex, float Param )
{
	FLOAT4 ParamF4 ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 224 )
		return -1 ;

	// 定数更新
	ParamF4.x = Param ;
	ParamF4.y = Param ;
	ParamF4.z = Param ;
	ParamF4.w = Param ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, &ParamF4, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数を設定する
extern	int			NS_SetPSConstF( int ConstantIndex, FLOAT4 Param )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 224 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, &Param, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数に行列を設定する
extern	int			NS_SetPSConstFMtx( int ConstantIndex, MATRIX Param )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + 4 > 224 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ( FLOAT4 * )&Param, 4, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数に転置した行列を設定する
extern	int			NS_SetPSConstFMtxT( int ConstantIndex, MATRIX Param )
{
	MATRIX Transpose ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + 4 > 224 )
		return -1 ;

	// 定数更新
	CreateTransposeMatrix( &Transpose, &Param ) ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ( FLOAT4 * )&Transpose, 4, TRUE ) ;

	// 終了
	return 0 ;
}


// ピクセルシェーダーの int 型定数を設定する
extern	int			NS_SetPSConstSI( int ConstantIndex, int Param )
{
	INT4 ParamI4 ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 16 )
		return -1 ;

	// 定数更新
	ParamI4.x = Param ;
	ParamI4.y = Param ;
	ParamI4.z = Param ;
	ParamI4.w = Param ;
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, &ParamI4, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの int 型定数を設定する
extern	int			NS_SetPSConstI( int ConstantIndex, INT4 Param )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 16 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, &Param, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの BOOL 型定数を設定する
extern	int			NS_SetPSConstB( int ConstantIndex, BOOL Param )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex >= 16 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_BOOL, DX_SHADERCONSTANTSET_USER, ConstantIndex, &Param, 1, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetPSConstSFArray( int ConstantIndex, const float *ParamArray, int ParamNum )
{
	FLOAT4 ParamArrayF4[ 256 ] ;
	int i ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 224 )
		return -1 ;

	// 配列にセット
	for( i = 0 ; i < ParamNum ; i ++ )
	{
		ParamArrayF4[ i ].x = ParamArray[ i ] ;
		ParamArrayF4[ i ].y = ParamArray[ i ] ;
		ParamArrayF4[ i ].z = ParamArray[ i ] ;
		ParamArrayF4[ i ].w = ParamArray[ i ] ;
	}

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArrayF4, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetPSConstFArray( int ConstantIndex, const FLOAT4 *ParamArray, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 224 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArray, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数に行列を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetPSConstFMtxArray( int ConstantIndex, const MATRIX *ParamArray, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum * 4 > 224 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArray, ParamNum * 4, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数に転置した行列を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetPSConstFMtxTArray( int ConstantIndex, const MATRIX *ParamArray, int ParamNum )
{
	int i ;
	MATRIX Transpose[ 224 / 4 ] ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum * 4 > 224 )
		return -1 ;

	// 定数更新
	for( i = 0 ; i < ParamNum ; i ++ )
	{
		Transpose[ i ].m[ 0 ][ 0 ] = ParamArray[ i ].m[ 0 ][ 0 ] ;
		Transpose[ i ].m[ 1 ][ 0 ] = ParamArray[ i ].m[ 0 ][ 1 ] ;
		Transpose[ i ].m[ 2 ][ 0 ] = ParamArray[ i ].m[ 0 ][ 2 ] ;
		Transpose[ i ].m[ 3 ][ 0 ] = ParamArray[ i ].m[ 0 ][ 3 ] ;

		Transpose[ i ].m[ 0 ][ 1 ] = ParamArray[ i ].m[ 1 ][ 0 ] ;
		Transpose[ i ].m[ 1 ][ 1 ] = ParamArray[ i ].m[ 1 ][ 1 ] ;
		Transpose[ i ].m[ 2 ][ 1 ] = ParamArray[ i ].m[ 1 ][ 2 ] ;
		Transpose[ i ].m[ 3 ][ 1 ] = ParamArray[ i ].m[ 1 ][ 3 ] ;

		Transpose[ i ].m[ 0 ][ 2 ] = ParamArray[ i ].m[ 2 ][ 0 ] ;
		Transpose[ i ].m[ 1 ][ 2 ] = ParamArray[ i ].m[ 2 ][ 1 ] ;
		Transpose[ i ].m[ 2 ][ 2 ] = ParamArray[ i ].m[ 2 ][ 2 ] ;
		Transpose[ i ].m[ 3 ][ 2 ] = ParamArray[ i ].m[ 2 ][ 3 ] ;

		Transpose[ i ].m[ 0 ][ 3 ] = ParamArray[ i ].m[ 3 ][ 0 ] ;
		Transpose[ i ].m[ 1 ][ 3 ] = ParamArray[ i ].m[ 3 ][ 1 ] ;
		Transpose[ i ].m[ 2 ][ 3 ] = ParamArray[ i ].m[ 3 ][ 2 ] ;
		Transpose[ i ].m[ 3 ][ 3 ] = ParamArray[ i ].m[ 3 ][ 3 ] ;
	}
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, Transpose, ParamNum * 4, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの int 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetPSConstSIArray( int ConstantIndex, const int *ParamArray, int ParamNum )
{
	INT4 ParamArrayI4[ 16 ] ;
	int i ;

	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 配列にパラメータをセット
	for( i = 0 ; i < ParamNum ; i ++ )
	{
		ParamArrayI4[ i ].x = ParamArray[ i ] ;
		ParamArrayI4[ i ].y = ParamArray[ i ] ;
		ParamArrayI4[ i ].z = ParamArray[ i ] ;
		ParamArrayI4[ i ].w = ParamArray[ i ] ;
	}

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArrayI4, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの int 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetPSConstIArray( int ConstantIndex, const INT4 *ParamArray, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArray, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの BOOL 型定数を設定する( 配列を使って連番インデックスに一度に設定 )
extern	int			NS_SetPSConstBArray( int ConstantIndex, const BOOL *ParamArray, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 定数更新
	SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_BOOL, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamArray, ParamNum, TRUE ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの float 型定数の設定をリセットする
extern	int			NS_ResetPSConstF( int ConstantIndex, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 256 )
		return -1 ;

	// 定数リセット
	ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamNum ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの int 型定数の設定をリセットする
extern	int			NS_ResetPSConstI( int ConstantIndex, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 定数リセット
	ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_INT, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamNum ) ;

	// 終了
	return 0 ;
}

// ピクセルシェーダーの BOOL 型定数の設定をリセットする
extern	int			NS_ResetPSConstB( int ConstantIndex, int ParamNum )
{
	// シェーダーが使えない場合は何もしない
	if( GRH.UseShader == FALSE )
		return 0 ;

	// 範囲越えチェック
	if( ConstantIndex < 0 || ConstantIndex + ParamNum > 16 )
		return -1 ;

	// 定数リセット
	ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_BOOL, DX_SHADERCONSTANTSET_USER, ConstantIndex, ParamNum ) ;

	// 終了
	return 0 ;
}

// シェーダー描画での描画先を設定する
extern int NS_SetRenderTargetToShader( int TargetIndex, int DrawScreen, int SurfaceIndex )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2 *OldImage2 ;

	// ターゲットインデックスの範囲チェック
	if( TargetIndex < 0 || TargetIndex >= GRH.RenderTargetNum )
		return -1 ;

	// 値が同じ場合は何もせず終了
//	if( GBASE.TargetScreen[ TargetIndex ] == DrawScreen && GBASE.TargetScreenSurface[ TargetIndex ] == SurfaceIndex )
//		return 0 ;

	// ターゲットが０でサーフェスインデックスも０の場合は SetDrawScreen に任せる
	if( TargetIndex == 0 && SurfaceIndex == 0 )
	{
		return NS_SetDrawScreen( DrawScreen ) ;
	}

	// ハードウエアで動作していない場合は何もしない
	if( GRA2.ValidHardWare == FALSE )
		return -1 ;

	// ターゲットが０以外の場合はシェーダーが使用できない場合は何もしない
	if( GRH.UseShader == FALSE )
		return -1 ;

	// デバイスが無効になっていたら何もせず終了
	if( GraphicsDevice_IsValid() == 0 )
		return -1 ;

	// 描画処理を終了しておく
	RenderVertexHardware() ;
	EndScene() ;

	// セットしていたテクスチャーを外す
	SetTextureHardware( NULL ) ;

	// 今までの描画先の画像情報の取得
	if( GRAPHCHKFULL( GBASE.TargetScreen[ TargetIndex ], OldImage2 ) )
	{
		OldImage2 = NULL ;
	}
	else
	{
		// 今までの描画先がレンダリングターゲットサーフェスだった場合はレンダリングターゲットテクスチャに転送する
		if( OldImage2->Hard.Draw[ 0 ].Tex->RenderTargetSurface )
		{
			UpdateDrawTexture( OldImage2->Hard.Draw[ 0 ].Tex, GBASE.TargetScreenSurface[ TargetIndex ] ) ;
		}
	}

	// 画像かどうかを判定
	if( GRAPHCHKFULL( DrawScreen, Image2 ) )
	{
		// 画像ではない場合は描画対象を無効にする
		GBASE.TargetScreen[ TargetIndex ] = 0 ;
		GBASE.TargetScreenSurface[ TargetIndex ] = 0 ;
		SetRenderTargetHardware( NULL, TargetIndex ) ;
		return 0 ;
	}

	// 画像だった場合は描画可能では無い場合はエラー
	if( Image2->Orig->FormatDesc.DrawValidFlag == FALSE )
		return -1 ;

	// 画像ハンドルを保存
	GBASE.TargetScreen[ TargetIndex ] = DrawScreen ;
	GBASE.TargetScreenSurface[ TargetIndex ] = SurfaceIndex ;

	// 描画先に正しいα値を書き込むかどうかのフラグを更新する
	RefreshAlphaChDrawMode() ;

	// 描画先をセット
	if( Image2->Hard.Draw[ 0 ].Tex->RenderTargetSurface )
	{
		SetRenderTargetHardware( Image2->Hard.Draw[ 0 ].Tex->RenderTargetSurface, TargetIndex ) ;
	}
	else
	{
		SetRenderTargetHardware( Image2->Hard.Draw[ 0 ].Tex->Surface[ SurfaceIndex ], TargetIndex ) ;
	}

	// 終了
	return 0 ;
}

// シェーダー描画で使用するグラフィックを設定する
extern	int			NS_SetUseTextureToShader( int StageIndex, int GraphHandle )
{
	// 有効範囲チェック
	if( StageIndex < 0 || StageIndex >= 16 )
		return -1 ;

	// グラフィックハンドルチェック
	if( GraphHandle != -1 )
	{
		IMAGEDATA2 *Image2 ;
		SHADOWMAPDATA *ShadowMap ;

		if( GRAPHCHK(     GraphHandle, Image2    ) &&
			SHADOWMAPCHK( GraphHandle, ShadowMap ) )
			return -1 ;

		// ハンドルを保存
		GRH.UserShaderRenderInfo.SetTextureGraphHandle[ StageIndex ] = GraphHandle ;
	}
	else
	{
		// ハンドルをリセット
		GRH.UserShaderRenderInfo.SetTextureGraphHandle[ StageIndex ] = 0 ;
	}

	// 終了
	return 0 ;
}

// シェーダー描画に使用する頂点シェーダーを設定する
extern	int			NS_SetUseVertexShader( int ShaderHandle )
{
	SHADERHANDLEDATA *VertexShader ;

	if( ShaderHandle > 0 && ( SHADERCHK( ShaderHandle, VertexShader ) || VertexShader->IsVertexShader == FALSE ) )
		return -1 ;

	// ハンドルをセット
	GRH.UserShaderRenderInfo.SetVertexShaderHandle = ShaderHandle <= 0 ? 0 : ShaderHandle ;

	// 終了
	return 0 ;
}

// シェーダー描画に使用するピクセルシェーダーを設定する
extern	int			NS_SetUsePixelShader( int ShaderHandle )
{
	SHADERHANDLEDATA *PixelShader ;

	if( ShaderHandle > 0 && ( SHADERCHK( ShaderHandle, PixelShader ) || PixelShader->IsVertexShader == TRUE ) )
		return -1 ;

	// ハンドルをセット
	GRH.UserShaderRenderInfo.SetPixelShaderHandle = ShaderHandle <= 0 ? 0 : ShaderHandle  ;

	// 終了
	return 0 ;
}


// ポリゴンの頂点の接線と従法線をＵＶ座標から計算してセットする
extern int NS_CalcPolygonBinormalAndTangentsToShader( VERTEX3DSHADER *Vertex, int PolygonNum )
{
	unsigned short *Indices ;
	int IndexNum ;
	int i ;
	int Result ;

	IndexNum = PolygonNum * 3 ;

	Indices = ( unsigned short * )DXALLOC( IndexNum * sizeof( unsigned short ) ) ;
	if( Indices == NULL )
	{
		DXST_ERRORLOGFMT_ADD( ( _T( "頂点インデックスを格納するメモリ領域の確保に失敗しました\n" ) ) ) ;
		return -1 ;
	}

	// 頂点インデックスをセット
	for( i = 0 ; i < IndexNum ; i ++ )
	{
		Indices[ i ] = ( unsigned short )i ;
	}

	// 接線と従法線を計算
	Result = NS_CalcPolygonIndexedBinormalAndTangentsToShader( Vertex, IndexNum, Indices, PolygonNum ) ;

	// 頂点インデックスを格納していたメモリ領域を開放
	DXFREE( Indices ) ;

	// 終了
	return Result ;
}



// ポリゴンの頂点の接線と従法線をＵＶ座標から計算してセットする(インデックス)
extern int NS_CalcPolygonIndexedBinormalAndTangentsToShader( VERTEX3DSHADER *Vertex, int VertexNum, const unsigned short *Indices, int PolygonNum )
{
	int i ;
	VECTOR v1, v2, vt, du, dv, vb, vn ;
	BYTE *UseFlag ;
	const unsigned short *Index ;
	int IndexNum ;
	VERTEX3DSHADER *Vert[ 3 ] ;

	// 使用している頂点のテーブルを作成する
	{
		UseFlag = ( BYTE * )DXALLOC( sizeof( BYTE ) * VertexNum ) ;
		if( UseFlag == NULL )
		{
			DXST_ERRORLOGFMT_ADD( ( _T( "頂点の接線と従法線の作成作業に必要なメモリ領域の確保に失敗しました\n" ) ) ) ;
			return -1 ;
		}
		_MEMSET( UseFlag, 0, VertexNum ) ;

		IndexNum = PolygonNum * 3 ;
		for( i = 0 ; i < IndexNum ; i ++ )
		{
			UseFlag[ Indices[ i ] ] = 1 ;
		}
	}

	// 接線と従法線の初期化
	for( i = 0 ; i < VertexNum ; i ++ )
	{
		if( UseFlag[ i ] == 0 ) continue ;
		Vertex[ i ].binorm.x = 0.0f ;
		Vertex[ i ].binorm.y = 0.0f ;
		Vertex[ i ].binorm.z = 0.0f ;
		Vertex[ i ].tan.x = 0.0f ;
		Vertex[ i ].tan.y = 0.0f ;
		Vertex[ i ].tan.z = 0.0f ;
	}

	// 全ての面の数だけ繰り返し
	Index = Indices ;
	for( i = 0 ; i < PolygonNum ; i ++, Index += 3 )
	{
		Vert[ 0 ] = &Vertex[ Index[ 0 ] ] ;
		Vert[ 1 ] = &Vertex[ Index[ 1 ] ] ;
		Vert[ 2 ] = &Vertex[ Index[ 2 ] ] ;

		v1.x = Vert[ 1 ]->pos.x - Vert[ 0 ]->pos.x ;
		v1.y = Vert[ 1 ]->u - Vert[ 0 ]->u ;
		v1.z = Vert[ 1 ]->v - Vert[ 0 ]->v ;

		v2.x = Vert[ 2 ]->pos.x - Vert[ 0 ]->pos.x ;
		v2.y = Vert[ 2 ]->u - Vert[ 0 ]->u ;
		v2.z = Vert[ 2 ]->v - Vert[ 0 ]->v ;

		vt = VCross( v1, v2 ) ;
		du.x = 1.0f ;
		if( VDot( vt, vt ) >= 0.0000001f )
		{
			du.x = -vt.y / vt.x ;
			dv.x = -vt.z / vt.x ;
		}

		v1.x = Vert[ 1 ]->pos.y - Vert[ 0 ]->pos.y ;
		v2.x = Vert[ 2 ]->pos.y - Vert[ 0 ]->pos.y ;

		vt = VCross( v1, v2 ) ;
		du.y = 1.0f ;
		if( VDot( vt, vt ) >= 0.0000001f )
		{
			du.y = -vt.y / vt.x ;
			dv.y = -vt.z / vt.x ;
		}

		v1.x = Vert[ 1 ]->pos.z - Vert[ 0 ]->pos.z ;
		v2.x = Vert[ 2 ]->pos.z - Vert[ 0 ]->pos.z ;

		vt = VCross( v1, v2 ) ;
		du.z = 1.0f ;
		if( VDot( vt, vt ) >= 0.0000001f )
		{
			du.z = -vt.y / vt.x ;
			dv.z = -vt.z / vt.x ;
		}

		VectorAdd( &Vert[ 0 ]->tan, &Vert[ 0 ]->tan, &du ) ;
		VectorAdd( &Vert[ 1 ]->tan, &Vert[ 1 ]->tan, &du ) ;
		VectorAdd( &Vert[ 2 ]->tan, &Vert[ 2 ]->tan, &du ) ;

		VectorAdd( &Vert[ 0 ]->binorm, &Vert[ 0 ]->binorm, &dv ) ;
		VectorAdd( &Vert[ 1 ]->binorm, &Vert[ 1 ]->binorm, &dv ) ;
		VectorAdd( &Vert[ 2 ]->binorm, &Vert[ 2 ]->binorm, &dv ) ;
	}

	// 法線の算出と正規化
	for( i = 0 ; i < VertexNum ; i ++ )
	{
		if( UseFlag[ i ] == 0 ) continue ;

		vt = VNorm( Vertex[ i ].tan ) ;
		vn = VNorm( VCross( vt, Vertex[ i ].binorm ) ) ;
		vb = VNorm( VCross( vn, vt ) ) ;

		// 正規化
		Vertex[ i ].tan    = vt ;
		Vertex[ i ].binorm = vb ;
	}

	// メモリの解放
	DXFREE( UseFlag ) ;

	// 終了
	return 0 ;
}


// シェーダー描画用描画前セットアップ関数
__inline void DrawPreparationToShader( int ParamFlag, int UseVertexShaderNo, int Is2D, int UseLibSubShaderConst )
{
	DIRECT3DBLENDINFO BlendInfo ;
	int i, Flag ;

	// 基本的なセットアップ処理
	Flag = ParamFlag | DRAWPREP_SPECULAR | DRAWPREP_NOTSHADERRESET | DRAWPREP_TEXADDRESS | DRAWPREP_NOBLENDSETTING | ( Is2D ? 0 : DRAWPREP_CULLING ) ;
	DRAWPREP_NOTEX( Flag )

	// ユーザー設定のシェーダー定数を有効にする
	if( UseLibSubShaderConst )
	{
		SetUseShaderContantInfoState( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTSET_MASK_LIB | DX_SHADERCONSTANTSET_MASK_LIB_SUB ) ;
	}
	else
	{
		SetUseShaderContantInfoState( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTSET_MASK_LIB | DX_SHADERCONSTANTSET_MASK_USER ) ;
	}

	// 頂点フォーマットはリセット
	GRH.SetVD = NULL ;
	GRH.SetFVF = 0 ;

	// ブレンドモードは自前でセットアップ
	{
		BlendInfo.SeparateAlphaBlendEnable = FALSE ;
		BlendInfo.SrcBlendAlpha = -1 ;
		BlendInfo.DestBlendAlpha = -1 ;
		BlendInfo.BlendOpAlpha = -1 ;

		// アルファテストパラメータが有効な場合はそれを優先する
		if( GBASE.AlphaTestMode != -1 )
		{
			BlendInfo.AlphaTestEnable = TRUE ;
			BlendInfo.AlphaFunc = GBASE.AlphaTestMode ;
			BlendInfo.AlphaRef = GBASE.AlphaTestParam ;
		}
		else
		{
			// デフォルトのアルファテストの設定をセット
			BlendInfo.AlphaTestEnable = TRUE ;
			BlendInfo.AlphaRef = 0 ;
			BlendInfo.AlphaFunc = D_D3DCMP_GREATER ;
		}

		// 出力先とのブレンド方式をセット
		BlendInfo.AlphaBlendEnable = GBASE.BlendMode != DX_BLENDMODE_NOBLEND && GBASE.BlendMode != DX_BLENDMODE_XOR ;
		BlendInfo.DestBlend = __RGBBlendStateTable[ GBASE.BlendMode ][ RGB_BLENDSTATE_TABLE_DESTBLEND ] ;
		BlendInfo.SrcBlend  = __RGBBlendStateTable[ GBASE.BlendMode ][ RGB_BLENDSTATE_TABLE_SRCBLEND ] ;
		BlendInfo.BlendOp   = __RGBBlendStateTable[ GBASE.BlendMode ][ RGB_BLENDSTATE_TABLE_BLENDOP ] ;
		BlendInfo.FactorColor = 0xffffffff ;

		// 減算ブレンド指定で D3DRS_BLENDOP が使用可能な場合は 14番目のブレンドモードを使用する
		if( GBASE.BlendMode == DX_BLENDMODE_SUB && GRH.ValidDestBlendOp )
		{
			BlendInfo.DestBlend = __RGBBlendStateTable[ DX_BLENDMODE_SUB1 ][ RGB_BLENDSTATE_TABLE_DESTBLEND ] ;
			BlendInfo.SrcBlend  = __RGBBlendStateTable[ DX_BLENDMODE_SUB1 ][ RGB_BLENDSTATE_TABLE_SRCBLEND ] ;
			BlendInfo.BlendOp   = __RGBBlendStateTable[ DX_BLENDMODE_SUB1 ][ RGB_BLENDSTATE_TABLE_BLENDOP ] ;
			BlendInfo.FactorColor = 0xffffffff ;
		}

		// 使用するテクスチャを列挙
		BlendInfo.UseTextureStageNum = 0 ;
		for( i = 0 ; i < 8 ; i ++ )
		{
			BlendInfo.TextureStageInfo[ i ].Texture = ( void * )( DWORD_PTR )GRH.UserShaderRenderInfo.SetTextureGraphHandle[ i ] ;
			BlendInfo.TextureStageInfo[ i ].TextureCoordIndex = i ;
			if( GRH.UserShaderRenderInfo.SetTextureGraphHandle[ i ] == 0 ) continue ;
			BlendInfo.UseTextureStageNum = i + 1 ;
		}

		// 設定を反映
		D_SetUserBlendInfo( &BlendInfo, TRUE, TRUE ) ;

		// 使用するテクスチャ座標をリセット
		D_ResetTextureCoord() ;
	}

	// 頂点シェーダーを使用するかどうかで処理を分岐
	if( UseVertexShaderNo >= 0 )
	{
		// 使用する頂点データフォーマットを更新
		if( GRH.SetVD != GRH.UserShaderDeclaration[ UseVertexShaderNo ] )
		{
			GRH.SetVD = GRH.UserShaderDeclaration[ UseVertexShaderNo ] ;
			GraphicsDevice_SetVertexDeclaration( GRH.SetVD ) ;
			GRH.SetFVF = 0 ;
		}

		// 使用する頂点シェーダーを更新
		SetDeviceVertexShaderToHandle( GRH.UserShaderRenderInfo.SetVertexShaderHandle ) ;
	}
	else
	{
		// 使用しない場合は頂点シェーダーをリセットする
		if( GRH.SetVS != NULL )
		{
			GRH.SetVS = NULL ;
			GRH.SetFVF = 0 ;
			GraphicsDevice_SetVertexShader( NULL ) ;
		}

		// 頂点データ形式をセット
		if( Is2D )
		{
			SETFVF( VERTEXFVF_SHADER_2D ) 
		}
		else
		{
			SETFVF( VERTEXFVF_SHADER_3D ) 
		}
	}

	// 使用するピクセルシェーダーを更新
	SetDevicePixelShaderToHandle( GRH.UserShaderRenderInfo.SetPixelShaderHandle ) ;
}

// シェーダーを使って２Ｄポリゴンを描画する
extern	int			NS_DrawPolygon2DToShader( const VERTEX2DSHADER *Vertex, int PolygonNum )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.UseShader == FALSE ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE, -1, TRUE, FALSE ) ;

	// 描画
	GraphicsDevice_DrawPrimitiveUP( D_D3DPT_TRIANGLELIST, PolygonNum, Vertex, sizeof( VERTEX2DSHADER ) ) ;

	// 終了
	return 0 ;
}

// シェーダーを使って３Ｄポリゴンを描画する
extern	int			NS_DrawPolygon3DToShader( const VERTEX3DSHADER *Vertex, int PolygonNum )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.UseShader == FALSE ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_3D | DRAWPREP_GOURAUDSHADE | DRAWPREP_FOG | DRAWPREP_PERSPECTIVE | DRAWPREP_LIGHTING, DX_VERTEX_TYPE_SHADER_3D, FALSE, FALSE ) ;

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 描画
	GraphicsDevice_DrawPrimitiveUP( D_D3DPT_TRIANGLELIST, PolygonNum, Vertex, sizeof( VERTEX3DSHADER ) ) ;

	// 終了
	return 0 ;
}

// シェーダーを使って２Ｄポリゴンを描画する(インデックス)
extern	int			NS_DrawPolygonIndexed2DToShader( const VERTEX2DSHADER *Vertex, int VertexNum, const unsigned short *Indices, int PolygonNum )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.UseShader == FALSE ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE, -1, TRUE, FALSE ) ;

	// 描画
	GraphicsDevice_DrawIndexedPrimitiveUP( D_D3DPT_TRIANGLELIST, 0, VertexNum, PolygonNum, Indices, D_D3DFMT_INDEX16, Vertex, sizeof( VERTEX2DSHADER ) ) ;

	// 終了
	return 0 ;
}

// シェーダーを使って３Ｄポリゴンを描画する(インデックス)
extern	int			NS_DrawPolygonIndexed3DToShader( const VERTEX3DSHADER *Vertex, int VertexNum, const unsigned short *Indices, int PolygonNum )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.UseShader == FALSE ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_3D | DRAWPREP_GOURAUDSHADE | DRAWPREP_FOG | DRAWPREP_PERSPECTIVE | DRAWPREP_LIGHTING, DX_VERTEX_TYPE_SHADER_3D, FALSE, FALSE ) ;

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 描画
	GraphicsDevice_DrawIndexedPrimitiveUP( D_D3DPT_TRIANGLELIST, 0, VertexNum, PolygonNum, Indices, D_D3DFMT_INDEX16, Vertex, sizeof( VERTEX3DSHADER ) ) ;

	// 終了
	return 0 ;
}

// シェーダーを使って２Ｄプリミティブを描画する
extern	int			NS_DrawPrimitive2DToShader( const VERTEX2DSHADER *Vertex, int VertexNum, int PrimitiveType )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.UseShader == FALSE ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE, -1, TRUE, FALSE ) ;

	// 描画
	GraphicsDevice_DrawPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, GETPRIMNUM( PrimitiveType, VertexNum ), Vertex, sizeof( VERTEX2DSHADER ) ) ;

	// 終了
	return 0 ;
}

// シェーダーを使って３Ｄプリミティブを描画する
extern	int			NS_DrawPrimitive3DToShader( const VERTEX3DSHADER *Vertex, int VertexNum, int PrimitiveType )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.UseShader == FALSE ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_3D | DRAWPREP_GOURAUDSHADE | DRAWPREP_FOG | DRAWPREP_PERSPECTIVE | DRAWPREP_LIGHTING, DX_VERTEX_TYPE_SHADER_3D, FALSE, FALSE ) ;

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 描画
	GraphicsDevice_DrawPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, GETPRIMNUM( PrimitiveType, VertexNum ), Vertex, sizeof( VERTEX3DSHADER ) ) ;

	// 終了
	return 0 ;
}

// シェーダーを使って２Ｄプリミティブを描画する(インデックス)
extern	int			NS_DrawPrimitiveIndexed2DToShader( const VERTEX2DSHADER *Vertex, int VertexNum, const unsigned short *Indices, int IndexNum, int PrimitiveType )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.UseShader == FALSE ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_GOURAUDSHADE | DRAWPREP_PERSPECTIVE, -1, TRUE, FALSE ) ;

	// 描画
	GraphicsDevice_DrawIndexedPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, 0, VertexNum, GETPRIMNUM( PrimitiveType, IndexNum ), Indices, D_D3DFMT_INDEX16, Vertex, sizeof( VERTEX2DSHADER ) ) ;

	// 終了
	return 0 ;
}

// シェーダーを使って３Ｄプリミティブを描画する(インデックス)
extern	int			NS_DrawPrimitiveIndexed3DToShader( const VERTEX3DSHADER *Vertex, int VertexNum, const unsigned short *Indices, int IndexNum, int PrimitiveType )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;
	if( GRH.UseShader == FALSE ) return -1 ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_3D | DRAWPREP_GOURAUDSHADE | DRAWPREP_FOG | DRAWPREP_PERSPECTIVE | DRAWPREP_LIGHTING, DX_VERTEX_TYPE_SHADER_3D, FALSE, FALSE ) ;

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 描画
	GraphicsDevice_DrawIndexedPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, 0, VertexNum, GETPRIMNUM( PrimitiveType, IndexNum ), Indices, D_D3DFMT_INDEX16, Vertex, sizeof( VERTEX3DSHADER ) ) ;

	// 終了
	return 0 ;
}

// シェーダーを使って３Ｄポリゴンを描画する( 頂点バッファ使用版 )
extern	int			NS_DrawPolygon3DToShader_UseVertexBuffer( int VertexBufHandle )
{
	return NS_DrawPrimitive3DToShader_UseVertexBuffer( VertexBufHandle, DX_PRIMTYPE_TRIANGLELIST ) ;
}

// シェーダーを使って３Ｄポリゴンを描画する( 頂点バッファとインデックスバッファ使用版 )
extern	int			NS_DrawPolygonIndexed3DToShader_UseVertexBuffer( int VertexBufHandle, int IndexBufHandle )
{
	return NS_DrawPrimitiveIndexed3DToShader_UseVertexBuffer( VertexBufHandle, IndexBufHandle, DX_PRIMTYPE_TRIANGLELIST ) ;
}

// シェーダーを使って３Ｄプリミティブを描画する( 頂点バッファ使用版 )
extern	int			NS_DrawPrimitive3DToShader_UseVertexBuffer( int VertexBufHandle, int PrimitiveType /* DX_PRIMTYPE_TRIANGLELIST 等 */ )
{
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;

	// エラー判定
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;

	return NS_DrawPrimitive3DToShader_UseVertexBuffer2( VertexBufHandle, PrimitiveType, 0, VertexBuffer->Num ) ;
}

// シェーダーを使って３Ｄプリミティブを描画する( 頂点バッファ使用版 )
extern	int			NS_DrawPrimitive3DToShader_UseVertexBuffer2( int VertexBufHandle, int PrimitiveType /* DX_PRIMTYPE_TRIANGLELIST 等 */, int StartVertex, int UseVertexNum )
{
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	int PrimitiveCount ;

	// エラー判定
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_3D | DRAWPREP_GOURAUDSHADE | DRAWPREP_FOG | DRAWPREP_PERSPECTIVE | DRAWPREP_LIGHTING, VertexBuffer->Type, FALSE, FALSE ) ;

	// プリミティブの数を取得
	PrimitiveCount = GETPRIMNUM( PrimitiveType, UseVertexNum ) ;

	// 描画
	if( VertexBuffer->Direct3DBuffer != NULL )
	{
		GraphicsDevice_SetStreamSource(
			0,
			VertexBuffer->Direct3DBuffer,
			0,
			VertexBuffer->UnitSize ) ;

		GraphicsDevice_DrawPrimitive(
			( D_D3DPRIMITIVETYPE )PrimitiveType,
			StartVertex,
			PrimitiveCount ) ;
	}
	else
	{
		GraphicsDevice_DrawPrimitiveUP(
			( D_D3DPRIMITIVETYPE )PrimitiveType,
			PrimitiveCount,
			( BYTE * )VertexBuffer->Buffer + StartVertex * VertexBuffer->UnitSize,
			VertexBuffer->UnitSize ) ;
	}

	// 終了
	return 0 ;
}

// シェーダーを使って３Ｄプリミティブを描画する( 頂点バッファとインデックスバッファ使用版 )
extern	int			NS_DrawPrimitiveIndexed3DToShader_UseVertexBuffer( int VertexBufHandle, int IndexBufHandle, int PrimitiveType /* DX_PRIMTYPE_TRIANGLELIST 等 */ )
{
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	INDEXBUFFERHANDLEDATA *IndexBuffer ;

	// エラー判定
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;
	if( INDEXBUFFERCHK( IndexBufHandle, IndexBuffer ) )
		return -1 ;

	return NS_DrawPrimitiveIndexed3DToShader_UseVertexBuffer2( VertexBufHandle, IndexBufHandle, PrimitiveType, 0, 0, VertexBuffer->Num, 0, IndexBuffer->Num ) ;
}

// シェーダーを使って３Ｄプリミティブを描画する( 頂点バッファとインデックスバッファ使用版 )
extern	int			NS_DrawPrimitiveIndexed3DToShader_UseVertexBuffer2( int VertexBufHandle, int IndexBufHandle, int PrimitiveType /* DX_PRIMTYPE_TRIANGLELIST 等 */, int BaseVertex, int StartVertex, int UseVertexNum, int StartIndex, int UseIndexNum )
{
	VERTEXBUFFERHANDLEDATA *VertexBuffer ;
	INDEXBUFFERHANDLEDATA *IndexBuffer ;
	int PrimitiveCount ;
	D_D3DFORMAT IndexFormat ;

	// エラー判定
	if( VERTEXBUFFERCHK( VertexBufHandle, VertexBuffer ) )
		return -1 ;
	if( INDEXBUFFERCHK( IndexBufHandle, IndexBuffer ) )
		return -1 ;

	// 行列をハードウエアに反映する
	ApplyLibMatrixToHardware() ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( DRAWPREP_3D | DRAWPREP_GOURAUDSHADE | DRAWPREP_FOG | DRAWPREP_PERSPECTIVE | DRAWPREP_LIGHTING, VertexBuffer->Type, FALSE, FALSE ) ;

	// インデックスタイプをセット
	IndexFormat = D_D3DFMT_INDEX16 ;
	switch( IndexBuffer->Type )
	{
	case DX_INDEX_TYPE_16BIT:
		IndexFormat = D_D3DFMT_INDEX16 ;
		break ;

	case DX_INDEX_TYPE_32BIT:
		IndexFormat = D_D3DFMT_INDEX32 ;
		break ;
	}

	// プリミティブの数を取得
	PrimitiveCount = GETPRIMNUM( PrimitiveType, UseIndexNum ) ;

	// 描画
	if( VertexBuffer->Direct3DBuffer != NULL &&
		IndexBuffer->Direct3DBuffer  != NULL )
	{
		GraphicsDevice_SetStreamSource(
			0,
			VertexBuffer->Direct3DBuffer,
			0,
			VertexBuffer->UnitSize ) ;
		GraphicsDevice_SetIndices( IndexBuffer->Direct3DBuffer ) ;

		GraphicsDevice_DrawIndexedPrimitive(
			( D_D3DPRIMITIVETYPE )PrimitiveType,
			BaseVertex,
			StartVertex,
			UseVertexNum,
			StartIndex,
			PrimitiveCount ) ;
	}
	else
	{
		GraphicsDevice_DrawIndexedPrimitiveUP(
			( D_D3DPRIMITIVETYPE )PrimitiveType,
			StartVertex,
			UseVertexNum,
			PrimitiveCount,
			( BYTE * )IndexBuffer->Buffer + StartIndex * IndexBuffer->UnitSize,
			IndexFormat, 
			( BYTE * )VertexBuffer->Buffer + BaseVertex * VertexBuffer->UnitSize,
			VertexBuffer->UnitSize ) ;
	}

	// 終了
	return 0 ;
}


#ifndef DX_NON_FILTER


// 画像にフィルター処理を行う
extern int NS_GraphFilter( int GrHandle, int FilterType /* DX_GRAPH_FILTER_GAUSS_H 等 */ , ... )
{
	int Result ;
	va_list VaList ;
	int W, H ;

	va_start( VaList, FilterType ) ;

	NS_GetGraphSize( GrHandle, &W, &H ) ;

	Result = GraphFilterRectBltBase( FALSE, GrHandle, -1, GrHandle, 0, FilterType, 0, 0, W, H, 0, 0, FALSE, 0, 0, VaList ) ;

	va_end( VaList ) ;

	return Result ;
}

// 画像のフィルター付き転送を行う
extern int NS_GraphFilterBlt( int SrcGrHandle, int DestGrHandle, int FilterType, ... )
{
	int Result ;
	va_list VaList ;
	int SrcW, SrcH ;

	va_start( VaList, FilterType ) ;

	NS_GetGraphSize( SrcGrHandle, &SrcW, &SrcH ) ;

	Result = GraphFilterRectBltBase( FALSE, SrcGrHandle, -1, DestGrHandle, 0, FilterType, 0, 0, SrcW, SrcH, 0, 0, FALSE, 0, 0, VaList ) ;

	va_end( VaList ) ;

	return Result ;
}

// 画像のフィルター付き転送を行う( 矩形指定 )
extern int NS_GraphFilterRectBlt( int SrcGrHandle, int DestGrHandle, int SrcX1, int SrcY1, int SrcX2, int SrcY2, int DestX, int DestY, int FilterType, ... )
{
	int Result ;
	va_list VaList ;

	va_start( VaList, FilterType ) ;

	Result = GraphFilterRectBltBase( FALSE, SrcGrHandle, -1, DestGrHandle, 0, FilterType, SrcX1, SrcY1, SrcX2, SrcY2, 0, 0, FALSE, DestX, DestY, VaList ) ;

	va_end( VaList ) ;

	return Result ;
}

// 二つの画像をブレンドする
extern	int	NS_GraphBlend( int GrHandle, int BlendGrHandle, int BlendRatio, int BlendType, ... )
{
	int Result ;
	va_list VaList ;
	int W, H ;

	va_start( VaList, BlendType ) ;

	NS_GetGraphSize( GrHandle, &W, &H ) ;

	Result = GraphFilterRectBltBase( TRUE, GrHandle, BlendGrHandle, GrHandle, BlendRatio, BlendType, 0, 0, W, H, 0, 0, FALSE, 0, 0, VaList ) ;

	va_end( VaList ) ;

	return Result ;
}

// 二つの画像をブレンドして結果を指定の画像に出力する
extern	int	NS_GraphBlendBlt( int SrcGrHandle, int BlendGrHandle, int DestGrHandle, int BlendRatio, int BlendType, ... )
{
	int Result ;
	va_list VaList ;
	int SrcW, SrcH ;

	va_start( VaList, BlendType ) ;

	NS_GetGraphSize( SrcGrHandle, &SrcW, &SrcH ) ;

	Result = GraphFilterRectBltBase( TRUE, SrcGrHandle, BlendGrHandle, DestGrHandle, BlendRatio, BlendType, 0, 0, SrcW, SrcH, 0, 0, FALSE, 0, 0, VaList ) ;

	va_end( VaList ) ;

	return Result ;
}

// 二つの画像をブレンドして結果を指定の画像に出力する( 矩形指定 )
extern	int	NS_GraphBlendRectBlt( int SrcGrHandle, int BlendGrHandle, int DestGrHandle, int SrcX1, int SrcY1, int SrcX2, int SrcY2, int BlendX, int BlendY, int DestX, int DestY, int BlendRatio, int BlendType, ... )
{
	int Result ;
	va_list VaList ;

	va_start( VaList, BlendType ) ;

	Result = GraphFilterRectBltBase( TRUE, SrcGrHandle, BlendGrHandle, DestGrHandle, BlendRatio, BlendType, SrcX1, SrcY1, SrcX2, SrcY2, BlendX, BlendY, TRUE, DestX, DestY, VaList ) ;

	va_end( VaList ) ;

	return Result ;
}


static int GraphFilterDestGraphSetup( GRAPHFILTER_INFO *Info, int PassNum, int UseWorkScreen, int *UseSrcGrHandle, int *UseDestGrHandle )
{
	SHADOWMAPDATA *SrcShadowMap = NULL ;
	SHADOWMAPDATA *DestShadowMap = NULL ;
	IMAGEDATA2 *SrcImage2 = NULL ;
	IMAGEDATA2 *DestImage2 = NULL ;
	IMAGEDATA2 *TempSrcImage2 = NULL ;
	int TexSizeW ;
	int TexSizeH ;
	int SrcTexFloatType ;
	int DestTexFloatType ;
	int SrcEqDestOrDestNonDrawValidHandle ;
	int AlwaysUseDestWorkHandle ;
	int UseDestWorkHandleIndex ;
	int UseSrcWorkHandleIndex ;
	int SrcGraphDivFlag ;

	if( !GRAPHCHK( Info->SrcGrHandle, SrcImage2 ) )
	{
		SrcTexFloatType = SrcImage2->Orig->FormatDesc.FloatTypeFlag ;
	}
	else
	if( !SHADOWMAPCHK( Info->SrcGrHandle, SrcShadowMap ) )
	{
		SrcTexFloatType = SrcShadowMap->TexFormat_Float ;
	}
	else
	{
		return -1 ;
	}

	if( !GRAPHCHK( Info->DestGrHandle, DestImage2 ) )
	{
		DestTexFloatType = DestImage2->Orig->FormatDesc.FloatTypeFlag ;
	}
	else
	if( !SHADOWMAPCHK( Info->DestGrHandle, DestShadowMap ) )
	{
		DestTexFloatType = DestShadowMap->TexFormat_Float ;
	}
	else
	{
		return -1 ;
	}

	UseSrcWorkHandleIndex = 0 ;

	// シェーダーが使えない場合は作業用画像は使用しない
	if( GRH.UseShader == FALSE )
	{
		*UseDestGrHandle = Info->DestGrHandle ;
	}
	else
	{
		if( SrcShadowMap == NULL &&
			( ( UseWorkScreen == 1 && Info->SrcGrHandle == Info->DestGrHandle ) ||
			  DestImage2->Orig->FormatDesc.DrawValidFlag == FALSE ) )
		{
			SrcEqDestOrDestNonDrawValidHandle = TRUE ;
		}
		else
		{
			SrcEqDestOrDestNonDrawValidHandle = FALSE ;
		}

		if( UseWorkScreen == 1 &&
			( ( Info->Pass % 2 == 0 && PassNum % 2 == 0 ) ||
			  ( Info->Pass % 2 == 1 && PassNum % 2 == 1 ) ) )
		{
			AlwaysUseDestWorkHandle = TRUE ;
		}
		else
		{
			AlwaysUseDestWorkHandle = FALSE ;
		}

		if(
			SrcShadowMap == NULL &&
			Info->Pass == 0 &&
			(
			  SrcImage2->Hard.DrawNum != 1 ||
			  SrcImage2->Hard.Draw[ 0 ].UsePosX != 0 ||
			  SrcImage2->Hard.Draw[ 0 ].UsePosY != 0
			)
		  )
		{
			SrcGraphDivFlag = TRUE ;
		}
		else
		{
			SrcGraphDivFlag = FALSE ;
		}

		if( SrcEqDestOrDestNonDrawValidHandle || AlwaysUseDestWorkHandle )
		{
			if( AlwaysUseDestWorkHandle == FALSE && SrcEqDestOrDestNonDrawValidHandle == TRUE )
			{
				UseDestWorkHandleIndex = 1 ;
				UseSrcWorkHandleIndex = 0 ;
			}
			else
			{
				UseDestWorkHandleIndex = 0 ;
				UseSrcWorkHandleIndex = 1 ;
			}

			if( SrcGraphDivFlag )
			{
				TexSizeW = SrcImage2->Width ;
				TexSizeH = SrcImage2->Height ;
			}
			else
			{
				NS_GetGraphTextureSize( Info->SrcGrHandle, &TexSizeW, &TexSizeH ) ;
			}

			*UseDestGrHandle = GetWorkTexture( DestTexFloatType, ( DWORD )TexSizeW, ( DWORD )TexSizeH, ( DWORD )UseDestWorkHandleIndex ) ;
			if( *UseDestGrHandle < 0 )
				return -1 ;
		}
		else
		{
			*UseDestGrHandle = Info->DestGrHandle ;
		}

		if( SrcGraphDivFlag )
		{
			VERTEX_2D Vert[ 4 ] ;
			IMAGEDATA2_HARD_VERT *TexVect ;
			int i ;

			TexSizeW = SrcImage2->Width ;
			TexSizeH = SrcImage2->Height ;

			*UseSrcGrHandle = GetWorkTexture( SrcTexFloatType, ( DWORD )TexSizeW, ( DWORD )TexSizeH, ( DWORD )UseSrcWorkHandleIndex ) ;
			if( *UseSrcGrHandle < 0 )
				return -1 ;

			GRAPHCHK( *UseSrcGrHandle, TempSrcImage2 ) ;
			SetRenderTargetHardware( TempSrcImage2->Hard.Draw[ 0 ].Tex->Surface[ 0 ] ) ;

			Vert[ 0 ].rhw = 1.0f ;
			Vert[ 1 ].rhw = 1.0f ;
			Vert[ 2 ].rhw = 1.0f ;
			Vert[ 3 ].rhw = 1.0f ;
			Vert[ 0 ].color = 0xffffffff ;
			Vert[ 1 ].color = 0xffffffff ;
			Vert[ 2 ].color = 0xffffffff ;
			Vert[ 3 ].color = 0xffffffff ;
			for( i = 0 ; i < SrcImage2->Hard.DrawNum ; i ++ )
			{
				TexVect = SrcImage2->Hard.Draw[ i ].Vertex ;

				Vert[ 0 ].pos.x = TexVect[ 0 ].x - 0.5f ;
				Vert[ 0 ].pos.y = TexVect[ 0 ].y - 0.5f ;
				Vert[ 0 ].pos.z = 0.0f ;
				Vert[ 0 ].u = TexVect[ 0 ].u ;
				Vert[ 0 ].v = TexVect[ 0 ].v ;
				Vert[ 1 ].pos.x = TexVect[ 1 ].x - 0.5f ;
				Vert[ 1 ].pos.y = TexVect[ 1 ].y - 0.5f ;
				Vert[ 1 ].pos.z = 0.0f ;
				Vert[ 1 ].u = TexVect[ 1 ].u ;
				Vert[ 1 ].v = TexVect[ 1 ].v ;
				Vert[ 2 ].pos.x = TexVect[ 2 ].x - 0.5f ;
				Vert[ 2 ].pos.y = TexVect[ 2 ].y - 0.5f ;
				Vert[ 2 ].u = TexVect[ 2 ].u ;
				Vert[ 2 ].v = TexVect[ 2 ].v ;
				Vert[ 2 ].pos.z = 0.0f ;
				Vert[ 3 ].pos.x = TexVect[ 3 ].x - 0.5f ;
				Vert[ 3 ].pos.y = TexVect[ 3 ].y - 0.5f ;
				Vert[ 3 ].pos.z = 0.0f ;
				Vert[ 3 ].u = TexVect[ 3 ].u ;
				Vert[ 3 ].v = TexVect[ 3 ].v ;
				DrawPrimitive2DHardware( Vert, 4, DX_PRIMTYPE_TRIANGLESTRIP, SrcImage2, TRUE, FALSE, FALSE, FALSE, i ) ;
			}
		}
	}

	return 0 ;
}

static int GraphFilterDestGraphUpdate( GRAPHFILTER_INFO *Info, int UseWorkScreen, int UseDestGrHandle, int FilterResult )
{
	if( FilterResult >= 0 )
	{
		if( GRH.UseShader == TRUE )
		{
			if( ( UseWorkScreen == 1 && Info->SrcGrHandle == Info->DestGrHandle ) ||
				UseDestGrHandle != Info->DestGrHandle )
			{
				GetDrawScreenGraphBase( UseDestGrHandle, 0, Info->DestX, Info->DestY, Info->DestX + Info->SrcX2 - Info->SrcX1, Info->DestY + Info->SrcY2 - Info->SrcY1, Info->DestX, Info->DestY, Info->DestGrHandle ) ;
			}
		}
	}

	return 0 ;
}

static int	GraphFilter_BasePolygonDraw( GRAPHFILTER_INFO *Info, int ScaleDivNum )
{
	VERTEX2DSHADER Vert[ 4 ] ;
	IMAGEDATA2 *SrcImage2 = NULL ;
	IMAGEDATA2 *BlendImage2 = NULL ;
	IMAGEDATA2 *DestImage2 = NULL ;
	SHADOWMAPDATA *SrcShadowMap = NULL ;
	SHADOWMAPDATA *DestShadowMap = NULL ;
	float SrcX1F, SrcX2F, SrcY1F, SrcY2F ;
	float SrcX1TexF, SrcX2TexF, SrcY1TexF, SrcY2TexF ;
	int SrcWidth, SrcHeight ;
	float DestX1F, DestX2F, DestY1F, DestY2F ;
	float BlendX1TexF, BlendX2TexF, BlendY1TexF, BlendY2TexF ;
	int SrcTexWidth, SrcTexHeight ;

	if( GRAPHCHK(     Info->SrcGrHandle, SrcImage2    ) &&
		SHADOWMAPCHK( Info->SrcGrHandle, SrcShadowMap ) )
		return -1 ;

	if( GRAPHCHK(     Info->DestGrHandle, DestImage2    ) &&
		SHADOWMAPCHK( Info->DestGrHandle, DestShadowMap ) )
		return -1 ;

	if( DestShadowMap != NULL )
	{
		SetRenderTargetHardware( DestShadowMap->Surface ) ;
	}
	else
	{
		SetRenderTargetHardware( CheckMultiSampleDrawValidGraph( Info->DestGrHandle ) ?
									DestImage2->Hard.Draw[ 0 ].Tex->RenderTargetSurface :
									DestImage2->Hard.Draw[ 0 ].Tex->Surface[ 0 ] ) ;
	}

	SrcX1F = ( float )Info->SrcX1 ;
	SrcX2F = ( float )Info->SrcX2 ;
	SrcY1F = ( float )Info->SrcY1 ;
	SrcY2F = ( float )Info->SrcY2 ;
	SrcWidth  = Info->SrcX2 - Info->SrcX1 ;
	SrcHeight = Info->SrcY2 - Info->SrcY1 ;

	if( ScaleDivNum != 1 )
	{
		DestX1F = ( float )  Info->DestX                             - 0.5f ;
		DestX2F = ( float )( Info->DestX + SrcWidth  / ScaleDivNum ) - 0.5f ;
		DestY1F = ( float )  Info->DestY                             - 0.5f ;
		DestY2F = ( float )( Info->DestY + SrcHeight / ScaleDivNum ) - 0.5f ;
	}
	else
	{
		DestX1F = ( float )  Info->DestX               - 0.5f ;
		DestX2F = ( float )( Info->DestX + SrcWidth  ) - 0.5f ;
		DestY1F = ( float )  Info->DestY               - 0.5f ;
		DestY2F = ( float )( Info->DestY + SrcHeight ) - 0.5f ;
	}

	NS_GetGraphTextureSize( Info->SrcGrHandle, &SrcTexWidth, &SrcTexHeight ) ;
	SrcX1TexF = SrcX1F / SrcTexWidth ;
	SrcX2TexF = SrcX2F / SrcTexWidth ;
	SrcY1TexF = SrcY1F / SrcTexHeight ;
	SrcY2TexF = SrcY2F / SrcTexHeight ;

	Vert[ 0 ].pos = VGet( DestX1F, DestY1F, 0.0f ) ;
	Vert[ 1 ].pos = VGet( DestX2F, DestY1F, 0.0f ) ;
	Vert[ 2 ].pos = VGet( DestX1F, DestY2F, 0.0f ) ;
	Vert[ 3 ].pos = VGet( DestX2F, DestY2F, 0.0f ) ;
	Vert[ 0 ].u = SrcX1TexF ; Vert[ 0 ].v = SrcY1TexF ;
	Vert[ 1 ].u = SrcX2TexF ; Vert[ 1 ].v = SrcY1TexF ;
	Vert[ 2 ].u = SrcX1TexF ; Vert[ 2 ].v = SrcY2TexF ;
	Vert[ 3 ].u = SrcX2TexF ; Vert[ 3 ].v = SrcY2TexF ;
	Vert[ 0 ].rhw = 1.0f ;
	Vert[ 1 ].rhw = 1.0f ;
	Vert[ 2 ].rhw = 1.0f ;
	Vert[ 3 ].rhw = 1.0f ;

	if( Info->IsBlend )
	{
		if( GRAPHCHK( Info->BlendGrHandle, BlendImage2 ) )
			return -1 ;

		if( Info->BlendPosEnable )
		{
			BlendX1TexF = ( float )  Info->BlendX               / BlendImage2->Orig->Hard.Tex[ 0 ].TexWidth ;
			BlendX2TexF = ( float )( Info->BlendX + SrcWidth )  / BlendImage2->Orig->Hard.Tex[ 0 ].TexWidth ;
			BlendY1TexF = ( float )  Info->BlendY               / BlendImage2->Orig->Hard.Tex[ 0 ].TexHeight ;
			BlendY2TexF = ( float )( Info->BlendY + SrcHeight ) / BlendImage2->Orig->Hard.Tex[ 0 ].TexHeight ;
		}
		else
		{
			BlendX1TexF = BlendImage2->Hard.Draw[ 0 ].Vertex[ 0 ].u ;
			BlendX2TexF = BlendImage2->Hard.Draw[ 0 ].Vertex[ 1 ].u ;
			BlendY1TexF = BlendImage2->Hard.Draw[ 0 ].Vertex[ 0 ].v ;
			BlendY2TexF = BlendImage2->Hard.Draw[ 0 ].Vertex[ 2 ].v ;
		}
		Vert[ 0 ].su = BlendX1TexF ; Vert[ 0 ].sv = BlendY1TexF ;
		Vert[ 1 ].su = BlendX2TexF ; Vert[ 1 ].sv = BlendY1TexF ;
		Vert[ 2 ].su = BlendX1TexF ; Vert[ 2 ].sv = BlendY2TexF ;
		Vert[ 3 ].su = BlendX2TexF ; Vert[ 3 ].sv = BlendY2TexF ;

		NS_SetUseTextureToShader( 1, Info->BlendGrHandle ) ;
	}

	NS_SetUseTextureToShader( 0, Info->SrcGrHandle ) ;

	// 描画の準備
	RenderVertexHardware() ;
	BeginScene() ;
	DrawPreparationToShader( 0, FALSE, TRUE, TRUE ) ;

	// 描画
	SETFVF( VERTEXFVF_SHADER_2D )
	GraphicsDevice_DrawPrimitiveUP( ( D_D3DPRIMITIVETYPE )DX_PRIMTYPE_TRIANGLESTRIP, GETPRIMNUM( DX_PRIMTYPE_TRIANGLESTRIP, 4 ), Vert, sizeof( VERTEX2DSHADER ) ) ;

	if( CheckMultiSampleDrawValidGraph( Info->DestGrHandle ) )
	{
		EndScene() ;
		UpdateDrawTexture( DestImage2->Hard.Draw[ 0 ].Tex, 0 ) ;
	}

	// 終了
	return 0 ;
}

static int GraphFilter_GetSoftImage( int GrHandle, BASEIMAGE *BaseImage, RECT *GetRect )
{
	RECT TempRect ;
	int Width, Height ;
	BASEIMAGE SurfaceImage ;
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_HARD_DRAW *HardDraw ;
	RECT SrcRect ;
	RECT DestRect ;
	int i ;
	int temp ;

	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	if( GetRect == NULL )
	{
		NS_GetGraphSize( GrHandle, &Width, &Height ) ;

		TempRect.left = 0 ;
		TempRect.right = Width ;
		TempRect.top = 0 ;
		TempRect.bottom = Height ;

		GetRect = &TempRect ;
	}
	else
	{
		Width = GetRect->right - GetRect->left ;
		Height = GetRect->bottom - GetRect->top ;
	}

	if( NS_CreateARGB8ColorBaseImage( Width, Height, BaseImage ) < 0 )
		return -1 ;

	if( Image2->Orig->FormatDesc.TextureFlag )
	{
		HardDraw = Image2->Hard.Draw ;
		for( i = 0 ; i < Image2->Hard.DrawNum ; i ++, HardDraw ++ )
		{
			SrcRect.left   = HardDraw->UsePosX ;
			SrcRect.right  = HardDraw->UsePosX + HardDraw->Width ;
			SrcRect.top    = HardDraw->UsePosY ;
			SrcRect.bottom = HardDraw->UsePosY + HardDraw->Height ;

			DestRect.left   = HardDraw->DrawPosX ;
			DestRect.right  = HardDraw->DrawPosX + HardDraw->Width ;
			DestRect.top    = HardDraw->DrawPosY ;
			DestRect.bottom = HardDraw->DrawPosY + HardDraw->Height ;

			if( DestRect.left   >= GetRect->right ||
				DestRect.right  <= GetRect->left ||
				DestRect.top    >= GetRect->bottom ||
				DestRect.bottom <= GetRect->top )
				continue ;

			if( DestRect.left < GetRect->left )
			{
				temp = GetRect->left - DestRect.left ;
				SrcRect.left += temp ;
				DestRect.left += temp ;
			}
			if( DestRect.right > GetRect->right )
			{
				temp = DestRect.right - GetRect->right ;
				SrcRect.right -= temp ;
				DestRect.right -= temp ;
			}
			if( DestRect.top < GetRect->top )
			{
				temp = GetRect->top - DestRect.top ;
				SrcRect.top += temp ;
				DestRect.top += temp ;
			}
			if( DestRect.bottom > GetRect->bottom )
			{
				temp = DestRect.bottom - GetRect->bottom ;
				SrcRect.bottom -= temp ;
				DestRect.bottom -= temp ;
			}

			if( LockDrawScreenBuffer( &SrcRect, &SurfaceImage, GrHandle, 0, TRUE, i ) < 0 )
			{
				NS_ReleaseBaseImage( BaseImage ) ;
				return -1 ;
			}

			NS_BltBaseImage( 0, 0, SrcRect.right - SrcRect.left, SrcRect.bottom - SrcRect.top, DestRect.left, DestRect.top, &SurfaceImage, BaseImage ) ;
			UnlockDrawScreenBuffer() ;
		}
	}
	else
	{
		if( LockDrawScreenBuffer( GetRect, &SurfaceImage, GrHandle, 0, TRUE, 0 ) < 0 )
		{
			NS_ReleaseBaseImage( BaseImage ) ;
			return -1 ;
		}

		NS_BltBaseImage( 0, 0, Width, Height, 0, 0, &SurfaceImage, BaseImage ) ;
		UnlockDrawScreenBuffer() ;
	}


	// 正常終了
	return 0 ;
}

static int	GraphFilter_SoftImageSetup( GRAPHFILTER_INFO *Info, int DestDiscard, int DestWidth, int DestHeight )
{
	RECT Rect ;
	int SrcWidth ;
	int SrcHeight ;

	SrcWidth = Info->SrcX2 - Info->SrcX1 ;
	SrcHeight = Info->SrcY2 - Info->SrcY1 ;

	if( DestWidth < 0 || DestHeight < 0 )
	{
		DestWidth = SrcWidth ;
		DestHeight = SrcHeight ;
	}
	Info->DestWidth = DestWidth ;
	Info->DestHeight = DestHeight ;

	Info->SrcImage.GraphData = NULL ;
	Info->BlendImage.GraphData = NULL ;
	Info->DestImage.GraphData = NULL ;

	Rect.left   = Info->SrcX1 ;
	Rect.right  = Info->SrcX2 ;
	Rect.top    = Info->SrcY1 ;
	Rect.bottom = Info->SrcY2 ;

	if( GraphFilter_GetSoftImage( Info->SrcGrHandle, &Info->SrcImage, &Rect ) < 0 )
		goto ERR ;

	if( Info->IsBlend )
	{
		if( GraphFilter_GetSoftImage( Info->BlendGrHandle, &Info->BlendImage, &Rect ) < 0 )
			goto ERR ;
	}

	if( DestDiscard )
	{
		if( NS_CreateARGB8ColorBaseImage( Info->DestWidth, Info->DestHeight, &Info->DestImage ) < 0 )
			goto ERR ;
	}
	else
	{
		Rect.left   = Info->DestX ;
		Rect.right  = Info->DestX + Info->DestWidth ;
		Rect.top    = Info->DestY ;
		Rect.bottom = Info->DestY + Info->DestHeight ;
		if( GraphFilter_GetSoftImage( Info->DestGrHandle, &Info->DestImage, &Rect ) < 0 )
			goto ERR ;
	}

	// 正常終了
	return 0 ;

ERR :
	if( Info->SrcImage.GraphData )
		NS_ReleaseBaseImage( &Info->SrcImage ) ;

	if( Info->BlendImage.GraphData )
		NS_ReleaseBaseImage( &Info->BlendImage ) ;

	if( Info->DestImage.GraphData )
		NS_ReleaseBaseImage( &Info->DestImage ) ;

	return -1 ;
}

static int	GraphFilter_SoftImageTerminate( GRAPHFILTER_INFO *Info )
{
	if( Info->SrcImage.GraphData )
		NS_ReleaseBaseImage( &Info->SrcImage ) ;

	if( Info->BlendImage.GraphData )
		NS_ReleaseBaseImage( &Info->BlendImage ) ;

	if( Info->DestImage.GraphData )
	{
		RECT Rect ;

		Rect.left   = 0 ;
		Rect.top    = 0 ;
		Rect.right  = Info->DestWidth ;
		Rect.bottom = Info->DestHeight ;
		BltBmpOrBaseImageToGraph3( NULL, NULL, NULL, &Rect, Info->DestX, Info->DestY, Info->DestGrHandle, FALSE, &Info->DestImage, NULL, FALSE, FALSE, FALSE ) ;
/*
		if( Info->UseTempDestImage )
		{
			if( Info->TempDestImage.GraphData )
			{
				NS_BltBaseImage( 0, 0, Info->DestWidth, Info->DestHeight, 0, 0, &Info->TempDestImage, &Info->DestImage ) ;
			}
		}

		UnlockDrawScreenBuffer() ;
*/
	}

	if( Info->DestImage.GraphData )
		NS_ReleaseBaseImage( &Info->DestImage ) ;

	return 0 ;
}

// 画像のフィルター付き転送を行う( 可変引数情報付き )
extern int GraphFilterRectBltBase( int IsBlend, int SrcGrHandle, int BlendGrHandle, int DestGrHandle, int BlendRatio, int FilterOrBlendType, int SrcX1, int SrcY1, int SrcX2, int SrcY2, int BlendX, int BlendY, int BlendPosEnable, int DestX, int DestY, va_list ParamList )
{
	LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
	SHADOWMAPDATA *SrcShadowMap = NULL ;
	SHADOWMAPDATA *DestShadowMap = NULL ;
	IMAGEDATA2 *SrcImage2 = NULL ;
	IMAGEDATA2 *DestImage2 = NULL ;
	IMAGEDATA2 *BlendImage2 = NULL ;
	IMAGEDATA2 *TargetScreenImage2 = NULL ;
	int UseDestGrHandle = -1 ;
	int UseSrcGrHandle ;
	int SrcImageWidth, SrcImageHeight ;
	int DestImageWidth, DestImageHeight ;
	int Width, Height ;
	int FilterResult = -1 ;
	int Pass ;
	int PassNum = -1 ;
	int UseWorkScreen ;
	GRAPHFILTER_INFO Info ;
	float BlendRatioF ;
	int Down_Scale_DivNum = 0 ;

	// エラー判定
	if( !GRAPHCHK( SrcGrHandle, SrcImage2 ) )
	{
		SrcImageWidth = SrcImage2->Width ;
		SrcImageHeight = SrcImage2->Height ;
	}
	else
	if( !SHADOWMAPCHK( SrcGrHandle, SrcShadowMap ) )
	{
		SrcImageWidth = SrcShadowMap->BaseSizeX ;
		SrcImageHeight = SrcShadowMap->BaseSizeY ;
	}
	else
	{
		return -1 ;
	}

	if( !GRAPHCHK(     DestGrHandle, DestImage2    ) )
	{
		DestImageWidth = DestImage2->Width ;
		DestImageHeight = DestImage2->Height ;
	}
	else
	if( !SHADOWMAPCHK( DestGrHandle, DestShadowMap ) )
	{
		DestImageWidth = DestShadowMap->BaseSizeX ;
		DestImageHeight = DestShadowMap->BaseSizeY ;
	}
	else
	{
		return -1 ;
	}

	if( CheckMultiSampleDrawValidGraph( GBASE.TargetScreen[ 0 ] ) )
	{
		GRAPHCHK( GBASE.TargetScreen[ 0 ], TargetScreenImage2 ) ;
	}

	if( SrcX2 <= SrcX1 ||
		SrcY2 <= SrcY1 ) return -1 ;

	if( IsBlend )
	{
		if( GRAPHCHK( BlendGrHandle, BlendImage2 ) )
			return -1 ;

		if( FilterOrBlendType < 0 || FilterOrBlendType >= DX_GRAPH_BLEND_NUM )
			return -1;
	}
	else
	{
		if( FilterOrBlendType < 0 || FilterOrBlendType >= DX_GRAPH_FILTER_NUM )
			return -1;
	}

	// 値の補正
	if( BlendRatio < 0 )
	{
		BlendRatio = 0 ;
	}
	else
	if( BlendRatio > 255 )
	{
		BlendRatio = 255 ;
	}
	BlendRatioF = BlendRatio / 255.0f ;

	// 座標の補正
	if( SrcX1 < 0 )
	{
		DestX += -SrcX1 ;
		BlendX += -SrcX1 ;
		SrcX1 = 0 ;
	}
	if( SrcY1 < 0 )
	{
		DestY += -SrcY1 ;
		BlendY += -SrcY1 ;
		SrcY1 = 0 ;
	}
	if( DestX < 0 )
	{
		SrcX1 += -DestX ;
		BlendX += -DestX ;
		DestX = 0 ;
	}
	if( DestY < 0 )
	{
		SrcY1 += -DestY ;
		BlendY += -DestY ;
		DestY = 0 ;
	}
	if( SrcX2 <= SrcX1 ||
		SrcY2 <= SrcY1 ) return 0 ;
	if( SrcX2 > SrcImageWidth )
	{
		SrcX2 = SrcImageWidth ;
	}
	if( SrcY2 > SrcImageHeight )
	{
		SrcY2 = SrcImageHeight ;
	}
	if( SrcX1 >= SrcImageWidth ||
		SrcY1 >= SrcImageHeight ||
		SrcX2 <= 0 ||
		SrcY2 <= 0 ||
		DestX >= DestImageWidth ||
		DestY >= DestImageHeight )
		return 0 ;

	Width = SrcX2 - SrcX1 ;
	Height = SrcY2 - SrcY1 ;
	if( Width <= 0 ||
		Height <= 0 )
		return 0 ;

	if( IsBlend == FALSE && FilterOrBlendType == DX_GRAPH_FILTER_DOWN_SCALE )
	{
		Down_Scale_DivNum = va_arg( ParamList, int ) ;

		if( DestX + Width / Down_Scale_DivNum > DestImageWidth )
		{
			Width = ( DestImageWidth - DestX ) * Down_Scale_DivNum ;
			SrcX2 = SrcX1 + Width ;
		}
		if( DestY + Height / Down_Scale_DivNum > DestImageHeight )
		{
			Height = ( DestImageHeight - DestY ) * Down_Scale_DivNum ;
			SrcY2 = SrcY1 + Height ;
		}
	}
	else
	{
		if( DestX + Width > DestImageWidth )
		{
			Width = DestImageWidth - DestX ;
			SrcX2 = SrcX1 + Width ;
		}
		if( DestY + Height > DestImageHeight )
		{
			Height = DestImageHeight - DestY ;
			SrcY2 = SrcY1 + Height ;
		}
	}
	if( Width <= 0 ||
		Height <= 0 )
		return 0 ;
	
	// 描画先がレンダリングターゲット専用のサーフェスを使用していて、且つ描画先の画像をブレンドで使う場合はここでサーフェスをアップデート
	if( TargetScreenImage2 != NULL &&
		( GBASE.TargetScreen[ 0 ] == SrcGrHandle ||
		  GBASE.TargetScreen[ 0 ] == DestGrHandle ||
		  ( IsBlend && GBASE.TargetScreen[ 0 ] == BlendGrHandle ) ) )
	{
		EndScene() ;
		UpdateDrawTexture( &TargetScreenImage2->Orig->Hard.Tex[ 0 ], GBASE.TargetScreenSurface[ 0 ] ) ;
	}

	// 情報のセット
	Info.IsBlend = IsBlend ;
	Info.FilterOrBlendType = FilterOrBlendType ;
	Info.BlendGrHandle = BlendGrHandle ;
	Info.BlendRatio = BlendRatioF ;
	Info.SrcX1 = SrcX1 ;
	Info.SrcY1 = SrcY1 ;
	Info.SrcX2 = SrcX2 ;
	Info.SrcY2 = SrcY2 ;
	Info.BlendX = BlendX ;
	Info.BlendY = BlendY ;
	Info.BlendPosEnable = BlendPosEnable ;
	Info.DestX = DestX ;
	Info.DestY = DestY ;

	// フィルター毎の引数を取得
	int			Gauss_PixelWidth = 0 ;
	float		Gauss_Param = 0.0f ;
	int			Bright_Clip_CmpType = 0 ;
	float		Bright_Clip_CmpParam = 0.0f ;
	int			Bright_Clip_ClipFillFlag = 0 ;
	COLOR_F		Bright_Clip_ClipFillColor = { 0.0f } ;
	int			Hsb_HueType = 0 ;
	float		Hsb_Hue = 0.0f ;
	float		Hsb_Saturation = 0.0f ;
	float		Hsb_Bright = 0.0f ;
	float		Mono_Cb = 0.0f ;
	float		Mono_Cr = 0.0f ;
	float		Lv_Min = 0.0f ;
	float		Lv_Max = 0.0f ;
	float		Lv_Gamma = 0.0f ;
	float		Lv_AfterMin = 0.0f ;
	float		Lv_AfterMax = 0.0f ;
	float		TC_Threshold = 0.0f ;
	COLOR_F		TC_LowColor = { 0.0f } ;
	COLOR_F		TC_HighColor = { 0.0f } ;
	int			GM_MapGrHandle = 0 ;
	int			GM_Reverse = 0 ;

	int			TempR = 0, TempG = 0, TempB = 0, TempA = 0 ;

	int			RGBA_R = 0 ;
	int			RGBA_G = 0 ;
	int			RGBA_B = 0 ;
	int			RGBA_A = 0 ;
	if( IsBlend )
	{
		switch( FilterOrBlendType )
		{
		case DX_GRAPH_BLEND_RGBA_SELECT_MIX :
			RGBA_R = va_arg( ParamList, int ) ;
			RGBA_G = va_arg( ParamList, int ) ;
			RGBA_B = va_arg( ParamList, int ) ;
			RGBA_A = va_arg( ParamList, int ) ;
			break ;
		}

		// パスの数を取得
		if( PassNum == -1 )
		{
			PassNum = GraphBlendPassNum_Table[ FilterOrBlendType ] ;
		}

		// 作業用テクスチャを使用するかどうかを取得
		UseWorkScreen = GraphBlendUseWorkScreen_Table[ FilterOrBlendType ] ;
	}
	else
	{
		switch( FilterOrBlendType )
		{
		case DX_GRAPH_FILTER_MONO :
			Mono_Cb = ( float )va_arg( ParamList, int ) * 100.0f / 255.0f ;
			Mono_Cr = ( float )va_arg( ParamList, int ) * 100.0f / 255.0f ;
			break ;

		case DX_GRAPH_FILTER_GAUSS :
			Gauss_PixelWidth = va_arg( ParamList, int ) ;
			Gauss_Param = ( float )va_arg( ParamList, int ) / 100.0f ;
			break ;

		case DX_GRAPH_FILTER_DOWN_SCALE :
//			Down_Scale_DivNum = va_arg( ParamList, int ) ;
			break ;

		case DX_GRAPH_FILTER_BRIGHT_CLIP :
			Bright_Clip_CmpType = va_arg( ParamList, int ) ;
			Bright_Clip_CmpParam = ( float )va_arg( ParamList, int ) ;
			Bright_Clip_ClipFillFlag = va_arg( ParamList, int ) ;
			if( Bright_Clip_ClipFillFlag )
			{
				NS_GetColor2( va_arg( ParamList, int ), &TempR, &TempG, &TempB ) ;
				TempA = va_arg( ParamList, int ) ;
				Bright_Clip_ClipFillColor = NS_GetColorF( TempR / 255.0f, TempG / 255.0f, TempB / 255.0f, TempA / 255.0f ) ;
			}
			break ;

		case DX_GRAPH_FILTER_HSB :
			Hsb_HueType = va_arg( ParamList, int ) ;
			Hsb_Hue = ( float )va_arg( ParamList, int ) ;
			Hsb_Saturation = ( float )va_arg( ParamList, int ) * 100.0f / 255.0f ;
			Hsb_Bright  = ( float )va_arg( ParamList, int ) * 100.0f / 255.0f ;

			if( Hsb_HueType == 1 )
			{
				PassNum = 1 ;
			}
			break ;

		case DX_GRAPH_FILTER_LEVEL :
			Lv_Min = ( float )va_arg( ParamList, int ) ;
			Lv_Max = ( float )va_arg( ParamList, int ) ;
			Lv_Gamma = ( float )va_arg( ParamList, int ) / 100.0f ;
			Lv_AfterMin = ( float )va_arg( ParamList, int ) ;
			Lv_AfterMax = ( float )va_arg( ParamList, int ) ;
			break ;

		case DX_GRAPH_FILTER_TWO_COLOR :
			TC_Threshold = ( float )va_arg( ParamList, int ) ;

			NS_GetColor2( va_arg( ParamList, int ), &TempR, &TempG, &TempB ) ;
			TempA = va_arg( ParamList, int ) ;
			TC_LowColor = NS_GetColorF( TempR / 255.0f, TempG / 255.0f, TempB / 255.0f, TempA / 255.0f ) ;

			NS_GetColor2( va_arg( ParamList, int ), &TempR, &TempG, &TempB ) ;
			TempA = va_arg( ParamList, int ) ;
			TC_HighColor = NS_GetColorF( TempR / 255.0f, TempG / 255.0f, TempB / 255.0f, TempA / 255.0f ) ;
			break ;

		case DX_GRAPH_FILTER_GRADIENT_MAP :
			GM_MapGrHandle = va_arg( ParamList, int ) ;
			GM_Reverse = va_arg( ParamList, int ) ;

			if( TargetScreenImage2 != NULL && GM_MapGrHandle == GBASE.TargetScreen[ 0 ] )
			{
				EndScene() ;
				UpdateDrawTexture( &TargetScreenImage2->Orig->Hard.Tex[ 0 ], GBASE.TargetScreenSurface[ 0 ] ) ;
			}
			break ;

		case DX_GRAPH_FILTER_PREMUL_ALPHA :
			break ;

		case DX_GRAPH_FILTER_INTERP_ALPHA :
			break ;
		}

		// パスの数を取得
		if( PassNum == -1 )
		{
			PassNum = GraphFilterPassNum_Table[ FilterOrBlendType ] ;
		}

		// 作業用テクスチャを使用するかどうかを取得
		UseWorkScreen = GraphFilterUseWorkScreen_Table[ FilterOrBlendType ] ;
	}
	if( SrcX1 != DestX || SrcY1 != DestY || GRH.ValidRenderTargetInputTexture == FALSE )
	{
		UseWorkScreen = 1 ;
	}

	// シェーダーが使えない場合は必ず１パスで終わる
	if( GRH.UseShader == FALSE )
	{
		PassNum = 1 ;
	}

	if( GRH.BeginSceneFlag == FALSE ) BeginScene() ;

	// パラメータの保存
	LibShader_PushBaseDrawParam( &DrawParamTemp ) ;

	// ループ処理の開始
	UseSrcGrHandle = SrcGrHandle ;
	for( Pass = 0 ; Pass < PassNum ; Pass ++ )
	{
		Info.Pass = Pass ;

		// 出力先のセットアップ
		Info.SrcGrHandle = SrcGrHandle ;
		Info.DestGrHandle = DestGrHandle ;
		if( GraphFilterDestGraphSetup( &Info, PassNum, UseWorkScreen, &UseSrcGrHandle, &UseDestGrHandle ) < 0 )
			break ;

		DestImage2 = NULL ;
		DestShadowMap = NULL ;
		if( GRAPHCHK(     UseDestGrHandle, DestImage2 ) &&
			SHADOWMAPCHK( UseDestGrHandle, DestShadowMap  ) )
			break ;

		// 情報のセット
		Info.SrcGrHandle = UseSrcGrHandle ;
		Info.DestGrHandle = UseDestGrHandle ;

		if( IsBlend )
		{
			// ブレンドタイプによって処理を分岐
			switch( FilterOrBlendType )
			{
			case DX_GRAPH_BLEND_RGBA_SELECT_MIX :
				FilterResult = GraphBlend_RGBA_Select_Mix( &Info, RGBA_R, RGBA_G, RGBA_B, RGBA_A ) ; 
				break ;

			case DX_GRAPH_BLEND_NORMAL :
			case DX_GRAPH_BLEND_MULTIPLE :
			case DX_GRAPH_BLEND_DIFFERENCE :
			case DX_GRAPH_BLEND_ADD :
			case DX_GRAPH_BLEND_SCREEN :
			case DX_GRAPH_BLEND_OVERLAY :
			case DX_GRAPH_BLEND_DODGE :
			case DX_GRAPH_BLEND_BURN :
			case DX_GRAPH_BLEND_DARKEN :
			case DX_GRAPH_BLEND_LIGHTEN :
			case DX_GRAPH_BLEND_SOFTLIGHT :
			case DX_GRAPH_BLEND_HARDLIGHT :
			case DX_GRAPH_BLEND_EXCLUSION :
			case DX_GRAPH_BLEND_NORMAL_ALPHACH :
			case DX_GRAPH_BLEND_ADD_ALPHACH :
			case DX_GRAPH_BLEND_MULTIPLE_A_ONLY :
				FilterResult = GraphBlend_Basic( &Info ) ;
				break ;
			}
		}
		else
		{
			// フィルターによって処理を分岐
			switch( FilterOrBlendType )
			{
			case DX_GRAPH_FILTER_MONO :
				FilterResult = GraphFilter_Mono( &Info, Mono_Cb, Mono_Cr ) ;
				break ;

			case DX_GRAPH_FILTER_GAUSS :
				FilterResult = GraphFilter_Gauss( &Info, Gauss_PixelWidth, Gauss_Param ) ; 
				break ;

			case DX_GRAPH_FILTER_DOWN_SCALE :
				FilterResult = GraphFilter_Down_Scale( &Info, Down_Scale_DivNum ) ;
				break ;

			case DX_GRAPH_FILTER_BRIGHT_CLIP :
				FilterResult = GraphFilter_Bright_Clip( &Info, Bright_Clip_CmpType, Bright_Clip_CmpParam, Bright_Clip_ClipFillFlag, &Bright_Clip_ClipFillColor ) ;
				break ;

			case DX_GRAPH_FILTER_HSB :
				FilterResult = GraphFilter_HSB( &Info, Hsb_HueType, Hsb_Hue, Hsb_Saturation, Hsb_Bright ) ;
				break ;

			case DX_GRAPH_FILTER_INVERT :
				FilterResult = GraphFilter_Invert( &Info ) ;
				break ;

			case DX_GRAPH_FILTER_LEVEL :
				FilterResult = GraphFilter_Level( &Info, Lv_Min, Lv_Max, Lv_Gamma, Lv_AfterMin, Lv_AfterMax ) ;
				break ;

			case DX_GRAPH_FILTER_TWO_COLOR :
				FilterResult = GraphFilter_TwoColor( &Info, TC_Threshold, &TC_LowColor, &TC_HighColor ) ;
				break ;

			case DX_GRAPH_FILTER_GRADIENT_MAP :
				FilterResult = GraphFilter_GradientMap( &Info, GM_MapGrHandle, GM_Reverse ) ;
				break ;

			case DX_GRAPH_FILTER_PREMUL_ALPHA :
				FilterResult = GraphFilter_PremulAlpha( &Info ) ;
				break ;

			case DX_GRAPH_FILTER_INTERP_ALPHA :
				FilterResult = GraphFilter_InterpAlpha( &Info ) ;
				break ;
			}
		}

		// 出力元の変更
		UseSrcGrHandle = UseDestGrHandle ;
	}

	// パラメータの復帰
	LibShader_PopBaseDrawParam( &DrawParamTemp ) ;

	// 出力先の更新
	Info.SrcGrHandle = SrcGrHandle ;
	Info.DestGrHandle = DestGrHandle ;
	GraphFilterDestGraphUpdate( &Info, UseWorkScreen, UseDestGrHandle, FilterResult ) ;

	// 終了
	return Pass == PassNum ? 0 : -1 ;
}

static int GraphFilter_Mono( GRAPHFILTER_INFO *Info, float Cb, float Cr )
{
	// 値を補正
	Cb /= 200.0f ;
	if( Cb < -0.5f )
	{
		Cb = -0.5f ;
	}
	else
	if( Cb > 0.5f )
	{
		Cb = 0.5f ;
	}

	Cr /= 200.0f ;
	if( Cr < -0.5f )
	{
		Cr = -0.5f ;
	}
	else
	if( Cr > 0.5f )
	{
		Cr = 0.5f ;
	}

	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 1 ] =
		{
			"Mono.pso",
		};
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		FLOAT4 ParamF4[ 2 ] ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		if( GRH.ShaderCode.MonoPS < 0 )
		{
			GRH.ShaderCode.MonoPS = MemLoadShaderCode( PsoFileName[ 0 ], false ) ;
			if( GRH.ShaderCode.MonoPS < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ 0 ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.MonoPS, &GRH.ShaderCode.MonoPS ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		ParamF4[ 0 ].x = 0.29900f ;
		ParamF4[ 0 ].y = 0.58700f ;
		ParamF4[ 0 ].z = 0.11400f ;
		ParamF4[ 0 ].w = 0.0f ;
		ParamF4[ 1 ].x = 1.40200f * Cr ;
		ParamF4[ 1 ].y = 0.34414f * Cb - 0.71414f * Cr ;
		ParamF4[ 1 ].z = 1.77200f * Cb ;
		ParamF4[ 1 ].w = 0.0f ;
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 2, FALSE ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.MonoPS ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 2 ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;
		int Y ;
		int RAdd ;
		int GAdd ;
		int BAdd ;
		int R, G, B ;

		RAdd = _FTOL( ( 1.40200f * Cr                 ) * 255.0f * 4096.0f ) ;
		GAdd = _FTOL( ( 0.34414f * Cb - 0.71414f * Cr ) * 255.0f * 4096.0f ) ;
		BAdd = _FTOL( ( 1.77200f * Cb                 ) * 255.0f * 4096.0f ) ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		do
		{
			i = Width ;
			do
			{
				Y = Src[ 0 ] * ( int )( 0.114f * 4096.0f ) +
					Src[ 1 ] * ( int )( 0.587f * 4096.0f ) +
					Src[ 2 ] * ( int )( 0.299f * 4096.0f ) ;
				B = ( Y + BAdd ) >> 12 ;
				G = ( Y + GAdd ) >> 12 ;
				R = ( Y + RAdd ) >> 12 ;
				if( B < 0 ) B = 0 ; else if( B > 255 ) B = 255 ;
				if( G < 0 ) G = 0 ; else if( G > 255 ) G = 255 ;
				if( R < 0 ) R = 0 ; else if( R > 255 ) R = 255 ;

				Dest[ 0 ] = ( BYTE )B ;
				Dest[ 1 ] = ( BYTE )G ;
				Dest[ 2 ] = ( BYTE )R ;
				Dest[ 3 ] = Src[ 3 ] ;

				Src  += 4 ;
				Dest += 4 ;
			}while( -- i ) ;

			Src  += SrcAddPitch ;
			Dest += DestAddPitch ;
		}while( -- Height ) ;

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int GraphFilter_Gauss( GRAPHFILTER_INFO *Info, int PixelWidth, float Param )
{
	static int PrevPixelWidth ;
	static float PrevParam ;
	static float Table[ 16 ] ;
	int WeightNum ;

	// PixelWidth の補正
	if( PixelWidth <= 8 )
	{
		PixelWidth = 8 ;
	}
	else
	if( PixelWidth <= 16 )
	{
		PixelWidth = 16 ;
	}
	else
	{
		PixelWidth = 32 ;
	}
	WeightNum = PixelWidth / 2 ;

	if( Param >= 0.0000001f )
	{
		float Temp ;

		Temp = PrevParam - Param ;
		if( Temp > 0.0002f || Temp < -0.0002f || PrevPixelWidth != PixelWidth )
		{
			float Total ;
			int i ;

			PrevParam = Param ;
			PrevPixelWidth = PixelWidth ;

			Total = 0.0f ;
			for( i = 0 ; i < WeightNum ; i ++ )
			{
				Table[ i ] = _EXPF( -0.5f * ( float )( i * i ) / Param ) ;
				if( i == 0 )
				{
					Total += Table[ i ] ;
				}
				else
				{
					Total += 2.0f * Table[ i ] ;
				}
			}

			for( i = 0 ; i < WeightNum ; i ++ )
				Table[ i ] /= Total ;
		}
	}

	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[] =
		{
			"Gauss_08Pixel_PS.pso",
			"Gauss_16Pixel_PS.pso",
			"Gauss_32Pixel_PS.pso"
		} ;
		IMAGEDATA2 *SrcImage2 = NULL ;
		SHADOWMAPDATA *SrcShadowMap = NULL ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		int UseShader = 0 ;
		FLOAT4 ParamF4[ 21 ] ;
		int TexWidth ;
		int TexHeight ;

		if( GRAPHCHK(     Info->SrcGrHandle, SrcImage2    ) &&
			SHADOWMAPCHK( Info->SrcGrHandle, SrcShadowMap ) )
			return -1 ;

		// PixelWidth によってシェーダーを変更
		switch( PixelWidth )
		{
		case 8  : UseShader = 0 ; break ;
		case 16 : UseShader = 1 ; break ;
		case 32 : UseShader = 2 ; break ;
		}

		if( Param < 0.0000001f )
		{
			IMAGEDATA2 *DestImage2 = NULL ;
			SHADOWMAPDATA *DestShadowMap = NULL ;

			if( GRAPHCHK(     Info->DestGrHandle, DestImage2    ) &&
				SHADOWMAPCHK( Info->DestGrHandle, DestShadowMap ) )
				return -1 ;

			if( DestShadowMap )
			{
				SetRenderTargetHardware( DestShadowMap->Surface ) ;
				NS_DrawGraph( 0, 0, Info->SrcGrHandle, FALSE ) ;
			}
			else
			{
				SetRenderTargetHardware( CheckMultiSampleDrawValidGraph( Info->DestGrHandle ) ?
											DestImage2->Hard.Draw[ 0 ].Tex->RenderTargetSurface :
											DestImage2->Hard.Draw[ 0 ].Tex->Surface[ 0 ] ) ;
				NS_DrawGraph( 0, 0, Info->SrcGrHandle, FALSE ) ;
				if( CheckMultiSampleDrawValidGraph( Info->DestGrHandle ) )
				{
					EndScene() ;
					UpdateDrawTexture( DestImage2->Hard.Draw[ 0 ].Tex, 0 ) ;
				}
			}
		}
		else
		{
			// 使用するシェーダーのセットアップ
			if( GRH.ShaderCode.Gauss_PS[ UseShader ] < 0 )
			{
				GRH.ShaderCode.Gauss_PS[ UseShader ] = MemLoadShaderCode( PsoFileName[ UseShader ], false ) ;
				if( GRH.ShaderCode.Gauss_PS[ UseShader ] < 0 )
				{
					DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ UseShader ] )) ;
					return -1 ;
				}
				NS_SetDeleteHandleFlag( GRH.ShaderCode.Gauss_PS[ UseShader ], &GRH.ShaderCode.Gauss_PS[ UseShader ] ) ;
			}

			NS_GetGraphTextureSize( Info->SrcGrHandle, &TexWidth, &TexHeight ) ;

			LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

			ParamF4[  0 ].x = ( float )TexWidth ;
			ParamF4[  0 ].y = ( float )TexHeight ;
			ParamF4[  1 ].x = Table[ 0 ] ;
			ParamF4[  1 ].y = Table[ 1 ] ;
			ParamF4[  1 ].z = Table[ 2 ] ;
			ParamF4[  1 ].w = Table[ 3 ] ;
			ParamF4[  2 ].x = Table[ 4 ] ;
			ParamF4[  2 ].y = Table[ 5 ] ;
			ParamF4[  2 ].z = Table[ 6 ] ;
			ParamF4[  2 ].w = Table[ 7 ] ;
			ParamF4[  3 ].x = Table[ 8 ] ;
			ParamF4[  3 ].y = Table[ 9 ] ;
			ParamF4[  3 ].z = Table[ 10 ] ;
			ParamF4[  3 ].w = Table[ 11 ] ;
			ParamF4[  4 ].x = Table[ 12 ] ;
			ParamF4[  4 ].y = Table[ 13 ] ;
			ParamF4[  4 ].z = Table[ 14 ] ;
			ParamF4[  4 ].w = Table[ 15 ] ;

			// パスによって処理を分岐
			switch( Info->Pass )
			{
			case 0 :
				ParamF4[  5 ].x =  0.0f / ParamF4[  0 ].x ; ParamF4[  5 ].y =  0.0f ; ParamF4[  5 ].z =  0.0f ; ParamF4[  5 ].w =  0.0f ;
				ParamF4[  6 ].x =  1.5f / ParamF4[  0 ].x ; ParamF4[  6 ].y =  0.0f ; ParamF4[  6 ].z =  0.0f ; ParamF4[  6 ].w =  0.0f ;
				ParamF4[  7 ].x =  3.5f / ParamF4[  0 ].x ; ParamF4[  7 ].y =  0.0f ; ParamF4[  7 ].z =  0.0f ; ParamF4[  7 ].w =  0.0f ;
				ParamF4[  8 ].x =  5.5f / ParamF4[  0 ].x ; ParamF4[  8 ].y =  0.0f ; ParamF4[  8 ].z =  0.0f ; ParamF4[  8 ].w =  0.0f ;
				ParamF4[  9 ].x =  7.5f / ParamF4[  0 ].x ; ParamF4[  9 ].y =  0.0f ; ParamF4[  9 ].z =  0.0f ; ParamF4[  9 ].w =  0.0f ;
				ParamF4[ 10 ].x =  9.5f / ParamF4[  0 ].x ; ParamF4[ 10 ].y =  0.0f ; ParamF4[ 10 ].z =  0.0f ; ParamF4[ 10 ].w =  0.0f ;
				ParamF4[ 11 ].x = 11.5f / ParamF4[  0 ].x ; ParamF4[ 11 ].y =  0.0f ; ParamF4[ 11 ].z =  0.0f ; ParamF4[ 11 ].w =  0.0f ;
				ParamF4[ 12 ].x = 13.5f / ParamF4[  0 ].x ; ParamF4[ 12 ].y =  0.0f ; ParamF4[ 12 ].z =  0.0f ; ParamF4[ 12 ].w =  0.0f ;
				ParamF4[ 13 ].x = 15.5f / ParamF4[  0 ].x ; ParamF4[ 13 ].y =  0.0f ; ParamF4[ 13 ].z =  0.0f ; ParamF4[ 13 ].w =  0.0f ;
				ParamF4[ 14 ].x = 17.5f / ParamF4[  0 ].x ; ParamF4[ 14 ].y =  0.0f ; ParamF4[ 14 ].z =  0.0f ; ParamF4[ 14 ].w =  0.0f ;
				ParamF4[ 15 ].x = 19.5f / ParamF4[  0 ].x ; ParamF4[ 15 ].y =  0.0f ; ParamF4[ 15 ].z =  0.0f ; ParamF4[ 15 ].w =  0.0f ;
				ParamF4[ 16 ].x = 21.5f / ParamF4[  0 ].x ; ParamF4[ 16 ].y =  0.0f ; ParamF4[ 16 ].z =  0.0f ; ParamF4[ 16 ].w =  0.0f ;
				ParamF4[ 17 ].x = 23.5f / ParamF4[  0 ].x ; ParamF4[ 17 ].y =  0.0f ; ParamF4[ 17 ].z =  0.0f ; ParamF4[ 17 ].w =  0.0f ;
				ParamF4[ 18 ].x = 25.5f / ParamF4[  0 ].x ; ParamF4[ 18 ].y =  0.0f ; ParamF4[ 18 ].z =  0.0f ; ParamF4[ 18 ].w =  0.0f ;
				ParamF4[ 19 ].x = 27.5f / ParamF4[  0 ].x ; ParamF4[ 19 ].y =  0.0f ; ParamF4[ 19 ].z =  0.0f ; ParamF4[ 19 ].w =  0.0f ;
				ParamF4[ 20 ].x = 29.5f / ParamF4[  0 ].x ; ParamF4[ 20 ].y =  0.0f ; ParamF4[ 20 ].z =  0.0f ; ParamF4[ 20 ].w =  0.0f ;
				break ;

			case 1 :
				ParamF4[  5 ].y =  0.0f / ParamF4[  0 ].y ; ParamF4[  5 ].x =  0.0f ; ParamF4[  5 ].z =  0.0f ; ParamF4[  5 ].w =  0.0f ;
				ParamF4[  6 ].y =  1.5f / ParamF4[  0 ].y ; ParamF4[  6 ].x =  0.0f ; ParamF4[  6 ].z =  0.0f ; ParamF4[  6 ].w =  0.0f ;
				ParamF4[  7 ].y =  3.5f / ParamF4[  0 ].y ; ParamF4[  7 ].x =  0.0f ; ParamF4[  7 ].z =  0.0f ; ParamF4[  7 ].w =  0.0f ;
				ParamF4[  8 ].y =  5.5f / ParamF4[  0 ].y ; ParamF4[  8 ].x =  0.0f ; ParamF4[  8 ].z =  0.0f ; ParamF4[  8 ].w =  0.0f ;
				ParamF4[  9 ].y =  7.5f / ParamF4[  0 ].y ; ParamF4[  9 ].x =  0.0f ; ParamF4[  9 ].z =  0.0f ; ParamF4[  9 ].w =  0.0f ;
				ParamF4[ 10 ].y =  9.5f / ParamF4[  0 ].y ; ParamF4[ 10 ].x =  0.0f ; ParamF4[ 10 ].z =  0.0f ; ParamF4[ 10 ].w =  0.0f ;
				ParamF4[ 11 ].y = 11.5f / ParamF4[  0 ].y ; ParamF4[ 11 ].x =  0.0f ; ParamF4[ 11 ].z =  0.0f ; ParamF4[ 11 ].w =  0.0f ;
				ParamF4[ 12 ].y = 13.5f / ParamF4[  0 ].y ; ParamF4[ 12 ].x =  0.0f ; ParamF4[ 12 ].z =  0.0f ; ParamF4[ 12 ].w =  0.0f ;
				ParamF4[ 13 ].y = 15.5f / ParamF4[  0 ].y ; ParamF4[ 13 ].x =  0.0f ; ParamF4[ 13 ].z =  0.0f ; ParamF4[ 13 ].w =  0.0f ;
				ParamF4[ 14 ].y = 17.5f / ParamF4[  0 ].y ; ParamF4[ 14 ].x =  0.0f ; ParamF4[ 14 ].z =  0.0f ; ParamF4[ 14 ].w =  0.0f ;
				ParamF4[ 15 ].y = 19.5f / ParamF4[  0 ].y ; ParamF4[ 15 ].x =  0.0f ; ParamF4[ 15 ].z =  0.0f ; ParamF4[ 15 ].w =  0.0f ;
				ParamF4[ 16 ].y = 21.5f / ParamF4[  0 ].y ; ParamF4[ 16 ].x =  0.0f ; ParamF4[ 16 ].z =  0.0f ; ParamF4[ 16 ].w =  0.0f ;
				ParamF4[ 17 ].y = 23.5f / ParamF4[  0 ].y ; ParamF4[ 17 ].x =  0.0f ; ParamF4[ 17 ].z =  0.0f ; ParamF4[ 17 ].w =  0.0f ;
				ParamF4[ 18 ].y = 25.5f / ParamF4[  0 ].y ; ParamF4[ 18 ].x =  0.0f ; ParamF4[ 18 ].z =  0.0f ; ParamF4[ 18 ].w =  0.0f ;
				ParamF4[ 19 ].y = 27.5f / ParamF4[  0 ].y ; ParamF4[ 19 ].x =  0.0f ; ParamF4[ 19 ].z =  0.0f ; ParamF4[ 19 ].w =  0.0f ;
				ParamF4[ 20 ].y = 29.5f / ParamF4[  0 ].y ; ParamF4[ 20 ].x =  0.0f ; ParamF4[ 20 ].z =  0.0f ; ParamF4[ 20 ].w =  0.0f ;
				break ;
			}

			SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 21, FALSE ) ;

			NS_SetUsePixelShader( GRH.ShaderCode.Gauss_PS[ UseShader ] ) ;

			GraphFilter_BasePolygonDraw( Info ) ;

			LibShader_PopShaderParam( &DrawParamTemp ) ;

			ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 21 ) ;

			if( Info->Pass == 0 )
			{
				VERTEX2D Vert[ 4 ] ;
				float Width ;
				float Height ;
				int TexWidth ;
				int TexHeight ;

				GetGraphTextureSize( Info->DestGrHandle, &TexWidth, &TexHeight ) ;
				Width  = ( float )( Info->SrcX2 - Info->SrcX1 ) ;
				Height = ( float )( Info->SrcY2 - Info->SrcY1 ) ;
				Vert[ 0 ].pos.x = Info->DestX			- 0.5f ;	Vert[ 0 ].pos.y = Info->DestY + Height	- 0.5f ;	Vert[ 0 ].pos.z = 0.0f ;	Vert[ 0 ].rhw = 1.0f ;
				Vert[ 1 ].pos.x = Info->DestX + Width	- 0.5f ;	Vert[ 1 ].pos.y = Info->DestY + Height	- 0.5f ;	Vert[ 1 ].pos.z = 0.0f ;	Vert[ 1 ].rhw = 1.0f ;
				Vert[ 2 ].pos.x = Info->DestX			- 0.5f ;	Vert[ 2 ].pos.y = TexHeight				- 0.5f ;	Vert[ 2 ].pos.z = 0.0f ;	Vert[ 2 ].rhw = 1.0f ;
				Vert[ 3 ].pos.x = Info->DestX + Width	- 0.5f ;	Vert[ 3 ].pos.y = TexHeight				- 0.5f ;	Vert[ 3 ].pos.z = 0.0f ;	Vert[ 3 ].rhw = 1.0f ;
				Vert[ 0 ].u = Info->DestX             / ( float )TexWidth ;	Vert[ 0 ].v = ( float )( Info->DestY + Height - 1 ) / TexHeight ;
				Vert[ 1 ].u = ( Info->DestX + Width ) / ( float )TexWidth ;	Vert[ 1 ].v = Vert[ 0 ].v ;
				Vert[ 2 ].u = Vert[ 0 ].u ;									Vert[ 2 ].v = Vert[ 0 ].v ;
				Vert[ 3 ].u = Vert[ 1 ].u ;									Vert[ 3 ].v = Vert[ 0 ].v ;
				Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
				Vert[ 1 ].dif = Vert[ 0 ].dif ;
				Vert[ 2 ].dif = Vert[ 0 ].dif ;
				Vert[ 3 ].dif = Vert[ 0 ].dif ;
				NS_DrawPrimitive2D( Vert, 4, DX_PRIMTYPE_TRIANGLESTRIP, Info->DestGrHandle, FALSE ) ;
			}
		}
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		BYTE *MinSrc ;
		BYTE *MaxSrc ;
		BYTE *MinSrcStart ;
		BYTE *MaxSrcStart ;
		DWORD i, j ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcPitch ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;
		int iTable[ 16 ] ;
		BYTE RGBA[ 64 ][ 4 ] ;
		BASEIMAGE WorkImage ;

		for( i = 0 ; i < ( DWORD )WeightNum ; i ++ )
		{
			iTable[ i ] = _FTOL( Table[ i ] * 65536.0f ) ;
		}

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
		{
			return -1 ;
		}

		if( Param < 0.0000001f )
		{
			Src = ( BYTE * )Info->SrcImage.GraphData ;
			Dest = ( BYTE * )Info->DestImage.GraphData ;

			SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
			DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

			do
			{
				i = Width ;
				do
				{
					*( ( DWORD * )Dest ) = *( ( DWORD * )Src ) ;

					Src  += 4 ;
					Dest += 4 ;
				}while( -- i ) ;

				Src  += SrcAddPitch ;
				Dest += DestAddPitch ;
			}while( -- Height ) ;
		}
		else
		{
			if( NS_CreateARGB8ColorBaseImage( Width, Height, &WorkImage ) >= 0 )
			{
				Src = ( BYTE * )Info->SrcImage.GraphData ;
				Dest = ( BYTE * )WorkImage.GraphData ;

				SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
				DestAddPitch = WorkImage.Pitch       - Width * 4 ;

				switch( PixelWidth )
				{
				case 8 :
					for( j = 0 ; j < Height ; j ++ )
					{
						MinSrc = Src ;
						MaxSrc = Src + 4 * ( Width - 1 ) ;
						for( i = 0 ; i < Width ; i ++ )
						{
							*( ( DWORD * )RGBA[  0 ] ) = *( ( DWORD * )Src ) ;
							*( ( DWORD * )RGBA[  1 ] ) = i < 1          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 1 ) ;
							*( ( DWORD * )RGBA[  2 ] ) = i < 2          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 2 ) ;
							*( ( DWORD * )RGBA[  3 ] ) = i + 1 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 1 ) ;
							*( ( DWORD * )RGBA[  4 ] ) = i + 2 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 2 ) ;
							*( ( DWORD * )RGBA[  5 ] ) = i < 3          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 3 ) ;
							*( ( DWORD * )RGBA[  6 ] ) = i < 4          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 4 ) ;
							*( ( DWORD * )RGBA[  7 ] ) = i + 3 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 3 ) ;
							*( ( DWORD * )RGBA[  8 ] ) = i + 4 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 4 ) ;
							*( ( DWORD * )RGBA[  9 ] ) = i < 5          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 5 ) ;
							*( ( DWORD * )RGBA[ 10 ] ) = i < 6          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 6 ) ;
							*( ( DWORD * )RGBA[ 11 ] ) = i + 5 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 5 ) ;
							*( ( DWORD * )RGBA[ 12 ] ) = i + 6 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 6 ) ;

							Dest[ 0 ] = ( BYTE )(
								( RGBA[ 0 ][ 0 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 0 ] + RGBA[  2 ][ 0 ] + RGBA[  3 ][ 0 ] + RGBA[  4 ][ 0 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 0 ] + RGBA[  6 ][ 0 ] + RGBA[  7 ][ 0 ] + RGBA[  8 ][ 0 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 0 ] + RGBA[ 10 ][ 0 ] + RGBA[ 11 ][ 0 ] + RGBA[ 12 ][ 0 ] ) * iTable[ 3 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 1 ] = ( BYTE )(
								( RGBA[ 0 ][ 1 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 1 ] + RGBA[  2 ][ 1 ] + RGBA[  3 ][ 1 ] + RGBA[  4 ][ 1 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 1 ] + RGBA[  6 ][ 1 ] + RGBA[  7 ][ 1 ] + RGBA[  8 ][ 1 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 1 ] + RGBA[ 10 ][ 1 ] + RGBA[ 11 ][ 1 ] + RGBA[ 12 ][ 1 ] ) * iTable[ 3 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 2 ] = ( BYTE )(
								( RGBA[ 0 ][ 2 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 2 ] + RGBA[  2 ][ 2 ] + RGBA[  3 ][ 2 ] + RGBA[  4 ][ 2 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 2 ] + RGBA[  6 ][ 2 ] + RGBA[  7 ][ 2 ] + RGBA[  8 ][ 2 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 2 ] + RGBA[ 10 ][ 2 ] + RGBA[ 11 ][ 2 ] + RGBA[ 12 ][ 2 ] ) * iTable[ 3 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 3 ] = ( BYTE )(
								( RGBA[ 0 ][ 3 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 3 ] + RGBA[  2 ][ 3 ] + RGBA[  3 ][ 3 ] + RGBA[  4 ][ 3 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 3 ] + RGBA[  6 ][ 3 ] + RGBA[  7 ][ 3 ] + RGBA[  8 ][ 3 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 3 ] + RGBA[ 10 ][ 3 ] + RGBA[ 11 ][ 3 ] + RGBA[ 12 ][ 3 ] ) * iTable[ 3 ] ) >> 1 ) ) >> 16 ) ;

							Src  += 4 ;
							Dest += 4 ;
						}

						Src  += SrcAddPitch ;
						Dest += DestAddPitch ;
					}
					break ;

				case 16 :
					for( j = 0 ; j < Height ; j ++ )
					{
						MinSrc = Src ;
						MaxSrc = Src + 4 * ( Width - 1 ) ;
						for( i = 0 ; i < Width ; i ++ )
						{
							*( ( DWORD * )RGBA[  0 ] ) = *( ( DWORD * )Src ) ;
							*( ( DWORD * )RGBA[  1 ] ) = i <  1          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  1 ) ;
							*( ( DWORD * )RGBA[  2 ] ) = i <  2          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  2 ) ;
							*( ( DWORD * )RGBA[  3 ] ) = i +  1 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  1 ) ;
							*( ( DWORD * )RGBA[  4 ] ) = i +  2 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  2 ) ;
							*( ( DWORD * )RGBA[  5 ] ) = i <  3          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  3 ) ;
							*( ( DWORD * )RGBA[  6 ] ) = i <  4          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  4 ) ;
							*( ( DWORD * )RGBA[  7 ] ) = i +  3 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  3 ) ;
							*( ( DWORD * )RGBA[  8 ] ) = i +  4 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  4 ) ;
							*( ( DWORD * )RGBA[  9 ] ) = i <  5          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  5 ) ;
							*( ( DWORD * )RGBA[ 10 ] ) = i <  6          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  6 ) ;
							*( ( DWORD * )RGBA[ 11 ] ) = i +  5 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  5 ) ;
							*( ( DWORD * )RGBA[ 12 ] ) = i +  6 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  6 ) ;
							*( ( DWORD * )RGBA[ 13 ] ) = i <  7          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  7 ) ;
							*( ( DWORD * )RGBA[ 14 ] ) = i <  8          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  8 ) ;
							*( ( DWORD * )RGBA[ 15 ] ) = i +  7 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  7 ) ;
							*( ( DWORD * )RGBA[ 16 ] ) = i +  8 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  8 ) ;
							*( ( DWORD * )RGBA[ 17 ] ) = i <  9          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  9 ) ;
							*( ( DWORD * )RGBA[ 18 ] ) = i < 10          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 10 ) ;
							*( ( DWORD * )RGBA[ 19 ] ) = i +  9 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  9 ) ;
							*( ( DWORD * )RGBA[ 20 ] ) = i + 10 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 10 ) ;
							*( ( DWORD * )RGBA[ 21 ] ) = i < 11          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 11 ) ;
							*( ( DWORD * )RGBA[ 22 ] ) = i < 12          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 12 ) ;
							*( ( DWORD * )RGBA[ 23 ] ) = i + 11 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 11 ) ;
							*( ( DWORD * )RGBA[ 24 ] ) = i + 12 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 12 ) ;
							*( ( DWORD * )RGBA[ 25 ] ) = i < 13          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 13 ) ;
							*( ( DWORD * )RGBA[ 26 ] ) = i < 14          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 14 ) ;
							*( ( DWORD * )RGBA[ 27 ] ) = i + 13 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 13 ) ;
							*( ( DWORD * )RGBA[ 28 ] ) = i + 14 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 14 ) ;

							Dest[ 0 ] = ( BYTE )(
								( RGBA[ 0 ][ 0 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 0 ] + RGBA[  2 ][ 0 ] + RGBA[  3 ][ 0 ] + RGBA[  4 ][ 0 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 0 ] + RGBA[  6 ][ 0 ] + RGBA[  7 ][ 0 ] + RGBA[  8 ][ 0 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 0 ] + RGBA[ 10 ][ 0 ] + RGBA[ 11 ][ 0 ] + RGBA[ 12 ][ 0 ] ) * iTable[ 3 ] +
									  ( RGBA[ 13 ][ 0 ] + RGBA[ 14 ][ 0 ] + RGBA[ 15 ][ 0 ] + RGBA[ 16 ][ 0 ] ) * iTable[ 4 ] +
									  ( RGBA[ 17 ][ 0 ] + RGBA[ 18 ][ 0 ] + RGBA[ 19 ][ 0 ] + RGBA[ 20 ][ 0 ] ) * iTable[ 5 ] +
									  ( RGBA[ 21 ][ 0 ] + RGBA[ 22 ][ 0 ] + RGBA[ 23 ][ 0 ] + RGBA[ 24 ][ 0 ] ) * iTable[ 6 ] +
									  ( RGBA[ 25 ][ 0 ] + RGBA[ 26 ][ 0 ] + RGBA[ 27 ][ 0 ] + RGBA[ 28 ][ 0 ] ) * iTable[ 7 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 1 ] = ( BYTE )(
								( RGBA[ 0 ][ 1 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 1 ] + RGBA[  2 ][ 1 ] + RGBA[  3 ][ 1 ] + RGBA[  4 ][ 1 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 1 ] + RGBA[  6 ][ 1 ] + RGBA[  7 ][ 1 ] + RGBA[  8 ][ 1 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 1 ] + RGBA[ 10 ][ 1 ] + RGBA[ 11 ][ 1 ] + RGBA[ 12 ][ 1 ] ) * iTable[ 3 ] +
									  ( RGBA[ 13 ][ 1 ] + RGBA[ 14 ][ 1 ] + RGBA[ 15 ][ 1 ] + RGBA[ 16 ][ 1 ] ) * iTable[ 4 ] +
									  ( RGBA[ 17 ][ 1 ] + RGBA[ 18 ][ 1 ] + RGBA[ 19 ][ 1 ] + RGBA[ 20 ][ 1 ] ) * iTable[ 5 ] +
									  ( RGBA[ 21 ][ 1 ] + RGBA[ 22 ][ 1 ] + RGBA[ 23 ][ 1 ] + RGBA[ 24 ][ 1 ] ) * iTable[ 6 ] +
									  ( RGBA[ 25 ][ 1 ] + RGBA[ 26 ][ 1 ] + RGBA[ 27 ][ 1 ] + RGBA[ 28 ][ 1 ] ) * iTable[ 7 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 2 ] = ( BYTE )(
								( RGBA[ 0 ][ 2 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 2 ] + RGBA[  2 ][ 2 ] + RGBA[  3 ][ 2 ] + RGBA[  4 ][ 2 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 2 ] + RGBA[  6 ][ 2 ] + RGBA[  7 ][ 2 ] + RGBA[  8 ][ 2 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 2 ] + RGBA[ 10 ][ 2 ] + RGBA[ 11 ][ 2 ] + RGBA[ 12 ][ 2 ] ) * iTable[ 3 ] +
									  ( RGBA[ 13 ][ 2 ] + RGBA[ 14 ][ 2 ] + RGBA[ 15 ][ 2 ] + RGBA[ 16 ][ 2 ] ) * iTable[ 4 ] +
									  ( RGBA[ 17 ][ 2 ] + RGBA[ 18 ][ 2 ] + RGBA[ 19 ][ 2 ] + RGBA[ 20 ][ 2 ] ) * iTable[ 5 ] +
									  ( RGBA[ 21 ][ 2 ] + RGBA[ 22 ][ 2 ] + RGBA[ 23 ][ 2 ] + RGBA[ 24 ][ 2 ] ) * iTable[ 6 ] +
									  ( RGBA[ 25 ][ 2 ] + RGBA[ 26 ][ 2 ] + RGBA[ 27 ][ 2 ] + RGBA[ 28 ][ 2 ] ) * iTable[ 7 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 3 ] = ( BYTE )(
								( RGBA[ 0 ][ 3 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 3 ] + RGBA[  2 ][ 3 ] + RGBA[  3 ][ 3 ] + RGBA[  4 ][ 3 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 3 ] + RGBA[  6 ][ 3 ] + RGBA[  7 ][ 3 ] + RGBA[  8 ][ 3 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 3 ] + RGBA[ 10 ][ 3 ] + RGBA[ 11 ][ 3 ] + RGBA[ 12 ][ 3 ] ) * iTable[ 3 ] +
									  ( RGBA[ 13 ][ 3 ] + RGBA[ 14 ][ 3 ] + RGBA[ 15 ][ 3 ] + RGBA[ 16 ][ 3 ] ) * iTable[ 4 ] +
									  ( RGBA[ 17 ][ 3 ] + RGBA[ 18 ][ 3 ] + RGBA[ 19 ][ 3 ] + RGBA[ 20 ][ 3 ] ) * iTable[ 5 ] +
									  ( RGBA[ 21 ][ 3 ] + RGBA[ 22 ][ 3 ] + RGBA[ 23 ][ 3 ] + RGBA[ 24 ][ 3 ] ) * iTable[ 6 ] +
									  ( RGBA[ 25 ][ 3 ] + RGBA[ 26 ][ 3 ] + RGBA[ 27 ][ 3 ] + RGBA[ 28 ][ 3 ] ) * iTable[ 7 ] ) >> 1 ) ) >> 16 ) ;

							Src  += 4 ;
							Dest += 4 ;
						}

						Src  += SrcAddPitch ;
						Dest += DestAddPitch ;
					}
					break ;

				case 32 :
					for( j = 0 ; j < Height ; j ++ )
					{
						MinSrc = Src ;
						MaxSrc = Src + 4 * ( Width - 1 ) ;
						for( i = 0 ; i < Width ; i ++ )
						{
							*( ( DWORD * )RGBA[  0 ] ) = *( ( DWORD * )Src ) ;
							*( ( DWORD * )RGBA[  1 ] ) = i <  1          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  1 ) ;
							*( ( DWORD * )RGBA[  2 ] ) = i <  2          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  2 ) ;
							*( ( DWORD * )RGBA[  3 ] ) = i +  1 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  1 ) ;
							*( ( DWORD * )RGBA[  4 ] ) = i +  2 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  2 ) ;
							*( ( DWORD * )RGBA[  5 ] ) = i <  3          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  3 ) ;
							*( ( DWORD * )RGBA[  6 ] ) = i <  4          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  4 ) ;
							*( ( DWORD * )RGBA[  7 ] ) = i +  3 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  3 ) ;
							*( ( DWORD * )RGBA[  8 ] ) = i +  4 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  4 ) ;
							*( ( DWORD * )RGBA[  9 ] ) = i <  5          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  5 ) ;
							*( ( DWORD * )RGBA[ 10 ] ) = i <  6          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  6 ) ;
							*( ( DWORD * )RGBA[ 11 ] ) = i +  5 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  5 ) ;
							*( ( DWORD * )RGBA[ 12 ] ) = i +  6 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  6 ) ;
							*( ( DWORD * )RGBA[ 13 ] ) = i <  7          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  7 ) ;
							*( ( DWORD * )RGBA[ 14 ] ) = i <  8          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  8 ) ;
							*( ( DWORD * )RGBA[ 15 ] ) = i +  7 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  7 ) ;
							*( ( DWORD * )RGBA[ 16 ] ) = i +  8 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  8 ) ;
							*( ( DWORD * )RGBA[ 17 ] ) = i <  9          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src -  9 ) ;
							*( ( DWORD * )RGBA[ 18 ] ) = i < 10          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 10 ) ;
							*( ( DWORD * )RGBA[ 19 ] ) = i +  9 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src +  9 ) ;
							*( ( DWORD * )RGBA[ 20 ] ) = i + 10 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 10 ) ;
							*( ( DWORD * )RGBA[ 21 ] ) = i < 11          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 11 ) ;
							*( ( DWORD * )RGBA[ 22 ] ) = i < 12          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 12 ) ;
							*( ( DWORD * )RGBA[ 23 ] ) = i + 11 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 11 ) ;
							*( ( DWORD * )RGBA[ 24 ] ) = i + 12 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 12 ) ;
							*( ( DWORD * )RGBA[ 25 ] ) = i < 13          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 13 ) ;
							*( ( DWORD * )RGBA[ 26 ] ) = i < 14          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 14 ) ;
							*( ( DWORD * )RGBA[ 27 ] ) = i + 13 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 13 ) ;
							*( ( DWORD * )RGBA[ 28 ] ) = i + 14 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 14 ) ;
							*( ( DWORD * )RGBA[ 29 ] ) = i < 15          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 15 ) ;
							*( ( DWORD * )RGBA[ 30 ] ) = i < 16          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 16 ) ;
							*( ( DWORD * )RGBA[ 31 ] ) = i + 15 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 15 ) ;
							*( ( DWORD * )RGBA[ 32 ] ) = i + 16 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 16 ) ;
							*( ( DWORD * )RGBA[ 33 ] ) = i < 17          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 17 ) ;
							*( ( DWORD * )RGBA[ 34 ] ) = i < 18          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 18 ) ;
							*( ( DWORD * )RGBA[ 35 ] ) = i + 17 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 17 ) ;
							*( ( DWORD * )RGBA[ 36 ] ) = i + 18 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 18 ) ;
							*( ( DWORD * )RGBA[ 37 ] ) = i < 19          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 19 ) ;
							*( ( DWORD * )RGBA[ 38 ] ) = i < 20          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 20 ) ;
							*( ( DWORD * )RGBA[ 39 ] ) = i + 19 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 19 ) ;
							*( ( DWORD * )RGBA[ 40 ] ) = i + 20 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 20 ) ;
							*( ( DWORD * )RGBA[ 41 ] ) = i < 21          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 21 ) ;
							*( ( DWORD * )RGBA[ 42 ] ) = i < 22          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 22 ) ;
							*( ( DWORD * )RGBA[ 43 ] ) = i + 21 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 21 ) ;
							*( ( DWORD * )RGBA[ 44 ] ) = i + 22 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 22 ) ;
							*( ( DWORD * )RGBA[ 45 ] ) = i < 23          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 23 ) ;
							*( ( DWORD * )RGBA[ 46 ] ) = i < 24          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 24 ) ;
							*( ( DWORD * )RGBA[ 47 ] ) = i + 23 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 23 ) ;
							*( ( DWORD * )RGBA[ 48 ] ) = i + 24 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 24 ) ;
							*( ( DWORD * )RGBA[ 49 ] ) = i < 25          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 25 ) ;
							*( ( DWORD * )RGBA[ 50 ] ) = i < 26          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 26 ) ;
							*( ( DWORD * )RGBA[ 51 ] ) = i + 25 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 25 ) ;
							*( ( DWORD * )RGBA[ 52 ] ) = i + 26 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 26 ) ;
							*( ( DWORD * )RGBA[ 53 ] ) = i < 27          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 27 ) ;
							*( ( DWORD * )RGBA[ 54 ] ) = i < 28          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 28 ) ;
							*( ( DWORD * )RGBA[ 55 ] ) = i + 27 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 27 ) ;
							*( ( DWORD * )RGBA[ 56 ] ) = i + 28 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 28 ) ;
							*( ( DWORD * )RGBA[ 57 ] ) = i < 29          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 29 ) ;
							*( ( DWORD * )RGBA[ 58 ] ) = i < 30          ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )Src - 30 ) ;
							*( ( DWORD * )RGBA[ 59 ] ) = i + 29 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 29 ) ;
							*( ( DWORD * )RGBA[ 60 ] ) = i + 30 >= Width ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )Src + 30 ) ;

							Dest[ 0 ] = ( BYTE )(
								( RGBA[ 0 ][ 0 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 0 ] + RGBA[  2 ][ 0 ] + RGBA[  3 ][ 0 ] + RGBA[  4 ][ 0 ] ) * iTable[  1 ] +
									  ( RGBA[  5 ][ 0 ] + RGBA[  6 ][ 0 ] + RGBA[  7 ][ 0 ] + RGBA[  8 ][ 0 ] ) * iTable[  2 ] +
									  ( RGBA[  9 ][ 0 ] + RGBA[ 10 ][ 0 ] + RGBA[ 11 ][ 0 ] + RGBA[ 12 ][ 0 ] ) * iTable[  3 ] +
									  ( RGBA[ 13 ][ 0 ] + RGBA[ 14 ][ 0 ] + RGBA[ 15 ][ 0 ] + RGBA[ 16 ][ 0 ] ) * iTable[  4 ] +
									  ( RGBA[ 17 ][ 0 ] + RGBA[ 18 ][ 0 ] + RGBA[ 19 ][ 0 ] + RGBA[ 20 ][ 0 ] ) * iTable[  5 ] +
									  ( RGBA[ 21 ][ 0 ] + RGBA[ 22 ][ 0 ] + RGBA[ 23 ][ 0 ] + RGBA[ 24 ][ 0 ] ) * iTable[  6 ] +
									  ( RGBA[ 25 ][ 0 ] + RGBA[ 26 ][ 0 ] + RGBA[ 27 ][ 0 ] + RGBA[ 28 ][ 0 ] ) * iTable[  7 ] +
									  ( RGBA[ 29 ][ 0 ] + RGBA[ 30 ][ 0 ] + RGBA[ 31 ][ 0 ] + RGBA[ 32 ][ 0 ] ) * iTable[  8 ] +
									  ( RGBA[ 33 ][ 0 ] + RGBA[ 34 ][ 0 ] + RGBA[ 35 ][ 0 ] + RGBA[ 36 ][ 0 ] ) * iTable[  9 ] +
									  ( RGBA[ 37 ][ 0 ] + RGBA[ 38 ][ 0 ] + RGBA[ 39 ][ 0 ] + RGBA[ 40 ][ 0 ] ) * iTable[ 10 ] +
									  ( RGBA[ 41 ][ 0 ] + RGBA[ 42 ][ 0 ] + RGBA[ 43 ][ 0 ] + RGBA[ 44 ][ 0 ] ) * iTable[ 11 ] +
									  ( RGBA[ 45 ][ 0 ] + RGBA[ 46 ][ 0 ] + RGBA[ 47 ][ 0 ] + RGBA[ 48 ][ 0 ] ) * iTable[ 12 ] +
									  ( RGBA[ 49 ][ 0 ] + RGBA[ 50 ][ 0 ] + RGBA[ 51 ][ 0 ] + RGBA[ 52 ][ 0 ] ) * iTable[ 13 ] +
									  ( RGBA[ 53 ][ 0 ] + RGBA[ 54 ][ 0 ] + RGBA[ 55 ][ 0 ] + RGBA[ 56 ][ 0 ] ) * iTable[ 14 ] +
									  ( RGBA[ 57 ][ 0 ] + RGBA[ 58 ][ 0 ] + RGBA[ 59 ][ 0 ] + RGBA[ 60 ][ 0 ] ) * iTable[ 15 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 1 ] = ( BYTE )(
								( RGBA[ 0 ][ 1 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 1 ] + RGBA[  2 ][ 1 ] + RGBA[  3 ][ 1 ] + RGBA[  4 ][ 1 ] ) * iTable[  1 ] +
									  ( RGBA[  5 ][ 1 ] + RGBA[  6 ][ 1 ] + RGBA[  7 ][ 1 ] + RGBA[  8 ][ 1 ] ) * iTable[  2 ] +
									  ( RGBA[  9 ][ 1 ] + RGBA[ 10 ][ 1 ] + RGBA[ 11 ][ 1 ] + RGBA[ 12 ][ 1 ] ) * iTable[  3 ] +
									  ( RGBA[ 13 ][ 1 ] + RGBA[ 14 ][ 1 ] + RGBA[ 15 ][ 1 ] + RGBA[ 16 ][ 1 ] ) * iTable[  4 ] +
									  ( RGBA[ 17 ][ 1 ] + RGBA[ 18 ][ 1 ] + RGBA[ 19 ][ 1 ] + RGBA[ 20 ][ 1 ] ) * iTable[  5 ] +
									  ( RGBA[ 21 ][ 1 ] + RGBA[ 22 ][ 1 ] + RGBA[ 23 ][ 1 ] + RGBA[ 24 ][ 1 ] ) * iTable[  6 ] +
									  ( RGBA[ 25 ][ 1 ] + RGBA[ 26 ][ 1 ] + RGBA[ 27 ][ 1 ] + RGBA[ 28 ][ 1 ] ) * iTable[  7 ] +
									  ( RGBA[ 29 ][ 1 ] + RGBA[ 30 ][ 1 ] + RGBA[ 31 ][ 1 ] + RGBA[ 32 ][ 1 ] ) * iTable[  8 ] +
									  ( RGBA[ 33 ][ 1 ] + RGBA[ 34 ][ 1 ] + RGBA[ 35 ][ 1 ] + RGBA[ 36 ][ 1 ] ) * iTable[  9 ] +
									  ( RGBA[ 37 ][ 1 ] + RGBA[ 38 ][ 1 ] + RGBA[ 39 ][ 1 ] + RGBA[ 40 ][ 1 ] ) * iTable[ 10 ] +
									  ( RGBA[ 41 ][ 1 ] + RGBA[ 42 ][ 1 ] + RGBA[ 43 ][ 1 ] + RGBA[ 44 ][ 1 ] ) * iTable[ 11 ] +
									  ( RGBA[ 45 ][ 1 ] + RGBA[ 46 ][ 1 ] + RGBA[ 47 ][ 1 ] + RGBA[ 48 ][ 1 ] ) * iTable[ 12 ] +
									  ( RGBA[ 49 ][ 1 ] + RGBA[ 50 ][ 1 ] + RGBA[ 51 ][ 1 ] + RGBA[ 52 ][ 1 ] ) * iTable[ 13 ] +
									  ( RGBA[ 53 ][ 1 ] + RGBA[ 54 ][ 1 ] + RGBA[ 55 ][ 1 ] + RGBA[ 56 ][ 1 ] ) * iTable[ 14 ] +
									  ( RGBA[ 57 ][ 1 ] + RGBA[ 58 ][ 1 ] + RGBA[ 59 ][ 1 ] + RGBA[ 60 ][ 1 ] ) * iTable[ 15 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 2 ] = ( BYTE )(
								( RGBA[ 0 ][ 2 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 2 ] + RGBA[  2 ][ 2 ] + RGBA[  3 ][ 2 ] + RGBA[  4 ][ 2 ] ) * iTable[  1 ] +
									  ( RGBA[  5 ][ 2 ] + RGBA[  6 ][ 2 ] + RGBA[  7 ][ 2 ] + RGBA[  8 ][ 2 ] ) * iTable[  2 ] +
									  ( RGBA[  9 ][ 2 ] + RGBA[ 10 ][ 2 ] + RGBA[ 11 ][ 2 ] + RGBA[ 12 ][ 2 ] ) * iTable[  3 ] +
									  ( RGBA[ 13 ][ 2 ] + RGBA[ 14 ][ 2 ] + RGBA[ 15 ][ 2 ] + RGBA[ 16 ][ 2 ] ) * iTable[  4 ] +
									  ( RGBA[ 17 ][ 2 ] + RGBA[ 18 ][ 2 ] + RGBA[ 19 ][ 2 ] + RGBA[ 20 ][ 2 ] ) * iTable[  5 ] +
									  ( RGBA[ 21 ][ 2 ] + RGBA[ 22 ][ 2 ] + RGBA[ 23 ][ 2 ] + RGBA[ 24 ][ 2 ] ) * iTable[  6 ] +
									  ( RGBA[ 25 ][ 2 ] + RGBA[ 26 ][ 2 ] + RGBA[ 27 ][ 2 ] + RGBA[ 28 ][ 2 ] ) * iTable[  7 ] +
									  ( RGBA[ 29 ][ 2 ] + RGBA[ 30 ][ 2 ] + RGBA[ 31 ][ 2 ] + RGBA[ 32 ][ 2 ] ) * iTable[  8 ] +
									  ( RGBA[ 33 ][ 2 ] + RGBA[ 34 ][ 2 ] + RGBA[ 35 ][ 2 ] + RGBA[ 36 ][ 2 ] ) * iTable[  9 ] +
									  ( RGBA[ 37 ][ 2 ] + RGBA[ 38 ][ 2 ] + RGBA[ 39 ][ 2 ] + RGBA[ 40 ][ 2 ] ) * iTable[ 10 ] +
									  ( RGBA[ 41 ][ 2 ] + RGBA[ 42 ][ 2 ] + RGBA[ 43 ][ 2 ] + RGBA[ 44 ][ 2 ] ) * iTable[ 11 ] +
									  ( RGBA[ 45 ][ 2 ] + RGBA[ 46 ][ 2 ] + RGBA[ 47 ][ 2 ] + RGBA[ 48 ][ 2 ] ) * iTable[ 12 ] +
									  ( RGBA[ 49 ][ 2 ] + RGBA[ 50 ][ 2 ] + RGBA[ 51 ][ 2 ] + RGBA[ 52 ][ 2 ] ) * iTable[ 13 ] +
									  ( RGBA[ 53 ][ 2 ] + RGBA[ 54 ][ 2 ] + RGBA[ 55 ][ 2 ] + RGBA[ 56 ][ 2 ] ) * iTable[ 14 ] +
									  ( RGBA[ 57 ][ 2 ] + RGBA[ 58 ][ 2 ] + RGBA[ 59 ][ 2 ] + RGBA[ 60 ][ 2 ] ) * iTable[ 15 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 3 ] = ( BYTE )(
								( RGBA[ 0 ][ 3 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 3 ] + RGBA[  2 ][ 3 ] + RGBA[  3 ][ 3 ] + RGBA[  4 ][ 3 ] ) * iTable[  1 ] +
									  ( RGBA[  5 ][ 3 ] + RGBA[  6 ][ 3 ] + RGBA[  7 ][ 3 ] + RGBA[  8 ][ 3 ] ) * iTable[  2 ] +
									  ( RGBA[  9 ][ 3 ] + RGBA[ 10 ][ 3 ] + RGBA[ 11 ][ 3 ] + RGBA[ 12 ][ 3 ] ) * iTable[  3 ] +
									  ( RGBA[ 13 ][ 3 ] + RGBA[ 14 ][ 3 ] + RGBA[ 15 ][ 3 ] + RGBA[ 16 ][ 3 ] ) * iTable[  4 ] +
									  ( RGBA[ 17 ][ 3 ] + RGBA[ 18 ][ 3 ] + RGBA[ 19 ][ 3 ] + RGBA[ 20 ][ 3 ] ) * iTable[  5 ] +
									  ( RGBA[ 21 ][ 3 ] + RGBA[ 22 ][ 3 ] + RGBA[ 23 ][ 3 ] + RGBA[ 24 ][ 3 ] ) * iTable[  6 ] +
									  ( RGBA[ 25 ][ 3 ] + RGBA[ 26 ][ 3 ] + RGBA[ 27 ][ 3 ] + RGBA[ 28 ][ 3 ] ) * iTable[  7 ] +
									  ( RGBA[ 29 ][ 3 ] + RGBA[ 30 ][ 3 ] + RGBA[ 31 ][ 3 ] + RGBA[ 32 ][ 3 ] ) * iTable[  8 ] +
									  ( RGBA[ 33 ][ 3 ] + RGBA[ 34 ][ 3 ] + RGBA[ 35 ][ 3 ] + RGBA[ 36 ][ 3 ] ) * iTable[  9 ] +
									  ( RGBA[ 37 ][ 3 ] + RGBA[ 38 ][ 3 ] + RGBA[ 39 ][ 3 ] + RGBA[ 40 ][ 3 ] ) * iTable[ 10 ] +
									  ( RGBA[ 41 ][ 3 ] + RGBA[ 42 ][ 3 ] + RGBA[ 43 ][ 3 ] + RGBA[ 44 ][ 3 ] ) * iTable[ 11 ] +
									  ( RGBA[ 45 ][ 3 ] + RGBA[ 46 ][ 3 ] + RGBA[ 47 ][ 3 ] + RGBA[ 48 ][ 3 ] ) * iTable[ 12 ] +
									  ( RGBA[ 49 ][ 3 ] + RGBA[ 50 ][ 3 ] + RGBA[ 51 ][ 3 ] + RGBA[ 52 ][ 3 ] ) * iTable[ 13 ] +
									  ( RGBA[ 53 ][ 3 ] + RGBA[ 54 ][ 3 ] + RGBA[ 55 ][ 3 ] + RGBA[ 56 ][ 3 ] ) * iTable[ 14 ] +
									  ( RGBA[ 57 ][ 3 ] + RGBA[ 58 ][ 3 ] + RGBA[ 59 ][ 3 ] + RGBA[ 60 ][ 3 ] ) * iTable[ 15 ] ) >> 1 ) ) >> 16 ) ;

							Src  += 4 ;
							Dest += 4 ;
						}

						Src  += SrcAddPitch ;
						Dest += DestAddPitch ;
					}
					break ;
				}

				Src = ( BYTE * )WorkImage.GraphData ;
				Dest = ( BYTE * )Info->DestImage.GraphData ;
				MinSrcStart = Src ;
				MaxSrcStart = Src + WorkImage.Pitch * ( Height - 1 ) ;

				SrcPitch     = WorkImage.Pitch ;
				SrcAddPitch  = WorkImage.Pitch       - Width * 4 ;
				DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

				switch( PixelWidth )
				{
				case 8 :
					for( j = 0 ; j < Height ; j ++ )
					{
						MinSrc = MinSrcStart ;
						MaxSrc = MaxSrcStart ;

						for( i = 0 ; i < Width ; i ++ )
						{
							*( ( DWORD * )RGBA[  0 ] ) = *( ( DWORD * )Src ) ;
							*( ( DWORD * )RGBA[  1 ] ) = j < 1           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 1 ) ) ;
							*( ( DWORD * )RGBA[  2 ] ) = j < 2           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 2 ) ) ;
							*( ( DWORD * )RGBA[  3 ] ) = j + 1 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 1 ) ) ;
							*( ( DWORD * )RGBA[  4 ] ) = j + 2 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 2 ) ) ;
							*( ( DWORD * )RGBA[  5 ] ) = j < 3           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 3 ) ) ;
							*( ( DWORD * )RGBA[  6 ] ) = j < 4           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 4 ) ) ;
							*( ( DWORD * )RGBA[  7 ] ) = j + 3 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 3 ) ) ;
							*( ( DWORD * )RGBA[  8 ] ) = j + 4 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 4 ) ) ;
							*( ( DWORD * )RGBA[  9 ] ) = j < 5           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 5 ) ) ;
							*( ( DWORD * )RGBA[ 10 ] ) = j < 6           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 6 ) ) ;
							*( ( DWORD * )RGBA[ 11 ] ) = j + 5 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 5 ) ) ;
							*( ( DWORD * )RGBA[ 12 ] ) = j + 6 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 6 ) ) ;

							Dest[ 0 ] = ( BYTE )(
								( RGBA[ 0 ][ 0 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 0 ] + RGBA[  2 ][ 0 ] + RGBA[  3 ][ 0 ] + RGBA[  4 ][ 0 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 0 ] + RGBA[  6 ][ 0 ] + RGBA[  7 ][ 0 ] + RGBA[  8 ][ 0 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 0 ] + RGBA[ 10 ][ 0 ] + RGBA[ 11 ][ 0 ] + RGBA[ 12 ][ 0 ] ) * iTable[ 3 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 1 ] = ( BYTE )(
								( RGBA[ 0 ][ 1 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 1 ] + RGBA[  2 ][ 1 ] + RGBA[  3 ][ 1 ] + RGBA[  4 ][ 1 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 1 ] + RGBA[  6 ][ 1 ] + RGBA[  7 ][ 1 ] + RGBA[  8 ][ 1 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 1 ] + RGBA[ 10 ][ 1 ] + RGBA[ 11 ][ 1 ] + RGBA[ 12 ][ 1 ] ) * iTable[ 3 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 2 ] = ( BYTE )(
								( RGBA[ 0 ][ 2 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 2 ] + RGBA[  2 ][ 2 ] + RGBA[  3 ][ 2 ] + RGBA[  4 ][ 2 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 2 ] + RGBA[  6 ][ 2 ] + RGBA[  7 ][ 2 ] + RGBA[  8 ][ 2 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 2 ] + RGBA[ 10 ][ 2 ] + RGBA[ 11 ][ 2 ] + RGBA[ 12 ][ 2 ] ) * iTable[ 3 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 3 ] = ( BYTE )(
								( RGBA[ 0 ][ 3 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 3 ] + RGBA[  2 ][ 3 ] + RGBA[  3 ][ 3 ] + RGBA[  4 ][ 3 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 3 ] + RGBA[  6 ][ 3 ] + RGBA[  7 ][ 3 ] + RGBA[  8 ][ 3 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 3 ] + RGBA[ 10 ][ 3 ] + RGBA[ 11 ][ 3 ] + RGBA[ 12 ][ 3 ] ) * iTable[ 3 ] ) >> 1 ) ) >> 16 ) ;

							MinSrc += 4 ;
							MaxSrc += 4 ;
							Src  += 4 ;
							Dest += 4 ;
						}

						Src  += SrcAddPitch ;
						Dest += DestAddPitch ;
					}
					break ;

				case 16 :
					for( j = 0 ; j < Height ; j ++ )
					{
						MinSrc = MinSrcStart ;
						MaxSrc = MaxSrcStart ;

						for( i = 0 ; i < Width ; i ++ )
						{
							*( ( DWORD * )RGBA[  0 ] ) = *( ( DWORD * )Src ) ;
							*( ( DWORD * )RGBA[  1 ] ) = j <  1           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  1 ) ) ;
							*( ( DWORD * )RGBA[  2 ] ) = j <  2           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  2 ) ) ;
							*( ( DWORD * )RGBA[  3 ] ) = j +  1 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  1 ) ) ;
							*( ( DWORD * )RGBA[  4 ] ) = j +  2 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  2 ) ) ;
							*( ( DWORD * )RGBA[  5 ] ) = j <  3           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  3 ) ) ;
							*( ( DWORD * )RGBA[  6 ] ) = j <  4           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  4 ) ) ;
							*( ( DWORD * )RGBA[  7 ] ) = j +  3 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  3 ) ) ;
							*( ( DWORD * )RGBA[  8 ] ) = j +  4 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  4 ) ) ;
							*( ( DWORD * )RGBA[  9 ] ) = j <  5           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  5 ) ) ;
							*( ( DWORD * )RGBA[ 10 ] ) = j <  6           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  6 ) ) ;
							*( ( DWORD * )RGBA[ 11 ] ) = j +  5 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  5 ) ) ;
							*( ( DWORD * )RGBA[ 12 ] ) = j +  6 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  6 ) ) ;
							*( ( DWORD * )RGBA[ 13 ] ) = j <  7           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  7 ) ) ;
							*( ( DWORD * )RGBA[ 14 ] ) = j <  8           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  8 ) ) ;
							*( ( DWORD * )RGBA[ 15 ] ) = j +  7 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  7 ) ) ;
							*( ( DWORD * )RGBA[ 16 ] ) = j +  8 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  8 ) ) ;
							*( ( DWORD * )RGBA[ 17 ] ) = j <  9           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  9 ) ) ;
							*( ( DWORD * )RGBA[ 18 ] ) = j < 10           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 10 ) ) ;
							*( ( DWORD * )RGBA[ 19 ] ) = j +  9 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  9 ) ) ;
							*( ( DWORD * )RGBA[ 20 ] ) = j + 10 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 10 ) ) ;
							*( ( DWORD * )RGBA[ 21 ] ) = j < 11           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 11 ) ) ;
							*( ( DWORD * )RGBA[ 22 ] ) = j < 12           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 12 ) ) ;
							*( ( DWORD * )RGBA[ 23 ] ) = j + 11 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 11 ) ) ;
							*( ( DWORD * )RGBA[ 24 ] ) = j + 12 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 12 ) ) ;
							*( ( DWORD * )RGBA[ 25 ] ) = j < 13           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 13 ) ) ;
							*( ( DWORD * )RGBA[ 26 ] ) = j < 14           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 14 ) ) ;
							*( ( DWORD * )RGBA[ 27 ] ) = j + 13 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 13 ) ) ;
							*( ( DWORD * )RGBA[ 28 ] ) = j + 14 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 14 ) ) ;

							Dest[ 0 ] = ( BYTE )(
								( RGBA[ 0 ][ 0 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 0 ] + RGBA[  2 ][ 0 ] + RGBA[  3 ][ 0 ] + RGBA[  4 ][ 0 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 0 ] + RGBA[  6 ][ 0 ] + RGBA[  7 ][ 0 ] + RGBA[  8 ][ 0 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 0 ] + RGBA[ 10 ][ 0 ] + RGBA[ 11 ][ 0 ] + RGBA[ 12 ][ 0 ] ) * iTable[ 3 ] +
									  ( RGBA[ 13 ][ 0 ] + RGBA[ 14 ][ 0 ] + RGBA[ 15 ][ 0 ] + RGBA[ 16 ][ 0 ] ) * iTable[ 4 ] +
									  ( RGBA[ 17 ][ 0 ] + RGBA[ 18 ][ 0 ] + RGBA[ 19 ][ 0 ] + RGBA[ 20 ][ 0 ] ) * iTable[ 5 ] +
									  ( RGBA[ 21 ][ 0 ] + RGBA[ 22 ][ 0 ] + RGBA[ 23 ][ 0 ] + RGBA[ 24 ][ 0 ] ) * iTable[ 6 ] +
									  ( RGBA[ 25 ][ 0 ] + RGBA[ 26 ][ 0 ] + RGBA[ 27 ][ 0 ] + RGBA[ 28 ][ 0 ] ) * iTable[ 7 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 1 ] = ( BYTE )(
								( RGBA[ 0 ][ 1 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 1 ] + RGBA[  2 ][ 1 ] + RGBA[  3 ][ 1 ] + RGBA[  4 ][ 1 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 1 ] + RGBA[  6 ][ 1 ] + RGBA[  7 ][ 1 ] + RGBA[  8 ][ 1 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 1 ] + RGBA[ 10 ][ 1 ] + RGBA[ 11 ][ 1 ] + RGBA[ 12 ][ 1 ] ) * iTable[ 3 ] +
									  ( RGBA[ 13 ][ 1 ] + RGBA[ 14 ][ 1 ] + RGBA[ 15 ][ 1 ] + RGBA[ 16 ][ 1 ] ) * iTable[ 4 ] +
									  ( RGBA[ 17 ][ 1 ] + RGBA[ 18 ][ 1 ] + RGBA[ 19 ][ 1 ] + RGBA[ 20 ][ 1 ] ) * iTable[ 5 ] +
									  ( RGBA[ 21 ][ 1 ] + RGBA[ 22 ][ 1 ] + RGBA[ 23 ][ 1 ] + RGBA[ 24 ][ 1 ] ) * iTable[ 6 ] +
									  ( RGBA[ 25 ][ 1 ] + RGBA[ 26 ][ 1 ] + RGBA[ 27 ][ 1 ] + RGBA[ 28 ][ 1 ] ) * iTable[ 7 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 2 ] = ( BYTE )(
								( RGBA[ 0 ][ 2 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 2 ] + RGBA[  2 ][ 2 ] + RGBA[  3 ][ 2 ] + RGBA[  4 ][ 2 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 2 ] + RGBA[  6 ][ 2 ] + RGBA[  7 ][ 2 ] + RGBA[  8 ][ 2 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 2 ] + RGBA[ 10 ][ 2 ] + RGBA[ 11 ][ 2 ] + RGBA[ 12 ][ 2 ] ) * iTable[ 3 ] +
									  ( RGBA[ 13 ][ 2 ] + RGBA[ 14 ][ 2 ] + RGBA[ 15 ][ 2 ] + RGBA[ 16 ][ 2 ] ) * iTable[ 4 ] +
									  ( RGBA[ 17 ][ 2 ] + RGBA[ 18 ][ 2 ] + RGBA[ 19 ][ 2 ] + RGBA[ 20 ][ 2 ] ) * iTable[ 5 ] +
									  ( RGBA[ 21 ][ 2 ] + RGBA[ 22 ][ 2 ] + RGBA[ 23 ][ 2 ] + RGBA[ 24 ][ 2 ] ) * iTable[ 6 ] +
									  ( RGBA[ 25 ][ 2 ] + RGBA[ 26 ][ 2 ] + RGBA[ 27 ][ 2 ] + RGBA[ 28 ][ 2 ] ) * iTable[ 7 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 3 ] = ( BYTE )(
								( RGBA[ 0 ][ 3 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 3 ] + RGBA[  2 ][ 3 ] + RGBA[  3 ][ 3 ] + RGBA[  4 ][ 3 ] ) * iTable[ 1 ] +
									  ( RGBA[  5 ][ 3 ] + RGBA[  6 ][ 3 ] + RGBA[  7 ][ 3 ] + RGBA[  8 ][ 3 ] ) * iTable[ 2 ] +
									  ( RGBA[  9 ][ 3 ] + RGBA[ 10 ][ 3 ] + RGBA[ 11 ][ 3 ] + RGBA[ 12 ][ 3 ] ) * iTable[ 3 ] +
									  ( RGBA[ 13 ][ 3 ] + RGBA[ 14 ][ 3 ] + RGBA[ 15 ][ 3 ] + RGBA[ 16 ][ 3 ] ) * iTable[ 4 ] +
									  ( RGBA[ 17 ][ 3 ] + RGBA[ 18 ][ 3 ] + RGBA[ 19 ][ 3 ] + RGBA[ 20 ][ 3 ] ) * iTable[ 5 ] +
									  ( RGBA[ 21 ][ 3 ] + RGBA[ 22 ][ 3 ] + RGBA[ 23 ][ 3 ] + RGBA[ 24 ][ 3 ] ) * iTable[ 6 ] +
									  ( RGBA[ 25 ][ 3 ] + RGBA[ 26 ][ 3 ] + RGBA[ 27 ][ 3 ] + RGBA[ 28 ][ 3 ] ) * iTable[ 7 ] ) >> 1 ) ) >> 16 ) ;

							MinSrc += 4 ;
							MaxSrc += 4 ;
							Src  += 4 ;
							Dest += 4 ;
						}

						Src  += SrcAddPitch ;
						Dest += DestAddPitch ;
					}
					break ;

				case 32 :
					for( j = 0 ; j < Height ; j ++ )
					{
						MinSrc = MinSrcStart ;
						MaxSrc = MaxSrcStart ;

						for( i = 0 ; i < Width ; i ++ )
						{
							*( ( DWORD * )RGBA[  0 ] ) = *( ( DWORD * )Src ) ;
							*( ( DWORD * )RGBA[  1 ] ) = j <  1           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  1 ) ) ;
							*( ( DWORD * )RGBA[  2 ] ) = j <  2           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  2 ) ) ;
							*( ( DWORD * )RGBA[  3 ] ) = j +  1 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  1 ) ) ;
							*( ( DWORD * )RGBA[  4 ] ) = j +  2 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  2 ) ) ;
							*( ( DWORD * )RGBA[  5 ] ) = j <  3           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  3 ) ) ;
							*( ( DWORD * )RGBA[  6 ] ) = j <  4           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  4 ) ) ;
							*( ( DWORD * )RGBA[  7 ] ) = j +  3 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  3 ) ) ;
							*( ( DWORD * )RGBA[  8 ] ) = j +  4 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  4 ) ) ;
							*( ( DWORD * )RGBA[  9 ] ) = j <  5           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  5 ) ) ;
							*( ( DWORD * )RGBA[ 10 ] ) = j <  6           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  6 ) ) ;
							*( ( DWORD * )RGBA[ 11 ] ) = j +  5 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  5 ) ) ;
							*( ( DWORD * )RGBA[ 12 ] ) = j +  6 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  6 ) ) ;
							*( ( DWORD * )RGBA[ 13 ] ) = j <  7           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  7 ) ) ;
							*( ( DWORD * )RGBA[ 14 ] ) = j <  8           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  8 ) ) ;
							*( ( DWORD * )RGBA[ 15 ] ) = j +  7 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  7 ) ) ;
							*( ( DWORD * )RGBA[ 16 ] ) = j +  8 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  8 ) ) ;
							*( ( DWORD * )RGBA[ 17 ] ) = j <  9           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch *  9 ) ) ;
							*( ( DWORD * )RGBA[ 18 ] ) = j < 10           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 10 ) ) ;
							*( ( DWORD * )RGBA[ 19 ] ) = j +  9 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch *  9 ) ) ;
							*( ( DWORD * )RGBA[ 20 ] ) = j + 10 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 10 ) ) ;
							*( ( DWORD * )RGBA[ 21 ] ) = j < 11           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 11 ) ) ;
							*( ( DWORD * )RGBA[ 22 ] ) = j < 12           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 12 ) ) ;
							*( ( DWORD * )RGBA[ 23 ] ) = j + 11 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 11 ) ) ;
							*( ( DWORD * )RGBA[ 24 ] ) = j + 12 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 12 ) ) ;
							*( ( DWORD * )RGBA[ 25 ] ) = j < 13           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 13 ) ) ;
							*( ( DWORD * )RGBA[ 26 ] ) = j < 14           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 14 ) ) ;
							*( ( DWORD * )RGBA[ 27 ] ) = j + 13 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 13 ) ) ;
							*( ( DWORD * )RGBA[ 28 ] ) = j + 14 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 14 ) ) ;
							*( ( DWORD * )RGBA[ 29 ] ) = j < 15           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 15 ) ) ;
							*( ( DWORD * )RGBA[ 30 ] ) = j < 16           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 16 ) ) ;
							*( ( DWORD * )RGBA[ 31 ] ) = j + 15 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 15 ) ) ;
							*( ( DWORD * )RGBA[ 32 ] ) = j + 16 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 16 ) ) ;
							*( ( DWORD * )RGBA[ 33 ] ) = j < 17           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 17 ) ) ;
							*( ( DWORD * )RGBA[ 34 ] ) = j < 18           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 18 ) ) ;
							*( ( DWORD * )RGBA[ 35 ] ) = j + 17 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 17 ) ) ;
							*( ( DWORD * )RGBA[ 36 ] ) = j + 18 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 18 ) ) ;
							*( ( DWORD * )RGBA[ 37 ] ) = j < 19           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 19 ) ) ;
							*( ( DWORD * )RGBA[ 38 ] ) = j < 20           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 20 ) ) ;
							*( ( DWORD * )RGBA[ 39 ] ) = j + 19 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 19 ) ) ;
							*( ( DWORD * )RGBA[ 40 ] ) = j + 20 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 20 ) ) ;
							*( ( DWORD * )RGBA[ 41 ] ) = j < 21           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 21 ) ) ;
							*( ( DWORD * )RGBA[ 42 ] ) = j < 22           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 22 ) ) ;
							*( ( DWORD * )RGBA[ 43 ] ) = j + 21 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 21 ) ) ;
							*( ( DWORD * )RGBA[ 44 ] ) = j + 22 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 22 ) ) ;
							*( ( DWORD * )RGBA[ 45 ] ) = j < 23           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 23 ) ) ;
							*( ( DWORD * )RGBA[ 46 ] ) = j < 24           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 24 ) ) ;
							*( ( DWORD * )RGBA[ 47 ] ) = j + 23 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 23 ) ) ;
							*( ( DWORD * )RGBA[ 48 ] ) = j + 24 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 24 ) ) ;
							*( ( DWORD * )RGBA[ 49 ] ) = j < 25           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 25 ) ) ;
							*( ( DWORD * )RGBA[ 50 ] ) = j < 26           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 26 ) ) ;
							*( ( DWORD * )RGBA[ 51 ] ) = j + 25 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 25 ) ) ;
							*( ( DWORD * )RGBA[ 52 ] ) = j + 26 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 26 ) ) ;
							*( ( DWORD * )RGBA[ 53 ] ) = j < 27           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 27 ) ) ;
							*( ( DWORD * )RGBA[ 54 ] ) = j < 28           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 28 ) ) ;
							*( ( DWORD * )RGBA[ 55 ] ) = j + 27 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 27 ) ) ;
							*( ( DWORD * )RGBA[ 56 ] ) = j + 28 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 28 ) ) ;
							*( ( DWORD * )RGBA[ 57 ] ) = j < 29           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 29 ) ) ;
							*( ( DWORD * )RGBA[ 58 ] ) = j < 30           ? *( ( DWORD * )MinSrc ) : *( ( DWORD * )( Src - SrcPitch * 30 ) ) ;
							*( ( DWORD * )RGBA[ 59 ] ) = j + 29 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 29 ) ) ;
							*( ( DWORD * )RGBA[ 60 ] ) = j + 30 >= Height ? *( ( DWORD * )MaxSrc ) : *( ( DWORD * )( Src + SrcPitch * 30 ) ) ;

							Dest[ 0 ] = ( BYTE )(
								( RGBA[ 0 ][ 0 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 0 ] + RGBA[  2 ][ 0 ] + RGBA[  3 ][ 0 ] + RGBA[  4 ][ 0 ] ) * iTable[  1 ] +
									  ( RGBA[  5 ][ 0 ] + RGBA[  6 ][ 0 ] + RGBA[  7 ][ 0 ] + RGBA[  8 ][ 0 ] ) * iTable[  2 ] +
									  ( RGBA[  9 ][ 0 ] + RGBA[ 10 ][ 0 ] + RGBA[ 11 ][ 0 ] + RGBA[ 12 ][ 0 ] ) * iTable[  3 ] +
									  ( RGBA[ 13 ][ 0 ] + RGBA[ 14 ][ 0 ] + RGBA[ 15 ][ 0 ] + RGBA[ 16 ][ 0 ] ) * iTable[  4 ] +
									  ( RGBA[ 17 ][ 0 ] + RGBA[ 18 ][ 0 ] + RGBA[ 19 ][ 0 ] + RGBA[ 20 ][ 0 ] ) * iTable[  5 ] +
									  ( RGBA[ 21 ][ 0 ] + RGBA[ 22 ][ 0 ] + RGBA[ 23 ][ 0 ] + RGBA[ 24 ][ 0 ] ) * iTable[  6 ] +
									  ( RGBA[ 25 ][ 0 ] + RGBA[ 26 ][ 0 ] + RGBA[ 27 ][ 0 ] + RGBA[ 28 ][ 0 ] ) * iTable[  7 ] +
									  ( RGBA[ 29 ][ 0 ] + RGBA[ 30 ][ 0 ] + RGBA[ 31 ][ 0 ] + RGBA[ 32 ][ 0 ] ) * iTable[  8 ] +
									  ( RGBA[ 33 ][ 0 ] + RGBA[ 34 ][ 0 ] + RGBA[ 35 ][ 0 ] + RGBA[ 36 ][ 0 ] ) * iTable[  9 ] +
									  ( RGBA[ 37 ][ 0 ] + RGBA[ 38 ][ 0 ] + RGBA[ 39 ][ 0 ] + RGBA[ 40 ][ 0 ] ) * iTable[ 10 ] +
									  ( RGBA[ 41 ][ 0 ] + RGBA[ 42 ][ 0 ] + RGBA[ 43 ][ 0 ] + RGBA[ 44 ][ 0 ] ) * iTable[ 11 ] +
									  ( RGBA[ 45 ][ 0 ] + RGBA[ 46 ][ 0 ] + RGBA[ 47 ][ 0 ] + RGBA[ 48 ][ 0 ] ) * iTable[ 12 ] +
									  ( RGBA[ 49 ][ 0 ] + RGBA[ 50 ][ 0 ] + RGBA[ 51 ][ 0 ] + RGBA[ 52 ][ 0 ] ) * iTable[ 13 ] +
									  ( RGBA[ 53 ][ 0 ] + RGBA[ 54 ][ 0 ] + RGBA[ 55 ][ 0 ] + RGBA[ 56 ][ 0 ] ) * iTable[ 14 ] +
									  ( RGBA[ 57 ][ 0 ] + RGBA[ 58 ][ 0 ] + RGBA[ 59 ][ 0 ] + RGBA[ 60 ][ 0 ] ) * iTable[ 15 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 1 ] = ( BYTE )(
								( RGBA[ 0 ][ 1 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 1 ] + RGBA[  2 ][ 1 ] + RGBA[  3 ][ 1 ] + RGBA[  4 ][ 1 ] ) * iTable[  1 ] +
									  ( RGBA[  5 ][ 1 ] + RGBA[  6 ][ 1 ] + RGBA[  7 ][ 1 ] + RGBA[  8 ][ 1 ] ) * iTable[  2 ] +
									  ( RGBA[  9 ][ 1 ] + RGBA[ 10 ][ 1 ] + RGBA[ 11 ][ 1 ] + RGBA[ 12 ][ 1 ] ) * iTable[  3 ] +
									  ( RGBA[ 13 ][ 1 ] + RGBA[ 14 ][ 1 ] + RGBA[ 15 ][ 1 ] + RGBA[ 16 ][ 1 ] ) * iTable[  4 ] +
									  ( RGBA[ 17 ][ 1 ] + RGBA[ 18 ][ 1 ] + RGBA[ 19 ][ 1 ] + RGBA[ 20 ][ 1 ] ) * iTable[  5 ] +
									  ( RGBA[ 21 ][ 1 ] + RGBA[ 22 ][ 1 ] + RGBA[ 23 ][ 1 ] + RGBA[ 24 ][ 1 ] ) * iTable[  6 ] +
									  ( RGBA[ 25 ][ 1 ] + RGBA[ 26 ][ 1 ] + RGBA[ 27 ][ 1 ] + RGBA[ 28 ][ 1 ] ) * iTable[  7 ] +
									  ( RGBA[ 29 ][ 1 ] + RGBA[ 30 ][ 1 ] + RGBA[ 31 ][ 1 ] + RGBA[ 32 ][ 1 ] ) * iTable[  8 ] +
									  ( RGBA[ 33 ][ 1 ] + RGBA[ 34 ][ 1 ] + RGBA[ 35 ][ 1 ] + RGBA[ 36 ][ 1 ] ) * iTable[  9 ] +
									  ( RGBA[ 37 ][ 1 ] + RGBA[ 38 ][ 1 ] + RGBA[ 39 ][ 1 ] + RGBA[ 40 ][ 1 ] ) * iTable[ 10 ] +
									  ( RGBA[ 41 ][ 1 ] + RGBA[ 42 ][ 1 ] + RGBA[ 43 ][ 1 ] + RGBA[ 44 ][ 1 ] ) * iTable[ 11 ] +
									  ( RGBA[ 45 ][ 1 ] + RGBA[ 46 ][ 1 ] + RGBA[ 47 ][ 1 ] + RGBA[ 48 ][ 1 ] ) * iTable[ 12 ] +
									  ( RGBA[ 49 ][ 1 ] + RGBA[ 50 ][ 1 ] + RGBA[ 51 ][ 1 ] + RGBA[ 52 ][ 1 ] ) * iTable[ 13 ] +
									  ( RGBA[ 53 ][ 1 ] + RGBA[ 54 ][ 1 ] + RGBA[ 55 ][ 1 ] + RGBA[ 56 ][ 1 ] ) * iTable[ 14 ] +
									  ( RGBA[ 57 ][ 1 ] + RGBA[ 58 ][ 1 ] + RGBA[ 59 ][ 1 ] + RGBA[ 60 ][ 1 ] ) * iTable[ 15 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 2 ] = ( BYTE )(
								( RGBA[ 0 ][ 2 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 2 ] + RGBA[  2 ][ 2 ] + RGBA[  3 ][ 2 ] + RGBA[  4 ][ 2 ] ) * iTable[  1 ] +
									  ( RGBA[  5 ][ 2 ] + RGBA[  6 ][ 2 ] + RGBA[  7 ][ 2 ] + RGBA[  8 ][ 2 ] ) * iTable[  2 ] +
									  ( RGBA[  9 ][ 2 ] + RGBA[ 10 ][ 2 ] + RGBA[ 11 ][ 2 ] + RGBA[ 12 ][ 2 ] ) * iTable[  3 ] +
									  ( RGBA[ 13 ][ 2 ] + RGBA[ 14 ][ 2 ] + RGBA[ 15 ][ 2 ] + RGBA[ 16 ][ 2 ] ) * iTable[  4 ] +
									  ( RGBA[ 17 ][ 2 ] + RGBA[ 18 ][ 2 ] + RGBA[ 19 ][ 2 ] + RGBA[ 20 ][ 2 ] ) * iTable[  5 ] +
									  ( RGBA[ 21 ][ 2 ] + RGBA[ 22 ][ 2 ] + RGBA[ 23 ][ 2 ] + RGBA[ 24 ][ 2 ] ) * iTable[  6 ] +
									  ( RGBA[ 25 ][ 2 ] + RGBA[ 26 ][ 2 ] + RGBA[ 27 ][ 2 ] + RGBA[ 28 ][ 2 ] ) * iTable[  7 ] +
									  ( RGBA[ 29 ][ 2 ] + RGBA[ 30 ][ 2 ] + RGBA[ 31 ][ 2 ] + RGBA[ 32 ][ 2 ] ) * iTable[  8 ] +
									  ( RGBA[ 33 ][ 2 ] + RGBA[ 34 ][ 2 ] + RGBA[ 35 ][ 2 ] + RGBA[ 36 ][ 2 ] ) * iTable[  9 ] +
									  ( RGBA[ 37 ][ 2 ] + RGBA[ 38 ][ 2 ] + RGBA[ 39 ][ 2 ] + RGBA[ 40 ][ 2 ] ) * iTable[ 10 ] +
									  ( RGBA[ 41 ][ 2 ] + RGBA[ 42 ][ 2 ] + RGBA[ 43 ][ 2 ] + RGBA[ 44 ][ 2 ] ) * iTable[ 11 ] +
									  ( RGBA[ 45 ][ 2 ] + RGBA[ 46 ][ 2 ] + RGBA[ 47 ][ 2 ] + RGBA[ 48 ][ 2 ] ) * iTable[ 12 ] +
									  ( RGBA[ 49 ][ 2 ] + RGBA[ 50 ][ 2 ] + RGBA[ 51 ][ 2 ] + RGBA[ 52 ][ 2 ] ) * iTable[ 13 ] +
									  ( RGBA[ 53 ][ 2 ] + RGBA[ 54 ][ 2 ] + RGBA[ 55 ][ 2 ] + RGBA[ 56 ][ 2 ] ) * iTable[ 14 ] +
									  ( RGBA[ 57 ][ 2 ] + RGBA[ 58 ][ 2 ] + RGBA[ 59 ][ 2 ] + RGBA[ 60 ][ 2 ] ) * iTable[ 15 ] ) >> 1 ) ) >> 16 ) ;

							Dest[ 3 ] = ( BYTE )(
								( RGBA[ 0 ][ 3 ] * iTable[ 0 ] +
								  ( ( ( RGBA[  1 ][ 3 ] + RGBA[  2 ][ 3 ] + RGBA[  3 ][ 3 ] + RGBA[  4 ][ 3 ] ) * iTable[  1 ] +
									  ( RGBA[  5 ][ 3 ] + RGBA[  6 ][ 3 ] + RGBA[  7 ][ 3 ] + RGBA[  8 ][ 3 ] ) * iTable[  2 ] +
									  ( RGBA[  9 ][ 3 ] + RGBA[ 10 ][ 3 ] + RGBA[ 11 ][ 3 ] + RGBA[ 12 ][ 3 ] ) * iTable[  3 ] +
									  ( RGBA[ 13 ][ 3 ] + RGBA[ 14 ][ 3 ] + RGBA[ 15 ][ 3 ] + RGBA[ 16 ][ 3 ] ) * iTable[  4 ] +
									  ( RGBA[ 17 ][ 3 ] + RGBA[ 18 ][ 3 ] + RGBA[ 19 ][ 3 ] + RGBA[ 20 ][ 3 ] ) * iTable[  5 ] +
									  ( RGBA[ 21 ][ 3 ] + RGBA[ 22 ][ 3 ] + RGBA[ 23 ][ 3 ] + RGBA[ 24 ][ 3 ] ) * iTable[  6 ] +
									  ( RGBA[ 25 ][ 3 ] + RGBA[ 26 ][ 3 ] + RGBA[ 27 ][ 3 ] + RGBA[ 28 ][ 3 ] ) * iTable[  7 ] +
									  ( RGBA[ 29 ][ 3 ] + RGBA[ 30 ][ 3 ] + RGBA[ 31 ][ 3 ] + RGBA[ 32 ][ 3 ] ) * iTable[  8 ] +
									  ( RGBA[ 33 ][ 3 ] + RGBA[ 34 ][ 3 ] + RGBA[ 35 ][ 3 ] + RGBA[ 36 ][ 3 ] ) * iTable[  9 ] +
									  ( RGBA[ 37 ][ 3 ] + RGBA[ 38 ][ 3 ] + RGBA[ 39 ][ 3 ] + RGBA[ 40 ][ 3 ] ) * iTable[ 10 ] +
									  ( RGBA[ 41 ][ 3 ] + RGBA[ 42 ][ 3 ] + RGBA[ 43 ][ 3 ] + RGBA[ 44 ][ 3 ] ) * iTable[ 11 ] +
									  ( RGBA[ 45 ][ 3 ] + RGBA[ 46 ][ 3 ] + RGBA[ 47 ][ 3 ] + RGBA[ 48 ][ 3 ] ) * iTable[ 12 ] +
									  ( RGBA[ 49 ][ 3 ] + RGBA[ 50 ][ 3 ] + RGBA[ 51 ][ 3 ] + RGBA[ 52 ][ 3 ] ) * iTable[ 13 ] +
									  ( RGBA[ 53 ][ 3 ] + RGBA[ 54 ][ 3 ] + RGBA[ 55 ][ 3 ] + RGBA[ 56 ][ 3 ] ) * iTable[ 14 ] +
									  ( RGBA[ 57 ][ 3 ] + RGBA[ 58 ][ 3 ] + RGBA[ 59 ][ 3 ] + RGBA[ 60 ][ 3 ] ) * iTable[ 15 ] ) >> 1 ) ) >> 16 ) ;

							MinSrc += 4 ;
							MaxSrc += 4 ;
							Src  += 4 ;
							Dest += 4 ;
						}

						Src  += SrcAddPitch ;
						Dest += DestAddPitch ;
					}
					break ;
				}

				NS_ReleaseBaseImage( &WorkImage ) ;
			}
		}

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int GraphFilter_Down_Scale( GRAPHFILTER_INFO *Info, int DivNum )
{
	// パラメータを補正
	if( DivNum <= 2 )
	{
		DivNum = 2 ;
	}
	else
	if( DivNum <= 4 )
	{
		DivNum = 4 ;
	}
	else
	{
		DivNum = 8 ;
	}

	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 3 ] =
		{
			"DownScaleX2.pso",
			"DownScaleX4.pso",
			"DownScaleX8.pso",
		} ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		IMAGEDATA2 *SrcImage2 ;
		int UseShader = 0 ;
		int UseConstNum = 0 ;
		FLOAT4 ParamF4[ 16 ] ;
		float TextureW ;
		float TextureH ;
		int i ;

		if( GRAPHCHK( Info->SrcGrHandle, SrcImage2 ) )
			return -1 ;

		// 使用するシェーダーのセットアップ
		switch( DivNum )
		{
		case 2 : UseShader = 0 ; break ;
		case 4 : UseShader = 1 ; break ;
		case 8 : UseShader = 2 ; break ;
		}
		if( GRH.ShaderCode.DownScalePS[ UseShader ] < 0 )
		{
			GRH.ShaderCode.DownScalePS[ UseShader ] = MemLoadShaderCode( PsoFileName[ UseShader ], false ) ;
			if( GRH.ShaderCode.DownScalePS[ UseShader ] < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ UseShader ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.DownScalePS[ UseShader ], &GRH.ShaderCode.DownScalePS[ UseShader ] ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		switch( DivNum )
		{
		case 2 :
			ParamF4[  0 ].x = 0.0f ; ParamF4[  0 ].y = 0.0f ; ParamF4[  0 ].z = 0.0f ; ParamF4[  0 ].w = 0.0f ;
			UseConstNum = 1 ;
			break ;

		case 4 :
			ParamF4[  0 ].x = -1.0f ; ParamF4[  0 ].y = -1.0f ; ParamF4[  0 ].z = 0.0f ; ParamF4[  0 ].w = 0.0f ;
			ParamF4[  1 ].x =  1.0f ; ParamF4[  1 ].y = -1.0f ; ParamF4[  1 ].z = 0.0f ; ParamF4[  1 ].w = 0.0f ;
			ParamF4[  2 ].x = -1.0f ; ParamF4[  2 ].y =  1.0f ; ParamF4[  2 ].z = 0.0f ; ParamF4[  2 ].w = 0.0f ;
			ParamF4[  3 ].x =  1.0f ; ParamF4[  3 ].y =  1.0f ; ParamF4[  3 ].z = 0.0f ; ParamF4[  3 ].w = 0.0f ;
			UseConstNum = 4 ;
			break ;

		case 8 :
			ParamF4[  0 ].x = -3.0f ; ParamF4[  0 ].y = -3.0f ; ParamF4[  0 ].z = 0.0f ; ParamF4[  0 ].w = 0.0f ;
			ParamF4[  1 ].x = -1.0f ; ParamF4[  1 ].y = -3.0f ; ParamF4[  1 ].z = 0.0f ; ParamF4[  1 ].w = 0.0f ;
			ParamF4[  2 ].x =  1.0f ; ParamF4[  2 ].y = -3.0f ; ParamF4[  2 ].z = 0.0f ; ParamF4[  2 ].w = 0.0f ;
			ParamF4[  3 ].x =  3.0f ; ParamF4[  3 ].y = -3.0f ; ParamF4[  3 ].z = 0.0f ; ParamF4[  3 ].w = 0.0f ;
			ParamF4[  4 ].x = -3.0f ; ParamF4[  4 ].y = -1.0f ; ParamF4[  4 ].z = 0.0f ; ParamF4[  4 ].w = 0.0f ;
			ParamF4[  5 ].x = -1.0f ; ParamF4[  5 ].y = -1.0f ; ParamF4[  5 ].z = 0.0f ; ParamF4[  5 ].w = 0.0f ;
			ParamF4[  6 ].x =  1.0f ; ParamF4[  6 ].y = -1.0f ; ParamF4[  6 ].z = 0.0f ; ParamF4[  6 ].w = 0.0f ;
			ParamF4[  7 ].x =  3.0f ; ParamF4[  7 ].y = -1.0f ; ParamF4[  7 ].z = 0.0f ; ParamF4[  7 ].w = 0.0f ;
			ParamF4[  8 ].x = -3.0f ; ParamF4[  8 ].y =  1.0f ; ParamF4[  8 ].z = 0.0f ; ParamF4[  8 ].w = 0.0f ;
			ParamF4[  9 ].x = -1.0f ; ParamF4[  9 ].y =  1.0f ; ParamF4[  9 ].z = 0.0f ; ParamF4[  9 ].w = 0.0f ;
			ParamF4[ 10 ].x =  1.0f ; ParamF4[ 10 ].y =  1.0f ; ParamF4[ 10 ].z = 0.0f ; ParamF4[ 10 ].w = 0.0f ;
			ParamF4[ 11 ].x =  3.0f ; ParamF4[ 11 ].y =  1.0f ; ParamF4[ 11 ].z = 0.0f ; ParamF4[ 11 ].w = 0.0f ;
			ParamF4[ 12 ].x = -3.0f ; ParamF4[ 12 ].y =  3.0f ; ParamF4[ 12 ].z = 0.0f ; ParamF4[ 12 ].w = 0.0f ;
			ParamF4[ 13 ].x = -1.0f ; ParamF4[ 13 ].y =  3.0f ; ParamF4[ 13 ].z = 0.0f ; ParamF4[ 13 ].w = 0.0f ;
			ParamF4[ 14 ].x =  1.0f ; ParamF4[ 14 ].y =  3.0f ; ParamF4[ 14 ].z = 0.0f ; ParamF4[ 14 ].w = 0.0f ;
			ParamF4[ 15 ].x =  3.0f ; ParamF4[ 15 ].y =  3.0f ; ParamF4[ 15 ].z = 0.0f ; ParamF4[ 15 ].w = 0.0f ;
			UseConstNum = 16 ;
			break ;
		}
		TextureW = ( float )SrcImage2->Orig->Hard.Tex[ 0 ].TexWidth ;
		TextureH = ( float )SrcImage2->Orig->Hard.Tex[ 0 ].TexHeight ;
		for( i = 0 ; i < UseConstNum ; i ++ )
		{
			ParamF4[ i ].x /= TextureW ;
			ParamF4[ i ].y /= TextureH ;
		}
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, UseConstNum, FALSE ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.DownScalePS[ UseShader ] ) ;

		GraphFilter_BasePolygonDraw( Info, DivNum ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, UseConstNum ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD SrcWidth ;
		DWORD SrcHeight ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcPitch ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;

		SrcWidth  = Info->SrcX2 - Info->SrcX1 ;
		SrcHeight = Info->SrcY2 - Info->SrcY1 ;
		Width  = SrcWidth  / DivNum ;
		Height = SrcHeight / DivNum ;

		if( GraphFilter_SoftImageSetup( Info, TRUE, Width, Height ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		SrcPitch = Info->SrcImage.Pitch ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		switch( DivNum )
		{
		case 2 :
			SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 * 2 + SrcPitch ;

			do
			{
				i = Width ;
				do
				{
					Dest[ 0 ] = ( Src[ 0 ] + Src[ 4 ] + Src[ SrcPitch + 0 ] + Src[ SrcPitch + 4 ] ) >> 2 ;
					Dest[ 1 ] = ( Src[ 1 ] + Src[ 5 ] + Src[ SrcPitch + 1 ] + Src[ SrcPitch + 5 ] ) >> 2 ;
					Dest[ 2 ] = ( Src[ 2 ] + Src[ 6 ] + Src[ SrcPitch + 2 ] + Src[ SrcPitch + 6 ] ) >> 2 ;
					Dest[ 3 ] = ( Src[ 3 ] + Src[ 7 ] + Src[ SrcPitch + 3 ] + Src[ SrcPitch + 7 ] ) >> 2 ;

					Src  += 4 * 2 ;
					Dest += 4 ;
				}while( -- i ) ;

				Src  += SrcAddPitch ;
				Dest += DestAddPitch ;
			}while( -- Height ) ;
			break ;

		case 4 :
			SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 * 4 + SrcPitch * 3 ;

			do
			{
				i = Width ;
				do
				{
					Dest[ 0 ] = (
						Src[                0 ] + Src[                4 ] + Src[                 8 ] + Src[                12 ] +
						Src[ SrcPitch     + 0 ] + Src[ SrcPitch     + 4 ] +	Src[ SrcPitch     +  8 ] + Src[ SrcPitch     + 12 ] +
						Src[ SrcPitch * 2 + 0 ] + Src[ SrcPitch * 2 + 4 ] +	Src[ SrcPitch * 2 +  8 ] + Src[ SrcPitch * 2 + 12 ] +
						Src[ SrcPitch * 3 + 0 ] + Src[ SrcPitch * 3 + 4 ] +	Src[ SrcPitch * 3 +  8 ] + Src[ SrcPitch * 3 + 12 ] ) >> 4 ;
					Dest[ 1 ] = (
						Src[                1 ] + Src[                5 ] + Src[                 9 ] + Src[                13 ] +
						Src[ SrcPitch     + 1 ] + Src[ SrcPitch     + 5 ] +	Src[ SrcPitch     +  9 ] + Src[ SrcPitch     + 13 ] +
						Src[ SrcPitch * 2 + 1 ] + Src[ SrcPitch * 2 + 5 ] +	Src[ SrcPitch * 2 +  9 ] + Src[ SrcPitch * 2 + 13 ] +
						Src[ SrcPitch * 3 + 1 ] + Src[ SrcPitch * 3 + 5 ] +	Src[ SrcPitch * 3 +  9 ] + Src[ SrcPitch * 3 + 13 ] ) >> 4 ;
					Dest[ 2 ] = (
						Src[                2 ] + Src[                6 ] + Src[                10 ] + Src[                14 ] +
						Src[ SrcPitch     + 2 ] + Src[ SrcPitch     + 6 ] +	Src[ SrcPitch     + 10 ] + Src[ SrcPitch     + 14 ] +
						Src[ SrcPitch * 2 + 2 ] + Src[ SrcPitch * 2 + 6 ] +	Src[ SrcPitch * 2 + 10 ] + Src[ SrcPitch * 2 + 14 ] +
						Src[ SrcPitch * 3 + 2 ] + Src[ SrcPitch * 3 + 6 ] +	Src[ SrcPitch * 3 + 10 ] + Src[ SrcPitch * 3 + 14 ] ) >> 4 ;
					Dest[ 3 ] = (
						Src[                3 ] + Src[                7 ] + Src[                11 ] + Src[                15 ] +
						Src[ SrcPitch     + 3 ] + Src[ SrcPitch     + 7 ] +	Src[ SrcPitch     + 11 ] + Src[ SrcPitch     + 15 ] +
						Src[ SrcPitch * 2 + 3 ] + Src[ SrcPitch * 2 + 7 ] +	Src[ SrcPitch * 2 + 11 ] + Src[ SrcPitch * 2 + 15 ] +
						Src[ SrcPitch * 3 + 3 ] + Src[ SrcPitch * 3 + 7 ] +	Src[ SrcPitch * 3 + 11 ] + Src[ SrcPitch * 3 + 15 ] ) >> 4 ;

					Src  += 4 * 4 ;
					Dest += 4 ;
				}while( -- i ) ;

				Src  += SrcAddPitch ;
				Dest += DestAddPitch ;
			}while( -- Height ) ;
			break ;

		case 8 :
			SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 * 8 + SrcPitch * 7 ;

			do
			{
				i = Width ;
				do
				{
					Dest[ 0 ] = (
						Src[                0 ] + Src[                4 ] + Src[                 8 ] + Src[                12 ] + Src[                16 ] + Src[                20 ] + Src[                24 ] + Src[                28 ] +
						Src[ SrcPitch     + 0 ] + Src[ SrcPitch     + 4 ] +	Src[ SrcPitch     +  8 ] + Src[ SrcPitch     + 12 ] + Src[ SrcPitch     + 16 ] + Src[ SrcPitch     + 20 ] + Src[ SrcPitch     + 24 ] + Src[ SrcPitch     + 28 ] +
						Src[ SrcPitch * 2 + 0 ] + Src[ SrcPitch * 2 + 4 ] +	Src[ SrcPitch * 2 +  8 ] + Src[ SrcPitch * 2 + 12 ] + Src[ SrcPitch * 2 + 16 ] + Src[ SrcPitch * 2 + 20 ] + Src[ SrcPitch * 2 + 24 ] + Src[ SrcPitch * 2 + 28 ] +
						Src[ SrcPitch * 3 + 0 ] + Src[ SrcPitch * 3 + 4 ] +	Src[ SrcPitch * 3 +  8 ] + Src[ SrcPitch * 3 + 12 ] + Src[ SrcPitch * 3 + 16 ] + Src[ SrcPitch * 3 + 20 ] + Src[ SrcPitch * 3 + 24 ] + Src[ SrcPitch * 3 + 28 ] +
						Src[ SrcPitch * 4 + 0 ] + Src[ SrcPitch * 4 + 4 ] +	Src[ SrcPitch * 4 +  8 ] + Src[ SrcPitch * 4 + 12 ] + Src[ SrcPitch * 4 + 16 ] + Src[ SrcPitch * 4 + 20 ] + Src[ SrcPitch * 4 + 24 ] + Src[ SrcPitch * 4 + 28 ] +
						Src[ SrcPitch * 5 + 0 ] + Src[ SrcPitch * 5 + 4 ] +	Src[ SrcPitch * 5 +  8 ] + Src[ SrcPitch * 5 + 12 ] + Src[ SrcPitch * 5 + 16 ] + Src[ SrcPitch * 5 + 20 ] + Src[ SrcPitch * 5 + 24 ] + Src[ SrcPitch * 5 + 28 ] +
						Src[ SrcPitch * 6 + 0 ] + Src[ SrcPitch * 6 + 4 ] +	Src[ SrcPitch * 6 +  8 ] + Src[ SrcPitch * 6 + 12 ] + Src[ SrcPitch * 6 + 16 ] + Src[ SrcPitch * 6 + 20 ] + Src[ SrcPitch * 6 + 24 ] + Src[ SrcPitch * 6 + 28 ] +
						Src[ SrcPitch * 7 + 0 ] + Src[ SrcPitch * 7 + 4 ] +	Src[ SrcPitch * 7 +  8 ] + Src[ SrcPitch * 7 + 12 ] + Src[ SrcPitch * 7 + 16 ] + Src[ SrcPitch * 7 + 20 ] + Src[ SrcPitch * 7 + 24 ] + Src[ SrcPitch * 7 + 28 ] ) >> 6 ;
					Dest[ 1 ] = (
						Src[                1 ] + Src[                5 ] + Src[                 9 ] + Src[                13 ] + Src[                17 ] + Src[                21 ] + Src[                25 ] + Src[                29 ] +
						Src[ SrcPitch     + 1 ] + Src[ SrcPitch     + 5 ] +	Src[ SrcPitch     +  9 ] + Src[ SrcPitch     + 13 ] + Src[ SrcPitch     + 17 ] + Src[ SrcPitch     + 21 ] + Src[ SrcPitch     + 25 ] + Src[ SrcPitch     + 29 ] +
						Src[ SrcPitch * 2 + 1 ] + Src[ SrcPitch * 2 + 5 ] +	Src[ SrcPitch * 2 +  9 ] + Src[ SrcPitch * 2 + 13 ] + Src[ SrcPitch * 2 + 17 ] + Src[ SrcPitch * 2 + 21 ] + Src[ SrcPitch * 2 + 25 ] + Src[ SrcPitch * 2 + 29 ] +
						Src[ SrcPitch * 3 + 1 ] + Src[ SrcPitch * 3 + 5 ] +	Src[ SrcPitch * 3 +  9 ] + Src[ SrcPitch * 3 + 13 ] + Src[ SrcPitch * 3 + 17 ] + Src[ SrcPitch * 3 + 21 ] + Src[ SrcPitch * 3 + 25 ] + Src[ SrcPitch * 3 + 29 ] +
						Src[ SrcPitch * 4 + 1 ] + Src[ SrcPitch * 4 + 5 ] +	Src[ SrcPitch * 4 +  9 ] + Src[ SrcPitch * 4 + 13 ] + Src[ SrcPitch * 4 + 17 ] + Src[ SrcPitch * 4 + 21 ] + Src[ SrcPitch * 4 + 25 ] + Src[ SrcPitch * 4 + 29 ] +
						Src[ SrcPitch * 5 + 1 ] + Src[ SrcPitch * 5 + 5 ] +	Src[ SrcPitch * 5 +  9 ] + Src[ SrcPitch * 5 + 13 ] + Src[ SrcPitch * 5 + 17 ] + Src[ SrcPitch * 5 + 21 ] + Src[ SrcPitch * 5 + 25 ] + Src[ SrcPitch * 5 + 29 ] +
						Src[ SrcPitch * 6 + 1 ] + Src[ SrcPitch * 6 + 5 ] +	Src[ SrcPitch * 6 +  9 ] + Src[ SrcPitch * 6 + 13 ] + Src[ SrcPitch * 6 + 17 ] + Src[ SrcPitch * 6 + 21 ] + Src[ SrcPitch * 6 + 25 ] + Src[ SrcPitch * 6 + 29 ] +
						Src[ SrcPitch * 7 + 1 ] + Src[ SrcPitch * 7 + 5 ] +	Src[ SrcPitch * 7 +  9 ] + Src[ SrcPitch * 7 + 13 ] + Src[ SrcPitch * 7 + 17 ] + Src[ SrcPitch * 7 + 21 ] + Src[ SrcPitch * 7 + 25 ] + Src[ SrcPitch * 7 + 29 ] ) >> 6 ;
					Dest[ 2 ] = (
						Src[                2 ] + Src[                6 ] + Src[                10 ] + Src[                14 ] + Src[                18 ] + Src[                22 ] + Src[                26 ] + Src[                30 ] +
						Src[ SrcPitch     + 2 ] + Src[ SrcPitch     + 6 ] +	Src[ SrcPitch     + 10 ] + Src[ SrcPitch     + 14 ] + Src[ SrcPitch     + 18 ] + Src[ SrcPitch     + 22 ] + Src[ SrcPitch     + 26 ] + Src[ SrcPitch     + 30 ] +
						Src[ SrcPitch * 2 + 2 ] + Src[ SrcPitch * 2 + 6 ] +	Src[ SrcPitch * 2 + 10 ] + Src[ SrcPitch * 2 + 14 ] + Src[ SrcPitch * 2 + 18 ] + Src[ SrcPitch * 2 + 22 ] + Src[ SrcPitch * 2 + 26 ] + Src[ SrcPitch * 2 + 30 ] +
						Src[ SrcPitch * 3 + 2 ] + Src[ SrcPitch * 3 + 6 ] +	Src[ SrcPitch * 3 + 10 ] + Src[ SrcPitch * 3 + 14 ] + Src[ SrcPitch * 3 + 18 ] + Src[ SrcPitch * 3 + 22 ] + Src[ SrcPitch * 3 + 26 ] + Src[ SrcPitch * 3 + 30 ] +
						Src[ SrcPitch * 4 + 2 ] + Src[ SrcPitch * 4 + 6 ] +	Src[ SrcPitch * 4 + 10 ] + Src[ SrcPitch * 4 + 14 ] + Src[ SrcPitch * 4 + 18 ] + Src[ SrcPitch * 4 + 22 ] + Src[ SrcPitch * 4 + 26 ] + Src[ SrcPitch * 4 + 30 ] +
						Src[ SrcPitch * 5 + 2 ] + Src[ SrcPitch * 5 + 6 ] +	Src[ SrcPitch * 5 + 10 ] + Src[ SrcPitch * 5 + 14 ] + Src[ SrcPitch * 5 + 18 ] + Src[ SrcPitch * 5 + 22 ] + Src[ SrcPitch * 5 + 26 ] + Src[ SrcPitch * 5 + 30 ] +
						Src[ SrcPitch * 6 + 2 ] + Src[ SrcPitch * 6 + 6 ] +	Src[ SrcPitch * 6 + 10 ] + Src[ SrcPitch * 6 + 14 ] + Src[ SrcPitch * 6 + 18 ] + Src[ SrcPitch * 6 + 22 ] + Src[ SrcPitch * 6 + 26 ] + Src[ SrcPitch * 6 + 30 ] +
						Src[ SrcPitch * 7 + 2 ] + Src[ SrcPitch * 7 + 6 ] +	Src[ SrcPitch * 7 + 10 ] + Src[ SrcPitch * 7 + 14 ] + Src[ SrcPitch * 7 + 18 ] + Src[ SrcPitch * 7 + 22 ] + Src[ SrcPitch * 7 + 26 ] + Src[ SrcPitch * 7 + 30 ] ) >> 6 ;
					Dest[ 3 ] = (
						Src[                3 ] + Src[                7 ] + Src[                11 ] + Src[                15 ] + Src[                19 ] + Src[                23 ] + Src[                27 ] + Src[                31 ] +
						Src[ SrcPitch     + 3 ] + Src[ SrcPitch     + 7 ] +	Src[ SrcPitch     + 11 ] + Src[ SrcPitch     + 15 ] + Src[ SrcPitch     + 19 ] + Src[ SrcPitch     + 23 ] + Src[ SrcPitch     + 27 ] + Src[ SrcPitch     + 31 ] +
						Src[ SrcPitch * 2 + 3 ] + Src[ SrcPitch * 2 + 7 ] +	Src[ SrcPitch * 2 + 11 ] + Src[ SrcPitch * 2 + 15 ] + Src[ SrcPitch * 2 + 19 ] + Src[ SrcPitch * 2 + 23 ] + Src[ SrcPitch * 2 + 27 ] + Src[ SrcPitch * 2 + 31 ] +
						Src[ SrcPitch * 3 + 3 ] + Src[ SrcPitch * 3 + 7 ] +	Src[ SrcPitch * 3 + 11 ] + Src[ SrcPitch * 3 + 15 ] + Src[ SrcPitch * 3 + 19 ] + Src[ SrcPitch * 3 + 23 ] + Src[ SrcPitch * 3 + 27 ] + Src[ SrcPitch * 3 + 31 ] +
						Src[ SrcPitch * 4 + 3 ] + Src[ SrcPitch * 4 + 7 ] +	Src[ SrcPitch * 4 + 11 ] + Src[ SrcPitch * 4 + 15 ] + Src[ SrcPitch * 4 + 19 ] + Src[ SrcPitch * 4 + 23 ] + Src[ SrcPitch * 4 + 27 ] + Src[ SrcPitch * 4 + 31 ] +
						Src[ SrcPitch * 5 + 3 ] + Src[ SrcPitch * 5 + 7 ] +	Src[ SrcPitch * 5 + 11 ] + Src[ SrcPitch * 5 + 15 ] + Src[ SrcPitch * 5 + 19 ] + Src[ SrcPitch * 5 + 23 ] + Src[ SrcPitch * 5 + 27 ] + Src[ SrcPitch * 5 + 31 ] +
						Src[ SrcPitch * 6 + 3 ] + Src[ SrcPitch * 6 + 7 ] +	Src[ SrcPitch * 6 + 11 ] + Src[ SrcPitch * 6 + 15 ] + Src[ SrcPitch * 6 + 19 ] + Src[ SrcPitch * 6 + 23 ] + Src[ SrcPitch * 6 + 27 ] + Src[ SrcPitch * 6 + 31 ] +
						Src[ SrcPitch * 7 + 3 ] + Src[ SrcPitch * 7 + 7 ] +	Src[ SrcPitch * 7 + 11 ] + Src[ SrcPitch * 7 + 15 ] + Src[ SrcPitch * 7 + 19 ] + Src[ SrcPitch * 7 + 23 ] + Src[ SrcPitch * 7 + 27 ] + Src[ SrcPitch * 7 + 31 ] ) >> 6 ;

					Src  += 4 * 8 ;
					Dest += 4 ;
				}while( -- i ) ;

				Src  += SrcAddPitch ;
				Dest += DestAddPitch ;
			}while( -- Height ) ;
			break ;
		}

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

// CmpType:比較タイプ( DX_CMP_LESS と DX_CMP_GREATER のみ指定できます )
// CmpParam:比較値( 0.0f～255.0f )
// ClipFillFlag:クリップしたピクセルを特定の色で塗りつぶすか( TRUE:塗りつぶす  FALSE:塗りつぶさない )
// ClipFillColor:クリップしたピクセルに塗る色( GetColorFで取得するもの )
static int GraphFilter_Bright_Clip( GRAPHFILTER_INFO *Info, int CmpType, float CmpParam, int ClipFillFlag, COLOR_F *ClipFillColor )
{
	// 値の補正
	if( CmpType != DX_CMP_LESS && CmpType != DX_CMP_GREATER )
		return -1 ;

	if( ClipFillFlag == TRUE && ClipFillColor == NULL )
		return -1 ;

	CmpParam /= 255.0f ;
	if( CmpParam < 0.0f )
	{
		CmpParam = 0.0f ;
	}
	else
	if( CmpParam > 1.0f )
	{
		CmpParam = 1.0f ;
	}

	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 2 ][ 2 ] =
		{
			"BrightClipLess.pso",
			"BrightClipFillLess.pso",
			"BrightClipGreater.pso",
			"BrightClipFillGreater.pso",
		} ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		int UseShader = 0 ;
		int UseFill ;
		FLOAT4 ParamF4[ 3 ] ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		UseFill = ClipFillFlag == TRUE ? 1 : 0 ;
		switch( CmpType )
		{
		case DX_CMP_GREATER :
			UseShader = 1 ;
			break ;

		case DX_CMP_LESS :
			UseShader = 0 ;
			break ;
		}
		if( GRH.ShaderCode.BrightClipPS[ UseShader ][ UseFill ] < 0 )
		{
			GRH.ShaderCode.BrightClipPS[ UseShader ][ UseFill ] = MemLoadShaderCode( PsoFileName[ UseShader ][ UseFill ], false ) ;
			if( GRH.ShaderCode.BrightClipPS[ UseShader ][ UseFill ] < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ UseShader ][ UseFill ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.BrightClipPS[ UseShader ][ UseFill ], &GRH.ShaderCode.BrightClipPS[ UseShader ][ UseFill ] ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		ParamF4[  0 ].x = CmpParam ;
		ParamF4[  0 ].y = CmpParam ;
		ParamF4[  0 ].z = CmpParam ;
		ParamF4[  0 ].w = CmpParam ;
		ParamF4[  1 ].x = 0.299f ;
		ParamF4[  1 ].y = 0.587f ;
		ParamF4[  1 ].z = 0.114f ;
		ParamF4[  1 ].w = 0.0f ;
		if( ClipFillColor != NULL )
		{
			ParamF4[  2 ].x = ClipFillColor->r ;
			ParamF4[  2 ].y = ClipFillColor->g ;
			ParamF4[  2 ].z = ClipFillColor->b ;
			ParamF4[  2 ].w = ClipFillColor->a ;
		}
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 3, FALSE ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.BrightClipPS[ UseShader ][ UseFill ] ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 3 ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;
		int Temp ;
		BYTE iClipFillColor[ 4 ] ;
		int iCmpParam ;

		iCmpParam = _FTOL( CmpParam * 255.0f * 4096.0f ) ;

		if( ClipFillColor != NULL )
		{
			Temp = _FTOL( ClipFillColor->b * 255.0f ) ;
			if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
			iClipFillColor[ 0 ] = ( BYTE )Temp ;

			Temp = _FTOL( ClipFillColor->g * 255.0f ) ;
			if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
			iClipFillColor[ 1 ] = ( BYTE )Temp ;

			Temp = _FTOL( ClipFillColor->r * 255.0f ) ;
			if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
			iClipFillColor[ 2 ] = ( BYTE )Temp ;

			Temp = _FTOL( ClipFillColor->a * 255.0f ) ;
			if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
			iClipFillColor[ 3 ] = ( BYTE )Temp ;
		}

		if( GraphFilter_SoftImageSetup( Info, FALSE ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		if( ClipFillFlag )
		{
			if( CmpType == DX_CMP_GREATER )
			{
				do
				{
					i = Width ;
					do
					{
						if( Src[ 0 ] * ( int )( 0.114f * 4096.0f ) +
							Src[ 1 ] * ( int )( 0.587f * 4096.0f ) +
							Src[ 2 ] * ( int )( 0.299f * 4096.0f ) > iCmpParam )
						{
							*( ( DWORD * )Dest ) = *( ( DWORD * )iClipFillColor ) ;
						}
						else
						{
							*( ( DWORD * )Dest ) = *( ( DWORD * )Src ) ;
						}

						Src  += 4 ;
						Dest += 4 ;
					}while( -- i ) ;

					Src  += SrcAddPitch ;
					Dest += DestAddPitch ;
				}while( -- Height ) ;
			}
			else
			{
				do
				{
					i = Width ;
					do
					{
						if( Src[ 0 ] * ( int )( 0.114f * 4096.0f ) +
							Src[ 1 ] * ( int )( 0.587f * 4096.0f ) +
							Src[ 2 ] * ( int )( 0.299f * 4096.0f ) < iCmpParam )
						{
							*( ( DWORD * )Dest ) = *( ( DWORD * )iClipFillColor ) ;
						}
						else
						{
							*( ( DWORD * )Dest ) = *( ( DWORD * )Src ) ;
						}

						Src  += 4 ;
						Dest += 4 ;
					}while( -- i ) ;

					Src  += SrcAddPitch ;
					Dest += DestAddPitch ;
				}while( -- Height ) ;
			}
		}
		else
		{
			if( CmpType == DX_CMP_GREATER )
			{
				do
				{
					i = Width ;
					do
					{
						if( Src[ 0 ] * ( int )( 0.114f * 4096.0f ) +
							Src[ 1 ] * ( int )( 0.587f * 4096.0f ) +
							Src[ 2 ] * ( int )( 0.299f * 4096.0f ) > iCmpParam )
						{
						}
						else
						{
							*( ( DWORD * )Dest ) = *( ( DWORD * )Src ) ;
						}

						Src  += 4 ;
						Dest += 4 ;
					}while( -- i ) ;

					Src  += SrcAddPitch ;
					Dest += DestAddPitch ;
				}while( -- Height ) ;
			}
			else
			{
				do
				{
					i = Width ;
					do
					{
						if( Src[ 0 ] * ( int )( 0.114f * 4096.0f ) +
							Src[ 1 ] * ( int )( 0.587f * 4096.0f ) +
							Src[ 2 ] * ( int )( 0.299f * 4096.0f ) < iCmpParam )
						{
						}
						else
						{
							*( ( DWORD * )Dest ) = *( ( DWORD * )Src ) ;
						}

						Src  += 4 ;
						Dest += 4 ;
					}while( -- i ) ;

					Src  += SrcAddPitch ;
					Dest += DestAddPitch ;
				}while( -- Height ) ;
			}
		}

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int GraphFilter_HSB( GRAPHFILTER_INFO *Info, int HueType, float Hue, float Saturation, float Bright )
{
	// 値を補正
	Hue = Hue / 360.0f ;
	if( HueType == 0 )
	{
		if( Hue < -0.5f )
		{
			Hue = -0.5f;
		}
		else
		if( Hue > 0.5f )
		{
			Hue = 0.5f;
		}
	}
	else
	{
		if( Hue < 0.0f )
		{
			Hue = 0.0f;
		}
		else
		if( Hue > 1.0f )
		{
			Hue = 1.0f;
		}
	}
	Hue *= 6.0f ;
	Saturation /= 100.0f;
	if( Saturation < -1.0f )
	{
		Saturation = -1.0f;
	}
	else
	if( Saturation > 1.0f )
	{
		Saturation = 1.0f;
	}
	Bright /= 100.0f;

	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 3 ] =
		{
			"Hsb_RGB_TO_HSB.pso",
			"Hsb_HSB_TO_RGB.pso",
			"Hsb_HSB_HLOCK.pso",
		} ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		int UseShader ;
		FLOAT4 ParamF4[ 3 ] ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		if( HueType == 1 )
		{
			UseShader = 2 ;
		}
		else
		{
			UseShader = Info->Pass ;
		}
		if( GRH.ShaderCode.HsbPS[ UseShader ] < 0 )
		{
			GRH.ShaderCode.HsbPS[ UseShader ] = MemLoadShaderCode( PsoFileName[ UseShader ], false ) ;
			if( GRH.ShaderCode.HsbPS[ UseShader ] < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ UseShader ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.HsbPS[ UseShader ], &GRH.ShaderCode.HsbPS[ UseShader ] ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		ParamF4[ 0 ].x = Hue ;
		ParamF4[ 0 ].y = Saturation > 0.0f ? Saturation * 5.0f : Saturation ;
		ParamF4[ 0 ].z = Bright ;
		ParamF4[ 0 ].w = 0.0f ;
		ParamF4[ 1 ].x = 0.5f ;
		ParamF4[ 1 ].y = 0.5f ;
		ParamF4[ 1 ].z = 0.5f ;
		ParamF4[ 1 ].w = 0.5f ;
		ParamF4[ 2 ].x = 1.0f ;
		ParamF4[ 2 ].y = 1.0f ;
		ParamF4[ 2 ].z = 1.0f ;
		ParamF4[ 2 ].w = 1.0f ;
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 3, FALSE ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.HsbPS[ UseShader ] ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 3 ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;
		int iHue ;
		int iSaturation ;
		int iBright ;
		int iH, iS, iB ;
		int Max ;
		int Min ;
		int Delta ;
		int R, G, B ;

		iHue        = _FTOL( Hue        * 256.0f ) ;
		iSaturation = _FTOL( ( Saturation > 0.0f ? Saturation * 5.0f : Saturation ) * 256.0f ) ;
		iBright     = _FTOL( Bright     * 256.0f ) ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		if( HueType == 1 )
		{
			if( iHue >= 0x600 )
			{
				iHue -= 0x600 ;
			}
			do
			{
				i = Width ;
				do
				{
					B = Src[ 0 ] ;
					G = Src[ 1 ] ;
					R = Src[ 2 ] ;

					if( iBright > 0 )
					{
						B += ( ( 255 - B ) * iBright ) >> 8 ;
						G += ( ( 255 - G ) * iBright ) >> 8 ;
						R += ( ( 255 - R ) * iBright ) >> 8 ;
					}
					else
					{
						B = ( B * ( 256 + iBright ) ) >> 8 ;
						G = ( G * ( 256 + iBright ) ) >> 8 ;
						R = ( R * ( 256 + iBright ) ) >> 8 ;
					}

					Max = R > G ? ( R > B ? R : B ) : ( G > B ? G : B ) ;
					Min = R < G ? ( R < B ? R : B ) : ( G < B ? G : B ) ;
					Delta = Max - Min;

					iB = ( Max + Min ) >> 1 ;
					if( Max == Min )
					{
						iS = 0 ;
					}
					else
					{
						if( iB > 128 )
						{
							iS = 512 - Max - Min; 
						}
						else
						{
							iS = Max + Min;
						}
						iS = ( Delta << 8 ) / iS;
					}

					iH = iHue ;

					iS = ( iS * ( 256 + iSaturation ) ) >> 8 ;
					if( iS > 256 ) iS = 256 ;

					int iHM ;
					iHM = iH & 0xff ;

					if( iH < 0x100 )
					{
						R = 255 ;
						G = iHM ;
						B = 0 ;
					}
					else
					if( iH < 0x200 )
					{
						R = 255 - iHM ;
						G = 255 ;
						B = 0 ;
					}
					else
					if( iH < 0x300 )
					{
						R = 0 ;
						G = 255 ;
						B = iHM ;
					}
					else
					if( iH < 0x400 )
					{
						R = 0 ;
						G = 255 - iHM ;
						B = 255 ;
					}
					else
					if( iH < 0x500 )
					{
						R = iHM ;
						G = 0 ;
						B = 255 ;
					}
					else
					{
						R = 255 ;
						G = 0 ;
						B = 255 - iHM ;
					}

					B += ( ( 128 - B ) * ( 256 - iS ) ) >> 8 ;
					G += ( ( 128 - G ) * ( 256 - iS ) ) >> 8 ;
					R += ( ( 128 - R ) * ( 256 - iS ) ) >> 8 ;

					if( iB <= 128 )
					{
						Dest[ 0 ] = ( BYTE )( ( B * ( iB << 1 ) ) >> 8 ) ;
						Dest[ 1 ] = ( BYTE )( ( G * ( iB << 1 ) ) >> 8 ) ;
						Dest[ 2 ] = ( BYTE )( ( R * ( iB << 1 ) ) >> 8 ) ;
					}
					else
					{
						Dest[ 0 ] = ( BYTE )( B + ( ( ( 255 - B ) * ( ( iB - 128 ) << 1 ) ) >> 8 ) ) ;
						Dest[ 1 ] = ( BYTE )( G + ( ( ( 255 - G ) * ( ( iB - 128 ) << 1 ) ) >> 8 ) ) ;
						Dest[ 2 ] = ( BYTE )( R + ( ( ( 255 - R ) * ( ( iB - 128 ) << 1 ) ) >> 8 ) ) ;
					}

					Dest[ 3 ] = Src[ 3 ] ;

					Src  += 4 ;
					Dest += 4 ;
				}while( -- i ) ;

				Src  += SrcAddPitch ;
				Dest += DestAddPitch ;
			}while( -- Height ) ;
		}
		else
		{
			do
			{
				i = Width ;
				do
				{
					B = Src[ 0 ] ;
					G = Src[ 1 ] ;
					R = Src[ 2 ] ;

					if( iBright > 0 )
					{
						B += ( ( 255 - B ) * iBright ) >> 8 ;
						G += ( ( 255 - G ) * iBright ) >> 8 ;
						R += ( ( 255 - R ) * iBright ) >> 8 ;
					}
					else
					{
						B = ( B * ( 256 + iBright ) ) >> 8 ;
						G = ( G * ( 256 + iBright ) ) >> 8 ;
						R = ( R * ( 256 + iBright ) ) >> 8 ;
					}

					Max = R > G ? ( R > B ? R : B ) : ( G > B ? G : B ) ;
					Min = R < G ? ( R < B ? R : B ) : ( G < B ? G : B ) ;
					Delta = Max - Min;

					iB = ( Max + Min ) >> 1 ;
					if( Max == Min )
					{
						iH = 0 ;
						iS = 0 ;
					}
					else
					{
						int tR, tG, tB ;

						if( iB > 128 )
						{
							iS = 512 - Max - Min; 
						}
						else
						{
							iS = Max + Min;
						}
						iS = ( Delta << 8 ) / iS;

						tB = ( ( Max - B ) << 8 ) / Delta ;
						tG = ( ( Max - G ) << 8 ) / Delta ;
						tR = ( ( Max - R ) << 8 ) / Delta ;
						if( R == Max )
						{
							iH = tB - tG ;
						}
						else
						if( G == Max )
						{
							iH = 0x200 + tR - tB ;
						}
						else
						{
							iH = 0x400 + tG - tR ;
						}
						if( iH < 0 )
						{
							iH += 0x600 ;
						}
					}

					iH += iHue ;
					if( iH < 0 )
					{
						iH += 0x600 ;
					}
					else
					if( iH >= 0x600 )
					{
						iH -= 0x600 ;
					}

					iS = ( iS * ( 256 + iSaturation ) ) >> 8 ;
					if( iS > 256 ) iS = 256 ;

					int iHM ;
					iHM = iH & 0xff ;

					if( iH < 0x100 )
					{
						R = 255 ;
						G = iHM ;
						B = 0 ;
					}
					else
					if( iH < 0x200 )
					{
						R = 255 - iHM ;
						G = 255 ;
						B = 0 ;
					}
					else
					if( iH < 0x300 )
					{
						R = 0 ;
						G = 255 ;
						B = iHM ;
					}
					else
					if( iH < 0x400 )
					{
						R = 0 ;
						G = 255 - iHM ;
						B = 255 ;
					}
					else
					if( iH < 0x500 )
					{
						R = iHM ;
						G = 0 ;
						B = 255 ;
					}
					else
					{
						R = 255 ;
						G = 0 ;
						B = 255 - iHM ;
					}

					B += ( ( 128 - B ) * ( 256 - iS ) ) >> 8 ;
					G += ( ( 128 - G ) * ( 256 - iS ) ) >> 8 ;
					R += ( ( 128 - R ) * ( 256 - iS ) ) >> 8 ;

					if( iB <= 128 )
					{
						Dest[ 0 ] = ( BYTE )( ( B * ( iB << 1 ) ) >> 8 ) ;
						Dest[ 1 ] = ( BYTE )( ( G * ( iB << 1 ) ) >> 8 ) ;
						Dest[ 2 ] = ( BYTE )( ( R * ( iB << 1 ) ) >> 8 ) ;
					}
					else
					{
						Dest[ 0 ] = ( BYTE )( B + ( ( ( 255 - B ) * ( ( iB - 128 ) << 1 ) ) >> 8 ) ) ;
						Dest[ 1 ] = ( BYTE )( G + ( ( ( 255 - G ) * ( ( iB - 128 ) << 1 ) ) >> 8 ) ) ;
						Dest[ 2 ] = ( BYTE )( R + ( ( ( 255 - R ) * ( ( iB - 128 ) << 1 ) ) >> 8 ) ) ;
					}

					Dest[ 3 ] = Src[ 3 ] ;

					Src  += 4 ;
					Dest += 4 ;
				}while( -- i ) ;

				Src  += SrcAddPitch ;
				Dest += DestAddPitch ;
			}while( -- Height ) ;
		}

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int GraphFilter_Invert( GRAPHFILTER_INFO *Info )
{
	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 1 ] =
		{
			"Invert.pso",
		} ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		if( GRH.ShaderCode.InvertPS < 0 )
		{
			GRH.ShaderCode.InvertPS = MemLoadShaderCode( PsoFileName[ 0 ], false ) ;
			if( GRH.ShaderCode.InvertPS < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ 0 ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.InvertPS, &GRH.ShaderCode.InvertPS ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.InvertPS ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		do
		{
			i = Width ;
			do
			{
				Dest[ 0 ] = 255 - Src[ 0 ] ;
				Dest[ 1 ] = 255 - Src[ 1 ] ;
				Dest[ 2 ] = 255 - Src[ 2 ] ;
				Dest[ 3 ] = Src[ 3 ] ;

				Src  += 4 ;
				Dest += 4 ;
			}while( -- i ) ;

			Src  += SrcAddPitch ;
			Dest += DestAddPitch ;
		}while( -- Height ) ;

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int GraphFilter_Level( GRAPHFILTER_INFO *Info, float Min, float Max, float Gamma, float AfterMin, float AfterMax )
{
	// 値を補正
	Min /= 255.0f ;
	Max /= 255.0f ;
	AfterMin /= 255.0f ;
	AfterMax /= 255.0f ;
	if( Min < 0.0f )
	{
		Min = 0.0f ;
	}
	else
	if( Min > 1.0f )
	{
		Min = 1.0f ;
	}
	if( Max < 0.0f )
	{
		Max = 0.0f ;
	}
	else
	if( Max > 1.0f )
	{
		Max = 1.0f ;
	}
	if( Gamma < 0.001f )
	{
		Gamma = 0.001f ;
	}
	if( AfterMin < 0.0f )
	{
		AfterMin = 0.0f ;
	}
	else
	if( AfterMin > 1.0f )
	{
		AfterMin = 1.0f ;
	}
	if( AfterMax < 0.0f )
	{
		AfterMax = 0.0f ;
	}
	else
	if( AfterMax > 1.0f )
	{
		AfterMax = 1.0f ;
	}
	if( Min > Max ) Min = Max ;
	if( AfterMin > AfterMax ) AfterMin = AfterMax ;

	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 1 ] =
		{
			"Level.pso",
		} ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		FLOAT4 ParamF4[ 1 ] ;
		int Always ;

		// NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// ガンマ補正テーブルのセットアップ
		Always = FALSE ;
		if( GRH.ShaderCode.GammaTex < 0 )
		{
			SETUP_GRAPHHANDLE_GPARAM GParam ;

			InitSetupGraphHandleGParam_Normal_NonDrawValid( &GParam, 32, FALSE, FALSE ) ;

			GRH.ShaderCode.GammaTex = MakeGraph_UseGParam( &GParam, 256, 1, FALSE, FALSE ) ;
			NS_SetDeleteHandleFlag( GRH.ShaderCode.GammaTex, &GRH.ShaderCode.GammaTex ) ;
			GRH.ShaderCode.PrevGamma = -10000000.0f ;
			Always = TRUE ;
		}
		if( Always == TRUE || _FABS( GRH.ShaderCode.PrevGamma - Gamma ) > 0.0001f )
		{
			BASEIMAGE GammaBaseImage ;
			NS_CreateXRGB8ColorBaseImage( 256, 1, &GammaBaseImage ) ;
			if( GammaBaseImage.GraphData != NULL )
			{
				int i ;
				float Param ;
				float GammaRev ;
				BYTE *Dest ;

				Dest = ( BYTE * )GammaBaseImage.GraphData ;
				GammaRev = 1.0f / Gamma ;
				for( i = 0 ; i < 256 ; i ++, Dest += 4 )
				{
					Param = _POW( ( float )i / 255.0f, GammaRev ) * 255.0f ;
					if( Param > 255.0f )
					{
						*Dest = 255 ;
					}
					else
					{
						*Dest = ( BYTE )_FTOL( Param ) ;
					}
					Dest[ 1 ] = Dest[ 0 ] ;
					Dest[ 2 ] = Dest[ 0 ] ;
					Dest[ 3 ] = Dest[ 0 ] ;
				}
				NS_BltBmpOrGraphImageToGraph( NULL, NULL, NULL, FALSE, &GammaBaseImage, NULL, 0, 0, GRH.ShaderCode.GammaTex ) ;

				GRH.ShaderCode.PrevGamma = Gamma ;

				NS_ReleaseBaseImage( &GammaBaseImage ) ;
			}
		}

		// 使用するシェーダーのセットアップ
		if( GRH.ShaderCode.LevelPS < 0 )
		{
			GRH.ShaderCode.LevelPS = MemLoadShaderCode( PsoFileName[ 0 ], false ) ;
			if( GRH.ShaderCode.LevelPS < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ 0 ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.LevelPS, &GRH.ShaderCode.LevelPS ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		ParamF4[ 0 ].x = Min ;
		ParamF4[ 0 ].y = 1.0f / ( Max - Min ) ;
		ParamF4[ 0 ].z = AfterMin ;
		ParamF4[ 0 ].w = AfterMax ;
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 1, FALSE ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.LevelPS ) ;

		NS_SetUseTextureToShader( 1, GRH.ShaderCode.GammaTex ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 1 ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;
		int iMin ;
		int iMax ;
		int iMinMaxLen ;
		int iAfterMin ;
		int iAfterMax ;
		int iAfterMinMaxLen ;
		int iAfterMin256 ;
		int R, G, B ;
		static float PrevGamma = -10000000.0f ;
		static int GammaTable[ 256 ] ;

		if( _FABS( PrevGamma - Gamma ) > 0.0001f )
		{
			int i ;
			float Param ;
			float GammaRev ;

			GammaRev = 1.0f / Gamma ;
			for( i = 0 ; i < 256 ; i ++ )
			{
				Param = _POW( ( float )i / 255.0f, GammaRev ) * 255.0f ;
				if( Param > 255.0f )
				{
					GammaTable[ i ] = 255 ;
				}
				else
				{
					GammaTable[ i ] = _FTOL( Param ) ;
				}
			}

			PrevGamma = Gamma ;
		}

		iMin = _FTOL( Min * 255 ) ;
		iMax = _FTOL( Max * 255 ) ;
		iMinMaxLen = iMax - iMin ;
		iAfterMin = _FTOL( AfterMin * 255 ) ;
		iAfterMax = _FTOL( AfterMax * 255 ) ;
		iAfterMinMaxLen = iAfterMax - iAfterMin ;
		iAfterMin256 = iAfterMin << 8 ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		do
		{
			i = Width ;
			do
			{
				B = ( ( Src[ 0 ] - iMin ) << 8 ) / iMinMaxLen;
				B = B < 0 ? GammaTable[ 0 ] : ( B > 255 ?  GammaTable[ 255 ] : GammaTable[ B ] ) ;

				G = ( ( Src[ 1 ] - iMin ) << 8 ) / iMinMaxLen;
				G = G < 0 ? GammaTable[ 0 ] : ( G > 255 ?  GammaTable[ 255 ] : GammaTable[ G ] ) ;

				R = ( ( Src[ 2 ] - iMin ) << 8 ) / iMinMaxLen;
				R = R < 0 ? GammaTable[ 0 ] : ( R > 255 ?  GammaTable[ 255 ] : GammaTable[ R ] ) ;

				Dest[ 0 ] = ( BYTE )( ( iAfterMin256 + iAfterMinMaxLen * B ) >> 8 ) ;
				Dest[ 1 ] = ( BYTE )( ( iAfterMin256 + iAfterMinMaxLen * G ) >> 8 ) ;
				Dest[ 2 ] = ( BYTE )( ( iAfterMin256 + iAfterMinMaxLen * R ) >> 8 ) ;
				Dest[ 3 ] = Src[ 3 ] ;

				Src  += 4 ;
				Dest += 4 ;
			}while( -- i ) ;

			Src  += SrcAddPitch ;
			Dest += DestAddPitch ;
		}while( -- Height ) ;

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int GraphFilter_TwoColor( GRAPHFILTER_INFO *Info, float Threshold, COLOR_F *LowColor, COLOR_F *HighColor )
{
	// 値を補正
	if( LowColor == NULL || HighColor == NULL )
		return -1 ;

	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		Threshold /= 255.0f ;

		static const char *PsoFileName[ 1 ] =
		{
			"TwoColor.pso",
		} ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		FLOAT4 ParamF4[ 3 ] ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		if( GRH.ShaderCode.TwoColorPS < 0 )
		{
			GRH.ShaderCode.TwoColorPS = MemLoadShaderCode( PsoFileName[ 0 ], false ) ;
			if( GRH.ShaderCode.TwoColorPS < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ 0 ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.TwoColorPS, &GRH.ShaderCode.TwoColorPS ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		ParamF4[ 0 ].x = 0.29900f ;
		ParamF4[ 0 ].y = 0.58700f ;
		ParamF4[ 0 ].z = 0.11400f ;
		ParamF4[ 0 ].w = Threshold ;
		ParamF4[ 1 ].x = LowColor->r ;
		ParamF4[ 1 ].y = LowColor->g ;
		ParamF4[ 1 ].z = LowColor->b ;
		ParamF4[ 1 ].w = LowColor->a ;
		ParamF4[ 2 ].x = HighColor->r ;
		ParamF4[ 2 ].y = HighColor->g ;
		ParamF4[ 2 ].z = HighColor->b ;
		ParamF4[ 2 ].w = HighColor->a ;
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 3, FALSE ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.TwoColorPS ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 3 ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;
		int Temp ;
		int iThreshold ;
		BYTE iLowColor[ 4 ] ;
		BYTE iHighColor[ 4 ] ;

		iThreshold = _FTOL( Threshold * 4096.0f ) ;

		Temp = _FTOL( LowColor->b * 255.0f ) ;
		if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
		iLowColor[ 0 ] = ( BYTE )Temp ;

		Temp = _FTOL( LowColor->g * 255.0f ) ;
		if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
		iLowColor[ 1 ] = ( BYTE )Temp ;

		Temp = _FTOL( LowColor->r * 255.0f ) ;
		if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
		iLowColor[ 2 ] = ( BYTE )Temp ;

		Temp = _FTOL( LowColor->a * 255.0f ) ;
		if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
		iLowColor[ 3 ] = ( BYTE )Temp ;


		Temp = _FTOL( HighColor->b * 255.0f ) ;
		if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
		iHighColor[ 0 ] = ( BYTE )Temp ;

		Temp = _FTOL( HighColor->g * 255.0f ) ;
		if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
		iHighColor[ 1 ] = ( BYTE )Temp ;

		Temp = _FTOL( HighColor->r * 255.0f ) ;
		if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
		iHighColor[ 2 ] = ( BYTE )Temp ;

		Temp = _FTOL( HighColor->a * 255.0f ) ;
		if( Temp < 0 ) Temp = 0 ; else if( Temp > 255 ) Temp = 255 ;
		iHighColor[ 3 ] = ( BYTE )Temp ;


		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		do
		{
			i = Width ;
			do
			{
				if( Src[ 0 ] * ( int )( 0.114f * 4096.0f ) +
					Src[ 1 ] * ( int )( 0.587f * 4096.0f ) +
					Src[ 2 ] * ( int )( 0.299f * 4096.0f ) < iThreshold )
				{
					*( ( DWORD * )Dest ) = *( ( DWORD * )iLowColor ) ;
				}
				else
				{
					*( ( DWORD * )Dest ) = *( ( DWORD * )iHighColor ) ;
				}

				Src  += 4 ;
				Dest += 4 ;
			}while( -- i ) ;

			Src  += SrcAddPitch ;
			Dest += DestAddPitch ;
		}while( -- Height ) ;

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int	GraphFilter_GradientMap( GRAPHFILTER_INFO *Info, int MapGrHandle, int Reverse )
{
	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 2 ] =
		{
			"GradientMap.pso",
			"GradientMapRev.pso",
		} ;
		int UseShader ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		FLOAT4 ParamF4[ 1 ] ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		UseShader = Reverse ? 1 : 0 ;
		if( GRH.ShaderCode.GradientMapPS[ UseShader ] < 0 )
		{
			GRH.ShaderCode.GradientMapPS[ UseShader ] = MemLoadShaderCode( PsoFileName[ UseShader ], false ) ;
			if( GRH.ShaderCode.GradientMapPS[ UseShader ] < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ UseShader ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.GradientMapPS[ UseShader ], &GRH.ShaderCode.GradientMapPS[ UseShader ] ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 2 ) ;

		ParamF4[ 0 ].x = 0.29900f ;
		ParamF4[ 0 ].y = 0.58700f ;
		ParamF4[ 0 ].z = 0.11400f ;
		ParamF4[ 0 ].w = 0.0f ;
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 1, FALSE ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.GradientMapPS[ UseShader ] ) ;

		NS_SetUseTextureToShader( 1, MapGrHandle ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 1 ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;
		BASEIMAGE GradImage ;
		DWORD GradMap[ 256 ] ;

		// グラデーションマップの配列をセットアップする
		{
			int GradWidth, GradHeight ;

			if( NS_GetGraphSize( MapGrHandle, &GradWidth, &GradHeight ) < 0 )
				return -1 ;

			if( GraphFilter_GetSoftImage( MapGrHandle, &GradImage, NULL ) < 0 )
				return -1 ;

			if( Reverse )
			{
				for( i = 0 ; i < 256 ; i ++ )
					GradMap[ 255 - i ] = *( ( DWORD * )( ( BYTE * )GradImage.GraphData + GradWidth * i / 256 * 4 ) ) ;
			}
			else
			{
				for( i = 0 ; i < 256 ; i ++ )
					GradMap[ i ] = *( ( DWORD * )( ( BYTE * )GradImage.GraphData + GradWidth * i / 256 * 4 ) ) ;
			}

			NS_ReleaseBaseImage( &GradImage ) ;
		}

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		do
		{
			i = Width ;
			do
			{
				*( ( DWORD * )Dest ) = GradMap[ ( Src[ 0 ] * ( int )( 0.114f * 4096.0f ) +
												  Src[ 1 ] * ( int )( 0.587f * 4096.0f ) +
												  Src[ 2 ] * ( int )( 0.299f * 4096.0f ) ) >> 12 ] ;

				Src  += 4 ;
				Dest += 4 ;
			}while( -- i ) ;

			Src  += SrcAddPitch ;
			Dest += DestAddPitch ;
		}while( -- Height ) ;

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int	GraphFilter_PremulAlpha( GRAPHFILTER_INFO *Info )
{
	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 1 ] =
		{
			"PremultipliedAlpha.pso",
		} ;
		int UseShader ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		UseShader = 0 ;
		if( GRH.ShaderCode.PreMulAlphaPS < 0 )
		{
			GRH.ShaderCode.PreMulAlphaPS = MemLoadShaderCode( PsoFileName[ UseShader ], false ) ;
			if( GRH.ShaderCode.PreMulAlphaPS < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ UseShader ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.PreMulAlphaPS, &GRH.ShaderCode.PreMulAlphaPS ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.PreMulAlphaPS ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		do
		{
			i = Width ;
			do
			{
				Dest[ 0 ] = ( Src[ 0 ] * Src[ 3 ] ) >> 8 ;
				Dest[ 1 ] = ( Src[ 1 ] * Src[ 3 ] ) >> 8 ;
				Dest[ 2 ] = ( Src[ 2 ] * Src[ 3 ] ) >> 8 ;
				Dest[ 3 ] = Src[ 3 ] ;

				Src  += 4 ;
				Dest += 4 ;
			}while( -- i ) ;

			Src  += SrcAddPitch ;
			Dest += DestAddPitch ;
		}while( -- Height ) ;

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int	GraphFilter_InterpAlpha( GRAPHFILTER_INFO *Info )
{
	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 1 ] =
		{
			"InterpolatedAlpha.pso",
		} ;
		int UseShader ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		UseShader = 0 ;
		if( GRH.ShaderCode.InterpAlphaPS < 0 )
		{
			GRH.ShaderCode.InterpAlphaPS = MemLoadShaderCode( PsoFileName[ UseShader ], false ) ;
			if( GRH.ShaderCode.InterpAlphaPS < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ UseShader ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.InterpAlphaPS, &GRH.ShaderCode.InterpAlphaPS ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 1 ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.InterpAlphaPS ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Dest ;
		DWORD tmp ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD DestAddPitch ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch  = Info->SrcImage.Pitch  - Width * 4 ;
		DestAddPitch = Info->DestImage.Pitch - Width * 4 ;

		do
		{
			i = Width ;
			do
			{
				if( Src[ 3 ] == 0 )
				{
					Dest[ 0 ] = 0 ;
					Dest[ 1 ] = 0 ;
					Dest[ 2 ] = 0 ;
				}
				else
				{
					tmp = Src[ 0 ] * 255 / Src[ 3 ] ; Dest[ 0 ] = ( BYTE )( tmp > 255 ? 255 : tmp ) ;
					tmp = Src[ 1 ] * 255 / Src[ 3 ] ; Dest[ 1 ] = ( BYTE )( tmp > 255 ? 255 : tmp ) ;
					tmp = Src[ 2 ] * 255 / Src[ 3 ] ; Dest[ 2 ] = ( BYTE )( tmp > 255 ? 255 : tmp ) ;
				}
				Dest[ 3 ] = Src[ 3 ] ;

				Src  += 4 ;
				Dest += 4 ;
			}while( -- i ) ;

			Src  += SrcAddPitch ;
			Dest += DestAddPitch ;
		}while( -- Height ) ;

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int	GraphBlend_Basic( GRAPHFILTER_INFO *Info )
{
	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 17 ] =
		{
			"BasBF_Normal.pso",			// DX_GRAPH_BLEND_NORMAL
			NULL,						// DX_GRAPH_BLEND_RGBA_SELECT_MIX
			"BasBF_Multiple.pso",		// DX_GRAPH_BLEND_MULTIPLE
			"BasBF_Difference.pso",		// DX_GRAPH_BLEND_DIFFERENCE
			"BasBF_Add.pso",			// DX_GRAPH_BLEND_ADD
			"BasBF_Screen.pso",			// DX_GRAPH_BLEND_SCREEN
			"BasBF_Overlay.pso",		// DX_GRAPH_BLEND_OVERLAY
			"BasBF_Dodge.pso",			// DX_GRAPH_BLEND_DODGE
			"BasBF_Burn.pso",			// DX_GRAPH_BLEND_BURN
			"BasBF_Darken.pso",			// DX_GRAPH_BLEND_DARKEN
			"BasBF_Lighten.pso",		// DX_GRAPH_BLEND_LIGHTEN
			"BasBF_SoftLight.pso",		// DX_GRAPH_BLEND_SOFTLIGHT
			"BasBF_HardLight.pso",		// DX_GRAPH_BLEND_HARDLIGHT
			"BasBF_Exclusion.pso",		// DX_GRAPH_BLEND_EXCLUSION
			"BasBF_Normal_AlphaCh.pso",	// DX_GRAPH_BLEND_NORMAL_ALPHACH
			"BasBF_Add_AlphaCh.pso",	// DX_GRAPH_BLEND_ADD_ALPHACH
			"BasBF_Multiple_AOnly.pso",	// DX_GRAPH_BLEND_MULTIPLE_A_ONLY
		} ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		int UseShader ;
		FLOAT4 ParamF4[ 2 ] ;

//		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		UseShader = Info->FilterOrBlendType ;
		if( GRH.ShaderCode.BasicBlendPS[ UseShader ] < 0 )
		{
			GRH.ShaderCode.BasicBlendPS[ UseShader ] = MemLoadShaderCode( PsoFileName[ UseShader ], false ) ;
			if( GRH.ShaderCode.BasicBlendPS[ UseShader ] < 0 )
			{
				DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ UseShader ] )) ;
				return -1 ;
			}
			NS_SetDeleteHandleFlag( GRH.ShaderCode.BasicBlendPS[ UseShader ], &GRH.ShaderCode.BasicBlendPS[ UseShader ] ) ;
		}

		LibShader_PushShaderParam( &DrawParamTemp, 2 ) ;

		ParamF4[ 0 ].x = Info->BlendRatio ;
		ParamF4[ 0 ].y = Info->BlendRatio ;
		ParamF4[ 0 ].z = Info->BlendRatio ;
		ParamF4[ 0 ].w = Info->BlendRatio ;
		ParamF4[ 1 ].x = 1.0f ;
		ParamF4[ 1 ].y = 1.0f ;
		ParamF4[ 1 ].z = 1.0f ;
		ParamF4[ 1 ].w = 1.0f ;
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 2, FALSE ) ;

		NS_SetUsePixelShader( GRH.ShaderCode.BasicBlendPS[ UseShader ] ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 2 ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Blend ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD BlendAddPitch ;
		DWORD DestAddPitch ;
		int R, G, B, A ;
		int BlendRatio ;
		int TempBlendRatio ;
		float fRGB[ 4 ] ;
		int iRGB[ 4 ] ;

		fRGB[ 3 ] = 0.0f ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		BlendRatio = _FTOL( Info->BlendRatio * 256.0f ) ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Blend = ( BYTE * )Info->BlendImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch   = Info->SrcImage.Pitch   - Width * 4 ;
		BlendAddPitch = Info->BlendImage.Pitch - Width * 4 ;
		DestAddPitch  = Info->DestImage.Pitch  - Width * 4 ;

		switch( Info->FilterOrBlendType )
		{
		case DX_GRAPH_BLEND_NORMAL :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;
						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( Blend[ 0 ] - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( Blend[ 1 ] - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( Blend[ 2 ] - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_MULTIPLE :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;
						B = ( Src[ 0 ] * Blend[ 0 ] ) >> 8 ;
						G = ( Src[ 1 ] * Blend[ 1 ] ) >> 8 ;
						R = ( Src[ 2 ] * Blend[ 2 ] ) >> 8 ;
						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_DIFFERENCE :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;
						B = Src[ 0 ] - Blend[ 0 ] ;
						G = Src[ 1 ] - Blend[ 1 ] ;
						R = Src[ 2 ] - Blend[ 2 ] ;
						if( B < 0 ) B = 0 ;
						if( G < 0 ) G = 0 ;
						if( R < 0 ) R = 0 ;
						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_ADD :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;
						B = Src[ 0 ] + Blend[ 0 ] ;
						G = Src[ 1 ] + Blend[ 1 ] ;
						R = Src[ 2 ] + Blend[ 2 ] ;
						if( B > 255 ) B = 255 ;
						if( G > 255 ) G = 255 ;
						if( R > 255 ) R = 255 ;
						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_SCREEN :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;
						B = 255 - ( ( ( 255 - Src[ 0 ] ) * ( 255 - Blend[ 0 ] ) ) >> 8 ) ;
						G = 255 - ( ( ( 255 - Src[ 1 ] ) * ( 255 - Blend[ 1 ] ) ) >> 8 ) ;
						R = 255 - ( ( ( 255 - Src[ 2 ] ) * ( 255 - Blend[ 2 ] ) ) >> 8 ) ;
						if( B > 255 ) B = 255 ;
						if( G > 255 ) G = 255 ;
						if( R > 255 ) R = 255 ;
						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_OVERLAY :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;

						if( Src[ 0 ] < 128 )
						{
							B = ( Src[ 0 ] * Blend[ 0 ] * 2 ) >> 8 ;
						}
						else
						{
							B = ( ( 2 * ( ( ( Src[ 0 ] + Blend[ 0 ] ) << 8 ) - Src[ 0 ] * Blend[ 0 ] ) ) >> 8 ) - 255 ;
						}
						if( B > 255 ) B = 255 ;

						if( Src[ 1 ] < 128 )
						{
							G = ( Src[ 1 ] * Blend[ 1 ] * 2 ) >> 8 ;
						}
						else
						{
							G = ( ( 2 * ( ( ( Src[ 1 ] + Blend[ 1 ] ) << 8 ) - Src[ 1 ] * Blend[ 1 ] ) ) >> 8 ) - 255 ;
						}
						if( G > 255 ) G = 255 ;

						if( Src[ 2 ] < 128 )
						{
							R = ( Src[ 2 ] * Blend[ 2 ] * 2 ) >> 8 ;
						}
						else
						{
							R = ( ( 2 * ( ( ( Src[ 2 ] + Blend[ 2 ] ) << 8 ) - Src[ 2 ] * Blend[ 2 ] ) ) >> 8 ) - 255 ;
						}
						if( R > 255 ) R = 255 ;

						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_DODGE :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;

						if( Blend[ 0 ] < 255 )
						{
							B = ( Src[ 0 ] << 8 ) / ( 255 - Blend[ 0 ] ) ;
							if( B > 255 ) B = 255 ;
						}
						else
						{
							B = 255 ;
						}

						if( Blend[ 1 ] < 255 )
						{
							G = ( Src[ 1 ] << 8 ) / ( 255 - Blend[ 1 ] ) ;
							if( G > 255 ) G = 255 ;
						}
						else
						{
							G = 255 ;
						}

						if( Blend[ 2 ] < 255 )
						{
							R = ( Src[ 2 ] << 8 ) / ( 255 - Blend[ 2 ] ) ;
							if( R > 255 ) R = 255 ;
						}
						else
						{
							R = 255 ;
						}

						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_BURN :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;

						B = 255 - ( ( 255 - Src[ 0 ] ) << 8 ) / ( Blend[ 0 ] + 1 ) ;
						if( B < 0 ) B = 0 ;

						G = 255 - ( ( 255 - Src[ 1 ] ) << 8 ) / ( Blend[ 1 ] + 1 ) ;
						if( G < 0 ) G = 0 ;

						R = 255 - ( ( 255 - Src[ 2 ] ) << 8 ) / ( Blend[ 2 ] + 1 ) ;
						if( R < 0 ) R = 0 ;

						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_DARKEN :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;

						B = Src[ 0 ] < Blend[ 0 ] ? Src[ 0 ] : Blend[ 0 ] ;
						G = Src[ 1 ] < Blend[ 1 ] ? Src[ 1 ] : Blend[ 1 ] ;
						R = Src[ 2 ] < Blend[ 2 ] ? Src[ 2 ] : Blend[ 2 ] ;

						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_LIGHTEN :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;

						B = Src[ 0 ] > Blend[ 0 ] ? Src[ 0 ] : Blend[ 0 ] ;
						G = Src[ 1 ] > Blend[ 1 ] ? Src[ 1 ] : Blend[ 1 ] ;
						R = Src[ 2 ] > Blend[ 2 ] ? Src[ 2 ] : Blend[ 2 ] ;

						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_SOFTLIGHT :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;

						if( Blend[ 0 ] < 128 )
						{
							fRGB[ 0 ] = _POW( Src[ 0 ] / 255.0f, ( 1.0f - Blend[ 0 ] / 255.0f ) * 2.0f ) ;
						}
						else
						{
							fRGB[ 0 ] = _POW( Src[ 0 ] / 255.0f, 0.5f / ( Blend[ 0 ] / 255.0f ) ) ;
						}

						if( Blend[ 1 ] < 128 )
						{
							fRGB[ 1 ] = _POW( Src[ 1 ] / 255.0f, ( 1.0f - Blend[ 1 ] / 255.0f ) * 2.0f ) ;
						}
						else
						{
							fRGB[ 1 ] = _POW( Src[ 1 ] / 255.0f, 0.5f / ( Blend[ 1 ] / 255.0f ) ) ;
						}

						if( Blend[ 2 ] < 128 )
						{
							fRGB[ 2 ] = _POW( Src[ 2 ] / 255.0f, ( 1.0f - Blend[ 2 ] / 255.0f ) * 2.0f ) ;
						}
						else
						{
							fRGB[ 2 ] = _POW( Src[ 2 ] / 255.0f, 0.5f / ( Blend[ 2 ] / 255.0f ) ) ;
						}

						fRGB[ 0 ] *= 255.0f ;
						fRGB[ 1 ] *= 255.0f ;
						fRGB[ 2 ] *= 255.0f ;
						_FTOL4( fRGB, iRGB ) ;

						B = iRGB[ 0 ] < 0 ? 0 : ( iRGB[ 0 ] > 255 ? 255 : iRGB[ 0 ] ) ;
						G = iRGB[ 1 ] < 0 ? 0 : ( iRGB[ 1 ] > 255 ? 255 : iRGB[ 1 ] ) ;
						R = iRGB[ 2 ] < 0 ? 0 : ( iRGB[ 2 ] > 255 ? 255 : iRGB[ 2 ] ) ;

						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_HARDLIGHT :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;

						if( Blend[ 0 ] < 128 )
						{
							B = ( Src[ 0 ] * Blend[ 0 ] * 2 ) >> 8 ;
						}
						else
						{
							B = ( ( 2 * ( ( ( Src[ 0 ] + Blend[ 0 ] ) << 8 ) - ( Src[ 0 ] * Blend[ 0 ] ) ) ) >> 8 ) - 255 ;
						}
						if( B > 255 ) B = 255 ;

						if( Blend[ 1 ] < 128 )
						{
							G = ( Src[ 1 ] * Blend[ 1 ] * 2 ) >> 8 ;
						}
						else
						{
							G = ( ( 2 * ( ( ( Src[ 1 ] + Blend[ 1 ] ) << 8 ) - ( Src[ 1 ] * Blend[ 1 ] ) ) ) >> 8 ) - 255 ;
						}
						if( G > 255 ) G = 255 ;

						if( Blend[ 2 ] < 128 )
						{
							R = ( Src[ 2 ] * Blend[ 2 ] * 2 ) >> 8 ;
						}
						else
						{
							R = ( ( 2 * ( ( ( Src[ 2 ] + Blend[ 2 ] ) << 8 ) - ( Src[ 2 ] * Blend[ 2 ] ) ) ) >> 8 ) - 255 ;
						}
						if( R > 255 ) R = 255 ;

						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_EXCLUSION :
			{
				do
				{
					i = Width ;
					do
					{
						TempBlendRatio = BlendRatio * Blend[ 3 ] ;

						B = ( ( ( Src[ 0 ] + Blend[ 0 ] ) << 8 ) - 2 * ( Src[ 0 ] * Blend[ 0 ] ) ) >> 8 ;
						if( B > 255 ) B = 255 ;

						G = ( ( ( Src[ 1 ] + Blend[ 1 ] ) << 8 ) - 2 * ( Src[ 1 ] * Blend[ 1 ] ) ) >> 8 ;
						if( G > 255 ) G = 255 ;

						R = ( ( ( Src[ 2 ] + Blend[ 2 ] ) << 8 ) - 2 * ( Src[ 2 ] * Blend[ 2 ] ) ) >> 8 ;
						if( R > 255 ) R = 255 ;

						Dest[ 0 ] = ( BYTE )( ( ( Src[ 0 ] << 16 ) + ( B - Src[ 0 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 1 ] = ( BYTE )( ( ( Src[ 1 ] << 16 ) + ( G - Src[ 1 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 2 ] = ( BYTE )( ( ( Src[ 2 ] << 16 ) + ( R - Src[ 2 ] ) * TempBlendRatio ) >> 16 ) ;
						Dest[ 3 ] = Src[ 3 ] ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_NORMAL_ALPHACH :
			{
				DWORD TempAlpha ;
				DWORD ReverseBlendAlpha ;
				DWORD BlendAlpha ;

				do
				{
					i = Width ;
					do
					{
						BlendAlpha = ( Blend[ 3 ] * BlendRatio ) >> 8 ;

						ReverseBlendAlpha = 256 - BlendAlpha ;
						TempAlpha = ReverseBlendAlpha * Src[ 3 ] + ( BlendAlpha << 8 ) ;
						if( TempAlpha != 0 )
						{
							Dest[ 0 ] = ( BYTE )( ( ReverseBlendAlpha * Src[ 3 ] * Src[ 0 ] + ( ( BlendAlpha * Blend[ 0 ] ) << 8 ) ) / TempAlpha ) ;
							Dest[ 1 ] = ( BYTE )( ( ReverseBlendAlpha * Src[ 3 ] * Src[ 1 ] + ( ( BlendAlpha * Blend[ 1 ] ) << 8 ) ) / TempAlpha ) ;
							Dest[ 2 ] = ( BYTE )( ( ReverseBlendAlpha * Src[ 3 ] * Src[ 2 ] + ( ( BlendAlpha * Blend[ 2 ] ) << 8 ) ) / TempAlpha ) ;
							Dest[ 3 ] = ( BYTE )( TempAlpha >> 8 ) ;
						}

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_ADD_ALPHACH :
			{
				DWORD TempAlpha ;
				DWORD TempC ;
				DWORD BlendAlpha ;

				do
				{
					i = Width ;
					do
					{
						BlendAlpha = ( Blend[ 3 ] * BlendRatio ) >> 8 ;
						TempAlpha = ( ( 256 - BlendAlpha ) * Src[ 3 ] + ( BlendAlpha << 8 ) ) >> 8 ;
						if( TempAlpha != 0 )
						{
							TempC = ( Src[ 3 ] * Src[ 0 ] + BlendAlpha * Blend[ 0 ] ) / TempAlpha ;
							Dest[ 0 ] = TempC > 255 ? 255 : ( BYTE )TempC ;

							TempC = ( Src[ 3 ] * Src[ 1 ] + BlendAlpha * Blend[ 1 ] ) / TempAlpha ;
							Dest[ 1 ] = TempC > 255 ? 255 : ( BYTE )TempC ;

							TempC = ( Src[ 3 ] * Src[ 2 ] + BlendAlpha * Blend[ 2 ] ) / TempAlpha ;
							Dest[ 2 ] = TempC > 255 ? 255 : ( BYTE )TempC ;

							Dest[ 3 ] = ( BYTE )( TempAlpha ) ;
						}

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;

		case DX_GRAPH_BLEND_MULTIPLE_A_ONLY :
			{
				TempBlendRatio = BlendRatio * 255 ;
				do
				{
					i = Width ;
					do
					{
						A = ( Src[ 3 ] * Blend[ 3 ] ) >> 8 ;
						Dest[ 0 ] = Src[ 0 ] ;
						Dest[ 1 ] = Src[ 1 ] ;
						Dest[ 2 ] = Src[ 2 ] ;
						Dest[ 3 ] = ( BYTE )( ( ( Src[ 3 ] << 16 ) + ( A - Src[ 3 ] ) * TempBlendRatio ) >> 16 ) ;

						Src   += 4 ;
						Blend += 4 ;
						Dest  += 4 ;
					}while( -- i ) ;

					Src   += SrcAddPitch ;
					Blend += SrcAddPitch ;
					Dest  += DestAddPitch ;
				}while( -- Height ) ;
			}
			break ;
		}

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

static int	GraphBlend_RGBA_Select_Mix( GRAPHFILTER_INFO *Info, int SelectR, int SelectG, int SelectB, int SelectA )
{
	// シェーダーが使えるかどうかで処理を分岐
	if( GRH.UseShader == TRUE )
	{
		static const char *PsoFileName[ 1 ] =
		{
			"RGBAMix_Base.pso",
		} ;
		static const char *CharTable[ 4 ] =
		{
			"R", "G", "B", "A"
		};
		int *PixelShaderHandle ;
		LIBSHADER_DRAWPARAMTEMP DrawParamTemp ;
		FLOAT4 ParamF4[ 2 ] ;
		char FileName[ 64 ] ;
		int SrcBlendReverse = FALSE ;
		int HandleTemp ;
		int SrcOnlyFlag = FALSE ;

		NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;

		// 使用するシェーダーのセットアップ
		if( SelectR >= DX_RGBA_SELECT_SRC_R && SelectR <= DX_RGBA_SELECT_SRC_A &&
			SelectG >= DX_RGBA_SELECT_SRC_R && SelectG <= DX_RGBA_SELECT_SRC_A &&
			SelectB >= DX_RGBA_SELECT_SRC_R && SelectB <= DX_RGBA_SELECT_SRC_A &&
			SelectA >= DX_RGBA_SELECT_SRC_R && SelectA <= DX_RGBA_SELECT_SRC_A )
		{
			SrcOnlyFlag = TRUE ;
		}
		else
		if( SelectR >= DX_RGBA_SELECT_BLEND_R && SelectR <= DX_RGBA_SELECT_BLEND_A &&
			SelectG >= DX_RGBA_SELECT_BLEND_R && SelectG <= DX_RGBA_SELECT_BLEND_A &&
			SelectB >= DX_RGBA_SELECT_BLEND_R && SelectB <= DX_RGBA_SELECT_BLEND_A &&
			SelectA >= DX_RGBA_SELECT_BLEND_R && SelectA <= DX_RGBA_SELECT_BLEND_A )
		{
			SelectR -= DX_RGBA_SELECT_BLEND_R ;
			SelectG -= DX_RGBA_SELECT_BLEND_R ;
			SelectB -= DX_RGBA_SELECT_BLEND_R ;
			SelectA -= DX_RGBA_SELECT_BLEND_R ;

			SrcOnlyFlag = TRUE ;
			SrcBlendReverse = TRUE ;

			HandleTemp = Info->BlendGrHandle ;
			Info->BlendGrHandle = Info->SrcGrHandle ;
			Info->SrcGrHandle = HandleTemp ;
		}

		if( SrcOnlyFlag )
		{
			PixelShaderHandle = &GRH.ShaderCode.RgbaMixS[ SelectR ][ SelectG ][ SelectB ][ SelectA ] ;
			if( *PixelShaderHandle < 0 )
			{
				if( GRA2.RGBAMixS_ShaderPackImage != NULL )
				{
					*PixelShaderHandle = NS_LoadPixelShaderFromMem( GRA2.RGBAMixS_ShaderAddress[ SelectR ][ SelectG ][ SelectB ][ SelectA ], GRA2.RGBAMixS_ShaderSize[ SelectR ][ SelectG ][ SelectB ][ SelectA ] ) ;
					if( *PixelShaderHandle < 0 )
					{
						DXST_ERRORLOGFMT_ADD(( _T( "RGBAMixS フィルター用シェーダーの作成に失敗しました" ) )) ;
						return -1 ;
					}
					NS_SetDeleteHandleFlag( *PixelShaderHandle, PixelShaderHandle ) ;
				}
			}
		}
		else
		if( SelectR == SelectG && SelectR == SelectB && SelectR != DX_RGBA_SELECT_BLEND_A && SelectR != DX_RGBA_SELECT_SRC_A )
		{
			if( SelectR >= DX_RGBA_SELECT_BLEND_R && SelectR <= DX_RGBA_SELECT_BLEND_A )
			{
				SelectR -= DX_RGBA_SELECT_BLEND_R ;
				SelectG -= DX_RGBA_SELECT_BLEND_R ;
				SelectB -= DX_RGBA_SELECT_BLEND_R ;
				SelectA += DX_RGBA_SELECT_BLEND_R ;

				SrcBlendReverse = TRUE ;

				HandleTemp = Info->BlendGrHandle ;
				Info->BlendGrHandle = Info->SrcGrHandle ;
				Info->SrcGrHandle = HandleTemp ;
			}

			PixelShaderHandle = &GRH.ShaderCode.RgbaMixSRRRB[ SelectR ][ SelectA - DX_RGBA_SELECT_BLEND_R ] ;
			if( *PixelShaderHandle < 0 )
			{
				_SPRINTF( FileName, "RGBAMix_S%sS%sS%sB%s.pso", CharTable[ SelectR ], CharTable[ SelectG ], CharTable[ SelectB ], CharTable[ SelectA - DX_RGBA_SELECT_BLEND_R ] ) ;
				*PixelShaderHandle = MemLoadShaderCode( FileName, false ) ;
				if( *PixelShaderHandle < 0 )
				{
					DXST_ERRORLOGFMT_ADD(( _T( "RGBAMixS フィルター用シェーダーの作成に失敗しました %s" ), FileName )) ;
					return -1 ;
				}
				NS_SetDeleteHandleFlag( *PixelShaderHandle, PixelShaderHandle ) ;
			}
		}
		else
		if( ( SelectR == DX_RGBA_SELECT_SRC_R   && SelectG == DX_RGBA_SELECT_SRC_G   && SelectB == DX_RGBA_SELECT_SRC_B   ) ||
			( SelectR == DX_RGBA_SELECT_BLEND_R && SelectG == DX_RGBA_SELECT_BLEND_G && SelectB == DX_RGBA_SELECT_BLEND_B ) )
		{
			if( SelectR == DX_RGBA_SELECT_BLEND_R )
			{
				SelectR -= DX_RGBA_SELECT_BLEND_R ;
				SelectG -= DX_RGBA_SELECT_BLEND_R ;
				SelectB -= DX_RGBA_SELECT_BLEND_R ;
				SelectA += DX_RGBA_SELECT_BLEND_R ;

				SrcBlendReverse = TRUE ;

				HandleTemp = Info->BlendGrHandle ;
				Info->BlendGrHandle = Info->SrcGrHandle ;
				Info->SrcGrHandle = HandleTemp ;
			}

			PixelShaderHandle = &GRH.ShaderCode.RgbaMixSRGBB[ SelectA - DX_RGBA_SELECT_BLEND_R ] ;
			if( *PixelShaderHandle < 0 )
			{
				_SPRINTF( FileName, "RGBAMix_S%sS%sS%sB%s.pso", CharTable[ SelectR ], CharTable[ SelectG ], CharTable[ SelectB ], CharTable[ SelectA - DX_RGBA_SELECT_BLEND_R ] ) ;
				*PixelShaderHandle = MemLoadShaderCode( FileName, false ) ;
				if( *PixelShaderHandle < 0 )
				{
					DXST_ERRORLOGFMT_ADD(( _T( "RGBAMixS フィルター用シェーダーの作成に失敗しました %s" ), FileName )) ;
					return -1 ;
				}
				NS_SetDeleteHandleFlag( *PixelShaderHandle, PixelShaderHandle ) ;
			}
		}
		else
		{
			PixelShaderHandle = &GRH.ShaderCode.RgbaMixBasePS ;
			if( *PixelShaderHandle < 0 )
			{
				*PixelShaderHandle = MemLoadShaderCode( PsoFileName[ 0 ], false ) ;
				if( *PixelShaderHandle < 0 )
				{
					DXST_ERRORLOGFMT_ADD(( _T( "フィルター用シェーダーの作成に失敗しました %s" ), PsoFileName[ 0 ] )) ;
					return -1 ;
				}
				NS_SetDeleteHandleFlag( *PixelShaderHandle, PixelShaderHandle ) ;
			}
		}

		LibShader_PushShaderParam( &DrawParamTemp, 2 ) ;

		ParamF4[ 0 ].x = Info->BlendRatio ;
		ParamF4[ 0 ].y = Info->BlendRatio ;
		ParamF4[ 0 ].z = Info->BlendRatio ;
		ParamF4[ 0 ].w = Info->BlendRatio ;
		ParamF4[ 1 ].x = ( float )SelectR + 0.5f ;
		ParamF4[ 1 ].y = ( float )SelectG + 0.5f ;
		ParamF4[ 1 ].z = ( float )SelectB + 0.5f ;
		ParamF4[ 1 ].w = ( float )SelectA + 0.5f ;
		SetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, ParamF4, 2, FALSE ) ;

		NS_SetUsePixelShader( *PixelShaderHandle ) ;

		GraphFilter_BasePolygonDraw( Info ) ;

		LibShader_PopShaderParam( &DrawParamTemp ) ;

		if( SrcBlendReverse )
		{
			HandleTemp = Info->BlendGrHandle ;
			Info->BlendGrHandle = Info->SrcGrHandle ;
			Info->SrcGrHandle = HandleTemp ;
		}

		ResetShaderConstantSet( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTTYPE_PS_FLOAT, DX_SHADERCONSTANTSET_LIB_SUB, 0, 2 ) ;
	}
	else
	{
		// シェーダーが使えない場合

		BYTE *Src ;
		BYTE *Blend ;
		BYTE *Dest ;
		DWORD i ;
		DWORD Width ;
		DWORD Height ;
		DWORD SrcAddPitch ;
		DWORD BlendAddPitch ;
		DWORD DestAddPitch ;

		if( GraphFilter_SoftImageSetup( Info ) < 0 )
			return -1 ;

		Src = ( BYTE * )Info->SrcImage.GraphData ;
		Blend = ( BYTE * )Info->BlendImage.GraphData ;
		Dest = ( BYTE * )Info->DestImage.GraphData ;

		Width  = Info->SrcX2 - Info->SrcX1 ;
		Height = Info->SrcY2 - Info->SrcY1 ;

		SrcAddPitch   = Info->SrcImage.Pitch   - Width * 4 ;
		BlendAddPitch = Info->BlendImage.Pitch - Width * 4 ;
		DestAddPitch  = Info->DestImage.Pitch  - Width * 4 ;

		do
		{
			i = Width ;
			do
			{
				switch( SelectB )
				{
				case DX_RGBA_SELECT_SRC_R :   Dest[ 0 ] = Src[ 2 ] ;   break ;
				case DX_RGBA_SELECT_SRC_G :   Dest[ 0 ] = Src[ 1 ] ;   break ;
				case DX_RGBA_SELECT_SRC_B :   Dest[ 0 ] = Src[ 0 ] ;   break ;
				case DX_RGBA_SELECT_SRC_A :   Dest[ 0 ] = Src[ 3 ] ;   break ;
				case DX_RGBA_SELECT_BLEND_R : Dest[ 0 ] = Blend[ 2 ] ; break ;
				case DX_RGBA_SELECT_BLEND_G : Dest[ 0 ] = Blend[ 1 ] ; break ;
				case DX_RGBA_SELECT_BLEND_B : Dest[ 0 ] = Blend[ 0 ] ; break ;
				case DX_RGBA_SELECT_BLEND_A : Dest[ 0 ] = Blend[ 3 ] ; break ;
				}

				switch( SelectG )
				{
				case DX_RGBA_SELECT_SRC_R :   Dest[ 1 ] = Src[ 2 ] ;   break ;
				case DX_RGBA_SELECT_SRC_G :   Dest[ 1 ] = Src[ 1 ] ;   break ;
				case DX_RGBA_SELECT_SRC_B :   Dest[ 1 ] = Src[ 0 ] ;   break ;
				case DX_RGBA_SELECT_SRC_A :   Dest[ 1 ] = Src[ 3 ] ;   break ;
				case DX_RGBA_SELECT_BLEND_R : Dest[ 1 ] = Blend[ 2 ] ; break ;
				case DX_RGBA_SELECT_BLEND_G : Dest[ 1 ] = Blend[ 1 ] ; break ;
				case DX_RGBA_SELECT_BLEND_B : Dest[ 1 ] = Blend[ 0 ] ; break ;
				case DX_RGBA_SELECT_BLEND_A : Dest[ 1 ] = Blend[ 3 ] ; break ;
				}

				switch( SelectR )
				{
				case DX_RGBA_SELECT_SRC_R :   Dest[ 2 ] = Src[ 2 ] ;   break ;
				case DX_RGBA_SELECT_SRC_G :   Dest[ 2 ] = Src[ 1 ] ;   break ;
				case DX_RGBA_SELECT_SRC_B :   Dest[ 2 ] = Src[ 0 ] ;   break ;
				case DX_RGBA_SELECT_SRC_A :   Dest[ 2 ] = Src[ 3 ] ;   break ;
				case DX_RGBA_SELECT_BLEND_R : Dest[ 2 ] = Blend[ 2 ] ; break ;
				case DX_RGBA_SELECT_BLEND_G : Dest[ 2 ] = Blend[ 1 ] ; break ;
				case DX_RGBA_SELECT_BLEND_B : Dest[ 2 ] = Blend[ 0 ] ; break ;
				case DX_RGBA_SELECT_BLEND_A : Dest[ 2 ] = Blend[ 3 ] ; break ;
				}

				switch( SelectA )
				{
				case DX_RGBA_SELECT_SRC_R :   Dest[ 3 ] = Src[ 2 ] ;   break ;
				case DX_RGBA_SELECT_SRC_G :   Dest[ 3 ] = Src[ 1 ] ;   break ;
				case DX_RGBA_SELECT_SRC_B :   Dest[ 3 ] = Src[ 0 ] ;   break ;
				case DX_RGBA_SELECT_SRC_A :   Dest[ 3 ] = Src[ 3 ] ;   break ;
				case DX_RGBA_SELECT_BLEND_R : Dest[ 3 ] = Blend[ 2 ] ; break ;
				case DX_RGBA_SELECT_BLEND_G : Dest[ 3 ] = Blend[ 1 ] ; break ;
				case DX_RGBA_SELECT_BLEND_B : Dest[ 3 ] = Blend[ 0 ] ; break ;
				case DX_RGBA_SELECT_BLEND_A : Dest[ 3 ] = Blend[ 3 ] ; break ;
				}

				Src   += 4 ;
				Blend += 4 ;
				Dest  += 4 ;
			}while( -- i ) ;

			Src   += SrcAddPitch ;
			Blend += SrcAddPitch ;
			Dest  += DestAddPitch ;
		}while( -- Height ) ;

		GraphFilter_SoftImageTerminate( Info ) ;
	}

	// 終了
	return 0 ;
}

// 事前用意のシェーダー用
static void LibShader_PushBaseDrawParam( LIBSHADER_DRAWPARAMTEMP *DrawParamTemp )
{
	int i ;

	for( i = 0 ; i < GRH.RenderTargetNum ; i ++ )
	{
		DrawParamTemp->TargetSurface[ i ] = GRH.TargetSurface[ i ] ;
	}
	for( i = 1 ; i < GRH.RenderTargetNum ; i ++ )
	{
		if( GRH.TargetSurface[ i ] != NULL )
		{
			SetRenderTargetHardware( NULL, i ) ;
		}
	}

	DrawParamTemp->UseZBufferFlag3D = GBASE.EnableZBufferFlag3D ;
	DrawParamTemp->BlendMode = GBASE.BlendMode ;
	DrawParamTemp->BlendParam = GBASE.BlendParam ;
	DrawParamTemp->DrawMode = GBASE.DrawMode ;
	DrawParamTemp->AlphaTestMode = GBASE.AlphaTestMode ;
	DrawParamTemp->AlphaTestParam = GBASE.AlphaTestParam ;
	DrawParamTemp->FogEnable = GBASE.FogEnable ;
	DrawParamTemp->LightEnable = GBASE.Light.ProcessDisable ? FALSE : TRUE ;
	
	NS_SetUseZBuffer3D( FALSE ) ;
	NS_SetDrawBlendMode( DX_BLENDMODE_SRCCOLOR, 255 ) ;
	NS_SetDrawMode( DX_DRAWMODE_BILINEAR ) ;
	NS_SetDrawAlphaTest( DX_CMP_ALWAYS, 0 ) ;
	NS_SetFogEnable( FALSE ) ;
	NS_SetUseLighting( FALSE ) ;
	if( GraphicsDevice_IsValid() != 0 )
	{
		GraphicsDevice_GetDepthStencilSurface( &DrawParamTemp->DepthStencilSurfaece ) ;
		GraphicsDevice_SetDepthStencilSurface( NULL ) ;
	}
}

static void LibShader_PopBaseDrawParam( LIBSHADER_DRAWPARAMTEMP *DrawParamTemp )
{
	int i ;

	if( GraphicsDevice_IsValid() != 0 )
	{
		GraphicsDevice_SetDepthStencilSurface( DrawParamTemp->DepthStencilSurfaece ) ;
		Graphics_ObjectRelease( DrawParamTemp->DepthStencilSurfaece ) ;
		DrawParamTemp->DepthStencilSurfaece = NULL ;
	}
	for( i = 0 ; i < GRH.RenderTargetNum ; i ++ )
	{
		if( DrawParamTemp->TargetSurface[ i ] != NULL )
		{
			SetRenderTargetHardware( DrawParamTemp->TargetSurface[ i ], i ) ;
		}
	}

	GRH.InitializeFlag = TRUE ;
	SetViewportHardwareEasy( GBASE.DrawArea.left, GBASE.DrawArea.top, GBASE.DrawArea.right, GBASE.DrawArea.bottom ) ;
	GRH.InitializeFlag = FALSE ;

	NS_SetUseLighting( DrawParamTemp->LightEnable ) ;
	NS_SetFogEnable( DrawParamTemp->FogEnable ) ;
	NS_SetDrawAlphaTest( DrawParamTemp->AlphaTestMode, DrawParamTemp->AlphaTestParam ) ;
	NS_SetDrawMode( DrawParamTemp->DrawMode ) ;
	NS_SetDrawBlendMode( DrawParamTemp->BlendMode, DrawParamTemp->BlendParam ) ;
	NS_SetUseZBuffer3D( DrawParamTemp->UseZBufferFlag3D ) ;
}

static void LibShader_PushShaderParam( LIBSHADER_DRAWPARAMTEMP *DrawParamTemp, int TextureNum )
{
	DrawParamTemp->UserSetVertexShaderHandle = GRH.UserShaderRenderInfo.SetVertexShaderHandle ;
	DrawParamTemp->UserSetPixelShaderHandle = GRH.UserShaderRenderInfo.SetPixelShaderHandle ;
	SetUseShaderContantInfoState( &GRH.ShaderConstantInfo, DX_SHADERCONSTANTSET_MASK_LIB | DX_SHADERCONSTANTSET_MASK_LIB_SUB ) ;
	if( TextureNum != 0 )
	{
		_MEMCPY( DrawParamTemp->UserSetTextureGraphHandle, GRH.UserShaderRenderInfo.SetTextureGraphHandle, sizeof( int ) * TextureNum ) ;
	}
	DrawParamTemp->TextureNum = TextureNum ;
}

static void LibShader_PopShaderParam( LIBSHADER_DRAWPARAMTEMP *DrawParamTemp )
{
	int i ;

	for( i = 0 ; i < DrawParamTemp->TextureNum ; i ++ )
	{
		NS_SetUseTextureToShader( i, DrawParamTemp->UserSetTextureGraphHandle[ i ] == 0 ? -1 : DrawParamTemp->UserSetTextureGraphHandle[ i ] ) ;
	}
	NS_SetUseVertexShader( DrawParamTemp->UserSetVertexShaderHandle ) ;
	NS_SetUsePixelShader( DrawParamTemp->UserSetPixelShaderHandle ) ;
}

#endif // DX_NON_FILTER










// 绘制设定相关函数

// 描画モードをセットする
extern	int NS_SetDrawMode( int DrawMode )
{
	if( GBASE.NotDrawFlag || DrawMode == GBASE.DrawMode )
		return 0 ;

	// 描画モードの保存
	GBASE.DrawMode = DrawMode ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// Direct3D に設定を反映
	if( GRA2.ValidHardWare )
	{
		SetDrawModeHardware( DrawMode ) ;
	}

	// 終了
	return 0 ;
}

// 最大異方性の値をセットする
extern int NS_SetMaxAnisotropy( int MaxAnisotropy )
{
	if( GBASE.NotDrawFlag || MaxAnisotropy == GBASE.MaxAnisotropy )
		return 0 ;

	// 最大異方性の保存
	GBASE.MaxAnisotropy = MaxAnisotropy ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// Direct3D に設定を反映
	if( GRA2.ValidHardWare )
	{
		SetMaxAnisotropyHardware( MaxAnisotropy ) ;
	}

	// 終了
	return 0 ;
}

// 描画ブレンドモードをセットする
extern	int NS_SetDrawBlendMode( int BlendMode, int BlendParam )
{
	if( GBASE.NotDrawFlag || ( GBASE.BlendMode == BlendMode && GBASE.BlendParam == BlendParam ) )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// ブレンドモードの保存
	if( GBASE.BlendMode != BlendMode )
	{
		GBASE.BlendMode = BlendMode ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}

	if( BlendParam > 255 ) BlendParam = 255 ;
	if( BlendParam < 0	 ) BlendParam = 0 ;
	GBASE.BlendParam = BlendParam ;
	SetMemImgDrawBlendMode( GBASE.BlendMode, GBASE.BlendParam ) ;

	// Direct3D の設定に反映
	if( GRA2.ValidHardWare )
	{
		// ディフーズカラーの更新
		GRH.DiffuseColor = GetDiffuseColor() ;
	}

	// 終了
	return 0 ;
}

// 描画時のアルファテストの設定を行う( TestMode:DX_CMP_GREATER等( -1:デフォルト動作に戻す )  TestParam:描画アルファ値との比較に使用する値 )
extern	int	NS_SetDrawAlphaTest( int TestMode, int TestParam )
{
	if( GBASE.NotDrawFlag || ( GBASE.AlphaTestMode == TestMode && GBASE.AlphaTestParam == TestParam ) )
		return 0 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// アルファテストパラメータを保存
	GBASE.AlphaTestMode = TestMode ;
	if( TestParam > 255 ) TestParam = 255 ;
	if( TestParam < 0	 ) TestParam = 0 ;
	GBASE.AlphaTestParam = TestParam ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// Direct3D の設定に反映
	if( GRA2.ValidHardWare )
	{
		// ディフーズカラーの更新
		GRH.DiffuseColor = GetDiffuseColor() ;
	}

	// 終了
	return 0 ;
}

// 描画処理時に描画する画像とブレンドするαチャンネル付き画像をセットする
extern	int NS_SetBlendGraph( int BlendGraph, int BorderParam, int BorderRange )
{
	return NS_SetBlendGraphParam( BlendGraph, DX_BLENDGRAPHTYPE_WIPE, BorderParam, BorderRange ) ;
/*
	IMAGEDATA2 *Image2 ;

	if( GBASE.NotDrawFlag || ( GBASE.BlendGraphBorderRange == BorderRange && GBASE.BlendGraph == BlendGraph && GBASE.BlendGraphBorderParam == BorderParam ) )
		return 0 ;

	// ブレンドする画像が -1 だったらブレンド画像処理を止めるということ
	if( BlendGraph == -1 )
	{
		Image2 = NULL ;
		GBASE.BlendGraph = -1 ;
	}
	else
	{
		// エラー判定
		if( GRAPHCHK( BlendGraph, Image2 ) )
			return -1 ;
		GBASE.BlendGraph = BlendGraph ;
	}

	CheckActiveState() ;

	if( BorderRange > 255 ) BorderRange = 255 ;
	else
	if( BorderRange < 0   ) BorderRange = 0   ;

	if( BorderParam > 255 ) BorderParam = 255 ;
	else
	if( BorderParam < 0	  ) BorderParam = 0   ;

	GBASE.BlendGraphBorderParam = BorderParam ;
	GBASE.BlendGraphBorderRange = BorderRange ;

	// Direct3D を使用しているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// Direct3D を使用している場合

		if( GraphicsDevice_IsValid() == 0 ) return -1 ;

		// ブレンド画像が NULL だったらブレンド画像処理の解除
		if( Image2 == NULL )
		{
			SetBlendTextureHardware( NULL, BorderParam, BorderRange ) ;
		}
		else
		{
			// テクスチャ画像ではなかったら終了
			if( Image2->Orig->FormatDesc.TextureFlag == FALSE ) 
				return -1 ;

			// ブレンドテクスチャをセットする
			SetBlendTextureHardware( Image2->Orig->Hard.Tex[ 0 ].Texture, BorderParam, BorderRange ) ;

			// テクスチャの幅と高さを保存
			GRH.InvBlendTextureWidth  = 1.0F / ( GRH.BlendTextureWidth  = (float)Image2->Orig->Hard.Tex[ 0 ].TexWidth )  ;
			GRH.InvBlendTextureHeight = 1.0F / ( GRH.BlendTextureHeight = (float)Image2->Orig->Hard.Tex[ 0 ].TexHeight ) ;
		}
	}
	else
	{
		// Direct3D を使用していない場合の処理

		// ブレンドグラフィックのアドレスを設定
		GRS.BlendMemImg = GBASE.BlendGraph == -1 ? NULL : &Image2->Orig->Soft.MemImg ;

		// MEMIMG システムへの設定
		SetBlendGraphParamMemImg( BorderParam, BorderRange ) ;
	}

	// 終了
	return 0 ;
*/
}

// ブレンド画像の起点座標をセットする
extern	int NS_SetBlendGraphPosition( int x, int y )
{
	// 今までと値が同じ場合は何もせず終了
	if( GBASE.BlendGraphX == x && GBASE.BlendGraphY == y ) return 0 ;

	// 座標を保存
	GBASE.BlendGraphX = x ;
	GBASE.BlendGraphY = y ;

	// 終了
	return 0 ;
}

// 描画処理時に描画する画像とブレンドする画像のブレンド設定を行う
extern	int NS_SetBlendGraphParam( int BlendGraph, int BlendType, ... )
{
	int Result ;
	va_list VaList ;

	va_start( VaList, BlendType ) ;

	Result = SetBlendGraphParamBase(  BlendGraph,  BlendType, VaList ) ;

	va_end( VaList ) ;

	return Result ;
}

// SetBlendGraphParam の可変長引数パラメータ付き
extern int SetBlendGraphParamBase( int BlendGraph, int BlendType, va_list ParamList )
{
	IMAGEDATA2 *Image2 ;
	int Param[ 16 ] ;

	// ブレンドする画像が -1 だったらブレンド画像処理を止めるということ
	if( BlendGraph <= 0 )
	{
		Image2 = NULL ;
		GBASE.BlendGraph = -1 ;
	}
	else
	{
		// エラー判定
		if( GRAPHCHK( BlendGraph, Image2 ) )
			return -1 ;
		GBASE.BlendGraph = BlendGraph ;
	}

	CheckActiveState() ;

	if( Image2 != NULL )
	{
		switch( BlendType )
		{
		case DX_BLENDGRAPHTYPE_NORMAL :
			int FadeRatio ;

			FadeRatio = va_arg( ParamList, int ) ;

			if( FadeRatio > 255 ) FadeRatio = 255 ;
			else
			if( FadeRatio < 0   ) FadeRatio = 0   ;

			Param[ 0 ] = FadeRatio ;
			break ;

		case DX_BLENDGRAPHTYPE_WIPE :
			int BorderRange ;
			int BorderParam ;

			BorderParam = va_arg( ParamList, int ) ;
			BorderRange = va_arg( ParamList, int ) ;

			if( BorderRange > 255 ) BorderRange = 255 ;
			else
			if( BorderRange < 0   ) BorderRange = 0   ;

			if( BorderParam > 255 ) BorderParam = 255 ;
			else
			if( BorderParam < 0	  ) BorderParam = 0   ;
			
			Param[ 0 ] = GBASE.BlendGraphBorderParam = BorderParam ;
			Param[ 1 ] = GBASE.BlendGraphBorderRange = BorderRange ;

			// Direct3D を使用していない場合のみ処理を分岐
			if( GRA2.ValidHardWare == FALSE )
			{
				// MEMIMG システムへの設定
				SetBlendGraphParamMemImg( BorderParam, BorderRange ) ;
			}
			break ;

		case DX_BLENDGRAPHTYPE_ALPHA :
			break ;
		}
	}

	// Direct3D を使用しているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// Direct3D を使用している場合

		if( GraphicsDevice_IsValid() == 0 ) return -1 ;
		
		// ブレンド画像が NULL もしくはテクスチャではなかったらブレンド画像処理の解除
		if( Image2 == NULL || Image2->Orig->FormatDesc.TextureFlag == FALSE )
		{
			GBASE.BlendGraph = -1 ;
			SetBlendTextureHardware( NULL ) ;
		}
		else
		{
			// ブレンドパラメータをセットする
			SetBlendTextureHardware( Image2->Hard.Draw[ 0 ].Tex[ 0 ].Texture, Image2->Hard.Draw[ 0 ].Tex[ 0 ].TexWidth, Image2->Hard.Draw[ 0 ].Tex[ 0 ].TexHeight ) ;
			SetBlendTextureParamHardware( BlendType, Param ) ;
		}
	}
	else
	{
		// Direct3D を使用していない場合の処理

		// ブレンドグラフィックのアドレスを設定
		GRS.BlendMemImg = GBASE.BlendGraph <= 0 ? NULL : &Image2->Orig->Soft.MemImg ;
	}

	// 終了
	return 0 ;
}

// 描画輝度をセット
extern	int NS_SetDrawBright( int RedBright, int GreenBright, int BlueBright )
{
	bool OldWhiteFlag ;
	bool NewWhiteFlag ;

	if( GBASE.DrawBright.Red   == RedBright  &&
		GBASE.DrawBright.Green == GreenBright &&
		GBASE.DrawBright.Blue  == BlueBright )
	{
		return 0 ;
	}

	if( (unsigned int)RedBright   > 255 )
	{
		     if( RedBright   > 255 ) RedBright   = 255 ;
		else if( RedBright   < 0   ) RedBright   = 0   ;
	}
	if( (unsigned int)GreenBright > 255 )
	{
		     if( GreenBright > 255 ) GreenBright = 255 ;
		else if( GreenBright < 0   ) GreenBright = 0   ;
	}
	if( (unsigned int)BlueBright  > 255 )
	{
		     if( BlueBright  > 255 ) BlueBright  = 255 ;
		else if( BlueBright  < 0   ) BlueBright  = 0   ;
	}

	// 輝度を保存
	OldWhiteFlag = ( GBASE.bDrawBright & 0xffffff ) == 0xffffff ;
	GBASE.DrawBright.Red   = ( BYTE )RedBright   ;
	GBASE.DrawBright.Blue  = ( BYTE )BlueBright  ;
	GBASE.DrawBright.Green = ( BYTE )GreenBright ;
	NewWhiteFlag = ( GBASE.bDrawBright & 0xffffff ) == 0xffffff ;
	SetMemImgDrawBright( GBASE.bDrawBright ) ;

	if( OldWhiteFlag != NewWhiteFlag )
	{
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}

	// Direct3D に設定を反映
	if( GRA2.ValidHardWare )
	{
		// ディフューズカラーの更新
		GRH.DiffuseColor = GetDiffuseColor() ;
	}

	// 終了
	return 0 ;
}

// 描画する画像の色成分を無視するかどうかを指定する( EnableFlag:この機能を使うかどうか( TRUE:使う  FALSE:使わない ) )
extern int NS_SetIgnoreDrawGraphColor( int EnableFlag )
{
	if( GBASE.IgnoreGraphColorFlag == EnableFlag )
		return 0 ;

	// 設定を保存
	GBASE.IgnoreGraphColorFlag = EnableFlag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// 描画先画面のセット
extern	int NS_SetDrawScreen( int DrawScreen )
{
	int OldScreen ;
	int OldScreenSurface ;
#ifndef DX_NON_MASK
	int MaskUseFlag ;
#endif
//	int Result ;
	IMAGEDATA2 *Image2 = NULL ;
	IMAGEDATA2 *OldImage2 = NULL ;
	SHADOWMAPDATA *ShadowMap = NULL ;
	SHADOWMAPDATA *OldShadowMap = NULL ;
	
	if( GRA2.InitializeFlag == FALSE ) return -1 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// グラフィック描画先が今までと同じだった場合何もせず終了
//	if( DrawScreen == GBASE.TargetScreen[ 0 ] && GBASE.TargetScreenSurface == 0 ) return 0 ;

	// 画像情報の取得
	if( GRH.ShadowMapDrawSetupRequest )
	{
		// アドレスの取得
		if( SHADOWMAPCHK( DrawScreen, ShadowMap ) )
			return -1 ;
	}
	else
	{
		if( !GRAPHCHKFULL( DrawScreen, Image2 ) )
		{
			// 画像だった場合は描画可能では無い場合はエラー
			if( Image2->Orig->FormatDesc.DrawValidFlag == FALSE )
				return -1 ;
		}
	}

	// 今までの描画先の画像情報の取得
	if( GRAPHCHKFULL( GBASE.TargetScreen[ 0 ], OldImage2 ) )
	{
		SHADOWMAPCHK( GBASE.TargetScreen[ 0 ], OldShadowMap ) ;
	}

	// 指定したスクリーンが無効だったら何もせず終了
	if( DrawScreen != DX_SCREEN_FRONT && DrawScreen != DX_SCREEN_BACK &&
		DrawScreen != DX_SCREEN_WORK  && DrawScreen != DX_SCREEN_TEMPFRONT &&
		ShadowMap == NULL &&
		( ( DrawScreen & DX_HANDLEERROR_MASK ) != 0                   ||
		  ( DrawScreen & DX_HANDLETYPE_MASK  ) != DX_HANDLETYPE_MASK_GRAPH || 
		  GetHandleInfo( DrawScreen ) == NULL ) )
	{
		return -1 ;
	}

	// 今までの画面が表画面だった場合は一度 ScreenCopy を行う
	if( DrawScreen == DX_SCREEN_FRONT )
	{
		NS_ScreenCopy() ;
	}

	// シャドウマップへの描画設定がされていたら解除
	if( GRH.ShadowMapDraw )
	{
		NS_ShadowMap_DrawEnd() ;
	}

#ifndef DX_NON_MASK
	// マスクを使用終了する手続きを取る
	MaskUseFlag = MASKD.MaskUseFlag ;
	NS_SetUseMaskScreenFlag( FALSE ) ;

	// 描画先のサイズでマスク画面を作成しなおす
	if( GRH.ShadowMapDrawSetupRequest == FALSE && MASKD.CreateMaskFlag )
	{
		int w, h ;
		NS_GetGraphSize( DrawScreen, &w, &h ) ;
		CreateMaskScreenFunction( TRUE, w, h ) ;
	}
#endif

	// 描画先を保存
	OldScreen = GBASE.TargetScreen[ 0 ] ;
	OldScreenSurface = GBASE.TargetScreenSurface[ 0 ] ;
	GBASE.TargetScreen[ 0 ] = DrawScreen ;
	GBASE.TargetScreenSurface[ 0 ] = 0 ;

	// 描画可能サイズの取得
	NS_GetGraphSize( DrawScreen, &GBASE.DrawSizeX, &GBASE.DrawSizeY ) ;

	// 描画先に正しいα値を書き込むかどうかのフラグを更新する
	RefreshAlphaChDrawMode() ;

	// ３Ｄ描画関係の描画先をセット
	if( GRA2.ValidHardWare )
	{
		if( GraphicsDevice_IsValid() != 0 )
		{
			// 描画処理を終了しておく
			RenderVertexHardware() ;
			EndScene() ;

			// セットしていたテクスチャーを外す
			SetTextureHardware( NULL ) ;

			// 今までの描画先がレンダリングターゲットサーフェスだった場合はレンダリングターゲットテクスチャに転送する
			if( OldImage2 != NULL && OldImage2->Hard.Draw[ 0 ].Tex->RenderTargetSurface )
			{
				UpdateDrawTexture( OldImage2->Hard.Draw[ 0 ].Tex, OldScreenSurface ) ;
			}

			// 描画先の変更

			// マスクサーフェスが存在していて且つ有効な場合はマスクサーフェスを描画対称にする
#ifndef DX_NON_MASK
			if( MASKD.MaskValidFlag && MASKD.MaskScreenSurface )
			{
				SetRenderTargetHardware( MASKD.MaskScreenSurface ) ;
			}
			else
#endif
			// シャドウマップが有効な場合はシャドウマップを描画対象にする
			if( ShadowMap )
			{
				SetRenderTargetHardware( ShadowMap->Surface ) ;
			}
			else
			// 描画可能画像が有効な場合は描画可能画像を描画対象にする
			if( Image2 )
			{
				if( Image2->Hard.Draw[ 0 ].Tex->RenderTargetSurface )
				{
					SetRenderTargetHardware( Image2->Hard.Draw[ 0 ].Tex->RenderTargetSurface ) ;
				}
				else
				{
					SetRenderTargetHardware( Image2->Hard.Draw[ 0 ].Tex->Surface[ GBASE.TargetScreenSurface[ 0 ] ] ) ;
				}
			}
			else
			{
				// それ以外の場合はサブバックバッファが有効な場合はサブバックバッファを描画対称にする
				SetRenderTargetHardware( GRH.SubBackBufferSurface ? GRH.SubBackBufferSurface : GRH.BackBufferSurface ) ;
			}

			// 使用するＺバッファのセットアップ
			SetupUseZBuffer() ;
		}
	}
	else
	{
		// ソフトウエアレンダリングの場合の処理

		// 描画先の決定
#ifndef DX_NON_MASK
		if( MASKD.MaskValidFlag )
		{
			// マスクが有効な場合はマスクを描画先にする
			GRS.TargetMemImg = &MASKD.MaskDrawMemImg ;
		}
		else
#endif
		{
			// 画像が描画対象かどうかで処理を分岐
			if( Image2 != NULL )
			{
				// アルファチャンネル付きの画像の場合は描画対象にできない
				if( Image2->Soft.MemImg.Base->UseAlpha == TRUE )
					return -1 ;

				// 描画可能画像を描画先に
				GRS.TargetMemImg = &Image2->Soft.MemImg ;
			}
			else
			{
				// メインバッファを描画先に
				GRS.TargetMemImg = &GRS.MainBufferMemImg ;
			}
		}
	}

	// 描画先が表画面だったら定期的に画面コピーを行う
	GraphicsDevice_SetupTimerPresent( DrawScreen == DX_SCREEN_FRONT ) ;

	// 変更に成功したら描画領域の更新を行う
	{
		// 描画領域を更新
		{
//			RECT SrcRect, ClippuRect ;
			RECT SrcRect ;
			int NewWidth, NewHeight, OldWidth, OldHeight ;

			NS_GetGraphSize( DrawScreen, &NewWidth, &NewHeight ) ;
			NS_GetGraphSize( OldScreen,  &OldWidth, &OldHeight ) ;

			SrcRect = GBASE.DrawArea ;

//			SETRECT( ClippuRect, 0, 0, NewWidth, NewHeight ) ;
//			RectClipping( &SrcRect, &ClippuRect ) ;

//			if( NewWidth != GBASE.DrawArea.right || NewHeight != GBASE.DrawArea.bottom )
			if( GRH.ShadowMapDrawSetupRequest || ( NewWidth != OldWidth ) || ( NewHeight != OldHeight ) )
			{
				NS_SetDrawArea( 0, 0, NewWidth, NewHeight ) ;
			}
			else
			{
				NS_SetDrawArea( SrcRect.left, SrcRect.top, SrcRect.right, SrcRect.bottom ) ;
			}
		}
		
		// ３Ｄ描画処理用の行列設定の初期化を行う
		{
			MATRIX mat ;
			float D ;

			// ドットアスペクトを１．０に戻す
			NS_SetCameraDotAspect( 1.0f ) ;
	
			// ワールド変換行列は単位行列
			CreateIdentityMatrix( &mat ) ;
			NS_SetTransformToWorld( &mat ) ;

			// ビューポート行列のセット( 描画領域の中心座標を視界の中心座標にする
			CreateViewportMatrix( &mat, ( float )GBASE.DrawSizeX / 2,	( float )GBASE.DrawSizeY / 2,
										( float )GBASE.DrawSizeX,		( float )GBASE.DrawSizeY ) ;
			GBASE.Direct3DViewportMatrix = mat ;
			CreateInverseMatrix( &GBASE.Direct3DViewportMatrixAnti, &mat ) ;

			// ライブラリ管理のビューポート行列を更新
			GBASE.CameraScreenCenterX = ( float )GBASE.DrawSizeX / 2.0f ;
			GBASE.CameraScreenCenterY = ( float )GBASE.DrawSizeY / 2.0f ;
			NS_SetCameraScreenCenter( GBASE.CameraScreenCenterX, GBASE.CameraScreenCenterY ) ;

			// ビュー行列は z = 0.0 の時に丁度スクリーン全体が写る位置と方向を持つカメラを
			{
				VECTOR up, at, eye ;

				D = (float)( ( GBASE.DrawSizeY / 2 ) / DEFAULT_TAN_FOV_HALF ) ;

				eye.x = (float)GBASE.DrawSizeX / 2 ;
				eye.y = (float)GBASE.DrawSizeY / 2 ;
				eye.z = -D;
				
				at.x = eye.x ;
				at.y = eye.y ;
				at.z = eye.z + 1.0F ;
				
				up.x = 0.0f ;
				up.y = 1.0F ;
				up.z = 0.0f ;
				
				NS_SetCameraPositionAndTargetAndUpVec( eye, at, up ) ;
//				CreateLookAtMatrix( &mat, &eye, &at, &up ) ;
//				NS_SetTransformToView( &mat ) ;
			}

			// プロジェクション行列は普通に
			NS_SetupCamera_Perspective( DEFAULT_FOV ) ;
			NS_SetCameraNearFar( D * 0.1f + DEFAULT_NEAR, D + DEFAULT_FAR ) ;
		}

#ifndef DX_NON_MASK
		// マスクを使用する手続きを取る
		NS_SetUseMaskScreenFlag( MaskUseFlag ) ;
#endif
	}

	// シャドウマップに対する描画準備リクエストだった場合はリクエストフラグを倒し、描画準備状態を保存する
	if( GRH.ShadowMapDrawSetupRequest )
	{
		GRH.ShadowMapDrawSetupRequest = FALSE ;

		// シャドウマップに対する描画であるかどうかのフラグを立てる
		GRH.ShadowMapDraw = TRUE ;

		// シャドウマップに対する描画の場合の、対象となるシャドウマップのハンドルを保存
		GRH.ShadowMapDrawHandle = DrawScreen ;
	}

	// 終了
	return 0 ;
}

// 描画先Ｚバッファのセット
extern	int	NS_SetDrawZBuffer( int DrawScreen )
{
	IMAGEDATA2 *Image2 ;
	
	if( GRA2.InitializeFlag == FALSE ) return -1 ;

	// ソフトが非アクティブの場合はアクティブになるまで待つ
	CheckActiveState() ;

	// 画像情報の取得
	if( GRAPHCHKFULL( DrawScreen, Image2 ) )
	{
		Image2 = NULL ;
	}
	else
	{
		// 画像だった場合は描画可能では無い場合やＺバッファを持っていない画像の場合はエラー
		if( Image2->Orig->FormatDesc.DrawValidFlag == FALSE ||
			Image2->Hard.Draw[ 0 ].Tex->ZBuffer == NULL )
			return -1 ;
	}

	// 描画先Ｚバッファのハンドルを保存
	GBASE.TargetZBuffer = DrawScreen ;

	// 描画先Ｚバッファを更新
	SetupUseZBuffer() ;

	// 終了
	return 0 ;
}

// 描画可能領域のセット
extern	int NS_SetDrawArea( int x1, int y1, int x2, int y2 )
{
	const char *HandleString = NULL ;
	int Buf, SizeX, SizeY ;
	IMAGEDATA2 *Image2 ;
	SHADOWMAPDATA *ShadowMap ;

	if( GBASE.NotDrawFlag ) return 0 ;

	// フルスクリーンマスク処理を行っている場合はマスク描画の結果を反映させる
	MASK_FULLSCREEN_MASKUPDATE

	// ソフトが非アクティブの場合はアクティブになるまで待つ
//	CheckActiveState() ;

	// オリジナルの描画エリアを保存
	GRA2.OriginalDrawRect.left   = x1 ;
	GRA2.OriginalDrawRect.top    = y1 ;
	GRA2.OriginalDrawRect.right  = x2 ;
	GRA2.OriginalDrawRect.bottom = y2 ;
	
	// 描画先の描画可能サイズを取得
	switch( GBASE.TargetScreen[ 0 ] )
	{
	case DX_SCREEN_BACK :
	case DX_SCREEN_FRONT :
		HandleString = GBASE.TargetScreen[ 0 ] == DX_SCREEN_BACK ? "Back Buffer" : "Front Buffer" ;
		SizeX = GRA2.MainScreenSizeX ;
		SizeY = GRA2.MainScreenSizeY ;
		break ;

	default :
		HandleString = "Image Buffer" ;
		// エラー判定
		if( !GRAPHCHK( GBASE.TargetScreen[ 0 ], Image2 ) )
		{
			SizeX = Image2->Width ;
			SizeY = Image2->Height ;
		}
		else
		if( !SHADOWMAPCHK( GBASE.TargetScreen[ 0 ], ShadowMap ) )
		{
			SizeX = ShadowMap->BaseSizeX ;
			SizeY = ShadowMap->BaseSizeY ;
		}
		else
		{
			return -1 ;
		}
		break ;
	}

	// 左右逆補正とはみ出し補正
	if( x1 > x2 ){ Buf = x1 ; x1 = x2 ; x2 = Buf ; }
	if( y1 > y2 ){ Buf = y1 ; y1 = y2 ; y2 = Buf ; }

	if( x1 < 0 )		x1 = 0 ;
	if( x1 > SizeX )	x1 = SizeX ; 
	if( x2 < 0 )		x2 = 0 ;
	if( x2 > SizeX )	x2 = SizeX ;

	if( y1 < 0 )		y1 = 0 ;
	if( y1 > SizeY )	y1 = SizeY ; 
	if( y2 < 0 )		y2 = 0 ;
	if( y2 > SizeY )	y2 = SizeY ;

	// 描画可能矩形セット
	GBASE.DrawAreaF.left   = ( float )( GBASE.DrawArea.left   = x1 ) ;
	GBASE.DrawAreaF.top    = ( float )( GBASE.DrawArea.top    = y1 ) ;
	GBASE.DrawAreaF.right  = ( float )( GBASE.DrawArea.right  = x2 ) ;
	GBASE.DrawAreaF.bottom = ( float )( GBASE.DrawArea.bottom = y2 ) ;
	SetMemImgDrawArea( &GBASE.DrawArea ) ;

	// 描画可能フラグをセットする
	GBASE.NotDrawFlagInSetDrawArea = x1 == x2 || y1 == y2 ;
	if( GBASE.NotDrawFlagInSetDrawArea == FALSE )
	{
		// Ｄｉｒｅｃｔ３Ｄの描画矩形のセット
		if( GRA2.ValidHardWare )
		{
			D_D3DVIEWPORT9 Viewport ;
			MATRIX TempMatrix ;

			if( GraphicsDevice_IsValid() == 0 )	return -1 ;

			if( GBASE.DrawArea.right  - GBASE.DrawArea.left == 0 ||
				GBASE.DrawArea.bottom - GBASE.DrawArea.top  == 0 )
				return -1 ;

			// ビューポートのセッティング
			_MEMSET( &Viewport, 0, sizeof( Viewport ) ) ;
			Viewport.X		= GBASE.DrawArea.left ;
			Viewport.Y		= GBASE.DrawArea.top ;
			Viewport.Width	= GBASE.DrawArea.right  - GBASE.DrawArea.left ;
			Viewport.Height	= GBASE.DrawArea.bottom - GBASE.DrawArea.top  ;
			Viewport.MinZ	= 0.0f ;
			Viewport.MaxZ	= 1.0f ;

			// セット
			SetViewportHardware( &Viewport ) ;
			SetScissorRectHardware( &GBASE.DrawArea ) ;

			// Direct3D のビューポート行列の更新
			CreateViewportMatrix(
				&GBASE.Direct3DViewportMatrix,
				( float )( GBASE.DrawArea.right  - GBASE.DrawArea.left ) / 2.0f + GBASE.DrawArea.left,
				( float )( GBASE.DrawArea.bottom - GBASE.DrawArea.top  ) / 2.0f + GBASE.DrawArea.top,
				( float )( GBASE.DrawArea.right  - GBASE.DrawArea.left ),
				( float )( GBASE.DrawArea.bottom - GBASE.DrawArea.top  ) ) ;
			CreateInverseMatrix( &GBASE.Direct3DViewportMatrixAnti, &GBASE.Direct3DViewportMatrix ) ;

			// 射影行列とビューポート行列の逆行列を乗算したものをセット
			CreateMultiplyMatrix( &TempMatrix, &GBASE.ProjectionMatrix, &GBASE.ViewportMatrix ) ;
			CreateMultiplyMatrix( &TempMatrix, &TempMatrix,             &GBASE.Direct3DViewportMatrixAnti ) ;
			SetTransformToProjectionHardware( &TempMatrix ) ;
			GBASE.MatchHardwareProjectionMatrix = TRUE ;
		}
	}

	// 終了
	return 0 ;
}

// ハードウエアの頂点演算処理機能を使用するかどうかを設定する
extern	int NS_SetUseHardwareVertexProcessing( int Flag )
{
	// 初期化前のみ有効
	if( DxSysData.DxLib_InitializeFlag == TRUE ) return -1 ;

	GRH.NonUseVertexHardwareProcess = !Flag ;

	// 終了
	return 0 ;
}

// ピクセル単位でライティングを行うかどうかを設定する、要 ShaderModel 3.0( TRUE:ピクセル単位のライティングを行う  FALSE:頂点単位のライティングを行う( デフォルト ) )
extern int NS_SetUsePixelLighting( int Flag )
{
	GRH.UsePixelLightingShader = Flag ;

	// 終了
	return 0 ;
}

// SetRestoreGraphCallback の旧名
extern int NS_SetRestoreShredPoint( void (* ShredPoint )( void ) )
{
	return NS_SetRestoreGraphCallback( ShredPoint ) ;
}

// グラフィックハンドル復元関数の登録
extern	int NS_SetRestoreGraphCallback( void (* Callback )( void ) )
{
	// グラフィック復元スレッドアドレスの登録
	if( Callback == NULL )
	{
		GBASE.GraphRestoreShred = DefaultRestoreGraphFunction ;
	}
	else
	{
		GBASE.GraphRestoreShred = Callback ;
	}

	// 終了
	return 0 ;
}

// グラフィック復元関数の実行
extern	int NS_RunRestoreShred( void )
{
#ifndef DX_NON_ASYNCLOAD
	// 非同期読み込みは一時的に無効にする
	int UseASyncThread = GetASyncLoadFlag() ;
	NS_SetUseASyncLoadFlag( FALSE ) ;
#endif

	// グラフィック復元スレッドの実行
	if( GBASE.GraphRestoreShred == NULL )
	{
		DefaultRestoreGraphFunction() ;
	}
	else
	{
		GBASE.GraphRestoreShred() ;
	}

#ifndef DX_NON_MODEL
	// モデルのテクスチャを再読み込み
	MV1ReloadTexture() ;
#endif

#ifndef DX_NON_FONT
	// フォントハンドルが持つキャッシュを初期化
	InitCacheFontToHandle() ;
#endif

#ifndef DX_NON_ASYNCLOAD
	// 非同期読み込みの設定を元に戻す
	NS_SetUseASyncLoadFlag( UseASyncThread ) ;
#endif

	// 終了
	return 0 ;
}

// グラフィックスデバイスがロストから復帰した際に呼ばれるコールバック関数を設定する
extern int NS_SetGraphicsDeviceRestoreCallbackFunction( void (* Callback )( void *Data ), void *CallbackData )
{
	GRH.DeviceRestoreCallbackFunction = Callback ;
	GRH.DeviceRestoreCallbackData = CallbackData ;

	// 終了
	return 0 ;
}

// グラフィックスデバイスがロストから復帰する前に呼ばれるコールバック関数を設定する
extern int NS_SetGraphicsDeviceLostCallbackFunction( void (* Callback )( void *Data ), void *CallbackData )
{
	GRH.DeviceLostCallbackFunction = Callback ;
	GRH.DeviceLostCallbackData = CallbackData ;

	// 終了
	return 0 ;
}

// ワールド変換用行列をセットする
extern	int NS_SetTransformToWorld( const MATRIX *Matrix )
{
	// 頂点を描画
	RenderVertexHardware() ;

	// データを保存
	GBASE.WorldMatrix = *Matrix ;
	GBASE.ValidBlendMatrix = FALSE ;

	// 全ての行列を掛け合わせた行列を更新
	RefreshBlendTransformMatrix() ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetTransformToWorldHardware( Matrix ) ;
		GBASE.MatchHardwareWorldMatrix = TRUE ;
	}

	// 終了
	return 0 ;
}

// ビュー変換用行列をセットする
extern	int NS_SetTransformToView( const MATRIX *Matrix )
{
	// 頂点を描画
	RenderVertexHardware() ;

	// データを保存
	GBASE.ViewMatrix = *Matrix ;
	GBASE.ValidBlendMatrix = FALSE ;

	// 全ての行列を掛け合わせた行列を更新
	RefreshBlendTransformMatrix() ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetTransformToViewHardware( Matrix ) ;
		GBASE.MatchHardwareViewMatrix = TRUE ;
	}

	// 終了
	return 0 ;
}

// 投影変換用行列をセットする
extern	int _SetTransformToProjection( const MATRIX *Matrix )
{
	// 頂点を描画
	RenderVertexHardware() ;

	// データを保存
	GBASE.ProjectionMatrix = *Matrix ;
	GBASE.ValidBlendMatrix = FALSE ;

	// 全ての行列を掛け合わせた行列を更新
	RefreshBlendTransformMatrix() ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		MATRIX TempMatrix ;

		CreateMultiplyMatrix( &TempMatrix, &GBASE.ProjectionMatrix, &GBASE.ViewportMatrix ) ;
		CreateMultiplyMatrix( &TempMatrix, &TempMatrix,             &GBASE.Direct3DViewportMatrixAnti ) ;
		SetTransformToProjectionHardware( &TempMatrix ) ;
		GBASE.MatchHardwareProjectionMatrix = TRUE ;
	}

	// 終了
	return 0 ;
}

// ビューポート行列をセットする
extern	int NS_SetTransformToViewport( const MATRIX *Matrix )
{
	// 頂点を描画
	RenderVertexHardware() ;

	// データを保存
	GBASE.ViewportMatrix = *Matrix ;
	GBASE.ValidBlendMatrix = FALSE ;

	// 全ての行列を掛け合わせた行列を更新
	RefreshBlendTransformMatrix() ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		MATRIX TempMatrix ;

		CreateMultiplyMatrix( &TempMatrix, &GBASE.ProjectionMatrix, &GBASE.ViewportMatrix ) ;
		CreateMultiplyMatrix( &TempMatrix, &TempMatrix,             &GBASE.Direct3DViewportMatrixAnti ) ;
		SetTransformToProjectionHardware( &TempMatrix ) ;
		GBASE.MatchHardwareProjectionMatrix = TRUE ;
	}

	// 終了
	return 0 ;
}

// ポリゴンカリングの有効、無効をセットする
extern int NS_SetUseBackCulling( int Flag )
{
	return NS_SetUseCullingFlag( Flag ) ;
}

// ポリゴンカリングの有効、無効をセットする
extern int NS_SetUseCullingFlag( int Flag )
{
	if( GBASE.CullMode == Flag ) return 0 ;

	// カリングモードのフラグを保存
	GBASE.CullMode = Flag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// テクスチャアドレスモードを設定する
extern	int NS_SetTextureAddressMode( int Mode /* DX_TEXADDRESS_WRAP 等 */, int Stage )
{
	if( Stage == -1 )
	{
		if( GBASE.TexAddressModeU[ 0 ] == Mode && GBASE.TexAddressModeV[ 0 ] == Mode &&
			GBASE.TexAddressModeU[ 1 ] == Mode && GBASE.TexAddressModeV[ 1 ] == Mode &&
			GBASE.TexAddressModeU[ 2 ] == Mode && GBASE.TexAddressModeV[ 2 ] == Mode &&
			GBASE.TexAddressModeU[ 3 ] == Mode && GBASE.TexAddressModeV[ 3 ] == Mode &&
			GBASE.TexAddressModeU[ 4 ] == Mode && GBASE.TexAddressModeV[ 4 ] == Mode &&
			GBASE.TexAddressModeU[ 5 ] == Mode && GBASE.TexAddressModeV[ 5 ] == Mode &&
			GBASE.TexAddressModeU[ 6 ] == Mode && GBASE.TexAddressModeV[ 6 ] == Mode &&
			GBASE.TexAddressModeU[ 7 ] == Mode && GBASE.TexAddressModeV[ 7 ] == Mode &&
			GBASE.TexAddressModeU[ 8 ] == Mode && GBASE.TexAddressModeV[ 8 ] == Mode &&
			GBASE.TexAddressModeU[ 9 ] == Mode && GBASE.TexAddressModeV[ 9 ] == Mode &&
			GBASE.TexAddressModeU[ 10 ] == Mode && GBASE.TexAddressModeV[ 10 ] == Mode &&
			GBASE.TexAddressModeU[ 11 ] == Mode && GBASE.TexAddressModeV[ 11 ] == Mode 
			) return 0;

		// 頂点を描画
		RenderVertexHardware() ;

		GBASE.TexAddressModeU[ 0 ] = Mode ;
		GBASE.TexAddressModeU[ 1 ] = Mode ;
		GBASE.TexAddressModeU[ 2 ] = Mode ;
		GBASE.TexAddressModeU[ 3 ] = Mode ;
		GBASE.TexAddressModeU[ 4 ] = Mode ;
		GBASE.TexAddressModeU[ 5 ] = Mode ;
		GBASE.TexAddressModeU[ 6 ] = Mode ;
		GBASE.TexAddressModeU[ 7 ] = Mode ;
		GBASE.TexAddressModeU[ 8 ] = Mode ;
		GBASE.TexAddressModeU[ 9 ] = Mode ;
		GBASE.TexAddressModeU[ 10 ] = Mode ;
		GBASE.TexAddressModeU[ 11 ] = Mode ;

		GBASE.TexAddressModeV[ 0 ] = Mode ;
		GBASE.TexAddressModeV[ 1 ] = Mode ;
		GBASE.TexAddressModeV[ 2 ] = Mode ;
		GBASE.TexAddressModeV[ 3 ] = Mode ;
		GBASE.TexAddressModeV[ 4 ] = Mode ;
		GBASE.TexAddressModeV[ 5 ] = Mode ;
		GBASE.TexAddressModeV[ 6 ] = Mode ;
		GBASE.TexAddressModeV[ 7 ] = Mode ;
		GBASE.TexAddressModeV[ 8 ] = Mode ;
		GBASE.TexAddressModeV[ 9 ] = Mode ;
		GBASE.TexAddressModeV[ 10 ] = Mode ;
		GBASE.TexAddressModeV[ 11 ] = Mode ;

		GRH.DrawPrepAlwaysFlag = TRUE ;
	}
	else
	{
		if( Stage < 0 || Stage >= USE_TEXTURESTAGE_NUM ) return 0 ;
		if( GBASE.TexAddressModeU[ Stage ] == Mode &&
			GBASE.TexAddressModeV[ Stage ] == Mode ) return 0;

		// 頂点を描画
		RenderVertexHardware() ;

		GBASE.TexAddressModeU[ Stage ] = Mode ;
		GBASE.TexAddressModeV[ Stage ] = Mode ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetTextureAddressHardware( Mode, Stage ) ;
	}

	// 終了
	return 0 ;
}


// テクスチャアドレスモードを設定する
extern	int NS_SetTextureAddressModeUV( int ModeU, int ModeV, int Stage )
{
	if( Stage == -1 )
	{
		if( GBASE.TexAddressModeU[ 0 ] == ModeU && GBASE.TexAddressModeV[ 0 ] == ModeV &&
			GBASE.TexAddressModeU[ 1 ] == ModeU && GBASE.TexAddressModeV[ 1 ] == ModeV &&
			GBASE.TexAddressModeU[ 2 ] == ModeU && GBASE.TexAddressModeV[ 2 ] == ModeV &&
			GBASE.TexAddressModeU[ 3 ] == ModeU && GBASE.TexAddressModeV[ 3 ] == ModeV &&
			GBASE.TexAddressModeU[ 4 ] == ModeU && GBASE.TexAddressModeV[ 4 ] == ModeV &&
			GBASE.TexAddressModeU[ 5 ] == ModeU && GBASE.TexAddressModeV[ 5 ] == ModeV &&
			GBASE.TexAddressModeU[ 6 ] == ModeU && GBASE.TexAddressModeV[ 6 ] == ModeV &&
			GBASE.TexAddressModeU[ 7 ] == ModeU && GBASE.TexAddressModeV[ 7 ] == ModeV &&
			GBASE.TexAddressModeU[ 8 ] == ModeU && GBASE.TexAddressModeV[ 8 ] == ModeV &&
			GBASE.TexAddressModeU[ 9 ] == ModeU && GBASE.TexAddressModeV[ 9 ] == ModeV &&
			GBASE.TexAddressModeU[ 10 ] == ModeU && GBASE.TexAddressModeV[ 10 ] == ModeV &&
			GBASE.TexAddressModeU[ 11 ] == ModeU && GBASE.TexAddressModeV[ 11 ] == ModeV 
			) return 0;

		// 頂点を描画
		RenderVertexHardware() ;

		GBASE.TexAddressModeU[ 0 ] = ModeU ;
		GBASE.TexAddressModeU[ 1 ] = ModeU ;
		GBASE.TexAddressModeU[ 2 ] = ModeU ;
		GBASE.TexAddressModeU[ 3 ] = ModeU ;
		GBASE.TexAddressModeU[ 4 ] = ModeU ;
		GBASE.TexAddressModeU[ 5 ] = ModeU ;
		GBASE.TexAddressModeU[ 6 ] = ModeU ;
		GBASE.TexAddressModeU[ 7 ] = ModeU ;
		GBASE.TexAddressModeU[ 8 ] = ModeU ;
		GBASE.TexAddressModeU[ 9 ] = ModeU ;
		GBASE.TexAddressModeU[ 10 ] = ModeU ;
		GBASE.TexAddressModeU[ 11 ] = ModeU ;

		GBASE.TexAddressModeV[ 0 ] = ModeV ;
		GBASE.TexAddressModeV[ 1 ] = ModeV ;
		GBASE.TexAddressModeV[ 2 ] = ModeV ;
		GBASE.TexAddressModeV[ 3 ] = ModeV ;
		GBASE.TexAddressModeV[ 4 ] = ModeV ;
		GBASE.TexAddressModeV[ 5 ] = ModeV ;
		GBASE.TexAddressModeV[ 6 ] = ModeV ;
		GBASE.TexAddressModeV[ 7 ] = ModeV ;
		GBASE.TexAddressModeV[ 8 ] = ModeV ;
		GBASE.TexAddressModeV[ 9 ] = ModeV ;
		GBASE.TexAddressModeV[ 10 ] = ModeV ;
		GBASE.TexAddressModeV[ 11 ] = ModeV ;

		GRH.DrawPrepAlwaysFlag = TRUE ;
	}
	else
	{
		if( Stage < 0 || Stage >= USE_TEXTURESTAGE_NUM ) return 0 ;
		if( GBASE.TexAddressModeU[ Stage ] == ModeU &&
			GBASE.TexAddressModeV[ Stage ] == ModeV ) return 0;

		// 頂点を描画
		RenderVertexHardware() ;

		GBASE.TexAddressModeU[ Stage ] = ModeU ;
		GBASE.TexAddressModeV[ Stage ] = ModeV ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetTextureAddressUHardware( ModeU, Stage ) ;
		SetTextureAddressVHardware( ModeV, Stage ) ;
	}

	// 終了
	return 0 ;
}

// テクスチャ座標変換パラメータをセットする
extern int NS_SetTextureAddressTransform( float TransU, float TransV, float ScaleU, float ScaleV, float RotCenterU, float RotCenterV, float Rotate )
{
	MATRIX Transform, Temp1, Temp2, Temp3 ;
	int UseFlag ;

	UseFlag = FALSE ;

	if( Rotate != 0.0f )
	{
		CreateTranslationMatrix( &Temp1, -RotCenterU, -RotCenterV, 0.0f ) ; 
		CreateRotationZMatrix( &Temp2, Rotate ) ;
		CreateTranslationMatrix( &Temp3,  RotCenterU,  RotCenterV, 0.0f ) ; 
		CreateMultiplyMatrix( &Transform, &Temp1, &Temp2 ) ;
		CreateMultiplyMatrix( &Transform, &Transform, &Temp3 ) ;
		UseFlag = TRUE ;
	}
	else
	{
		CreateIdentityMatrix( &Transform ) ;
	}

	if( TransU != 0.0f || TransV != 0.0f )
	{
		CreateTranslationMatrix( &Temp1, TransU, TransV, 0.0f ) ;
		CreateMultiplyMatrix( &Transform, &Transform, &Temp1 ) ;
		UseFlag = TRUE ;
	}

	if( ScaleU != 1.0f || ScaleV != 1.0f )
	{
		CreateScalingMatrix( &Temp1, ScaleU, ScaleV, 1.0f ) ;
		CreateMultiplyMatrix( &Transform, &Transform, &Temp1 ) ;
		UseFlag = TRUE ;
	}

	// 元から使用しない場合は何もしない
	if( GBASE.TextureTransformUse == UseFlag && UseFlag == FALSE )
		return 0 ;

	// 設定を保存
	GBASE.TextureTransformUse = UseFlag ;
	GBASE.TextureTransformMatrix = Transform ;
	GBASE.TextureMatrixValid = FALSE ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetTextureAddressTransformMatrixHardware( UseFlag, &Transform ) ;
	}

	// 正常終了
	return 0 ;
}

// テクスチャ座標変換行列をセットする
extern int NS_SetTextureAddressTransformMatrix( MATRIX Matrix )
{
	// 設定を保存
	GBASE.TextureTransformUse = TRUE ;
	GBASE.TextureMatrixValid = TRUE ;
	GBASE.TextureMatrix = Matrix ;
	GBASE.TextureTransformMatrix = Matrix ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetTextureAddressTransformMatrixHardware( TRUE, &Matrix ) ;
	}

	// 正常終了
	return 0 ;
}

// テクスチャ座標変換パラメータをリセットする
extern int NS_ResetTextureAddressTransform( void )
{
	return NS_SetTextureAddressTransform( 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f ) ;
}

// フォグを有効にするかどうかを設定する( TRUE:有効  FALSE:無効 )
extern int NS_SetFogEnable( int Flag )
{
	if( GBASE.FogEnable == Flag && GRH.InitializeFlag == FALSE &&
		( GRA2.ValidHardWare == FALSE || ( GRA2.ValidHardWare && GRH.FogEnable == Flag ) ) ) return 0;

	// 頂点を描画
	RenderVertexHardware() ;

	GBASE.FogEnable = Flag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetFogEnableHardware( Flag ) ;
	}

	// 終了
	return 0 ;
}

// フォグモードを設定する
extern	int NS_SetFogMode( int Mode /* DX_FOGMODE_NONE 等 */ )
{
	if( GBASE.FogMode == Mode && GRH.InitializeFlag == FALSE &&
		( GRA2.ValidHardWare == FALSE || ( GRA2.ValidHardWare && GRH.FogMode == Mode ) ) ) return 0;

	// 頂点を描画
	RenderVertexHardware() ;

	GBASE.FogMode = Mode ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetFogModeHardware( Mode ) ;
	}

	// 終了
	return 0 ;
}

// フォグカラーを変更する
extern	int NS_SetFogColor( int r, int g, int b )
{
	DWORD color = ( ( 0xff ) << 24 ) | ( ( r & 0xff ) << 16 ) | ( ( g & 0xff ) << 8 ) | ( b & 0xff ) ;

	if( GBASE.FogColor == color && GRH.InitializeFlag == FALSE &&
		( GRA2.ValidHardWare == FALSE || ( GRA2.ValidHardWare && GRH.FogColor == color ) ) ) return 0;

	// 頂点を描画
	RenderVertexHardware() ;

	GBASE.FogColor = color ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetFogColorHardware( color ) ;
	}

	// 終了
	return 0 ;
}

// フォグが始まる距離と終了する距離を設定する( 0.0f ～ 1.0f )
extern	int	NS_SetFogStartEnd( float start, float end )
{
	if( GBASE.FogStart == start && GBASE.FogEnd == end && GRH.InitializeFlag == FALSE &&
		( GRA2.ValidHardWare == FALSE || ( GRA2.ValidHardWare && GRH.FogStart == start && GRH.FogEnd == end ) ) ) return 0 ;

	// 頂点を描画
	RenderVertexHardware() ;

	GBASE.FogStart = start ;
	GBASE.FogEnd = end ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetFogStartEndHardware( start, end ) ;
	}

	// 終了
	return 0 ;
}

// フォグの密度を設定する( 0.0f ～ 1.0f )
extern	int	NS_SetFogDensity( float density )
{
	if( GBASE.FogDensity == density && GRH.InitializeFlag == FALSE &&
		( GRA2.ValidHardWare == FALSE || ( GRA2.ValidHardWare && GRH.FogDensity == density ) ) ) return 0;

	// 頂点を描画
	RenderVertexHardware() ;

	GBASE.FogDensity = density ;

	// Direct3D に設定
	if( GRA2.ValidHardWare )
	{
		SetFogDensityHardware( density ) ;
	}

	// 終了
	return 0 ;
}

// システムメモリ上にグラフィックを作成するかどうかのフラグをセットする( TRUE:システムメモリ上に作成  FALSE:ＶＲＡＭ上に作成 )
extern	int NS_SetUseSystemMemGraphCreateFlag( int Flag )
{
	// フラグを保存する
	GBASE.SystemMemImageCreateFlag = Flag ;

	// 終了
	return 0 ;
}

// ＶＲＡＭを使用するかのフラグをセットする
extern	int NS_SetUseVramFlag( int Flag )
{
	return NS_SetUseSystemMemGraphCreateFlag( Flag == TRUE ? FALSE : TRUE ) ;
}

// DirectX のオブジェクトを解放する
extern void ReleaseDirectXObject( void )
{
	if( DxSysData.NotDrawFlag == FALSE )
	{
		// ハードウエアの場合のみ以下の処理を行う
		if( GRA2.ValidHardWare == TRUE )
		{
#ifndef DX_NON_MASK
			// マスクサーフェスを一時削除
			ReleaseMaskSurface() ;
#endif
			// グラフィックハンドルが持つ DirectX オブジェクトの解放
			ReleaseOrigDirectXObjectAll() ;
		}

		// システムが持つ DirectX オブジェクトの解放
		TerminateDirectX() ;
	}
}

// グラフィックスシステムの復帰、又は変更付きの再セットアップを行う
static int RestoreOrChangeSetupGraphSystem( int Change, int ScreenSizeX = -1, int ScreenSizeY = -1, int ColorBitDepth = -1, int RefreshRate = -1 )
{
	int i ;

#ifndef DX_NON_ASYNCLOAD
	// 非同期読み込みの途中の場合は、非同期読み込みが終了するまで待つ
	while( NS_GetASyncLoadNum() > 0 )
	{
		ProcessASyncLoadRequestMainThread() ;
		if( WinData.ProcessorNum <= 1 )
		{
			Thread_Sleep( 2 ) ;
		}
		else
		{
			Thread_Sleep( 0 ) ;
		}
	}
#endif // DX_NON_ASYNCLOAD

	// グラフィックスデバイスのロストから復帰する前に呼ぶ関数が登録されていたら実行する
	if( GRH.DeviceLostCallbackFunction )
	{
		GRH.DeviceLostCallbackFunction( GRH.DeviceLostCallbackData ) ;
	}

	// DirectX のオブジェクトを解放する
	ReleaseDirectXObject() ;

	if( Change == TRUE )
	{
		// 画面モードのセット
		SetMainScreenSize( ScreenSizeX, ScreenSizeY ) ;
		GRA2.MainScreenColorBitDepth = ColorBitDepth ;
		GRA2.MainScreenRefreshRate   = RefreshRate ;
		SetMemImgDefaultColorType( ColorBitDepth == 32 ? 1 : 0 ) ;
	}
	else
	{
		// DirectInput オブジェクトの再セットアップ
#ifndef DX_NON_INPUT
		TerminateDirectInput() ;
		InitializeDirectInput() ;
#endif // DX_NON_INPUT
	}

//	DXST_ERRORLOGFMT_ADD(( _T( "確保メモリ数:%d  確保メモリ総サイズ:%dByte(%dKByte)" ), NS_DxGetAllocNum(), NS_DxGetAllocSize(), NS_DxGetAllocSize() / 1024 )) ;

	if( DxSysData.NotDrawFlag == FALSE )
	{
		// DirectX オブジェクトの再作成
		InitializeDirectX() ;

		// ハードウエアの場合のみ以下の処理を行う
		if( GRA2.ValidHardWare == TRUE )
		{
			MATRIX ViewMatrix, ProjectionMatrix, ViewportMatrix ;

			// グラフィックハンドルが持つ DirectX オブジェクトの再取得
			AllocOrigDirectXObjectAll() ;

#ifndef DX_NON_MASK
			// マスクサーフェスの再作成
			ReCreateMaskSurface() ;
#endif
			// アクティブグラフィックのアドレスを再度設定
			if( Change == FALSE )
			{
				ViewMatrix       = GBASE.ViewMatrix ;
				ProjectionMatrix = GBASE.ProjectionMatrix ;
				ViewportMatrix   = GBASE.ViewportMatrix ;
			}
			NS_SetRenderTargetToShader( 0, GBASE.TargetScreen[ 0 ], GBASE.TargetScreenSurface[ 0 ] ) ;

			// グラフィック関係の設定を初期化
			ReInitializeHardware() ;

			// 画面の初期化
			NS_ClearDrawScreen() ;
			NS_ScreenFlip() ;
			NS_ClearDrawScreen() ;
			NS_ScreenFlip() ;

			// デバイスロスト発生時に削除するフラグが立っているグラフィックを削除する
			DeleteDeviceLostDeleteGraph() ;

			// グラフィックの復元
/*
			if( Change == TRUE )
			{
				// グラフィックの復元
				DefaultRestoreGraphFunction() ;

#ifndef DX_NON_MODEL
				// モデルのテクスチャを再読み込み
				MV1ReloadTexture() ;
#endif
				// フォントハンドルが持つキャッシュを初期化
				InitCacheFontToHandle() ;
			}
			else
*/			{
				NS_RunRestoreShred() ;
			}

			// グラフィックスデバイスのロストから復帰したときに呼ぶ関数が登録されていたら実行する
			if( GRH.DeviceRestoreCallbackFunction )
			{
				GRH.DeviceRestoreCallbackFunction( GRH.DeviceRestoreCallbackData ) ;
			}

			// ハードウエアの設定をリフレッシュ
			RefreshRenderStateHardware() ;

#ifndef DX_NON_MODEL
			// 頂点バッファのセットアップ
			MV1SetupVertexBufferAll() ;
#endif

			// ライトの設定を Direct3D に再反映するようにフラグをセット
			GBASE.Light.D3DRefresh = TRUE ;

			// その他の再設定
			if( Change == FALSE )
			{
				NS_SetDrawArea( GRA2.OriginalDrawRect.left, GRA2.OriginalDrawRect.top, GRA2.OriginalDrawRect.right, GRA2.OriginalDrawRect.bottom ) ;
				NS_SetTransformToWorld( &GBASE.WorldMatrix );
				NS_SetTransformToView( &ViewMatrix );
				NS_SetTransformToProjection( &ProjectionMatrix );
				NS_SetTransformToViewport( &ViewportMatrix );
			}

			// ０以外のターゲットのセットアップ
			for( i = 1 ; i < GRH.RenderTargetNum ; i ++ )
			{
				NS_SetRenderTargetToShader( i, GBASE.TargetScreen[ i ], GBASE.TargetScreenSurface[ i ] ) ;
			}
		}

#ifndef DX_NON_MOVIE
		// ムービーグラフィックの再生
		RestoreMovieAll() ;
#endif
	}

	// 終了
	return 0 ;
}

// ＤＸライブラリのグラフィック関連の復帰処理を行う
extern	int NS_RestoreGraphSystem( void )
{
	RestoreOrChangeSetupGraphSystem( FALSE ) ;

	// 終了
	return 0 ;
}

// Vista以降の Windows Aero を無効にするかどうかをセットする、TRUE:無効にする  FALSE:有効にする( DxLib_Init の前に呼ぶ必要があります )
extern int NS_SetAeroDisableFlag( int Flag )
{
	// 初期化前のみ有効
	if( DxSysData.DxLib_InitializeFlag == TRUE ) return -1 ;

	if( Flag )
	{
		GRH.DisableAeroFlag = 2 ;
	}
	else
	{
		GRH.DisableAeroFlag = 1 ;
	}

	// 終了
	return 0 ;
}

// Vista以降の環境で Direct3D9Ex を使用するかどうかを設定する( TRUE:使用する( デフォルト )  FALSE:使用しない )
extern int NS_SetUseDirect3D9Ex( int Flag )
{
	// 初期化前のみ有効
	if( DxSysData.DxLib_InitializeFlag == TRUE ) return -1 ;

	// フラグを保存
	GRH.NotUseDirect3D9Ex = Flag == FALSE ? TRUE : FALSE ;

	// 終了
	return 0 ;
}


// 色情報取得関係

extern COLOR_F NS_GetColorF( float Red, float Green, float Blue, float Alpha )
{
	COLOR_F Ret = { Red,  Green,  Blue,  Alpha } ;
	return Ret ;
}

extern COLOR_U8 NS_GetColorU8( int Red, int Green, int Blue, int Alpha )
{
	COLOR_U8 Ret = { ( BYTE )Blue, ( BYTE )Green, ( BYTE )Red, ( BYTE )Alpha } ;
	return Ret ;
}

// ３原色値から現在の画面モードに対応した色データ値を得る
extern	DWORD	NS_GetColor( int Red, int Green, int Blue )
{
	COLORDATA *ColorData ;

	// 色情報を返す
	if( GRA2.ValidHardWare == TRUE )
		ColorData = GetD3DFormatColorData( GRA2.MainScreenColorBitDepth == 16 ? D_D3DFMT_R5G6B5 : D_D3DFMT_X8R8G8B8 ) ;
	else
		ColorData = GetMemImgColorData(    GRA2.MainScreenColorBitDepth == 16 ?               0 :                 1, FALSE, FALSE ) ;
	
	return ColorData->NoneMask +
				( ( ( BYTE )Red   >> ( 8 - ColorData->RedWidth   ) ) << ColorData->RedLoc   ) +
				( ( ( BYTE )Green >> ( 8 - ColorData->GreenWidth ) ) << ColorData->GreenLoc ) +
				( ( ( BYTE )Blue  >> ( 8 - ColorData->BlueWidth  ) ) << ColorData->BlueLoc  ) ;
}

// 画面モードに対応した色データ値から個々の３原色データを抜き出す
extern	int		NS_GetColor2( int Color, int *Red, int *Green, int *Blue )
{
	COLORDATA *ColorData ;
	int MaxRed, MaxGreen, MaxBlue ;

	// 色情報を返す
	if( GRA2.ValidHardWare == TRUE )
		ColorData = GetD3DFormatColorData( GRA2.MainScreenColorBitDepth == 16 ? D_D3DFMT_R5G6B5 : D_D3DFMT_X8R8G8B8 ) ;
	else
		ColorData = GetMemImgColorData(    GRA2.MainScreenColorBitDepth == 16 ?               0 :                 1, FALSE, FALSE ) ;

	MaxRed		= ( 1 << ColorData->RedWidth   ) - 1 ; 
	MaxGreen	= ( 1 << ColorData->GreenWidth ) - 1 ;
	MaxBlue		= ( 1 << ColorData->BlueWidth  ) - 1 ; 

	// 色情報を格納する
	*Red	= ( ( Color & ColorData->RedMask   ) >> ColorData->RedLoc   ) * 255 / MaxRed   ;
	*Green	= ( ( Color & ColorData->GreenMask ) >> ColorData->GreenLoc ) * 255 / MaxGreen ;
	*Blue	= ( ( Color & ColorData->BlueMask  ) >> ColorData->BlueLoc  ) * 255 / MaxBlue  ;

	// 終了
	return 0 ;
}



// グラフィックハンドルが有効かどうかを調べる( TRUE:有効  FALSE:無効 )
extern	int IsValidGraphHandle( int GrHandle )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHKFULL( GrHandle, Image2 ) )
		return FALSE ;

	// 終了
	return TRUE ;
}

// 描画先バッファをアンロックする
extern int UnlockDrawScreenBuffer( void )
{
	// ロックしていなかったら何もせずに終了
	if( GRH.DrawScreenBufferLockFlag == FALSE ) return 0 ;

	// ハードウエアを使用しているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// 一時的に使用しているサーフェスをロックしたかどうかで処理を分岐
		if( GRH.DrawScreenBufferLockSMSurface != NULL )
		{
			// ロックの解除
			GraphicsSurface_UnlockRect( GRH.DrawScreenBufferLockSMSurface ) ;

			// 一時的に作成したサーフェスの解放
			// Graphics_ObjectRelease( GRH.DrawScreenBufferLockSMSurface ) ;
			ReleaseSysMemSurface( GRH.DrawScreenBufferLockSMSurfaceIndex, FALSE ) ;

			// サーフェスキャッシュインデックスを無効化
			GRH.DrawScreenBufferLockSMSurfaceIndex = -1 ;

			// ポインタを無効化
			GRH.DrawScreenBufferLockSMSurface = NULL ;
		}
		else
		{
			// 描画対象のサーフェスのロックを解除
			GraphicsSurface_UnlockRect( GRH.DrawScreenBufferLockSurface ) ;
			GRH.DrawScreenBufferLockSurface = NULL ;
		}
	}
	else
	{
	}

	// ロック中フラグを倒す
	GRH.DrawScreenBufferLockFlag = FALSE ;

	return 0 ;
}


// シェーダー定数情報の初期化
extern int InitializeShaderConstantInfoSet( SHADERCONSTANTINFOSET *ConstInfoSet )
{
	int i ;

	// とりあえず零初期化
	_MEMSET( ConstInfoSet, 0, sizeof( *ConstInfoSet ) ) ;

	// シェーダー定数の使用領域情報を初期化する
	for( i = 0 ; i < DX_SHADERCONSTANTSET_NUM ; i ++ )
	{
		InitializeShaderConstantUseArea( &ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_FLOAT ][ i ].UseArea, 256 ) ;
		ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_FLOAT ][ i ].UnitSize = sizeof( FLOAT4 ) ;

		InitializeShaderConstantUseArea( &ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_INT   ][ i ].UseArea,  16 ) ;
		ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_INT ][ i ].UnitSize = sizeof( INT4 ) ;

		InitializeShaderConstantUseArea( &ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_BOOL  ][ i ].UseArea,  16 ) ;
		ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_BOOL ][ i ].UnitSize = sizeof( BOOL ) ;

		InitializeShaderConstantUseArea( &ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_FLOAT ][ i ].UseArea, 224 ) ;
		ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_FLOAT ][ i ].UnitSize = sizeof( FLOAT4 ) ;

		InitializeShaderConstantUseArea( &ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_INT   ][ i ].UseArea,  16 ) ;
		ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_INT ][ i ].UnitSize = sizeof( INT4 ) ;

		InitializeShaderConstantUseArea( &ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_BOOL  ][ i ].UseArea,  16 ) ;
		ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_BOOL ][ i ].UnitSize = sizeof( BOOL ) ;
	}

	// 終了
	return 0 ;
}

// 指定のシェーダー定数セットを適用するかどうかを設定する
extern int SetUseShaderContantInfoState( SHADERCONSTANTINFOSET *ConstInfoSet, int ApplyMask )
{
	BYTE *BeforeMap ;
	BYTE AfterMap[ DX_SHADERCONSTANTTYPE_NUM ][ 256 ] ;
	BYTE ChangeInfo[ DX_SHADERCONSTANTTYPE_NUM ][ 256 ][ 2 ] ;
	int ChangeInfoNum[ DX_SHADERCONSTANTTYPE_NUM ] ;
	SHADERCONSTANTINFO *Info ;
	BYTE *Map ;
	FLOAT4 FloatConst[ 256 ] ;
	INT4 IntConst[ 16 ] ;
	BOOL BoolConst[ 16 ] ;
	int i, j, k, Size ;
	BYTE Start, End ;

	// 指定の定数セットの状態に変化が無い場合は何もしない
	if( ConstInfoSet->ApplyMask == ApplyMask )
		return 0 ;

	// マスクを保存
	ConstInfoSet->ApplyMask = ApplyMask ;

	// マスクからフラグマップを作成
	for( i = 0 ; i < DX_SHADERCONSTANTSET_NUM ; i ++ )
	{
		ConstInfoSet->IsApply[ i ] = ( ApplyMask & ( 1 << i ) ) != 0 ? TRUE : FALSE ;
	}

	// 変化後の使用マップの作成
	_MEMSET( AfterMap, 0xff, sizeof( AfterMap ) ) ;
	for( i = 0 ; i < DX_SHADERCONSTANTSET_NUM ; i ++ )
	{
		if( ConstInfoSet->IsApply[ i ] )
		{
			for( j = 0 ; j < DX_SHADERCONSTANTTYPE_NUM ; j ++ )
			{
				CreateUseAreaMap( &ConstInfoSet->Info[ j ][ i ].UseArea, AfterMap[ j ], ( BYTE )i ) ;
			}
		}
	}

	// 変化がある箇所の情報を構築
	for( i = 0 ; i < DX_SHADERCONSTANTTYPE_NUM ; i ++ )
	{
		BeforeMap = ConstInfoSet->SetMap[ i ] ;
		ChangeInfoNum[ i ] = 0 ;
		Size = ConstInfoSet->Info[ i ][ 0 ].UseArea.TotalSize ;
		j = 0;
		for(;;)
		{
			for( ; j < Size && ( AfterMap[ i ][ j ] == 0xff || BeforeMap[ j ] == AfterMap[ i ][ j ] ) ; j ++ ){}
			if( j == Size ) break ;

			ChangeInfo[ i ][ ChangeInfoNum[ i ] ][ 0 ] = ( BYTE )j ;

			for( ; j < Size && AfterMap[ i ][ j ] != 0xff && BeforeMap[ j ] != AfterMap[ i ][ j ] ; j ++ ){}

			ChangeInfo[ i ][ ChangeInfoNum[ i ] ][ 1 ] = ( BYTE )j ;

			ChangeInfoNum[ i ] ++ ;
		}
	}

	// 変化後の使用中タイプマップを保存
	_MEMCPY( ConstInfoSet->SetMap, AfterMap, sizeof( AfterMap ) ) ;


	// 変化のある箇所の定数を Direct3DDevice9 に適用

	for( j = 0 ; j < ChangeInfoNum[ DX_SHADERCONSTANTTYPE_VS_FLOAT ] ; j ++ )
	{
		Start = ChangeInfo[ DX_SHADERCONSTANTTYPE_VS_FLOAT ][ j ][ 0 ] ;
		End   = ChangeInfo[ DX_SHADERCONSTANTTYPE_VS_FLOAT ][ j ][ 1 ] ;
		Map = AfterMap[ DX_SHADERCONSTANTTYPE_VS_FLOAT ] ;
		Info = ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_FLOAT ] ;
		for( k = Start ; k < End ; k ++ )
		{
			FloatConst[ k ] = Info[ Map[ k ] ].Float4[ k ] ;
		}
		GraphicsDevice_SetVertexShaderConstantF( Start, ( float * )&FloatConst[ Start ], End - Start ) ;
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_VS_FLOAT ].Float4[ Start ], ( float * )&FloatConst[ Start ], sizeof( FLOAT4 ) * ( End - Start ) ) ;
	}

	for( j = 0 ; j < ChangeInfoNum[ DX_SHADERCONSTANTTYPE_VS_INT ] ; j ++ )
	{
		Start = ChangeInfo[ DX_SHADERCONSTANTTYPE_VS_INT ][ j ][ 0 ] ;
		End   = ChangeInfo[ DX_SHADERCONSTANTTYPE_VS_INT ][ j ][ 1 ] ;
		Map = AfterMap[ DX_SHADERCONSTANTTYPE_VS_INT ] ;
		Info = ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_INT ] ;
		for( k = Start ; k < End ; k ++ )
		{
			IntConst[ k ] = Info[ Map[ k ] ].Int4[ k ] ;
		}
		GraphicsDevice_SetVertexShaderConstantI( Start, ( int * )&IntConst[ Start ], End - Start ) ;
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_VS_INT ].Int4[ Start ], ( int * )&IntConst[ Start ], sizeof( INT4 ) * ( End - Start ) ) ;
	}

	for( j = 0 ; j < ChangeInfoNum[ DX_SHADERCONSTANTTYPE_VS_BOOL ] ; j ++ )
	{
		Start = ChangeInfo[ DX_SHADERCONSTANTTYPE_VS_BOOL ][ j ][ 0 ] ;
		End   = ChangeInfo[ DX_SHADERCONSTANTTYPE_VS_BOOL ][ j ][ 1 ] ;
		Map = AfterMap[ DX_SHADERCONSTANTTYPE_VS_BOOL ] ;
		Info = ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_VS_BOOL ] ;
		for( k = Start ; k < End ; k ++ )
		{
			BoolConst[ k ] = Info[ Map[ k ] ].Bool[ k ] ;
		}
		GraphicsDevice_SetVertexShaderConstantB( Start, ( BOOL * )&BoolConst[ Start ], End - Start ) ;
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_VS_BOOL ].Bool[ Start ], ( BOOL * )&BoolConst[ Start ], sizeof( BOOL ) * ( End - Start ) ) ;
	}



	for( j = 0 ; j < ChangeInfoNum[ DX_SHADERCONSTANTTYPE_PS_FLOAT ] ; j ++ )
	{
		Start = ChangeInfo[ DX_SHADERCONSTANTTYPE_PS_FLOAT ][ j ][ 0 ] ;
		End   = ChangeInfo[ DX_SHADERCONSTANTTYPE_PS_FLOAT ][ j ][ 1 ] ;
		Map = AfterMap[ DX_SHADERCONSTANTTYPE_PS_FLOAT ] ;
		Info = ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_FLOAT ] ;
		for( k = Start ; k < End ; k ++ )
		{
			FloatConst[ k ] = Info[ Map[ k ] ].Float4[ k ] ;
		}
		GraphicsDevice_SetPixelShaderConstantF( Start, ( float * )&FloatConst[ Start ], End - Start ) ;
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_PS_FLOAT ].Float4[ Start ], ( float * )&FloatConst[ Start ], sizeof( FLOAT4 ) * ( End - Start ) ) ;
	}

	for( j = 0 ; j < ChangeInfoNum[ DX_SHADERCONSTANTTYPE_PS_INT ] ; j ++ )
	{
		Start = ChangeInfo[ DX_SHADERCONSTANTTYPE_PS_INT ][ j ][ 0 ] ;
		End   = ChangeInfo[ DX_SHADERCONSTANTTYPE_PS_INT ][ j ][ 1 ] ;
		Map = AfterMap[ DX_SHADERCONSTANTTYPE_PS_INT ] ;
		Info = ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_INT ] ;
		for( k = Start ; k < End ; k ++ )
		{
			IntConst[ k ] = Info[ Map[ k ] ].Int4[ k ] ;
		}
		GraphicsDevice_SetPixelShaderConstantI( Start, ( int * )&IntConst[ Start ], End - Start ) ;
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_PS_INT ].Int4[ Start ], ( int * )&IntConst[ Start ], sizeof( INT4 ) * ( End - Start ) ) ;
	}

	for( j = 0 ; j < ChangeInfoNum[ DX_SHADERCONSTANTTYPE_PS_BOOL ] ; j ++ )
	{
		Start = ChangeInfo[ DX_SHADERCONSTANTTYPE_PS_BOOL ][ j ][ 0 ] ;
		End   = ChangeInfo[ DX_SHADERCONSTANTTYPE_PS_BOOL ][ j ][ 1 ] ;
		Map = AfterMap[ DX_SHADERCONSTANTTYPE_PS_BOOL ] ;
		Info = ConstInfoSet->Info[ DX_SHADERCONSTANTTYPE_PS_BOOL ] ;
		for( k = Start ; k < End ; k ++ )
		{
			BoolConst[ k ] = Info[ Map[ k ] ].Bool[ k ] ;
		}
		GraphicsDevice_SetPixelShaderConstantB( Start, ( BOOL * )&BoolConst[ Start ], End - Start ) ;
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_PS_BOOL ].Bool[ Start ], ( BOOL * )&BoolConst[ Start ], sizeof( BOOL ) * ( End - Start ) ) ;
	}

	// 終了
	return 0 ;
}

// シェーダー定数情報をデバイスに設定する
static int SetShaderConstantDeviceSet( SHADERCONSTANTINFOSET *ConstInfoSet, int TypeIndex, int ConstantIndex, const void *Param, int ParamNum )
{
	union
	{
		FLOAT4 TempArrayF[ 256 ] ;
		INT4 TempArrayI[ 16 ] ;
		BOOL TempArrayB[ 16 ] ;
	} ;

	// データが無い場合はマップから参照する
	if( Param == NULL )
	{
		SHADERCONSTANTINFO *Info ;
		BYTE *Map ;
		int Start, End ;
		int i ;

		Start = ConstantIndex ;
		End = Start + ParamNum ;
		Map = ConstInfoSet->SetMap[ TypeIndex ] ;

		Info = ConstInfoSet->Info[ TypeIndex ] ;
		switch( TypeIndex )
		{
		case DX_SHADERCONSTANTTYPE_VS_FLOAT :
		case DX_SHADERCONSTANTTYPE_PS_FLOAT :
			for( i = Start ; i < End ; i ++ )
			{
				TempArrayF[ i ] = Info[ Map[ i ] ].Float4[ i ] ;
			}
			Param = &TempArrayF[ Start ] ;
			break ;

		case DX_SHADERCONSTANTTYPE_VS_INT :
		case DX_SHADERCONSTANTTYPE_PS_INT :
			for( i = Start ; i < End ; i ++ )
			{
				TempArrayI[ i ] = Info[ Map[ i ] ].Int4[ i ] ;
			}
			Param = &TempArrayI[ Start ] ;
			break ;

		case DX_SHADERCONSTANTTYPE_VS_BOOL :
		case DX_SHADERCONSTANTTYPE_PS_BOOL :
			for( i = Start ; i < End ; i ++ )
			{
				TempArrayB[ i ] = Info[ Map[ i ] ].Bool[ i ] ;
			}
			Param = &TempArrayB[ Start ] ;
			break ;
		}
	}

	// デバイスにセットとパラメータを保存
	switch( TypeIndex )
	{
	case DX_SHADERCONSTANTTYPE_VS_FLOAT :
		if( GRH.UseShader == TRUE ) 
		{
			GraphicsDevice_SetVertexShaderConstantF( ConstantIndex, ( float * )Param, ParamNum ) ;
		}
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_VS_FLOAT ].Float4[ ConstantIndex ], Param, sizeof( FLOAT4 ) * ParamNum ) ;
		break ;

	case DX_SHADERCONSTANTTYPE_VS_INT :
		if( GRH.UseShader == TRUE ) 
		{
			GraphicsDevice_SetVertexShaderConstantI( ConstantIndex, ( int * )Param, ParamNum ) ;
		}
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_VS_INT ].Int4[ ConstantIndex ], Param, sizeof( INT4 ) * ParamNum ) ;
		break ;

	case DX_SHADERCONSTANTTYPE_VS_BOOL :
		if( GRH.UseShader == TRUE ) 
		{
			GraphicsDevice_SetVertexShaderConstantB( ConstantIndex, ( BOOL * )Param, ParamNum ) ;
		}
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_VS_BOOL ].Bool[ ConstantIndex ], Param, sizeof( BOOL ) * ParamNum ) ;
		break ;

	case DX_SHADERCONSTANTTYPE_PS_FLOAT :
		if( GRH.UseShader == TRUE ) 
		{
			GraphicsDevice_SetPixelShaderConstantF( ConstantIndex, ( float * )Param, ParamNum ) ;
		}
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_PS_FLOAT ].Float4[ ConstantIndex ], Param, sizeof( FLOAT4 ) * ParamNum ) ;
		break ;

	case DX_SHADERCONSTANTTYPE_PS_INT :
		if( GRH.UseShader == TRUE ) 
		{
			GraphicsDevice_SetPixelShaderConstantI( ConstantIndex, ( int * )Param, ParamNum ) ;
		}
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_PS_INT ].Int4[ ConstantIndex ], Param, sizeof( INT4 ) * ParamNum ) ;
		break ;

	case DX_SHADERCONSTANTTYPE_PS_BOOL :
		if( GRH.UseShader == TRUE ) 
		{
			GraphicsDevice_SetPixelShaderConstantB( ConstantIndex, ( BOOL * )Param, ParamNum ) ;
		}
		_MEMCPY( &ConstInfoSet->FixInfo[ DX_SHADERCONSTANTTYPE_PS_BOOL ].Bool[ ConstantIndex ], Param, sizeof( BOOL ) * ParamNum ) ;
		break ;
	}

	// 終了
	return 0 ;
}

// シェーダー定数情報を設定する
extern int SetShaderConstantSet( SHADERCONSTANTINFOSET *ConstInfoSet, int TypeIndex, int SetIndex, int ConstantIndex, const void *Param, int ParamNum, int UpdateUseArea )
{
	int Start, End ;
	int i ;
	bool bMaskHit ;
	BYTE *Map ;
	BYTE *UseMap ;
	SHADERCONSTANTINFO *Info ;

	Info = &ConstInfoSet->Info[ TypeIndex ][ SetIndex ] ;

	// 単体の使用範囲の更新
	if( UpdateUseArea )
	{
		SetShaderConstantUseArea( &Info->UseArea, TRUE, ConstantIndex, ParamNum ) ;
	}

	// 配列にデータをセット
	_MEMCPY( &Info->Data[ ConstantIndex * Info->UnitSize ], Param, ParamNum * Info->UnitSize ) ;

	// 範囲のセット
	Start = ConstantIndex ;
	End = Start + ParamNum ;

	// 全体の使用領域の更新
	bMaskHit = false ;
	Map = ConstInfoSet->SetMap[ TypeIndex ] ;
	UseMap = ConstInfoSet->UseMap[ TypeIndex ][ SetIndex ] ;
	for( i = Start; i < End; i++ )
	{
		UseMap[ i ] = TRUE ;

		if( ConstInfoSet->IsApply[ SetIndex ] )
		{
			if( Map[ i ] == 0xff || Map[ i ] <= SetIndex )
			{
				Map[ i ] = ( BYTE )SetIndex ;
			}
			else
			{
				bMaskHit = true ;
			}
		}
	}

	// デバイスにセット
	if( ConstInfoSet->IsApply[ SetIndex ] )
	{
		SetShaderConstantDeviceSet( ConstInfoSet, TypeIndex, ConstantIndex, bMaskHit == false ? Param : NULL, ParamNum ) ;
	}

	// 終了
	return 0 ;
}

// 指定領域のシェーダー定数情報をリセットする
extern int ResetShaderConstantSet( SHADERCONSTANTINFOSET *ConstInfoSet, int TypeIndex, int SetIndex, int ConstantIndex, int ParamNum )
{
	int Start, End ;
	int i, j ;
	bool bMaskHit ;
	BYTE *Map ;
	BYTE ( *UseMap )[ 256 ] ;
	SHADERCONSTANTINFO *Info ;

	// 使用範囲の更新
	Info = &ConstInfoSet->Info[ TypeIndex ][ SetIndex ] ;
	SetShaderConstantUseArea( &Info->UseArea, FALSE, ConstantIndex, ParamNum ) ;

	// 範囲のセット
	Start = ConstantIndex ;
	End = Start + ParamNum ;

	// 使用領域の更新
	Map = ConstInfoSet->SetMap[ TypeIndex ] ;
	UseMap = ConstInfoSet->UseMap[ TypeIndex ] ;
	bMaskHit = false ;
	for( i = Start; i < End; i++ )
	{
		UseMap[ SetIndex ][ i ] = FALSE ;

		if( Map[ i ] == SetIndex )
		{
			for( j = SetIndex; j >= 0 && UseMap[ j ][ i ] == FALSE; j-- ){}
			if( j == -1 )
			{
				Map[ i ] = 0xff ;
			}
			else
			{
				Map[ i ] = ( BYTE )j ;
				bMaskHit = true ;
			}
		}
	}

	// 使用領域が変化することで今まで無効だった定数が有効になる場合は定数情報の更新
	if( bMaskHit )
	{
		SetShaderConstantDeviceSet( ConstInfoSet, TypeIndex, ConstantIndex, NULL, ParamNum ) ;
	}

	// 終了
	return 0 ;
}

// 描画先バッファをロックする
extern int LockDrawScreenBuffer( RECT *LockRect, BASEIMAGE *BaseImage, int TargetScreen, int TargetScreenSurface, int ReadOnly, int TargetScreenTextureNo )
{
	IMAGEDATA2 *TargImage2 ;
	int Width, Height ;
	RECT DestRect ;
	HRESULT hr ;
	int UseSysMemSurfaceIndex = -1 ;

	// 描画処理を完了しておく
	RenderVertexHardware() ;
	EndScene() ;

	// 描画先の画像データアドレスを取得する
	if( TargetScreen == -1 )
	{
		TargetScreen = GBASE.TargetScreen[ 0 ] ;
		TargetScreenSurface = GBASE.TargetScreenSurface[ 0 ] ;
	}
	else
	{
		if( TargetScreenSurface == -1 )
		{
			TargetScreenSurface = 0 ;
		}
	}
	if( GRAPHCHKFULL( TargetScreen, TargImage2 ) )
		TargImage2 = NULL ;

	// 矩形のデータが不正だった場合エラー
	if( LockRect->left < 0 || LockRect->left >= LockRect->right  ||
		LockRect->top  < 0 || LockRect->top  >= LockRect->bottom ||
		LockRect->right  > GBASE.DrawSizeX ||
		LockRect->bottom > GBASE.DrawSizeY ) return -1 ;

	Width  = LockRect->right  - LockRect->left ;
	Height = LockRect->bottom - LockRect->top ;

	// ハードウエアを使用しているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// テクスチャの場合
		DX_DIRECT3DSURFACE9 *TargetSurface ;
		D_D3DFORMAT TargetFormat ;
		COLORDATA *TargetColorData ;
		D_D3DLOCKED_RECT SrcLockRect ;

		// 取り込み元となるサーフェスの決定

		// 描画可能画像が対象の場合
		if( TargImage2 )
		{
			TargetSurface = TargImage2->Orig->Hard.Tex[ TargetScreenTextureNo ].RenderTargetSurface ?
							TargImage2->Orig->Hard.Tex[ TargetScreenTextureNo ].RenderTargetSurface :
							TargImage2->Orig->Hard.Tex[ TargetScreenTextureNo ].Surface[ TargetScreenSurface ] ;
			TargetFormat = GRH.TextureFormat[ TargImage2->Orig->ColorFormat ] ;
		}
		else
		// それ以外の場合はサブバックバッファが有効だったらそれが対象
		{
			TargetSurface = GRH.SubBackBufferSurface ? GRH.SubBackBufferSurface : GRH.BackBufferSurface ;
			TargetFormat = GRH.ScreenFormat ;
		}
		TargetColorData = GetD3DFormatColorData( TargetFormat ) ;

		// ロックできる場合はいきなりロック
		if( GRH.UseRenderTargetLock == TRUE && 
			GraphicsSurface_LockRect( TargetSurface, &SrcLockRect, LockRect, ReadOnly ? D_D3DLOCK_READONLY : 0 ) == D_D3D_OK )
		{
			// ロックしたサーフェスのポインタを保存
			GRH.DrawScreenBufferLockSurface = TargetSurface ;

			// 一時的に使用しているサーフェスのポインタをリセット
			GRH.DrawScreenBufferLockSMSurface = NULL ;
		}
		else
		// 駄目だった場合は一度メモリに取り込んでからロック
		{
			DX_DIRECT3DSURFACE9 *RTSurface ;
			DX_DIRECT3DSURFACE9 *SMSurface ;

			// 取り込みサイズと同じ大きさの描画可能サーフェスの作成
			RTSurface = NULL ;
			if( GraphicsDevice_CreateRenderTarget(
					Width, Height, TargetFormat, D_D3DMULTISAMPLE_NONE, 0, FALSE, &RTSurface, NULL ) != D_D3D_OK )
			{
				DXST_ERRORLOG_ADD( _T( "バックバッファロック用描画可能サーフェスの作成に失敗しました\n" ) ) ;
				return -1 ;
			}

			// 取り込みサイズと同じ大きさのシステムメモリ上のオフスクリーンサーフェスの作成
			SMSurface = NULL ;
/*
			if( GraphicsDevice_CreateOffscreenPlainSurface(
					Width, Height, TargetFormat, D_D3DPOOL_SYSTEMMEM, &SMSurface, NULL ) != D_D3D_OK )
			{
				DXST_ERRORLOG_ADD( _T( "バックバッファロック用システムメモリサーフェスの作成に失敗しました\n" ) ) ;
				Graphics_ObjectRelease( RTSurface ) ;
				return -1 ;
			}
*/
			for(;;)
			{
				UseSysMemSurfaceIndex = GetSysMemSurface( Width, Height, TargetFormat, FALSE ) ;
				if( UseSysMemSurfaceIndex != -1 ) break ;
				if( NS_ProcessMessage() != 0 ) break ;
				Thread_Sleep( 1 ) ;
			}
			if( UseSysMemSurfaceIndex == -1 )
			{
				DXST_ERRORLOG_ADD( _T( "バックバッファロック用システムメモリサーフェスの作成に失敗しました\n" ) ) ;
				Graphics_ObjectRelease( RTSurface ) ;
				return -1 ;
			}
			SMSurface = GRH.SysMemSurface[ UseSysMemSurfaceIndex ].MemSurface ;

			// まず描画可能サーフェスに内容を転送する
			DestRect.left   = 0 ;
			DestRect.top    = 0 ;
			DestRect.right  = Width ;
			DestRect.bottom = Height ;
			hr = GraphicsDevice_StretchRect(
				TargetSurface, LockRect,
				RTSurface, &DestRect, D_D3DTEXF_NONE ) ;

			// その後システムメモリサーフェスに内容を転送する
			hr = GraphicsDevice_GetRenderTargetData(
				RTSurface, SMSurface ) ;

			// システムメモリサーフェスをロック
			hr = GraphicsSurface_LockRect( SMSurface, &SrcLockRect, NULL, ReadOnly ? D_D3DLOCK_READONLY : 0 ) ;

			// 一時的に使用しているサーフェスのポインタを保存
			GRH.DrawScreenBufferLockSMSurface = SMSurface ;

			// 一時的に使用しているサーフェスキャッシュのインデックスを保存
			GRH.DrawScreenBufferLockSMSurfaceIndex = UseSysMemSurfaceIndex ;

			// 一時的に作成したサーフェスの解放
			Graphics_ObjectRelease( RTSurface ) ;
		}

		// 基本イメージ構造体のデータにセット
		BaseImage->ColorData = *TargetColorData ;
		BaseImage->Width = Width ;
		BaseImage->Height = Height ;
		BaseImage->Pitch = SrcLockRect.Pitch ;
		BaseImage->GraphData = SrcLockRect.pBits ;
		BaseImage->MipMapCount = 0 ;
		BaseImage->GraphDataCount = 0 ;
	}
	else
	{
		// ソフトウエアレンダリングの場合

		// データをセット
		if( TargImage2 )
		{
			BaseImage->ColorData = *TargImage2->Soft.MemImg.Base->ColorDataP ;
			BaseImage->Pitch = TargImage2->Soft.MemImg.Base->Pitch ;
			BaseImage->GraphData = ( BYTE * )TargImage2->Soft.MemImg.UseImage + BaseImage->ColorData.PixelByte * LockRect->left + BaseImage->Pitch * LockRect->top ;
		}
		else
		{
			BaseImage->ColorData = *GRS.MainBufferMemImg.Base->ColorDataP ;
			BaseImage->Pitch = GRS.MainBufferMemImg.Base->Pitch ;
			BaseImage->GraphData = ( BYTE * )GRS.MainBufferMemImg.UseImage + BaseImage->ColorData.PixelByte * LockRect->left + BaseImage->Pitch * LockRect->top ;
		}
		BaseImage->Width = Width ;
		BaseImage->Height = Height ;
		BaseImage->MipMapCount = 0 ;
		BaseImage->GraphDataCount = 0 ;
	}

	// ロック中フラグを立てる
	GRH.DrawScreenBufferLockFlag = TRUE ;

	// 終了
	return 0 ;
}

// 描画対象の画面から指定領域のグラフィックを基本イメージデータに転送する
extern int NS_GetDrawScreenBaseImage( int x1, int y1, int x2, int y2, BASEIMAGE *BaseImage )
{
	return NS_GetDrawScreenBaseImageDestPos( x1, y1, x2, y2, BaseImage, 0, 0 ) ;
}

// 描画対象の画面から指定領域を基本イメージデータに転送する( 転送先座標指定版 )
extern	int NS_GetDrawScreenBaseImageDestPos( int x1, int y1, int x2, int y2, BASEIMAGE *BaseImage, int DestX, int DestY )
{
	RECT SrcRect ;
	BASEIMAGE BufferImage ;

	// 座標チェック
	if( x1 < 0 || y1 < 0 || x1 >= x2 || y1 >= y2 )
	{
		return -1 ;
	}

	// 取り込みサイズと取り込み先が画像サイズより大きい場合はエラー
	if( BaseImage->Width < DestX + x2 - x1 || BaseImage->Height < DestY + y2 - y1 )
	{
		return -1 ;
	}

	// 描画先バッファをロック
	SrcRect.left   = x1 ;
	SrcRect.right  = x2 ;
	SrcRect.top    = y1 ;
	SrcRect.bottom = y2 ;
	if( LockDrawScreenBuffer( &SrcRect, &BufferImage, -1, -1, TRUE, 0 ) < 0 )
	{
		return -1 ;
	}

//	// 取り込みサイズと画像サイズが違う場合はエラー
//	if( BaseImage->Width != BufferImage.Width || BaseImage->Height != BufferImage.Height ) return -1 ;

	// データを転送
	NS_BltBaseImage( DestX, DestY, &BufferImage, BaseImage ) ;

	// 描画先バッファをアンロック
	UnlockDrawScreenBuffer() ;

	// 終了
	return 0 ;
}

// 描画可能画像やバックバッファから指定領域のグラフィックを取得する
extern	int GetDrawScreenGraphBase( int TargetScreen, int TargetScreenSurface, int x1, int y1, int x2, int y2, int destX, int destY, int GrHandle )
{
	IMAGEDATA2 *Image2, *TargImage2 ;
//	IMAGEDATA2_HARD_DRAW *DrawTex ;
	int Width, Height ;
//	int i ;
	RECT Rect, SrcRect, DestRect, DestBaseRect ;
//	HRESULT hr ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	// 描画処理を完了しておく
	RenderVertexHardware() ;
	EndScene() ;

	// 描画先の画像データアドレスを取得する
	if( GRAPHCHKFULL( TargetScreen, TargImage2 ) )
		TargImage2 = NULL ;

	// 矩形のデータが不正だった場合エラー
	if( x1 < 0 || x1 >= x2 ||
		y1 < 0 || y1 >= y2 ||
		x2 > GBASE.DrawSizeX ||
		y2 > GBASE.DrawSizeY ) return -1 ;

	// 取り込み先が画像をはみ出ていたらエラー
	Width  = x2 - x1 ;
	Height = y2 - y1 ;
	if( Image2->Width < Width + destX || Image2->Height < Height + destY ) return -1 ;
	DestBaseRect.left = destX ;
	DestBaseRect.top = destY ;
	DestBaseRect.right = destX + Width ;
	DestBaseRect.bottom = destY + Height ;

	// テクスチャかどうかで処理を分岐
	if( Image2->Orig->FormatDesc.TextureFlag )
	{
		// テクスチャの場合
		DX_DIRECT3DSURFACE9 *TargetSurface ;
		D_D3DFORMAT TargetFormat ;
//		COLORDATA *DestColorData ;
		COLORDATA *TargetColorData ;

		// 取り込み元となるサーフェスの決定

		// 描画可能画像が対象の場合
		if( TargImage2 )
		{
			TargetSurface = TargImage2->Orig->Hard.Tex[ 0 ].RenderTargetSurface ?
							TargImage2->Orig->Hard.Tex[ 0 ].RenderTargetSurface :
							TargImage2->Orig->Hard.Tex[ 0 ].Surface[ TargetScreenSurface ] ;
			TargetFormat = GRH.TextureFormat[ TargImage2->Orig->ColorFormat ] ;
		}
		else
		// それ以外の場合はサブバックバッファが有効だったらそれが対象
		{
			TargetSurface = GRH.SubBackBufferSurface ? GRH.SubBackBufferSurface : GRH.BackBufferSurface ;
			TargetFormat = GRH.ScreenFormat ;
		}
		TargetColorData = GetD3DFormatColorData( TargetFormat ) ;

		// 転送先となるサーフェスが描画可能テクスチャだった場合は単純に転送
		if( Image2->Orig->FormatDesc.DrawValidFlag )
		{
			SrcRect.left = x1 ;
			SrcRect.top = y1 ;
			SrcRect.right = x2 ;
			SrcRect.bottom = y2 ;

			DestRect.left = destX ;
			DestRect.top = destY ;
			DestRect.right = destX + Width ;
			DestRect.bottom = destY + Height ;
			GraphicsDevice_StretchRect(
				TargetSurface,                            &SrcRect,
				Image2->Orig->Hard.Tex[ 0 ].Surface[ 0 ], &DestRect, D_D3DTEXF_NONE ) ;
		}
		else
		// 通常のテクスチャだった場合は最初にロックを試し、駄目だったら一度メモリに取り込んでから転送
		{
//			D_D3DLOCKED_RECT DestLockRect ;
//			POINT DestPoint ;

			// 描画先バッファをロック
			BASEIMAGE LockImage ;
//			DX_DIRECT3DTEXTURE9 *UseTex ;
			SrcRect.left = x1 ;
			SrcRect.top = y1 ;
			SrcRect.right = x2 ;
			SrcRect.bottom = y2 ;
			if( LockDrawScreenBuffer( &SrcRect, &LockImage, TargetScreen, TargetScreenSurface, TRUE, 0 ) < 0 )
				return -1 ;

			// テクスチャに転送
			Rect.left = 0 ;
			Rect.top = 0 ;
			Rect.right = LockImage.Width ;
			Rect.bottom = LockImage.Height ;
			BltBmpOrBaseImageToGraph3(
				NULL,
				NULL, NULL,
				&Rect,
				destX, destY,
				GrHandle,
				FALSE,
				&LockImage, NULL,
				FALSE,
				FALSE,
				FALSE
			) ;

			// 描画先バッファのアンロック
			UnlockDrawScreenBuffer() ;
		}
	}
	else
	{
		// ソフトウエアレンダリングの場合

		// 描画対象から転送
		Rect.left = x1 ;
		Rect.top = y1 ;
		Rect.right = x2 ;
		Rect.bottom = y2 ;
		BltMemImg( &Image2->Soft.MemImg, TargImage2 ? &TargImage2->Soft.MemImg : &GRS.MainBufferMemImg, &Rect, destX, destY ) ;
	}

	// 終了
	return 0 ;
}

// アクティブになっている画面から指定領域のグラフィックを取得する
extern	int NS_GetDrawScreenGraph( int x1, int y1, int x2, int y2, int GrHandle, int /*UseClientFlag*/ )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	// 取り込みサイズと画像サイズが違う場合はエラー
	if( Image2->Width != x2 - x1 || Image2->Height != y2 - y1 ) return -1 ;

	return GetDrawScreenGraphBase( GBASE.TargetScreen[ 0 ], GBASE.TargetScreenSurface[ 0 ], x1, y1, x2, y2, 0, 0, GrHandle ) ;
}

// 描画可能画像から指定領域のグラフィックを取得する
extern int NS_BltDrawValidGraph( int TargetDrawValidGrHandle, int x1, int y1, int x2, int y2, int DestX, int DestY, int DestGrHandle )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHK( TargetDrawValidGrHandle, Image2 ) )
		return -1 ;

	return GetDrawScreenGraphBase( TargetDrawValidGrHandle, 0, x1, y1, x2, y2, DestX, DestY, DestGrHandle ) ;
}

// 指定の画像のＡＲＧＢ８のフルカラーイメージを取得する
extern const DWORD *NS_GetFullColorImage( int GrHandle )
{
	IMAGEDATA2 *Image2 ;

	if( GBASE.NotDrawFlag ) return 0 ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return NULL ;

	// フルカラーイメージを格納するメモリ領域をまだ確保していない場合は確保する
	if( Image2->FullColorImage == NULL )
	{
		Image2->FullColorImage = ( DWORD * )DXALLOC( Image2->Width * 4 * Image2->Height ) ;
		if( Image2->FullColorImage == NULL )
		{
			DXST_ERRORLOG_ADD( _T( "フルカラーの画像イメージデータを格納するメモリ領域を確保出来ませんでした。\n" ) ) ;
			return NULL;
		}
	}

#ifndef DX_NON_MOVIE

	// ムービーの場合は処理を分岐
	if( Image2->MovieHandle >= 0 )
	{
		MOVIEGRAPH * Movie ;
		Movie = GetMovieData( Image2->MovieHandle ) ;
		if( Movie == NULL ) return NULL ;
		static BASEIMAGE Src, Dest ;

		// サーフェスモードがオーバーレイの場合は無理
		if( Movie->SurfaceMode == DX_MOVIESURFACE_OVERLAY ) return NULL ;

		// それ以外の場合はムービーから直接データを取得する

		// ムービーのフレームを更新
		if( NS_GetMovieStateToGraph( GrHandle ) == FALSE )
		{
			int Time ;

			Time = NS_TellMovieToGraph( GrHandle ) ;
			NS_PlayMovieToGraph( GrHandle ) ;
			UpdateMovie( Image2->MovieHandle, TRUE ) ;
			NS_PauseMovieToGraph( GrHandle ) ;
			NS_SeekMovieToGraph( GrHandle, Time ) ;
		}
		else
		{
//			UpdateMovieToGraph( GrHandle ) ;
		}

		// 転送先基本イメージデータの情報を準備する
		CreateARGB8ColorData( &Dest.ColorData ) ;
		Dest.Width     = Image2->Width ;
		Dest.Height    = Image2->Height ;
		Dest.GraphData = Image2->FullColorImage ;
		Dest.Pitch     = Image2->Width * 4 ;

		// 传送
		BltBaseImage( 0, 0, Image2->Width, Image2->Height, 0, 0, &Movie->NowImage, &Dest ) ;
	}
	else
#endif
	{
	}

	// イメージのポインタを返す
	return (DWORD *)Image2->FullColorImage ;
}


// グラフィックメモリ領域のロック
extern int NS_GraphLock( int GrHandle, int *PitchBuf, void **DataPointBuf, COLORDATA **ColorDataPP )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	int i ;
	RECT Rect ;
	COLORDATA *ColorData ;
	BYTE *Dest, *Src ;
	DWORD WidthByte ;
	HRESULT hr ;

	// 画像かどうかで処理を分岐
	if( GrHandle == DX_SCREEN_BACK || GrHandle == DX_SCREEN_FRONT )
	{
		// ハードウエアを使用しているかどうかで処理を分岐
		if( GRA2.ValidHardWare )
		{
			// ハードウエアでのロックは対応していない
			return -1 ;
		}
		else
		{
			// ソフトウエアの場合は画面イメージの情報を返す
			if( ColorDataPP  ) *ColorDataPP  = GRS.MainBufferMemImg.Base->ColorDataP ;
			if( PitchBuf     ) *PitchBuf     = GRS.MainBufferMemImg.Base->Pitch ;
			if( DataPointBuf ) *DataPointBuf = GRS.MainBufferMemImg.UseImage ;
		}
	}
	else
	{
		// エラー判定
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;

		// 既にロックしてあったらエラー
		if( Image2->LockFlag == TRUE ) return -1 ;

		// ロックフラグを立てる
		Image2->LockFlag = TRUE ;

		// テクスチャかどうかで処理を分岐
		if( Image2->Orig->FormatDesc.TextureFlag )
		{
			// テクスチャの場合
			D_D3DLOCKED_RECT LockRect ;
			DX_DIRECT3DSURFACE9 *SMSurface ;

			// 描画を終了しておく
			RenderVertexHardware() ;
			EndScene() ;

			// テクスチャのフォーマットを取得
			ColorData = GetD3DFormatColorData( GRH.TextureFormat[ Image2->Orig->ColorFormat ] ) ;

			// ロック時のテンポラリイメージを格納するためのメモリを確保
			Image2->LockImagePitch = Image2->Width * ColorData->PixelByte ;
			Image2->LockImage = ( BYTE * )DXALLOC( Image2->Height * Image2->LockImagePitch ) ;
			if( Image2->LockImage == NULL )
			{
				DXST_ERRORLOG_ADD( _T( "ロック用テンポラリイメージ格納用メモリの確保に失敗しました\n" ) ) ;
				return -1 ;
			}

			// 描画情報の数だけ繰り返し
			DrawTex = Image2->Hard.Draw ;
			SMSurface = NULL ;
			for( i = 0 ; i < Image2->Hard.DrawNum ; i ++, DrawTex ++ )
			{
				// Direct3D9Ex を使用しているか、描画可能テクスチャの場合は一度システムメモリサーフェスにデータを転送してからロックする
				if( Graphics_IsExObject() || Image2->Orig->FormatDesc.DrawValidFlag )
				{
					DX_DIRECT3DSURFACE9 *RTSurface ;
					RECT DestRect ;

					// 取り込みサイズと同じ大きさの描画可能サーフェスの作成
					RTSurface = NULL ;
					if( GraphicsDevice_CreateRenderTarget(
							DrawTex->Width,
							DrawTex->Height,
							GRH.TextureFormat[ Image2->Orig->ColorFormat ],
							D_D3DMULTISAMPLE_NONE,
							0,
							FALSE,
							&RTSurface,
							NULL
						) != D_D3D_OK )
					{
						DXST_ERRORLOG_ADD( _T( "ロック用描画可能サーフェスの作成に失敗しました\n" ) ) ;
						return -1 ;
					}

					// 取り込みサイズと同じ大きさのシステムメモリ上のオフスクリーンサーフェスの作成
					if( GraphicsDevice_CreateOffscreenPlainSurface(
							DrawTex->Width,
							DrawTex->Height,
							GRH.TextureFormat[ Image2->Orig->ColorFormat ],
							D_D3DPOOL_SYSTEMMEM,
							&SMSurface,
							NULL
						) != D_D3D_OK )
					{
						DXST_ERRORLOG_ADD( _T( "ロック用システムメモリサーフェスの作成に失敗しました\n" ) ) ;
						Graphics_ObjectRelease( RTSurface ) ;
						return -1 ;
					}

					// まず描画可能サーフェスに内容を転送する
					Rect.left       = DrawTex->UsePosX ;
					Rect.top        = DrawTex->UsePosY ;
					Rect.right      = DrawTex->UsePosX + DrawTex->Width ;
					Rect.bottom     = DrawTex->UsePosY + DrawTex->Height ;
					DestRect.left   = 0 ;
					DestRect.top    = 0 ;
					DestRect.right  = DrawTex->Width ;
					DestRect.bottom = DrawTex->Height ;
					hr = GraphicsDevice_StretchRect(
						DrawTex->Tex->Surface[ 0 ], &Rect,
						RTSurface, &DestRect, D_D3DTEXF_NONE ) ;

					// その後システムメモリサーフェスに内容を転送する
					hr = GraphicsDevice_GetRenderTargetData( RTSurface, SMSurface ) ;

					// 一時的に作成したサーフェスの解放
					Graphics_ObjectRelease( RTSurface ) ;

					// システムメモリーフェスをロック
					Rect.left   = 0 ;
					Rect.top    = 0 ;
					Rect.right  = DrawTex->Width ;
					Rect.bottom = DrawTex->Height ;
					hr = GraphicsSurface_LockRect( SMSurface, &LockRect, &Rect, D_D3DLOCK_READONLY ) ;
				}
				else
				{
					// それ以外の場合はいきなりロック
					Rect.left   = DrawTex->UsePosX ;
					Rect.top    = DrawTex->UsePosY ;
					Rect.right  = DrawTex->UsePosX + DrawTex->Width ;
					Rect.bottom = DrawTex->UsePosY + DrawTex->Height ;
					hr = GraphicsSurface_LockRect( DrawTex->Tex->Surface[ 0 ], &LockRect, &Rect, D_D3DLOCK_READONLY ) ;
				}

				// 传送
				Src = ( BYTE * )LockRect.pBits ;
				Dest = Image2->LockImage + DrawTex->DrawPosX * ColorData->PixelByte + DrawTex->DrawPosY * Image2->LockImagePitch ;
				WidthByte = DrawTex->Width * ColorData->PixelByte ;
				for( i = 0 ; i < DrawTex->Height ; i ++, Dest += Image2->LockImagePitch, Src += LockRect.Pitch )
				{
					_MEMCPY( Dest, Src, WidthByte ) ;
				}

				// ロックの解除
				if( SMSurface )
				{
					GraphicsSurface_UnlockRect( SMSurface ) ;
					Graphics_ObjectRelease( SMSurface ) ;
				}
				else
				{
					GraphicsSurface_UnlockRect( DrawTex->Tex->Surface[ 0 ] ) ;
				}
			}

			// 情報の格納
			if( PitchBuf     ) *PitchBuf = Image2->LockImagePitch ;
			if( DataPointBuf ) *DataPointBuf = ( void * )Image2->LockImage ;
			if( ColorDataPP  ) *ColorDataPP = ColorData ;
		}
		else
		{
			// テクスチャではない場合
			if( PitchBuf     ) *PitchBuf     = Image2->Soft.MemImg.Base->Pitch ;
			if( DataPointBuf ) *DataPointBuf = Image2->Soft.MemImg.UseImage ;
			if( ColorDataPP  ) *ColorDataPP  = Image2->Soft.MemImg.Base->ColorDataP ;
		}
	}

	// 終了
	return 0 ;
}

// グラフィックメモリ領域のロック解除
extern	int NS_GraphUnLock( int GrHandle )
{
	IMAGEDATA2 *Image2 ;
	IMAGEDATA2_HARD_DRAW *DrawTex ;
	int i, j ;
	RECT Rect, SrcRect ;
	COLORDATA *ColorData ;
	BYTE *Dest, *Src ;
	DWORD WidthByte ;
	POINT DestPoint ;
	HRESULT hr ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	// ロックしてなかったらエラー
	if( Image2->LockFlag == FALSE ) return -1 ;

	// ロックフラグを倒す
	Image2->LockFlag = FALSE ;

	// テクスチャかどうかで処理を分岐
	if( Image2->Orig->FormatDesc.TextureFlag )
	{
		// テクスチャの場合
		D_D3DLOCKED_RECT LockRect ;
		DX_DIRECT3DSURFACE9 *SMSurface ;

		// 描画を終了しておく
		RenderVertexHardware() ;
		EndScene() ;

		// テクスチャのフォーマットを取得
		ColorData = GetD3DFormatColorData( GRH.TextureFormat[ Image2->Orig->ColorFormat ] ) ;

		// 描画情報の数だけ繰り返し
		DrawTex = Image2->Hard.Draw ;
		SMSurface = NULL ;
		for( i = 0 ; i < Image2->Hard.DrawNum ; i ++, DrawTex ++ )
		{
			// Direct3D9Ex を使用しているか、又は描画可能テクスチャかどうかで処理を分岐
			if( Graphics_IsExObject() || Image2->Orig->FormatDesc.DrawValidFlag )
			{
				// Direct3D9Ex を使用しているか、又は描画可能テクスチャの場合は一度システムメモリサーフェスにデータを転送してから更新する
				if( GraphicsDevice_CreateOffscreenPlainSurface( DrawTex->Width, DrawTex->Height, GRH.TextureFormat[ Image2->Orig->ColorFormat ], D_D3DPOOL_SYSTEMMEM, &SMSurface, NULL ) != D_D3D_OK )
				{
					DXST_ERRORLOG_ADD( _T( "ロック用テンポラリのシステムメモリ配置サーフェスの作成に失敗しました\n" ) ) ;
					return -1 ;
				}

				// 作成したテクスチャをロック
				hr = GraphicsSurface_LockRect( SMSurface, &LockRect, NULL, 0 ) ;

				// データを転送
				Src = Image2->LockImage + ColorData->PixelByte * DrawTex->DrawPosX + Image2->LockImagePitch * DrawTex->DrawPosY ;
				Dest = ( BYTE * )LockRect.pBits ;
				WidthByte = Image2->Width * ColorData->PixelByte ;
				for( j = 0 ; j < DrawTex->Height ; j ++, Src += Image2->LockImagePitch, Dest += LockRect.Pitch )
				{
					_MEMCPY( Dest, Src, WidthByte ) ;
				}

				// ロック解除
				GraphicsSurface_UnlockRect( SMSurface ) ;

				// システムメモリサーフェスから描画可能テクスチャに転送
				SrcRect.left = 0 ;
				SrcRect.top = 0 ;
				SrcRect.right = DrawTex->Width ;
				SrcRect.bottom = DrawTex->Height ;
				DestPoint.x = DrawTex->UsePosX ;
				DestPoint.y = DrawTex->UsePosY ;
				hr = GraphicsDevice_UpdateSurface(
					SMSurface,                  &SrcRect,
					DrawTex->Tex->Surface[ 0 ], &DestPoint ) ;

				// システムメモリサーフェス解放
				if( SMSurface )
				{
					Graphics_ObjectRelease( SMSurface ) ;
					SMSurface = NULL ;
				}
			}
			else
			{
				// 通常のテクスチャの場合はロックして転送する

				// ロック
				Rect.left = DrawTex->UsePosX ;
				Rect.top = DrawTex->UsePosY ;
				Rect.right = DrawTex->UsePosX + DrawTex->Width ;
				Rect.bottom = DrawTex->UsePosY + DrawTex->Height ;
				hr = GraphicsSurface_LockRect( DrawTex->Tex->Surface[ 0 ], &LockRect, &Rect, 0 ) ;

				// 传送
				Src = Image2->LockImage + DrawTex->DrawPosX * ColorData->PixelByte + DrawTex->DrawPosY * Image2->LockImagePitch ;
				Dest = ( BYTE * )LockRect.pBits ;
				WidthByte = DrawTex->Width * ColorData->PixelByte ;
				for( i = 0 ; i < DrawTex->Height ; i ++, Src += Image2->LockImagePitch, Dest += LockRect.Pitch )
				{
					_MEMCPY( Dest, Src, WidthByte ) ;
				}

				// ロックの解除
				GraphicsSurface_UnlockRect( DrawTex->Tex->Surface[ 0 ] ) ;
			}
		}

		// ロックイメージの解放
		DXFREE( Image2->LockImage ) ;
		Image2->LockImage = NULL ;
	}
	else
	{
		// テクスチャではない場合
	}

	// 終了
	return 0 ;
}

// グラフィックにＺバッファを使用するかどうかを設定する
extern	int NS_SetUseGraphZBuffer( int GrHandle, int UseFlag, int BitDepth )
{
	IMAGEDATA2 *Image2 ;
	int DepthIndex ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	// テクスチャではない場合は何もしない
	if( Image2->Orig->FormatDesc.TextureFlag == FALSE )
		return -1 ;

	// 描画可能ではない場合も何もしない
	if( Image2->Orig->FormatDesc.DrawValidFlag == FALSE )
		return -1 ;

	// ビット深度のセット
	if( Image2->Orig->ZBufferFlag == TRUE && BitDepth < 0 )
	{
		DepthIndex = Image2->Orig->ZBufferBitDepthIndex ;
	}
	else
	{
		switch( BitDepth )
		{
		default :
		case 16 : DepthIndex = ZBUFFER_FORMAT_16BIT ; break ;
		case 24 : DepthIndex = ZBUFFER_FORMAT_24BIT ; break ;
		case 32 : DepthIndex = ZBUFFER_FORMAT_32BIT ; break ;
		}
	}

	// Ｚバッファを使うフラグとビット深度が同じだったら何もしない
	if( Image2->Orig->ZBufferFlag == UseFlag && Image2->Orig->ZBufferBitDepthIndex == DepthIndex )
		return 0 ;

	// フラグを保存
	Image2->Orig->ZBufferFlag = UseFlag ;

	// ビット深度インデックスを保存
	Image2->Orig->ZBufferBitDepthIndex = DepthIndex ;

	// テクスチャの作り直し
	CreateOrigTexture( Image2->Orig ) ;

	// 終了
	return 0 ;
}

// グラフィックのＺバッファの状態を別のグラフィックのＺバッファにコピーする( DestGrHandle も SrcGrHandle もＺバッファを持っている描画可能画像で、且つアンチエイリアス画像ではないことが条件 )
extern int NS_CopyGraphZBufferImage( int DestGrHandle, int SrcGrHandle )
{
	IMAGEDATA2 *SrcImage2 ;
	IMAGEDATA2 *DestImage2 ;

	// エラー判定
	if( GRAPHCHK( SrcGrHandle, SrcImage2 ) )
		return -1 ;

	if( GRAPHCHK( DestGrHandle, DestImage2 ) )
		return -1 ;

	// テクスチャではない場合は何もしない
	if( SrcImage2->Orig->FormatDesc.TextureFlag == FALSE ||
		DestImage2->Orig->FormatDesc.TextureFlag == FALSE )
		return -1 ;

	// 描画可能ではない場合も何もしない
	if( SrcImage2->Orig->FormatDesc.DrawValidFlag == FALSE ||
		DestImage2->Orig->FormatDesc.DrawValidFlag == FALSE )
		return -1 ;

	// アンチエイリアスレンダリングターゲットの場合も何もしない
	if( SrcImage2->Orig->FormatDesc.MSSamples != D_D3DMULTISAMPLE_NONE ||
		DestImage2->Orig->FormatDesc.MSSamples != D_D3DMULTISAMPLE_NONE )
		return -1 ;

	// Ｚバッファが無い場合も何もしない
	if( SrcImage2->Orig->Hard.Tex[ 0 ].ZBuffer == NULL ||
		DestImage2->Orig->Hard.Tex[ 0 ].ZBuffer == NULL )
		return -1 ;

	// サイズが違う場合も何もしない
	if( SrcImage2->Orig->Hard.Tex[ 0 ].TexWidth != DestImage2->Orig->Hard.Tex[ 0 ].TexWidth ||
		SrcImage2->Orig->Hard.Tex[ 0 ].TexHeight != DestImage2->Orig->Hard.Tex[ 0 ].TexHeight )
		return -1 ;

	// 描画を終わらせておく
	RenderVertexHardware() ;
	EndScene() ;

	// 传送
	if( GraphicsDevice_StretchRect( SrcImage2->Orig->Hard.Tex[ 0 ].ZBuffer, NULL, DestImage2->Orig->Hard.Tex[ 0 ].ZBuffer, NULL, D_D3DTEXF_NONE ) != D_D3D_OK )
	{
		DXST_ERRORLOG_ADD( _T( "Zバッファーイメージの転送に失敗しました\n" ) ) ;
		return -1 ;
	}

	// 正常終了
	return 0 ;
}

// グラフィックスデバイスのデバイスロスト発生時に指定のグラフィックハンドルを削除するかどうかを設定する( TRUE:デバイスロスト時に削除する  FALSE:デバイスロストが発生しても削除しない )
extern int NS_SetDeviceLostDeleteGraphFlag(	int GrHandle, int DeleteFlag )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
		return -1 ;

	Image2->DeviceLostDeleteFlag = DeleteFlag ? TRUE : FALSE ;

	return 0 ;
}

// グラフィックのサイズを得る
extern	int NS_GetGraphSize( int GrHandle, int *SizeXBuf, int *SizeYBuf )
{
	IMAGEDATA2 *Image2 ;
	SHADOWMAPDATA *ShadowMap ;

	switch( GrHandle )
	{
	case DX_SCREEN_BACK	 :
	case DX_SCREEN_FRONT :
		if( SizeXBuf ) *SizeXBuf = GRA2.MainScreenSizeX ;
		if( SizeYBuf ) *SizeYBuf = GRA2.MainScreenSizeY ;
		break ;

	default :
		// エラー判定
		if( !GRAPHCHK_ASYNC( GrHandle, Image2 ) )
		{
			if( SizeXBuf ) *SizeXBuf = Image2->Width ;
			if( SizeYBuf ) *SizeYBuf = Image2->Height ;
		}
		else
		if( !SHADOWMAPCHK( GrHandle, ShadowMap ) )
		{
			if( SizeXBuf ) *SizeXBuf = ShadowMap->BaseSizeX ;
			if( SizeYBuf ) *SizeYBuf = ShadowMap->BaseSizeY ;
		}
		else
		{
			return -1 ;
		}
		break ;
	}

	return 0 ;
}

// グラフィックに使用されているテクスチャーのサイズを得る
extern int NS_GetGraphTextureSize( int GrHandle, int *SizeXBuf, int *SizeYBuf )
{
	IMAGEDATA2 *Image2 = NULL ;
	SHADOWMAPDATA *ShadowMap = NULL ;

	// エラー判定
	if( GRAPHCHK(     GrHandle, Image2    ) &&
		SHADOWMAPCHK( GrHandle, ShadowMap ) )
		return -1 ;

	// シャドウマップかどうかで処理を分岐
	if( ShadowMap != NULL )
	{
		if( SizeXBuf ) *SizeXBuf = ShadowMap->BaseSizeX ;
		if( SizeYBuf ) *SizeYBuf = ShadowMap->BaseSizeY ;
	}
	else
	{
		// テクスチャかどうかで処理を分岐
		if( Image2->Orig->FormatDesc.TextureFlag )
		{
			if( SizeXBuf ) *SizeXBuf = Image2->Orig->Hard.Tex[ 0 ].TexWidth ;
			if( SizeYBuf ) *SizeYBuf = Image2->Orig->Hard.Tex[ 0 ].TexHeight ;
		}
		else
		{
			if( SizeXBuf ) *SizeXBuf = Image2->Width ;
			if( SizeYBuf ) *SizeYBuf = Image2->Height ;
		}
	}

	// 終了
	return 0 ;
}

// グラフィックが持つミップマップレベルの数を取得する
extern int NS_GetGraphMipmapCount( int GrHandle )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	// ハードウェアを使用していない場合は１
	if( Image2->Orig->FormatDesc.TextureFlag == FALSE )
		return 1 ;

	// ミップマップの数を返す
	return Image2->Orig->Hard.MipMapCount ;
}

// グラフィックハンドルが画像ファイルから読み込まれていた場合、その画像のファイルパスを取得する
extern int NS_GetGraphFilePath( int GrHandle, TCHAR *FilePathBuffer )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHK( GrHandle, Image2 ) )
		return -1 ;

	// 画像ファイルパスが無い場合はエラー
	if( Image2->ReadBase->FileName == NULL )
		return -1 ;

	// 画像ファイルパスをコピー
	if( FilePathBuffer != NULL )
	{
		_TSTRCPY( FilePathBuffer, Image2->ReadBase->FileName ) ;
	}

	// 正常終了の場合は文字列サイズを返す
	return _TSTRLEN( Image2->ReadBase->FileName ) ;
}

// グラフィックに使用される最大テクスチャサイズを取得する
extern int NS_GetMaxGraphTextureSize( int *SizeX, int *SizeY )
{
	if( SizeX != NULL ) *SizeX = GRH.DeviceCaps.MaxTextureWidth ;
	if( SizeY != NULL ) *SizeY = GRH.DeviceCaps.MaxTextureHeight ;

	// 終了
	return 0 ;
}

// 現在の画面の大きさとカラービット数を得る 
extern	int NS_GetScreenState( int *SizeX, int *SizeY, int *ColorBitDepth )
{
	if( GBASE.Emulation320x240Flag || GRH.FullScreenEmulation320x240 )
	{
		if( SizeX ) *SizeX = 320 ;
		if( SizeY ) *SizeY = 240 ;
	}
	else
	{
		if( SizeX ) *SizeX = GRA2.MainScreenSizeX ;
		if( SizeY ) *SizeY = GRA2.MainScreenSizeY ;
	}

	if( ColorBitDepth ) *ColorBitDepth = GRA2.MainScreenColorBitDepth ;

	// 終了
	return 0 ;
}

// 描画に３Ｄ機能を使うかフラグを取得
extern	int NS_GetUse3DFlag( void )
{
	// 終了
	return !GRA2.NotUseHardWare ;
}


// ２Ｄグラフィックサーフェス作成時にシステムメモリーを使用するかのフラグ取得
extern	int NS_GetUseVramFlag( void )
{
	return NS_GetUseSystemMemGraphCreateFlag() == TRUE ? FALSE : TRUE ;
}

// 同時に描画を行うことができる画面の数を取得する
extern int NS_GetMultiDrawScreenNum( void )
{
	return GRH.RenderTargetNum ;
}




// 辅助相关
// これから新たにグラフィックを作成する場合に使用するカラー情報を取得する
extern	int NS_GetCreateGraphColorData( COLORDATA * /*ColorData*/, IMAGEFORMATDESC * /*Format*/ )
{
	// 終了
	return 0 ;
}

// 画像作成用関係

// 画像の元データの情報を保存する
extern int SetGraphBaseInfo(
	int GrHandle,
	const TCHAR *FileName,
	const COLORDATA *BmpColorData,
	HBITMAP RgbBmp,
	HBITMAP AlphaBmp,
	const void *MemImage,
	int MemImageSize,
	const void *AlphaMemImage,
	int AlphaMemImageSize,
	const BASEIMAGE *Image,
	const BASEIMAGE *AlphaImage,
	int ReverseFlag,
	int UnionGrHandle,
	int ASyncThread
)
{
	SETGRAPHBASEINFO_GPARAM GParam ;

	InitSetGraphBaseInfoGParam( &GParam ) ;

	return SetGraphBaseInfo_UseGParam( &GParam, GrHandle, FileName, BmpColorData, RgbBmp, AlphaBmp, MemImage, MemImageSize,
										AlphaMemImage, AlphaMemImageSize, Image, AlphaImage, ReverseFlag, UnionGrHandle, ASyncThread ) ;
}

// SetGraphBaseInfo のグローバル変数にアクセスしないバージョン
extern int SetGraphBaseInfo_UseGParam(
	SETGRAPHBASEINFO_GPARAM *GParam,
	int GrHandle,
	const TCHAR *FileName,
	const COLORDATA *BmpColorData,
	HBITMAP RgbBmp,
	HBITMAP AlphaBmp,
	const void *MemImage,
	int MemImageSize,
	const void *AlphaMemImage,
	int AlphaMemImageSize,
	const BASEIMAGE *Image,
	const BASEIMAGE *AlphaImage,
	int ReverseFlag,
	int UnionGrHandle,
	int ASyncThread
)
{
	IMAGEDATA2 *Image2, *SrcImage2 = NULL ;
	TCHAR Path[ 1024 ] ;
	int Len ;
	BASEIMAGE BmpImage, AlphaBmpImage ;

	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( GrHandle, Image2 ) )
			return -1 ;
		GRAPHCHKFULL_ASYNC( UnionGrHandle, SrcImage2 ) ;
	}
	else
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return -1 ;
		GRAPHCHKFULL( UnionGrHandle, SrcImage2 ) ;
	}

	// 既にファイルパス用のメモリが確保されていたら解放
	if( Image2->ReadBase )
	{
		Image2->ReadBase->RefCount -- ;
		if( Image2->ReadBase->RefCount == 0 )
		{
			DXFREE( Image2->ReadBase ) ;
			Image2->ReadBase = NULL ;
		}
	}

	// ビットマップが有効な場合は BASEIMAGE 構造体を構築する
	if( RgbBmp )
	{
#ifdef __WINDOWS__
		BITMAP BitmapInfo ;
		BITMAP AlphaBitmapInfo ;

		GetObject( RgbBmp, sizeof( BITMAP ), ( void * )&BitmapInfo ) ;
		_MEMSET( &BmpImage, 0, sizeof( BASEIMAGE ) ) ;
		BmpImage.GraphData = BitmapInfo.bmBits ;
		BmpImage.Width = BitmapInfo.bmWidth ;
		BmpImage.Height = BitmapInfo.bmHeight ;
		BmpImage.Pitch = ( BmpImage.Pitch + 3 ) / 4 * 4 ;
		_MEMCPY( &BmpImage.ColorData, BmpColorData, sizeof( COLORDATA ) ) ; 
		Image = &BmpImage ;

		if( AlphaBmp )
		{
			GetObject( AlphaBmp, sizeof( BITMAP ), ( void * )&AlphaBitmapInfo ) ;
			_MEMSET( &AlphaBmpImage, 0, sizeof( BASEIMAGE ) ) ;
			AlphaBmpImage.GraphData = AlphaBitmapInfo.bmBits ;
			AlphaBmpImage.Width = AlphaBitmapInfo.bmWidth ;
			AlphaBmpImage.Height = AlphaBitmapInfo.bmHeight ;
			AlphaBmpImage.Pitch = ( AlphaBmpImage.Pitch + 3 ) / 4 * 4 ;
			_MEMCPY( &AlphaBmpImage.ColorData, BmpColorData, sizeof( COLORDATA ) ) ; 
			AlphaImage = &AlphaBmpImage ;
		}
#else // __WINDOWS__
		return -1 ;
#endif // __WINDOWS__
	}

	// 元データの情報が一切ないか、バックアップを拒否するフラグが立っていた場合はバックアップをしない
	if( GParam->NotGraphBaseDataBackupFlag || ( FileName == NULL && MemImage == NULL && Image == NULL && SrcImage2 == NULL ) )
	{
		Image2->ReadBase = NULL ;
	}
	else
	{
		// 共有ハンドルの指定がある場合は共有情報をセットする
		if( SrcImage2 != NULL )
		{
			// ファイル名情報のアドレスを貰う
			Image2->ReadBase = SrcImage2->ReadBase ;

			// 参照数を増やす
			if( SrcImage2->ReadBase )
			{
				SrcImage2->ReadBase->RefCount ++ ;
			}
		}
		else
		{
			// ファイル名が有効な場合はファイル名を保存
			if( FileName )
			{
				// フルパスを取得
				ConvertFullPathT_( FileName, Path ) ;

				// ファイル名保存用のメモリを確保
				Len = _TSTRLEN( Path ) ;
				Image2->ReadBase = ( IMAGEDATA_READBASE * )DXCALLOC( sizeof( IMAGEDATA_READBASE ) + ( Len + 1 ) * sizeof( TCHAR ) ) ;
				if( Image2->ReadBase == NULL )
				{
					DXST_ERRORLOG_ADD( _T( "転送する画像ファイルのファイル名を保存するメモリ領域の確保に失敗しました\n" ) ) ;
					return -1 ;
				}
				Image2->ReadBase->FileName = ( TCHAR * )( Image2->ReadBase + 1 ) ;

				// ファイルパスを保存
				_MEMCPY( Image2->ReadBase->FileName, Path, ( Len + 1 ) * sizeof( TCHAR ) ) ;
			}
			else
			// メモリイメージが有効な場合はメモリイメージを保存
			if( MemImage )
			{
				// メモリイメージ保存用のメモリを確保
				Image2->ReadBase = ( IMAGEDATA_READBASE * )DXALLOC( sizeof( IMAGEDATA_READBASE ) + MemImageSize + AlphaMemImageSize ) ;
				if( Image2->ReadBase == NULL )
				{
					DXST_ERRORLOG_ADD( _T( "転送する画像データを保存するメモリ領域の確保に失敗しました\n" ) ) ;
					return -1 ;
				}
				_MEMSET( Image2->ReadBase, 0, sizeof( IMAGEDATA_READBASE ) ) ;

				// メモリイメージを保存
				Image2->ReadBase->MemImage = Image2->ReadBase + 1 ;
				Image2->ReadBase->MemImageSize = MemImageSize ;
				_MEMCPY( Image2->ReadBase->MemImage, MemImage, MemImageSize ) ;

				if( AlphaMemImage )
				{
					Image2->ReadBase->AlphaMemImage = ( BYTE * )Image2->ReadBase->MemImage + MemImageSize ;
					Image2->ReadBase->AlphaMemImageSize = AlphaMemImageSize ;
					_MEMCPY( Image2->ReadBase->AlphaMemImage, AlphaMemImage, AlphaMemImageSize ) ;
				}
			}
			else
			// 基本イメージデータが有効な場合は基本イメージデータを保存
			if( Image )
			{
				int ImageSize, AlphaImageSize = 0 ;
				int AllocSize ;

				ImageSize =  NS_GetBaseImageGraphDataSize( Image ) ;
				AllocSize = ImageSize + sizeof( BASEIMAGE ) ;
				if( AlphaImage )
				{
					AlphaImageSize = NS_GetBaseImageGraphDataSize( AlphaImage ) ;
					AllocSize += AlphaImageSize + sizeof( BASEIMAGE ) ;
				}

				// 基本イメージ保存用のメモリを確保
				Image2->ReadBase = ( IMAGEDATA_READBASE * )DXALLOC( sizeof( IMAGEDATA_READBASE ) + AllocSize ) ;
				if( Image2->ReadBase == NULL )
				{
					DXST_ERRORLOG_ADD( _T( "転送する基本イメージを保存するメモリ領域の確保に失敗しました\n" ) ) ;
					return -1 ;
				}
				_MEMSET( Image2->ReadBase, 0, sizeof( IMAGEDATA_READBASE ) ) ;

				// 基本イメージをメモリに保存
				Image2->ReadBase->BaseImage = ( BASEIMAGE * )( Image2->ReadBase + 1 ) ;
				_MEMCPY( Image2->ReadBase->BaseImage, Image, sizeof( BASEIMAGE ) ) ;
				Image2->ReadBase->BaseImage->GraphData = Image2->ReadBase->BaseImage + 1 ;
				_MEMCPY( Image2->ReadBase->BaseImage->GraphData, Image->GraphData, ImageSize ) ;

				if( AlphaImage )
				{
					Image2->ReadBase->AlphaBaseImage = ( BASEIMAGE * )( ( BYTE * )Image2->ReadBase->BaseImage->GraphData + ImageSize ) ;
					_MEMCPY( Image2->ReadBase->AlphaBaseImage, AlphaImage, sizeof( BASEIMAGE ) ) ;
					Image2->ReadBase->AlphaBaseImage->GraphData = Image2->ReadBase->AlphaBaseImage + 1 ;
					_MEMCPY( Image2->ReadBase->AlphaBaseImage->GraphData, AlphaImage->GraphData, AlphaImageSize ) ;
				}
			}

			// 反転フラグを保存する
			Image2->ReadBase->ReverseFlag = ReverseFlag ;

			// 参照数を１にする
			Image2->ReadBase->RefCount = 1 ;
		}
	}

	// 終了
	return 0 ;
}

// SetGraphName のグローバル変数にアクセスしないバージョン
extern int SetGraphName_UseGParam( SETGRAPHBASEINFO_GPARAM *GParam, int GrHandle, const TCHAR *GraphName, int ReverseFlag, int UnionGrHandle, int ASyncThread )
{
	return SetGraphBaseInfo_UseGParam( GParam, GrHandle, GraphName, NULL, NULL, NULL, NULL, 0, NULL, 0, NULL, NULL, ReverseFlag, UnionGrHandle, ASyncThread ) ;
}

// 特定のファイルから画像を読み込んだ場合のファイルパスをセットする
extern int SetGraphName( int GrHandle, const TCHAR *GraphName, int ReverseFlag, int UnionGrHandle, int ASyncThread )
{
	return SetGraphBaseInfo( GrHandle, GraphName, NULL, NULL, NULL, NULL, 0, NULL, 0, NULL, NULL, ReverseFlag, UnionGrHandle, ASyncThread ) ;
}

// GraphImage データからサイズを割り出し、それに合ったグラフィックハンドルを作成する
extern int CreateDXGraph_UseGParam(
	SETUP_GRAPHHANDLE_GPARAM *GParam,
	int GrHandle,
	const BASEIMAGE *RgbImage,
	const BASEIMAGE *AlphaImage,
	int TextureFlag,
	int ASyncThread
)
{
	if( GRA2.InitializeFlag == FALSE ) return -1 ;

	if( ASyncThread == FALSE )
	{
		CheckActiveState() ;
	}

	// 二つのグラフィックのサイズが違った場合はエラー
	if( AlphaImage != NULL && ( RgbImage->Width != AlphaImage->Width || RgbImage->Height != AlphaImage->Height ) )
		return -1 ;

	// キューブマップテクスチャを作成するかどうかをセット
	GParam->CubeMapTextureCreateFlag = RgbImage->GraphDataCount == CUBEMAP_SURFACE_NUM ? TRUE : FALSE ;

	// ハンドルの初期化
	if( SetupGraphHandle_UseGParam(
			GParam,
			GrHandle,
			RgbImage->Width, RgbImage->Height, TextureFlag,
			RgbImage->ColorData.AlphaWidth != 0 || AlphaImage != NULL,
			RgbImage->ColorData.PixelByte == 1 && 
			RgbImage->ColorData.AlphaWidth == 0 &&
			AlphaImage == NULL,
			RgbImage->ColorData.Format,
			RgbImage->MipMapCount == 0 ? -1 : RgbImage->MipMapCount,
			ASyncThread ) == -1 )
		return -1 ;

	// 終了
	return 0 ;
}

/*
// GraphImage データに合ったサイズの分割グラフィックハンドルを作成する
extern int NS_CreateDXDivGraph( BASEIMAGE *RgbImage, BASEIMAGE *AlphaImage, int AllNum, int XNum, int YNum, int SizeX, int SizeY, int *HandleBuf, int TextureFlag )
{
	// 終了
	return 0 ;
}
*/

// グラフィックハンドルを作成しない DerivationGraph
extern int DerivationGraphBase( int GrHandle, int SrcX, int SrcY, int Width, int Height, int SrcGraphHandle, int ASyncThread )
{
	IMAGEDATA2 *Image2 ;

	if( GBASE.NotDrawFlag == TRUE ) return 0 ;

	// エラー判定
	if( ASyncThread )
	{
		if( GRAPHCHK_ASYNC( SrcGraphHandle, Image2 ) )
			return -1 ;
	}
	else
	{
		if( GRAPHCHK( SrcGraphHandle, Image2 ) )
			return -1 ;
	}

	// 補正
	if( SrcX < 0 || SrcY < 0 || SrcX >= Image2->Width || SrcY >= Image2->Height ) return -1 ;
	if( SrcX + Width  > Image2->Width  ) Width  = Image2->Width  - SrcX ;
	if( SrcY + Height > Image2->Height ) Height = Image2->Height - SrcY ;

	// 抜き出しグラフィックの初期化
	if( InitializeDerivationGraphHandle( GrHandle, SrcX, SrcY, Width, Height, SrcGraphHandle, ASyncThread ) == -1 )
		return -1 ;

	// 正常終了
	return 0 ;
}

// DerivationGraph のグローバル変数にアクセスしないバージョン
extern int DerivationGraph_UseGParam(
	int SrcX,
	int SrcY,
	int Width,
	int Height,
	int SrcGraphHandle,
	int ASyncThread
)
{
	int NewGraphHandle ;

	// 新たなグラフィックデータの追加
	NewGraphHandle = AddGraphHandle() ;
	if( NewGraphHandle == -1 ) return -1 ;

	if( DerivationGraphBase( NewGraphHandle, SrcX, SrcY, Width, Height, SrcGraphHandle, ASyncThread ) < 0 )
	{
		NS_DeleteGraph( NewGraphHandle ) ;
		return -1 ;
	}

	// 返回句柄
	return NewGraphHandle ;
}

// 指定のグラフィックの指定部分だけを抜き出して新たなグラフィックハンドルを作成する
extern int NS_DerivationGraph( int SrcX, int SrcY, int Width, int Height, int SrcGraphHandle )
{
	return DerivationGraph_UseGParam( SrcX, SrcY, Width, Height, SrcGraphHandle, FALSE ) ;
}





// 設定関係関数

// 簡略化ブレンド処理を行うか否かのフラグをセットする
extern	int		NS_SetBasicBlendFlag( int /*Flag*/ )
{
	// 終了
	return 0 ;
}

// 通常描画にプログラマブルシェーダーを使用するかどうかを設定する( TRUE:使用する( デフォルト )  FALSE:使用しない )
extern	int		NS_SetUseNormalDrawShader( int Flag )
{
	Flag = Flag ? FALSE : TRUE ;

	// フラグが同じ場合は何もしない
	if( Flag == GRH.NormalDraw_NotUseShader )
		return 0 ;

	// フラグを保存
	GRH.NormalDraw_NotUseShader = Flag ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 設定をリフレッシュ
	RefreshRenderStateHardware() ;

	// 終了
	return 0 ;
}

// ソフトウエアレンダリングモードを使用するかどうかをセットする
extern int NS_SetUseSoftwareRenderModeFlag( int Flag )
{
	return NS_SetScreenMemToVramFlag( Flag == TRUE ? FALSE : TRUE ) ;
}

// 画面データをＶＲＡＭに置くか、フラグ
extern	int		NS_SetScreenMemToVramFlag( int Flag )
{
	// 初期化前のみ使用可能
	if( DxSysData.DxLib_InitializeFlag == TRUE ) return -1 ;

	GRA2.NotUseHardWare = !Flag ;

	// 終了
	return 0 ;
}

// ３Ｄ機能を使うか、のフラグをセット
extern	int NS_SetUse3DFlag( int Flag )
{
	// 初期化前のみ有効
	if( DxSysData.DxLib_InitializeFlag == TRUE ) return -1 ;

	GRA2.NotUseHardWare = !Flag ;

	// 終了
	return 0 ;
}

// ３Ｄ機能を使わないフラグのセット
extern	int		NS_SetNotUse3DFlag( int Flag )
{
	// 初期化前のみ使用可能
	if( DxSysData.DxLib_InitializeFlag == TRUE ) return -1 ;

	GRA2.NotUseHardWare = Flag ;

	// 終了
	return 0 ;
}

// フルスクリーン時の画面のリフレッシュレートを変更する(Windows2000以降のみ有効)
extern	int		NS_SetDisplayRefreshRate( int /*RefreshRate*/ )
{
	// 終了
	return 0 ;
}

// DirectDraw や Direct3D の協調レベルをマルチスレッド対応にするかどうかをセットする
extern	int		NS_SetMultiThreadFlag( int Flag )
{
	if( GRH.InitializeFlag == TRUE )
		return -1 ;

	GRH.UseMultiThread = Flag ;

	// 終了
	return 0 ;
}

// 使用する DirectDraw デバイスのインデックスを設定する
extern int NS_SetUseDirectDrawDeviceIndex( int Index )
{
	// 値を保存する
	GRH.ValidAdapterNumber = TRUE ;
	GRH.UseAdapterNumber = Index ;

	// 終了
	return 0 ;
}







// メイン画面のサイズ値を変更する
extern void SetMainScreenSize( int SizeX, int SizeY )
{
	GRA2.MainScreenSizeX = SizeX ;
	GRA2.MainScreenSizeY = SizeY ;

	if( ( GBASE.Emulation320x240Flag || GRH.FullScreenEmulation320x240 ) && GRA2.MainScreenSizeX == 640 && GRA2.MainScreenSizeY == 480 )
	{
		GRA2.MainScreenSizeX_Result = 320 ;
		GRA2.MainScreenSizeY_Result = 240 ;
	}
	else
	{
		GRA2.MainScreenSizeX_Result = GRA2.MainScreenSizeX == 0 ? DEFAULT_SCREEN_SIZE_X : GRA2.MainScreenSizeX ;
		GRA2.MainScreenSizeY_Result = GRA2.MainScreenSizeY == 0 ? DEFAULT_SCREEN_SIZE_Y : GRA2.MainScreenSizeY ;
	}

	SetMathScreenSize( GRA2.MainScreenSizeX_Result, GRA2.MainScreenSizeY_Result ) ;
}

// 描画サイズを取得する
extern int NS_GetDrawScreenSize( int *XBuf, int *YBuf )
{
	if( XBuf ) *XBuf = GRA2.MainScreenSizeX_Result == 0 ? DEFAULT_SCREEN_SIZE_X : GRA2.MainScreenSizeX_Result ;
	if( YBuf ) *YBuf = GRA2.MainScreenSizeY_Result == 0 ? DEFAULT_SCREEN_SIZE_Y : GRA2.MainScreenSizeY_Result ; ;

	// 終了
	return 0 ;
}

// 使用色ビット数を返す
extern int NS_GetScreenBitDepth( void )
{
	// 終了
	return NS_GetColorBitDepth() ;
}

// 画面の色ビット深度を得る
extern int NS_GetColorBitDepth( void )
{
	// 終了
	return GRA2.MainScreenColorBitDepth == 0 ? DEFAULT_COLOR_BITDEPTH : GRA2.MainScreenColorBitDepth ;
}

// 画面モードが変更されているかどうかのフラグを取得する
extern	int						NS_GetChangeDisplayFlag( void )
{
#ifdef __WINDOWS__
	// 終了
	return NS_GetWindowModeFlag() == FALSE ;
#else // __WINDOWS__
	return FALSE ;
#endif // __WINDOWS__
}


// 画面グラフィックデータがシステムメモリに存在するかフラグの取得
extern	int						NS_GetScreenMemToSystemMemFlag( void )
{
	// 終了
	return GRA2.ValidHardWare == FALSE ;
}




// ビデオメモリの容量を得る
extern	int						NS_GetVideoMemorySize( int *AllSize, int *FreeSize )
{
	return OldGraphicsInterface_GetVideoMemorySize( AllSize, FreeSize ) ;
}


// 変更可能なディスプレイモードの数を取得する
extern int NS_GetDisplayModeNum( void )
{
	// ディスプレイモードのセットアップが行われていない場合はセットアップをする
	if( GRH.DisplayMode == NULL )
	{
		SetupDisplayModeData( &GRH.DisplayModeNum, &GRH.DisplayMode ) ;
	}

	return GRH.DisplayModeNum ;
}

// 変更可能なディスプレイモードの情報を取得する( ModeIndex は 0 ～ GetDisplayModeNum の戻り値-1 )
extern DISPLAYMODEDATA NS_GetDisplayMode( int ModeIndex )
{
	// ディスプレイモードのセットアップが行われていない場合はセットアップをする
	if( GRH.DisplayMode == NULL )
	{
		SetupDisplayModeData( &GRH.DisplayModeNum, &GRH.DisplayMode ) ;
	}

	if( GRH.DisplayModeNum <= ModeIndex || ModeIndex < 0 )
	{
		DISPLAYMODEDATA ErrorResult = { -1, -1, -1, -1 } ;
		return ErrorResult ;
	}

	return GRH.DisplayMode[ ModeIndex ] ;
}

// ディスプレーのカラーデータポインタを得る
extern	const COLORDATA *NS_GetDispColorData( void )
{
	if( GRA2.ValidHardWare )
	{
		return GetD3DFormatColorData( GRH.ScreenFormat ) ;
	}
	else
	{
		return GRS.MainBufferMemImg.Base->ColorDataP ;
	}
}

// 有効な Direct3D デバイスアダプタの数を取得する
extern int NS_GetDirect3DAdapterNum( void )
{
	int Result = -1 ;

	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE || DxLib_GetEndRequest() )
	{
		// Direct3D9.DLL の読み込み
		if( Graphics_LoadDLL() < 0 )
			return -1 ;

		// Direct3D9 の作成
		if( Graphics_Create() == 0 )
		{
			// アダプタ数の取得
			Result = Graphics_GetAdapterCount() ;

			// Direct3D9 の解放
			Graphics_Release() ;
		}

		// d3d9.dll の解放
		Graphics_FreeDLL() ;

		return Result ;
	}
	else
	{
		return Graphics_GetAdapterCount() ;
	}
}



// 调色板操作相关函数

// メモリ上に読み込んだ画像のパレットを取得する(フルカラー画像の場合は無効)
extern	int		NS_GetGraphPalette( int GrHandle, int ColorIndex, int *Red, int *Green, int *Blue )
{
	MEMIMG *MemImg ;
	int Color;

	// エラーチェック
	if( ColorIndex < 0 || ColorIndex > 255 ) return -1 ;
	PALETTEIMAGECHK( GrHandle, MemImg );
	
	// パレットを取得する
	switch( MemImg->Base->ColorType )
	{
	case 0: Color = ((WORD  *)MemImg->Base->Palette)[ ColorIndex ]; break;
	case 1: Color = ((DWORD *)MemImg->Base->Palette)[ ColorIndex ]; break;
	default : return -1 ;
	}
	NS_GetColor5( MemImg->Base->ColorDataP, Color, Red, Green, Blue ) ;
	
	// 終了
	return 0 ;
}

// メモリ上に読み込んだ画像の SetGraphPalette で変更する前のパレットを取得する
extern  int		NS_GetGraphOriginalPalette( int GrHandle, int ColorIndex, int *Red, int *Green, int *Blue )
{
	MEMIMG *MemImg ;
	int Color ;
	
	// エラーチェック
	if( ColorIndex < 0 || ColorIndex > 255 ) return -1 ;
	PALETTEIMAGECHK( GrHandle, MemImg );

	// パレットを取得する
	switch( MemImg->Base->ColorType )
	{
	case 0: Color = ((WORD  *)MemImg->Base->OriginalPalette)[ColorIndex]; break;
	case 1: Color = ((DWORD *)MemImg->Base->OriginalPalette)[ColorIndex]; break;
	default : return -1 ;
	}
	NS_GetColor5( MemImg->Base->ColorDataP, Color, Red, Green, Blue ) ;
	
	// 終了
	return 0 ;
}

// メモリ上に読み込んだ画像のパレットを変更する(フルカラー画像の場合は無効)
extern	int		NS_SetGraphPalette( int GrHandle, int ColorIndex, int Color )
{
	MEMIMG *MemImg ;
	int Red, Green, Blue ;
	COLORDATA *ColorData ;

	// エラーチェック
	if( ColorIndex < 0 || ColorIndex > 255 ) return -1 ;
	PALETTEIMAGECHK( GrHandle, MemImg );

	// 色コードをセットする
	NS_GetColor2( Color, &Red, &Green, &Blue ) ;
	ColorData = MemImg->Base->ColorDataP ;
	Color = ColorData->NoneMask +
				( ( ( BYTE )Red   >> ( 8 - ColorData->RedWidth   ) ) << ColorData->RedLoc   ) +
				( ( ( BYTE )Green >> ( 8 - ColorData->GreenWidth ) ) << ColorData->GreenLoc ) +
				( ( ( BYTE )Blue  >> ( 8 - ColorData->BlueWidth  ) ) << ColorData->BlueLoc  ) ;
	switch( MemImg->Base->ColorType )
	{
	case 0: ((WORD  *)MemImg->Base->Palette)[ColorIndex] = (WORD)Color;  break;
	case 1: ((DWORD *)MemImg->Base->Palette)[ColorIndex] = (DWORD)Color; break;
	}
	
	// 終了
	return 0 ;
}

// SetGraphPalette で変更したパレットを全て元に戻す
extern int NS_ResetGraphPalette( int GrHandle )
{
	MEMIMG *MemImg ;
	int Size;
	
	// エラーチェック
	PALETTEIMAGECHK( GrHandle, MemImg );

	// 元のパレットをコピーする
	switch( MemImg->Base->ColorType )
	{
	case 0 : Size = 1 ; break ;
	case 1 : Size = 2 ; break ;
	default : return -1 ;
	}
	_MEMCPY( MemImg->Base->Palette, MemImg->Base->OriginalPalette, MemImg->Base->ColorNum << Size ) ;
	
	// 終了
	return 0 ;
}


// 简易图像相关函数

// 指定座標の色を取得する
extern int NS_GetPixel( int x, int y )
{
	RECT SrcRect ;
	BASEIMAGE BufferImage ;
	COLORDATA *DestColorData ;
	IMAGEDATA2 *Image2 ;
	int Ret = -1 ;

	// 描画座標チェック
	if( x < 0 || y < 0 || x >= GBASE.DrawSizeX || y >= GBASE.DrawSizeY ) return -1 ;

	// ハードウエア機能を使用するかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// 使っている場合
		RenderVertexHardware() ;
		EndScene();

		// 描画先バッファをロック
		SrcRect.left   = x ;
		SrcRect.right  = x + 1 ;
		SrcRect.top    = y ;
		SrcRect.bottom = y + 1 ;
		if( LockDrawScreenBuffer( &SrcRect, &BufferImage, -1, -1, TRUE, 0 ) < 0 )
			return -1 ;

		DestColorData = GetD3DFormatColorData( GRH.ScreenFormat ) ;
		switch( BufferImage.ColorData.ColorBitDepth )
		{
		case 16 : Ret = NS_GetColor4( DestColorData, &BufferImage.ColorData, ( int )*( ( WORD  * )BufferImage.GraphData ) ) & ~DestColorData->NoneMask ; break ;
		case 32 : Ret = NS_GetColor4( DestColorData, &BufferImage.ColorData, ( int )*( ( DWORD * )BufferImage.GraphData ) ) & ~DestColorData->NoneMask ; break ;
		}

		// 描画先バッファをアンロック
		UnlockDrawScreenBuffer() ;
	}
	else
	{
		MEMIMG *Img ;

		// ハードウェアを使用しない場合

		// エラー判定
		if( GRAPHCHKFULL( GBASE.TargetScreen[ 0 ], Image2 ) )
			Image2 = NULL ;

		// 描画先によって処理を分岐
		if( Image2 )
		{
			Img = &Image2->Soft.MemImg ;
		}
		else
		{
			Img = &GRS.MainBufferMemImg ;
		}

		switch( GRA2.MainScreenColorBitDepth )
		{
		case 16 : Ret = *( (  WORD * )( ( char * )Img->UseImage + 2 * x + Img->Base->Pitch * y ) ) ; break ;
		case 32 : Ret = *( ( DWORD * )( ( char * )Img->UseImage + 4 * x + Img->Base->Pitch * y ) ) ; break ;
		}
	}

	// 終了
	return Ret ;
}

// 指定点から境界色があるところまで塗りつぶす
extern int NS_Paint( int x, int y, int FillColor, int BoundaryColor )
{
	IMAGEDATA2 *Image2 ;

	// エラー判定
	if( GRAPHCHKFULL( GBASE.TargetScreen[ 0 ], Image2 ) )
		Image2 = NULL ;

	// ハードウェアを使用しているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// ハードウエアの機能を使用している場合
		D_D3DFORMAT TargetFormat ;
		DX_DIRECT3DSURFACE9 *TargetSurface, *SMSurface ;
		int Width, Height ;
		MEMIMG MemImg ;

		if( GraphicsDevice_IsValid() == 0 ) return -1 ;

		// 描画を終了させておく
		RenderVertexHardware() ;
		EndScene() ;

		// 描画先によって処理を分岐
		if( Image2 )
		{
			// 描画先が描画可能サーフェスの場合
			TargetSurface = Image2->Orig->Hard.Tex[ 0 ].Surface[ GBASE.TargetScreenSurface[ 0 ] ] ;
			TargetFormat = GRH.TextureFormat[ Image2->Orig->ColorFormat ] ;
			Width = Image2->Orig->Hard.Tex[ 0 ].TexWidth ;
			Height = Image2->Orig->Hard.Tex[ 0 ].TexHeight ;
		}
		else
		{
			// 描画先がサブバックバッファ又はバックバッファの場合
			TargetSurface = GRH.SubBackBufferSurface ? GRH.SubBackBufferSurface : GRH.BackBufferSurface ; 
			TargetFormat = GRH.ScreenFormat ;
			Width = GRA2.MainScreenSizeX ;
			Height = GRA2.MainScreenSizeY ;
		}

		// フルスクリーンアンチエイリアスを使用しているかどうかで処理を分岐
		//if( GRH.FSAAMultiSampleType != D_D3DMULTISAMPLE_NONE )
		if( true )
		{
			BASEIMAGE ScreenImage ;
			int DrawMode ;
			int DrawBlendMode ;
			int DrawBlendParam ;
			RGBCOLOR DrawBright ;
			RECT DrawArea ;

			// 画面のイメージを取得
			NS_CreateXRGB8ColorBaseImage( GBASE.DrawSizeX, GBASE.DrawSizeY, &ScreenImage ) ;
			NS_GetDrawScreenBaseImage( 0, 0, GBASE.DrawSizeX, GBASE.DrawSizeY, &ScreenImage ) ;

			// Paint 処理用の MEMIMG をセットアップする
			_MEMSET( &MemImg, 0, sizeof( MEMIMG ) ) ;
			InitializeMemImg(
				&MemImg,
				GBASE.DrawSizeX,
				GBASE.DrawSizeY,
				ScreenImage.Pitch,
				0,
				1,
				FALSE, FALSE, FALSE, ScreenImage.GraphData ) ;

			// Paint 処理を行う
			PaintMemImg( &MemImg, x, y, FillColor, BoundaryColor ) ;

			// MEMIMG の後始末
			TerminateMemImg( &MemImg ) ;

			// 画面にペイント後の画像を描画
			DrawBlendMode = GBASE.BlendMode ;
			DrawBlendParam = GBASE.BlendParam ;
			DrawMode = GBASE.DrawMode ;
			DrawBright = GBASE.DrawBright ;
			DrawArea = GBASE.DrawArea ;

			NS_SetDrawBlendMode( DX_BLENDMODE_SRCCOLOR, 255 ) ;
			NS_SetDrawMode( DX_DRAWMODE_NEAREST ) ;
			NS_SetDrawBright( 255, 255, 255 ) ;
			NS_SetDrawArea( 0, 0, GBASE.DrawSizeX, GBASE.DrawSizeY ) ;

			NS_DrawBaseImage( 0, 0, &ScreenImage ) ;

			NS_SetDrawBlendMode( DrawBlendMode, DrawBlendParam ) ;
			NS_SetDrawMode( DrawMode ) ;
			NS_SetDrawBright( DrawBright.Red, DrawBright.Green, DrawBright.Blue ) ;
			NS_SetDrawArea( DrawArea.left, DrawArea.top, DrawArea.right, DrawArea.bottom ) ;

			NS_ReleaseBaseImage( &ScreenImage ) ;
		}
		else
		{
			D_D3DLOCKED_RECT LockRect ;
			COLORDATA *ColorData ;

			ColorData = GetD3DFormatColorData( TargetFormat ) ;

			// 描画先のコピーを取得するシステムメモリサーフェスを作成
			if( GraphicsDevice_CreateOffscreenPlainSurface(
					Width, Height, TargetFormat, D_D3DPOOL_SYSTEMMEM, &SMSurface, NULL ) != D_D3D_OK )
			{
				DXST_ERRORLOG_ADD( _T( "Paint 用システムメモリサーフェスの作成に失敗しました\n" ) ) ;
				return -1 ;
			}

			// システムメモリサーフェスに描画先の内容を転送する
			GraphicsDevice_GetRenderTargetData(
				TargetSurface, SMSurface ) ;

			// システムメモリサーフェスをロック
			GraphicsSurface_LockRect( SMSurface, &LockRect, NULL, D_D3DLOCK_READONLY ) ; 

			// Paint 処理用の MEMIMG をセットアップする
			_MEMSET( &MemImg, 0, sizeof( MEMIMG ) ) ;
			InitializeMemImg(
				&MemImg,
				GBASE.DrawSizeX,
				GBASE.DrawSizeY,
				LockRect.Pitch,
				0,
				ColorData->ColorBitDepth == 16 ? 0 : 1,
				FALSE, FALSE, FALSE, LockRect.pBits ) ;

			// Paint 処理を行う
			PaintMemImg( &MemImg, x, y, FillColor, BoundaryColor ) ;

			// MEMIMG の後始末
			TerminateMemImg( &MemImg ) ;

			// システムメモリサーフェスのロックを解除
			GraphicsSurface_UnlockRect( SMSurface ) ;

			// システムメモリサーフェスの内容を描画先に転送する
			GraphicsDevice_UpdateSurface(
				SMSurface,     NULL,
				TargetSurface, NULL ) ;

			// システムメモリサーフェスの解放
			Graphics_ObjectRelease( SMSurface ) ;
		}
	}
	else
	{
		MEMIMG *Img ;

		// ハードウエアの機能を使用していない場合

		if( Image2 )
		{
			Img = &Image2->Soft.MemImg ;
		}
		else
		{
			Img = &GRS.MainBufferMemImg ;
		}

		PaintMemImg( Img, x, y, FillColor, BoundaryColor ) ;
	}
	
	// 終了
	return 0 ;
}


// 等待相关函数

// 垂直同期信号を待つ
extern	int		NS_WaitVSync( int SyncNum )
{
	return GraphicsDevice_WaitVSync( SyncNum ) ;
}

// 缓慢操作相关函数

#if 0
#define LOGMAX		5000000
int LogNum;
short Log[LOGMAX];
int time ;
LONGLONG Time ;
#endif

// 裏画面と表画面を交換する
// 表画面が裏画面からのスケーリングの場合は、CopyRect はコピー先矩形 )
extern int ScreenFlipBase( RECT *CopyRect )
{
	static int EndFlag = FALSE ;

	GBASE.ScreenFlipFlag = TRUE ;

	// もしフラグがたっていたらなにもせず終了
	if( EndFlag )
		goto END ;

	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE || DxLib_GetEndRequest() )
		goto ERR ;

	// フルスクリーンマスク処理を行っている場合はマスク描画の結果を反映させる
	MASK_FULLSCREEN_MASKUPDATE

#if !defined( DX_NON_LOG ) && !defined( DX_NON_PRINTF_DX )
	// ログ出力を行う設定の場合のみログ出力を行う
	if( NS_GetLogDrawFlag() )
	{
		int BlendMode, BlendParam, RedBright, GreenBright, BlueBright ;
		RECT DrawRect ;

		BlendMode   = GBASE.BlendMode ;
		BlendParam  = GBASE.BlendParam ;
		DrawRect    = GBASE.DrawArea ;
		RedBright   = GBASE.DrawBright.Red ;
		GreenBright = GBASE.DrawBright.Green ;
		BlueBright  = GBASE.DrawBright.Blue ;

		NS_SetDrawArea( 0, 0, GRA2.MainScreenSizeX, GRA2.MainScreenSizeY ) ;

		// 描画モードをノーブレンドにセット
		NS_SetDrawBlendMode( DX_BLENDMODE_NOBLEND, 0 ) ;

		// 輝度を１００％にセット
		NS_SetDrawBright( 255,255,255 ) ;

		// フラグをたてる
		EndFlag = TRUE ;

		// ログ描画
		DrawLog() ;

		// フラグを倒す
		EndFlag = FALSE ;

		// 設定を元に戻す
		NS_SetDrawArea( DrawRect.left, DrawRect.top, DrawRect.right, DrawRect.bottom ) ; 
		NS_SetDrawBlendMode( BlendMode, BlendParam ) ;
		NS_SetDrawBright( RedBright, GreenBright, BlueBright ) ;
	}
#endif

	// 裏画面の内容を表画面に反映
	GraphicsDevice_Present( CopyRect ) ;


END:
	GBASE.ScreenFlipFlag = FALSE ;

	// 終了
	return 0 ;


ERR:
	GBASE.ScreenFlipFlag = FALSE ;

	// エラー終了
	return -1;
}

// 裏画面と表画面を交換する
extern int NS_ScreenFlip( void )
{
	return ScreenFlipBase( NULL ) ;
}

// 裏画面の内容を表画面に描画する
extern int NS_ScreenCopy( void )
{
	// サブバックバッファのセットアップ
	if( 
#ifdef __WINDOWS__
		NS_GetWindowModeFlag() == FALSE && 
#endif // __WINDOWS__
		GRA2.ValidHardWare == TRUE )
		SetupSubBackBuffer() ;

	// フリップ
	return ScreenFlipBase( NULL ) ;
}

#ifdef __WINDOWS__

// 裏画面の内容を指定のウインドウに転送する
extern int NS_BltBackScreenToWindow( HWND Window, int ClientX, int ClientY )
{
	RECT SrcRect, DestRect, WinRect ;

	GetClientRect( Window, &WinRect ) ;

	SrcRect.left   = 0 ;
	SrcRect.top    = 0 ;
	SrcRect.right  = GRA2.MainScreenSizeX ;
	SrcRect.bottom = GRA2.MainScreenSizeY ;

	DestRect.left   = WinRect.left + ClientX ;
	DestRect.top    = WinRect.top  + ClientY ;
	DestRect.right  = WinRect.left + ClientX + GRA2.MainScreenSizeX ;
	DestRect.bottom = WinRect.top  + ClientY + GRA2.MainScreenSizeY ;

	if( DestRect.left < WinRect.left )
	{
		SrcRect.left += WinRect.left - DestRect.left ;
		DestRect.left = WinRect.left ;
	}

	if( DestRect.top < WinRect.top )
	{
		SrcRect.top += WinRect.top - DestRect.top ;
		DestRect.top = WinRect.top ;
	}

	if( DestRect.right > WinRect.right )
	{
		SrcRect.right -= DestRect.right - WinRect.right ;
		DestRect.right = WinRect.right ;
	}

	if( DestRect.bottom > WinRect.bottom )
	{
		SrcRect.bottom -= DestRect.bottom - WinRect.bottom ;
		DestRect.bottom = WinRect.bottom ;
	}

	return NS_BltRectBackScreenToWindow( Window, SrcRect, DestRect ) ;
}

// 裏画面の指定の領域をウインドウのクライアント領域の指定の領域に転送する
extern int NS_BltRectBackScreenToWindow( HWND Window, RECT BackScreenRect, RECT WindowClientRect )
{
	// 初期化判定
	if( DxSysData.DxLib_InitializeFlag == FALSE || DxLib_GetEndRequest() ) return -1 ;

	// フルスクリーンモードでは使用できない
	if( NS_GetWindowModeFlag() == FALSE ) return -1 ;

	// 実行
	return GraphicsDevice_BltRectBackScreenToWindow( Window, BackScreenRect, WindowClientRect ) ;
}

#endif // __WINDOWS__

// 画面モードのセット
extern int NS_SetGraphMode( int ScreenSizeX, int ScreenSizeY, int ColorBitDepth, int RefreshRate )
{
	int Width, Height, CDepth, RRate ;

	// エラーチェック
	if( ScreenSizeX <= 0 || ScreenSizeY <= 0 ||
		( ColorBitDepth != 8 && ColorBitDepth != 16 && ColorBitDepth != 32 ) )
		return DX_CHANGESCREEN_RETURN ;

	// 初期化前の場合は設定値だけ保存する
	if( DxSysData.DxLib_InitializeFlag == FALSE )
	{
		SetMainScreenSize( ScreenSizeX, ScreenSizeY ) ;
		GRA2.MainScreenColorBitDepth = ColorBitDepth ;
		GRA2.MainScreenRefreshRate = RefreshRate ;
		SetMemImgDefaultColorType( ColorBitDepth == 32 ? 1 : 0 ) ;
		return 0 ;
	}

	// 元の値を取っておく
	Width	= GRA2.MainScreenSizeX ;
	Height	= GRA2.MainScreenSizeX ;
	CDepth	= GRA2.MainScreenColorBitDepth ;
	RRate	= GRA2.MainScreenRefreshRate ;

	// 画面モードを変更
	ChangeGraphMode( ScreenSizeX, ScreenSizeY, ColorBitDepth, FALSE, RefreshRate ) ;

	// 戻り値のセット
	if( ScreenSizeX		== GRA2.MainScreenSizeX &&
		ScreenSizeY		== GRA2.MainScreenSizeY 
#ifdef __WINDOWS__
		&&
		(
		  NS_GetWindowModeFlag() == FALSE ||
		  (
		    NS_GetWindowModeFlag() == TRUE &&
		    ColorBitDepth	== GRA2.MainScreenColorBitDepth &&
		    RefreshRate		== GRA2.MainScreenRefreshRate
		  )
		)
#endif // __WINDOWS__
	  )
	{
		return DX_CHANGESCREEN_OK ;
	}
	else
	{
		if( Width	== GRA2.MainScreenSizeX &&
			Height	== GRA2.MainScreenSizeY &&
			CDepth	== GRA2.MainScreenColorBitDepth &&
			RRate	== GRA2.MainScreenRefreshRate )
		{
			return DX_CHANGESCREEN_RETURN ;
		}
		else
		{
			if( GRA2.MainScreenSizeX == DEFAULT_SCREEN_SIZE_X && 
				GRA2.MainScreenSizeY == DEFAULT_SCREEN_SIZE_Y 
#ifdef __WINDOWS__
				&& 
				(
				  NS_GetWindowModeFlag() == FALSE ||
				  (
					NS_GetWindowModeFlag() == TRUE &&
				    GRA2.MainScreenColorBitDepth == DEFAULT_COLOR_BITDEPTH &&
				    GRA2.MainScreenRefreshRate   == 0
				  )
				)
#endif // __WINDOWS__
			  )
			{
				return DX_CHANGESCREEN_DEFAULT ;
			}
			else
			{
				return -1 ;
			}
		}
	}
}

// メイン画面のＺバッファの設定を変更する
extern int SetZBufferMode( int ZBufferSizeX, int ZBufferSizeY, int ZBufferBitDepth )
{
	HRESULT hr ;
	DX_DIRECT3DSURFACE9 *SetZBuffer ;
	int UseScreenZBuffer = FALSE ;
	int BitIndex ;

	// 値のチェックと保存
	if( ZBufferSizeX > 0 && ZBufferSizeY > 0 )
	{
		for( GRH.ZBufferSizeX = 1 ; GRH.ZBufferSizeX < ZBufferSizeX ; GRH.ZBufferSizeX <<= 1 ){}
		for( GRH.ZBufferSizeY = 1 ; GRH.ZBufferSizeY < ZBufferSizeY ; GRH.ZBufferSizeY <<= 1 ){}
		GRH.UserZBufferSizeSet = TRUE ;
	}
	if( ZBufferBitDepth > 0 )
	{
		if( ZBufferBitDepth != 16 && ZBufferBitDepth != 24 && ZBufferBitDepth != 32 )
		{
			return -1 ;
		}
		GRH.ZBufferBitDepth = ZBufferBitDepth ;
		GRH.UserZBufferBitDepthSet = TRUE ;
	}

	// 初期化前の場合は値だけ設定して終了
	if( GraphicsDevice_IsValid() == 0 )
		return 0 ;

	// 現在設定されているＺバッファを取得
	GraphicsDevice_GetDepthStencilSurface( &SetZBuffer ) ;

	// もし画面用Ｚバッファが使用されている場合は一旦外す
	if( SetZBuffer == GRH.ZBufferSurface )
	{
		GraphicsDevice_SetDepthStencilSurface( NULL ) ;
		UseScreenZBuffer = TRUE ;
	}
	Graphics_ObjectRelease( SetZBuffer ) ;
	SetZBuffer = NULL ;

	// Zバッファを開放
	if( GRH.ZBufferSurface )
	{
		Graphics_ObjectRelease( GRH.ZBufferSurface ) ;
		GRH.ZBufferSurface = NULL ;
	}

	// 新たなＺバッファの作成
	switch( GRH.ZBufferBitDepth )
	{
	default:
	case 16 : BitIndex = 0 ; break ;
	case 24 : BitIndex = 1 ; break ;
	case 32 : BitIndex = 2 ; break ;
	}
	hr = GraphicsDevice_CreateDepthStencilSurface( GRH.ZBufferSizeX, GRH.ZBufferSizeY, GRH.ZBufferFormat[ BitIndex ], GRH.FSAAMultiSampleType, GRH.FSAAMultiSampleQuality, TRUE, &GRH.ZBufferSurface, NULL ) ;
	if( FAILED( hr ) )
	{
		DXST_ERRORLOG_ADD( _T( "Ｚバッファの作成に失敗しました\n" ) ) ;
		return -1 ;
	}

	// もし画面用Ｚバッファが使用されている場合は再セット
	if( UseScreenZBuffer )
	{
		GraphicsDevice_SetDepthStencilSurface( GRH.ZBufferSurface ) ;

		// クリア
		GraphicsDevice_Clear( 0, NULL, D_D3DCLEAR_ZBUFFER, 0, 1.0f, 0 ) ;
	}

	// 正常終了
	return 0 ;
}

// 画面用のＺバッファのサイズを設定する
extern int NS_SetZBufferSize( int ZBufferSizeX, int ZBufferSizeY )
{
	return SetZBufferMode( ZBufferSizeX, ZBufferSizeY, -1 ) ;
}

// 画面用のＺバッファのビット深度を設定する( 16 or 24 or 32 )
extern int NS_SetZBufferBitDepth( int BitDepth )
{
	return SetZBufferMode( -1, -1, BitDepth ) ;
}

// 画面のフルスクリーンアンチエイリアスモードの設定をする
extern int NS_SetFullSceneAntiAliasingMode( int Samples, int Quality )
{
	// 設定できるのは初期化前のみ
	if( DxSysData.DxLib_InitializeFlag == TRUE )
		return 0 ;

	GRH.FSAAMultiSampleType = ( D_D3DMULTISAMPLE_TYPE )Samples ;
	GRH.FSAAMultiSampleQuality = Quality ;

	// 終了
	return 0 ;
}

// ScreenFlip 時に表画面全体に転送する裏画面の領域を設定する( DxLib_Init の前でのみ使用可能 )
extern int NS_SetGraphDisplayArea( int x1, int y1, int x2, int y2 )
{
	// 初期後の場合は何もせず終了
	if( DxSysData.DxLib_InitializeFlag == TRUE )
		return -1 ;

	// パラメータチェック
	if( x1 >= x2 || y1 >= y2 )
	{
		GRA2.ValidGraphDisplayArea = FALSE ;
		return -1 ;
	}

	// パラメータ保存
	GRA2.GraphDisplayArea.left = x1 ;
	GRA2.GraphDisplayArea.right = x2 ;
	GRA2.GraphDisplayArea.top = y1 ;
	GRA2.GraphDisplayArea.bottom = y2 ;

	GRA2.ValidGraphDisplayArea = TRUE ;

	// 終了
	return 0 ;
}

// 画面モード変更時( とウインドウモード変更時 )にグラフィックスシステムの設定やグラフィックハンドルをリセットするかどうかを設定する( TRUE:リセットする  FALSE:リセットしない )
extern int NS_SetChangeScreenModeGraphicsSystemResetFlag( int Flag )
{
	GRA2.ChangeScreenModeNotGraphicsSystemFlag = Flag ? FALSE : TRUE ;

	return 0 ;
}

// 指定の解像度が対応しているかどうかを調べる関数
static int CheckDisplaySetting( int ScreenSizeX, int ScreenSizeY, int ColorBitDepth )
{
	int Num, i ;
	DISPLAYMODEDATA Mode ;

	Num = NS_GetDisplayModeNum() ;
	for( i = 0 ; i < Num ; i ++ )
	{
		Mode = NS_GetDisplayMode( i ) ;
		if( Mode.Width == ScreenSizeX && Mode.Height == ScreenSizeY && Mode.ColorBitDepth == ColorBitDepth )
			return TRUE ;
	}

	return FALSE ;
}

// 画面モードの変更２
extern int ChangeGraphMode( int ScreenSizeX, int ScreenSizeY, int ColorBitDepth, int ChangeWindowFlag, int RefreshRate )
{
	int BackScSizeX, BackScSizeY, BackScColorBitDepth, BackRefreshRate ;
	int Ret = DX_CHANGESCREEN_OK ;
	int InitFlag ;
#ifndef DX_NON_FONT
	TCHAR FontName[ 128 ] ;
	int FontSize     = 0 ;
	int FontThick    = 0 ;
	int FontType     = 0 ;
	int FontCharSet  = 0 ;
	int FontEdgeSize = 0 ;
	int FontItalic   = 0 ;
	int FontSpace    = 0 ;
	int FontUse      = 0 ;
#endif // DX_NON_FONT
	int Result ;
	int i ;

	// ChangeGraphMode実行中フラグを立てる
	GRA2.ChangeGraphModeFlag = TRUE ;

	// 頂点を掃いておく
	RenderVertexHardware() ;

	// 既に初期化済みかどうかを取得しておく
	InitFlag = GRA2.InitializeFlag ;

#ifdef __WINDOWS__
	// フルスクリーンモードで 320x240 指定の場合はエミュレーションモードにする
	if( NS_GetWindowModeFlag() == FALSE && ScreenSizeX == 320 && ScreenSizeY == 240 )
	{
		GRH.FullScreenEmulation320x240 = TRUE ;
		ScreenSizeX = 640 ;
		ScreenSizeY = 480 ;
	}
	else
	{
		if( NS_GetWindowModeFlag() == TRUE &&
			ChangeWindowFlag == TRUE &&
			GRH.FullScreenEmulation320x240 == TRUE &&
			GRA2.MainScreenSizeX == 640 &&
			GRA2.MainScreenSizeY == 480 )
		{
			ScreenSizeX = 320 ;
			ScreenSizeY = 240 ;
		}

		if( NS_GetWindowModeFlag() == TRUE ||
			GRA2.MainScreenSizeX != 640 ||
			GRA2.MainScreenSizeY != 480 )
		{
			GRH.FullScreenEmulation320x240 = FALSE ;
		}
	}
#endif // __WINDOWS__

	// -1 だった部分は既存の値で代用
	if( ScreenSizeX		== -1 ) ScreenSizeX   = GRA2.MainScreenSizeX ;
	if( ScreenSizeY		== -1 ) ScreenSizeY   = GRA2.MainScreenSizeY ;
	if( ColorBitDepth	== -1 ) ColorBitDepth = GRA2.MainScreenColorBitDepth ;
	if( RefreshRate		== -1 ) RefreshRate   = GRA2.MainScreenRefreshRate ;

	// もし以前と画面モードが全く同じ場合は何もせず終了
	if( ScreenSizeX      == GRA2.MainScreenSizeX &&
		ScreenSizeY      == GRA2.MainScreenSizeY &&
		ColorBitDepth    == GRA2.MainScreenColorBitDepth &&
		ChangeWindowFlag == FALSE &&
		RefreshRate      == GRA2.MainScreenRefreshRate )
	{
		goto END ;
	}

	DXST_ERRORLOG_ADD( _T( "画面モード変更処理を開始します\n" ) ) ;
	DXST_ERRORLOG_TABADD ;

#ifndef DX_NON_FONT

	// 既に初期化されていたらフォントの情報をとっておく
	if( InitFlag && NS_CheckFontHandleValid( NS_GetDefaultFontHandle() ) )
	{
		NS_GetFontStateToHandle( FontName, &FontSize, &FontThick, DX_DEFAULT_FONT_HANDLE, &FontType, &FontCharSet, &FontEdgeSize, &FontItalic ) ;
		FontSpace = NS_GetFontSpaceToHandle( DX_DEFAULT_FONT_HANDLE ) ;
		FontUse = TRUE ;
	}

#endif // DX_NON_FONT

	// 既存の画面モードのパラメータをとっておく
	BackScSizeX			= GRA2.MainScreenSizeX ; 
	BackScSizeY			= GRA2.MainScreenSizeY ;
	BackScColorBitDepth	= GRA2.MainScreenColorBitDepth ;
	BackRefreshRate		= GRA2.MainScreenRefreshRate ;

	// ＤＸライブラリの初期化前は実行できない
	if( DxSysData.DxLib_RunInitializeFlag == FALSE && DxSysData.DxLib_InitializeFlag == FALSE )
		goto END ;

#ifdef __WINDOWS__
	// フルスクリーンモードで対応していない画面モードだった場合はここで終了
	if( NS_GetWindowModeFlag() == FALSE && CheckDisplaySetting( ScreenSizeX, ScreenSizeY, ColorBitDepth ) == FALSE )
		goto END ;
#endif // __WINDOWS__

	// 画面モード変更時にグラフィックスシステムをリセットするかどうかで処理を分岐
	if( GRA2.ChangeScreenModeNotGraphicsSystemFlag )
	{
		// リセットしない場合

		// 指定の画面モードに変更できるかどうかを調べる
#ifdef __WINDOWS__
		if( NS_GetWindowModeFlag() == FALSE )
		{
			// フルスクリーンの場合は指定の解像度が対応しているかどうかを調べる
			if( CheckDisplaySetting( ScreenSizeX, ScreenSizeY, ColorBitDepth ) == FALSE )
			{
				// 対応していなかったら画面モードは変更しない
				goto END ;
			}
		}
		else
		{
			int DesktopW, DesktopH ;

			// ウインドウモードの場合は指定の解像度がデスクトップのサイズを超えていないかどうかを調べる
			NS_GetDefaultState( &DesktopW, &DesktopH, NULL ) ;
			if( DesktopW < ScreenSizeX || DesktopH < ScreenSizeY )
				goto END ;
		}
#endif // __WINDOWS__

		// チェンジ
		RestoreOrChangeSetupGraphSystem( TRUE, ScreenSizeX, ScreenSizeY, ColorBitDepth, RefreshRate ) ;

#ifdef __WINDOWS__
		// ウインドウスタイルセット
		if( NS_GetWindowModeFlag() == TRUE /*|| GRA2.ValidHardWare == FALSE*/ )
		{
			SetWindowStyle() ;
		}
#endif // __WINDOWS__

		DXST_ERRORLOG_TABSUB ;
		DXST_ERRORLOG_ADD( _T( "画面モード変更処理は正常に終了しました\n" ) ) ;
	}
	else
	{
		// リセットする場合

		// グラフィクスシステムの終了
		if( GRA2.InitializeFlag )
		{
			TerminateGraphics2() ;
		}

		// 画面モードのセット
		SetMainScreenSize( ScreenSizeX, ScreenSizeY ) ;
		GRA2.MainScreenColorBitDepth = ColorBitDepth ;
		GRA2.MainScreenRefreshRate   = RefreshRate ;
		SetMemImgDefaultColorType( ColorBitDepth == 32 ? 1 : 0 ) ;

#ifndef DX_NON_FONT
		// デフォルトフォントの設定をセット
		if( FontUse == TRUE )
		{
			NS_SetDefaultFontState( FontName, FontSize, FontThick, FontType, FontCharSet, FontEdgeSize, FontItalic ) ;
			NS_SetFontSpace( FontSpace ) ;
		}
#endif // DX_NON_FONT

		// グラフィックシステムの再初期化
		Result = InitializeGraphics2() ;

		// 失敗した場合の処理
		if( Result == -1 )
		{
			// エラーが発生した場合で画面モードが 320x240 だった場合は
			// 擬似 320x240 モードで試す
			if( GRA2.MainScreenSizeX == 320 && GRA2.MainScreenSizeY == 240 )
			{
				SetMainScreenSize( 640, 480 ) ;
				NS_SetEmulation320x240( TRUE ) ;
				Result = InitializeGraphics2() ;
			}

			// エラーが発生した場合は元の画面モードに戻す
			if( Result == -1 )
			{
				SetMainScreenSize( BackScSizeX, BackScSizeY ) ;
				GRA2.MainScreenColorBitDepth = BackScColorBitDepth ;
				GRA2.MainScreenRefreshRate   = BackRefreshRate ;
				SetMemImgDefaultColorType( BackScColorBitDepth == 32 ? 1 : 0 ) ;
				if( InitializeGraphics2() == -1 )
				{
					// それでも駄目だった場合はＤＸライブラリのデフォルトの画面モードに変更
					SetMainScreenSize( DEFAULT_SCREEN_SIZE_X, DEFAULT_SCREEN_SIZE_Y ) ;
					GRA2.MainScreenColorBitDepth = DEFAULT_COLOR_BITDEPTH ;
					GRA2.MainScreenRefreshRate   = 0 ;
					SetMemImgDefaultColorType( 0 ) ;
					if( InitializeGraphics2() == -1 )
					{
						// それでも駄目だった場合は640x480 32bit を試す
						SetMainScreenSize( DEFAULT_SCREEN_SIZE_X, DEFAULT_SCREEN_SIZE_Y ) ;
						GRA2.MainScreenColorBitDepth = 32 ;
						GRA2.MainScreenRefreshRate   = 0 ;
						SetMemImgDefaultColorType( 0 ) ;
						if( InitializeGraphics2() == -1 )
						{
							Ret = -1 ;
							DxLib_Error( DXSTRING( _T( "予期せぬ画面モード変更不能現象が起きました2\n" ) ) ) ;
							goto END ;
						}
					}
				}
			}
		}

#ifdef __WINDOWS__
		// ウインドウスタイルセット
		if( NS_GetWindowModeFlag() == TRUE /*|| GRA2.ValidHardWare == FALSE*/ )
		{
			SetWindowStyle() ;
		}
#endif // __WINDOWS__

		DXST_ERRORLOG_TABSUB ;
		DXST_ERRORLOG_ADD( _T( "画面モード変更処理は正常に終了しました\n" ) ) ;

		// メッセージ処理
		NS_ProcessMessage() ;

		// 描画先の設定しなおし
		NS_SetRenderTargetToShader( 0, GBASE.TargetScreen[ 0 ], GBASE.TargetScreenSurface[ 0 ] ) ;
		for( i = 1 ; i < GRH.RenderTargetNum ; i ++ )
		{
			NS_SetRenderTargetToShader( i, -1 ) ;
		}
	}

#ifdef __WINDOWS__
	// ドラッグ＆ドロップの設定をし直す
	RefreshDragFileValidFlag() ;
#endif // __WINDOWS__

END:
	// ChangeGraphMode 実行中フラグを倒す
	GRA2.ChangeGraphModeFlag = FALSE ;

	// 終了
	return Ret ;
}

extern	int		SetD3DDialogBoxMode( int Flag )
{
	HRESULT hr ;

	if( GraphicsDevice_IsValid() == 0 ) return 0 ;
	EndScene() ;
	hr = GraphicsDevice_SetDialogBoxMode( Flag ) ;

	return 0 ;
}

#ifndef DX_NON_MODEL

// 指定のシェーダーをセットアップする( TRUE:成功  FALSE:失敗 )
extern int SetupShader( int VertexShaderIndex, int VertexShaderIndex_PL, int PixelShaderIndex, int PixelShaderIndex_PL )
{
	int ValidPL ;
	DX_DIRECT3DVERTEXSHADER9 **VS_PL ;
	void **VSAddress_PL ;
	DX_DIRECT3DPIXELSHADER9  **PS_PL ;
	void **PSAddress_PL ;
	DX_DIRECT3DVERTEXSHADER9 **VS ;
	void **VSAddress ;
	DX_DIRECT3DPIXELSHADER9  **PS ;
	void **PSAddress ;
	int PS_Type_PL ;
	int PS_ShadowMap_PL ;
	int PS_MultiTexBlendMode_PL ;
	int PS_ToonType_PL ;
	int PS_ToonSphereOP_PL ;
	int PS_ToonDiffuseBlendOP_PL ;
	int PS_ToonSpecularBlendOP_PL ;
	int PS_SpecularMap_PL ;
	int PS_BumpMap_PL ;
	int PS_LightIndex_PL ;
	int PS_Specular_PL ;
	int VS_Type ;
	int VS_ShaderModel ;
	int VS_ShadowMap ;
	int VS_MeshType ;
	int VS_BumpMap ;
	int VS_FogMode ;
	int VS_LightIndex ;
	int VS_Specular ;
	int PS_Type ;
	int PS_ShaderModel ;
	int PS_ShadowMap ;
	int PS_MultiTexBlendMode ;
	int PS_Toon ;
	int PS_ToonType ;
	int PS_ToonSphereOP ;
	int PS_ToonDiffuseBlendOP ;
	int PS_ToonSpecularBlendOP ;
	int PS_SpecularMap ;
	int PS_BumpMap ;
	int PS_LightIndex ;
	int PS_Specular ;
//	int Time = NS_GetNowCount() ;

	if( 0 )
//	if( Time % 1000 < 500 )
	{
		GRH.UseShader = FALSE ;
		GRH.ValidTexTempRegFlag = FALSE ;
		return FALSE ;
	}
/*	else
	{
		GRH.UseShader = TRUE ;
	}
*/

	// シェーダが使えない場合は失敗
	if( GRH.UseShader == FALSE )
		return FALSE ;

	if( VertexShaderIndex >= 0 )
	{
		VS_PL        = &( ( DX_DIRECT3DVERTEXSHADER9 ** )GRH.MV1_PixelLighting_VertexShader         )[ VertexShaderIndex_PL ] ;
		VSAddress_PL = &( ( void **                     )GRA2.MV1_PixelLighting_VertexShaderAddress )[ VertexShaderIndex_PL ] ;
	}

	if( PixelShaderIndex >= 0 )
	{
		PS_Type_PL        = PIXELLIGHTING_PIXELSHADER_GET_TYPE(        PixelShaderIndex_PL ) ;
		PS_ShadowMap_PL   = PIXELLIGHTING_PIXELSHADER_GET_SHADOWMAP(   PixelShaderIndex_PL ) ;
		PS_SpecularMap_PL = PIXELLIGHTING_PIXELSHADER_GET_SPECULARMAP( PixelShaderIndex_PL ) ;
		PS_BumpMap_PL     = PIXELLIGHTING_PIXELSHADER_GET_BUMPMAP(     PixelShaderIndex_PL ) ;
		PS_LightIndex_PL  = PIXELLIGHTING_PIXELSHADER_GET_LIGHTINDEX(  PixelShaderIndex_PL ) ;
		PS_Specular_PL    = PIXELLIGHTING_PIXELSHADER_GET_SPECULAR(    PixelShaderIndex_PL ) ;
		switch( PS_Type_PL )
		{
		case PIXELLIGHTING_PIXELSHADER_TYPE_TOON :
			PS_ToonType_PL            = PIXELLIGHTING_PIXELSHADER_GET_TOONTYPE(     PixelShaderIndex_PL ) ;
			PS_ToonSphereOP_PL        = PIXELLIGHTING_PIXELSHADER_GET_TOONSPHEREOP( PixelShaderIndex_PL ) ;
			PS_ToonDiffuseBlendOP_PL  = PIXELLIGHTING_PIXELSHADER_GET_TOONDIFBLDOP( PixelShaderIndex_PL ) ;
			PS_ToonSpecularBlendOP_PL = PIXELLIGHTING_PIXELSHADER_GET_TOONSPCBLDOP( PixelShaderIndex_PL ) ;

			PS_PL        = &GRH.MV1_PixelLighting_ToonPixelShader[ PS_ShadowMap_PL ][ PS_ToonType_PL ][ PS_ToonSphereOP_PL ][ PS_ToonDiffuseBlendOP_PL ][ PS_ToonSpecularBlendOP_PL ][ PS_SpecularMap_PL ][ PS_BumpMap_PL ][ PS_LightIndex_PL ][ PS_Specular_PL ] ;
			PSAddress_PL = &GRA2.MV1_PixelLighting_ToonPixelShaderAddress[ PS_ShadowMap_PL ][ PS_ToonType_PL ][ PS_ToonSphereOP_PL ][ PS_ToonDiffuseBlendOP_PL ][ PS_ToonSpecularBlendOP_PL ][ PS_SpecularMap_PL ][ PS_BumpMap_PL ][ PS_LightIndex_PL ][ PS_Specular_PL ] ;
			break ;

		case PIXELLIGHTING_PIXELSHADER_TYPE_NORMAL :
			PS_MultiTexBlendMode_PL = PIXELLIGHTING_PIXELSHADER_GET_MULTITEX( PixelShaderIndex_PL ) ;

			PS_PL        = &GRH.MV1_PixelLighting_PixelShader[ PS_ShadowMap_PL ][ PS_MultiTexBlendMode_PL ][ PS_SpecularMap_PL ][ PS_BumpMap_PL ][ PS_LightIndex_PL ][ PS_Specular_PL ] ;
			PSAddress_PL = &GRA2.MV1_PixelLighting_PixelShaderAddress[ PS_ShadowMap_PL ][ PS_MultiTexBlendMode_PL ][ PS_SpecularMap_PL ][ PS_BumpMap_PL ][ PS_LightIndex_PL ][ PS_Specular_PL ] ;
			break ;
		}
	}

	if( VertexShaderIndex >= 0 )
	{
		VS_Type     = VERTEXSHADER_GET_TYPE(        VertexShaderIndex ) ;
		VS_MeshType = VERTEXSHADER_GET_MESHTYPE(    VertexShaderIndex ) ;
		VS_FogMode  = VERTEXSHADER_GET_FOGMODE(     VertexShaderIndex ) ;
		switch( VS_Type )
		{
		case VERTEXSHADER_TYPE_NORMAL :
			VS_LightIndex  = VERTEXSHADER_GET_LIGHTINDEX(  VertexShaderIndex ) ;
			if( VS_LightIndex == 0 )
			{
				VS        = &GRH.MV1_NoLightingVertexShader[ VS_MeshType ][ VS_FogMode ] ;
				VSAddress = &GRA2.MV1_NoLightingVertexShaderAddress[ VS_MeshType ][ VS_FogMode ] ;
			}
			else
			{
				VS_ShaderModel = VERTEXSHADER_GET_SHADERMODEL( VertexShaderIndex ) ;
				VS_ShadowMap   = VERTEXSHADER_GET_SHADOWMAP(   VertexShaderIndex ) ;
				VS_BumpMap     = VERTEXSHADER_GET_BUMPMAP(     VertexShaderIndex ) ;
				VS_Specular    = VERTEXSHADER_GET_SPECULAR(    VertexShaderIndex ) ;

				if( GRH.ValidVertexShader_SM3 )
				{
					VS_ShaderModel = 1 ;
				}

				VS        = &GRH.MV1_LightingVertexShader[ VS_ShaderModel ][ VS_ShadowMap ][ VS_MeshType ][ VS_BumpMap ][ VS_FogMode ][ VS_LightIndex ][ VS_Specular ] ;
				VSAddress = &GRA2.MV1_LightingVertexShaderAddress[ VS_ShaderModel ][ VS_ShadowMap ][ VS_MeshType ][ VS_BumpMap ][ VS_FogMode ][ VS_LightIndex ][ VS_Specular ] ;
			}
			break ;

		case VERTEXSHADER_TYPE_DRAW_SHADOWMAP :
			VS        = &GRH.MV1_ShadowMapVertexShader[ VS_MeshType ] ;
			VSAddress = &GRA2.MV1_ShadowMapVertexShaderAddress[ VS_MeshType ] ;
			break ;

		case VERTEXSHADER_TYPE_TOON_OUTLINE :
			VS        = &GRH.MV1_ToonOutLineVertexShader[ VS_MeshType ][ VS_FogMode ] ;
			VSAddress = &GRA2.MV1_ToonOutLineVertexShaderAddress[ VS_MeshType ][ VS_FogMode ] ;
			break ;
		}
	}

	if( PixelShaderIndex >= 0 )
	{
		PS_Type        = PIXELSHADER_GET_TYPE(        PixelShaderIndex ) ;
		PS_ShaderModel = PIXELSHADER_GET_SHADERMODEL( PixelShaderIndex ) ;
		PS_ShadowMap   = PIXELSHADER_GET_SHADOWMAP(   PixelShaderIndex ) ;
		PS_SpecularMap = PIXELSHADER_GET_SPECULARMAP( PixelShaderIndex ) ;
		PS_BumpMap     = PIXELSHADER_GET_BUMPMAP(     PixelShaderIndex ) ;
		PS_LightIndex  = PIXELSHADER_GET_LIGHTINDEX(  PixelShaderIndex ) ;
		PS_Specular    = PIXELSHADER_GET_SPECULAR(    PixelShaderIndex ) ;

		if( GRH.ValidPixelShader_SM3 )
		{
			PS_ShaderModel = 1 ;
		}

		switch( PS_Type )
		{
		case PIXELSHADER_TYPE_NORMAL :
			PS_Toon = PIXELSHADER_GET_TOON( PixelShaderIndex ) ;
			if( PS_Toon )
			{
				PS_ToonType            = PIXELSHADER_GET_TOONTYPE(     PixelShaderIndex ) ;
				PS_ToonDiffuseBlendOP  = PIXELSHADER_GET_TOONDIFBLDOP( PixelShaderIndex ) ;
				if( PS_LightIndex == 0 )
				{
					PS        = &GRH.MV1_ToonNoLightingPixelShader[ PS_ToonType ][ PS_ToonDiffuseBlendOP ] ;
					PSAddress = &GRA2.MV1_ToonNoLightingPixelShaderAddress[ PS_ToonType ][ PS_ToonDiffuseBlendOP ] ;
				}
				else
				{
					PS_ToonSphereOP        = PIXELSHADER_GET_TOONSPHEREOP( PixelShaderIndex ) ;
					PS_ToonSpecularBlendOP = PIXELSHADER_GET_TOONSPCBLDOP( PixelShaderIndex ) ;

					PS        = &GRH.MV1_ToonLightingPixelShader[ PS_ShaderModel ][ PS_ShadowMap ][ PS_ToonType ][ PS_ToonSphereOP ][ PS_ToonDiffuseBlendOP ][ PS_ToonSpecularBlendOP ][ PS_SpecularMap ][ PS_BumpMap ][ PS_LightIndex ][ PS_Specular ] ;
					PSAddress = &GRA2.MV1_ToonLightingPixelShaderAddress[ PS_ShaderModel ][ PS_ShadowMap ][ PS_ToonType ][ PS_ToonSphereOP ][ PS_ToonDiffuseBlendOP ][ PS_ToonSpecularBlendOP ][ PS_SpecularMap ][ PS_BumpMap ][ PS_LightIndex ][ PS_Specular ] ;
				}
			}
			else
			{
				PS_MultiTexBlendMode = PIXELSHADER_GET_MULTITEX( PixelShaderIndex ) ;
				if( PS_LightIndex == 0 )
				{
					PS        = &GRH.MV1_NoLightingPixelShader[ PS_MultiTexBlendMode ] ;
					PSAddress = &GRA2.MV1_NoLightingPixelShaderAddress[ PS_MultiTexBlendMode ] ;
				}
				else
				{
					PS        = &GRH.MV1_LightingPixelShader[ PS_ShaderModel ][ PS_ShadowMap ][ PS_MultiTexBlendMode ][ PS_SpecularMap ][ PS_BumpMap ][ PS_LightIndex ][ PS_Specular ] ;
					PSAddress = &GRA2.MV1_LightingPixelShaderAddress[ PS_ShaderModel ][ PS_ShadowMap ][ PS_MultiTexBlendMode ][ PS_SpecularMap ][ PS_BumpMap ][ PS_LightIndex ][ PS_Specular ] ;
				}
			}
			break ;

		case PIXELSHADER_TYPE_DRAW_SHADOWMAP :
			PS_Toon = PIXELSHADER_GET_TOON( PixelShaderIndex ) ;
			if( PS_Toon )
			{
				PS_ToonType            = PIXELSHADER_GET_TOONTYPE(     PixelShaderIndex ) ;
				PS_ToonSphereOP        = PIXELSHADER_GET_TOONSPHEREOP( PixelShaderIndex ) ;
				PS_ToonDiffuseBlendOP  = PIXELSHADER_GET_TOONDIFBLDOP( PixelShaderIndex ) ;

				PS        = &GRH.MV1_ShadowMapToonPixelShader[ PS_ToonType ][ PS_ToonSphereOP ][ PS_ToonDiffuseBlendOP ] ;
				PSAddress = &GRA2.MV1_ShadowMapToonPixelShaderAddress[ PS_ToonType ][ PS_ToonSphereOP ][ PS_ToonDiffuseBlendOP ] ;
			}
			else
			{
				PS        = &GRH.MV1_ShadowMapPixelShader ;
				PSAddress = &GRA2.MV1_ShadowMapPixelShaderAddress ;
			}
			break ;

		case PIXELSHADER_TYPE_TOON_OUTLINE :
			PS        = &GRH.MV1_ToonOutLinePixelShader ;
			PSAddress = &GRA2.MV1_ToonOutLinePixelShaderAddress ;
			break ;
		}
	}

	ValidPL = 
		VertexShaderIndex >= 0 &&
		GRH.ValidVertexShader_SM3 &&
		VS_Type == VERTEXSHADER_TYPE_NORMAL &&
		VS_LightIndex != 0 &&
		*VSAddress_PL != NULL &&

		PixelShaderIndex >= 0 &&
		GRH.ValidPixelShader_SM3 &&
		PS_Type == PIXELSHADER_TYPE_NORMAL &&
		PS_LightIndex != 0 &&
		*PSAddress_PL != NULL
	;

//	void *Addr1 = *VSAddress_PL ;
//	void *Addr2 = *PSAddress_PL ;

	if( ( GRH.UseOnlyPixelLightingTypeCode || GRH.UsePixelLightingShader ) && ValidPL )
	{
SHADER_MODEL_3:
		if( VertexShaderIndex >= 0 )
		{
			// シェーダーがあるかどうかを調べる
			if( *VS_PL == NULL )
			{
				// シェーダーの作成を試みる
				if( GraphicsDevice_CreateVertexShader( ( DWORD * )*VSAddress_PL, VS_PL ) != D_D3D_OK )
					return FALSE ;
			}

			// バーテックスシェーダーのセットアップ
			if( GRH.SetVS != *VS_PL )
			{
				GRH.SetVS = *VS_PL ;
				GraphicsDevice_SetVertexShader( GRH.SetVS ) ;
				GRH.DrawPrepAlwaysFlag = TRUE ;
			}
		}

		if( PixelShaderIndex >= 0 )
		{
			// シェーダーがあるかどうかを調べる
			if( *PS_PL == NULL )
			{
				// シェーダーの作成を試みる
				if( GraphicsDevice_CreatePixelShader( ( DWORD * )*PSAddress_PL, PS_PL ) != D_D3D_OK )
					return FALSE ;
			}

			// ピクセルシェーダーのセットアップ
			if( GRH.SetPS != *PS_PL )
			{
				GRH.SetPS = *PS_PL ;
				GraphicsDevice_SetPixelShader( GRH.SetPS ) ;
				GRH.NormalPS = FALSE ;
				GRH.DrawPrepAlwaysFlag = TRUE ;
			}
		}
	}
	else
	{
		if( VertexShaderIndex >= 0 )
		{
			// シェーダーがあるかどうかを調べる
			if( *VS == NULL )
			{
				// シェーダーの作成を試みる
				if( *VSAddress == NULL ||
					GraphicsDevice_CreateVertexShader( ( DWORD * )*VSAddress, VS ) != D_D3D_OK )
				{
					if( ValidPL )
					{
						goto SHADER_MODEL_3 ;
					}
					return FALSE ;
				}
			}

			// バーテックスシェーダーのセットアップ
		#ifdef DXLIB_DEBUG
			GraphicsDevice_SetVertexShader( MV1Man.VS_Test ) ;
			GRH.SetVS = MV1Man.VS_Test ;

			if( GRH.SetVD != MV1Man.VertexDeclaration[ 1 ][ 0 ][ 1 ] )
			{
				GRH.SetVD = MV1Man.VertexDeclaration[ 1 ][ 0 ][ 1 ] ;
				GraphicsDevice_SetVertexDeclaration( GRH.SetVD ) ;
			}
		#else
			if( GRH.SetVS != *VS )
			{
				GRH.SetVS = *VS ;
				GraphicsDevice_SetVertexShader( GRH.SetVS ) ;
				GRH.DrawPrepAlwaysFlag = TRUE ;
			}
		#endif
		}

		if( PixelShaderIndex >= 0 )
		{
			// シェーダーがあるかどうかを調べる
			if( *PS == NULL )
			{
				// シェーダーの作成を試みる
				if( *PSAddress == NULL ||
					GraphicsDevice_CreatePixelShader( ( DWORD * )*PSAddress, PS ) != D_D3D_OK )
				{
					if( ValidPL )
					{
						goto SHADER_MODEL_3 ;
					}

					return FALSE ;
				}
			}

			// ピクセルシェーダーのセットアップ
		#ifdef DXLIB_DEBUG
			GraphicsDevice_SetPixelShader( MV1Man.PS_Test ) ;
			GRH.SetPS = MV1Man.PS_Test ;
		#else
			if( GRH.SetPS != *PS )
			{
				GRH.SetPS = *PS ;
				GraphicsDevice_SetPixelShader( GRH.SetPS ) ;
				GRH.NormalPS = FALSE ;
				GRH.DrawPrepAlwaysFlag = TRUE ;
			}
		#endif
		}
	}


	// 終了
	return TRUE ;
}

// 指定の頂点データ定義をセットアップ
extern	int		SetupVertexDeclaration( int BumpMap, int SkinMesh, int UVNum )
{
	if( GRH.SetVD != GRH.DefaultVertexDeclaration[ BumpMap ][ SkinMesh ][ UVNum ] )
	{
		GRH.SetVD = GRH.DefaultVertexDeclaration[ BumpMap ][ SkinMesh ][ UVNum ] ;
		GraphicsDevice_SetVertexDeclaration( GRH.SetVD ) ;
		GRH.SetFVF = 0 ;
	}

	// 終了
	return 0 ;
}

#endif // DX_NON_MODEL

// 指定の頂点シェーダーをデバイスにセットする
extern int SetDeviceVertexShaderToHandle( int ShaderHandle )
{
	SHADERHANDLEDATA *VertexShader ;

	// ハンドルチェック
	if( SHADERCHK( ShaderHandle, VertexShader ) )
		return -1 ;
	if( VertexShader->IsVertexShader == FALSE )
		return -1 ;

	// シェーダーのセット
	if( GRH.SetVS != VertexShader->VertexShader && GRH.InitializeFlag == FALSE )
	{
		GRH.SetVS = VertexShader->VertexShader ;
		GraphicsDevice_SetVertexShader( GRH.SetVS ) ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}

	// 正常終了
	return 0 ;
}

// 指定のピクセルシェーダーをデバイスにセットする
extern int SetDevicePixelShaderToHandle( int ShaderHandle )
{
	SHADERHANDLEDATA *PixelShader ;

	// ハンドルチェック
	if( SHADERCHK( ShaderHandle, PixelShader ) )
		return -1 ;
	if( PixelShader->IsVertexShader != FALSE )
		return -1 ;

	// シェーダーのセット
	if( GRH.SetPS != PixelShader->PixelShader && GRH.InitializeFlag == FALSE )
	{
		GRH.SetPS = PixelShader->PixelShader ;
		GraphicsDevice_SetPixelShader( GRH.SetPS ) ;
		GRH.NormalPS = FALSE ;
		GRH.DrawPrepAlwaysFlag = TRUE ;
	}

	// 正常終了
	return 0 ;
}


// (補助関数)メモリイメージを描画先になっているスクリーンに出力する、画像とスクリーンの大きさは同じでなければならない
extern	int		MemImgScreenOut( MEMIMG * /*MemImg*/ )
{
	// 終了
	return 0 ;
}

// 画面画像保存関数

#ifndef DX_NON_SAVEFUNCTION

// 現在描画対象になっている画面をＢＭＰ形式で保存する
extern int NS_SaveDrawScreenToBMP( int x1, int y1, int x2, int y2, const TCHAR *FileName )
{
	return NS_SaveDrawScreen( x1, y1, x2, y2, FileName, DX_IMAGESAVETYPE_BMP );
}

// 現在描画対象になっている画面をＪＰＥＧ形式で保存する Quality = 画質、値が大きいほど低圧縮高画質,0～100 
extern int NS_SaveDrawScreenToJPEG( int x1, int y1, int x2, int y2, const TCHAR *FileName, int Quality, int Sample2x1 )
{
	return NS_SaveDrawScreen( x1, y1, x2, y2, FileName, DX_IMAGESAVETYPE_JPEG, Quality, Sample2x1 );
}

// 現在描画対象になっている画面をＰＮＧ形式で保存する CompressionLevel = 圧縮率、値が大きいほど高圧縮率高負荷、０は無圧縮,0～9
extern int NS_SaveDrawScreenToPNG( int x1, int y1, int x2, int y2, const TCHAR *FileName, int CompressionLevel )
{
	return NS_SaveDrawScreen( x1, y1, x2, y2, FileName, DX_IMAGESAVETYPE_PNG, 80, CompressionLevel );
}

// Jpeg_Quality         = 0:低画質～100:高画質
// Png_CompressionLevel = 0:無圧縮～  9:最高圧縮
// 現在描画対象になっている画面を保存する
extern int NS_SaveDrawScreen( int x1, int y1, int x2, int y2, const TCHAR *FileName, int SaveType, int Jpeg_Quality, int Jpeg_Sample2x1, int Png_CompressionLevel )
{
	IMAGEDATA2 *Image2 ;
	BASEIMAGE BaseImage;
	DX_DIRECT3DSURFACE9 *TargetSurface, *SMSurface = NULL, *VMSurface ;
	D_D3DFORMAT TargetFormat ;
	D_D3DLOCKED_RECT LockRect ;
	int Width, Height ;

	// エラー判定
	if( GRAPHCHKFULL( GBASE.TargetScreen[ 0 ], Image2 ) )
		Image2 = NULL ;

	// ゼロ初期化
	_MEMSET( &BaseImage, 0, sizeof( BASEIMAGE ) ) ;

	// サイズが不正な場合は何もせずに終了
	if( x1 >= x2 || y1 >= y2 || x1 < 0 || y1 < 0 || x2 > GBASE.DrawSizeX || y2 > GBASE.DrawSizeY ) return -1 ;

	// サイズのセット
	BaseImage.Width = x2 - x1 ;
	BaseImage.Height = y2 - y1 ;
	BaseImage.MipMapCount = 0 ;
	BaseImage.GraphDataCount = 0 ;

	// ハードウェアを使用しているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// ハードウエアの機能を使用している場合

		if( GraphicsDevice_IsValid() == 0 ) return -1 ;

		// 描画を終了させておく
		RenderVertexHardware() ;
		EndScene() ;

		// 描画先によって処理を分岐
		if( Image2 )
		{
			// 描画先が描画可能サーフェスの場合
			TargetSurface = Image2->Orig->Hard.Tex[ 0 ].RenderTargetSurface ?
							Image2->Orig->Hard.Tex[ 0 ].RenderTargetSurface :
			Image2->Orig->Hard.Tex[ 0 ].Surface[ GBASE.TargetScreenSurface[ 0 ] ] ;
			TargetFormat = GRH.TextureFormat[ Image2->Orig->ColorFormat ] ;
			Width = Image2->Orig->Hard.Tex[ 0 ].TexWidth ;
			Height = Image2->Orig->Hard.Tex[ 0 ].TexHeight ;
		}
		else
		{
			// 描画先がサブバックバッファ又はバックバッファの場合
			TargetSurface = GRH.SubBackBufferSurface ? GRH.SubBackBufferSurface : GRH.BackBufferSurface ; 
			TargetFormat = GRH.ScreenFormat ;
			Width = GRA2.MainScreenSizeX ;
			Height = GRA2.MainScreenSizeY ;
		}
		BaseImage.ColorData = *GetD3DFormatColorData( TargetFormat ) ;

		// 描画先のコピーを取得するシステムメモリサーフェスを作成
		if( GraphicsDevice_CreateOffscreenPlainSurface(
				Width, Height, TargetFormat, D_D3DPOOL_SYSTEMMEM, &SMSurface, NULL ) != D_D3D_OK )
		{
			DXST_ERRORLOG_ADD( _T( "SaveDrawScreen 用システムメモリサーフェスの作成に失敗しました\n" ) ) ;
			return -1 ;
		}

		// システムメモリサーフェスに描画先の内容を転送する
		if( GraphicsDevice_GetRenderTargetData(	TargetSurface, SMSurface ) != D_D3D_OK )
		{
			// 直接システムメモリへの転送に失敗した場合はオフスクリーンサーフェスを介してシステムメモリサーフェスに転送する
			GraphicsDevice_CreateRenderTarget_ASync( Width, Height, TargetFormat, D_D3DMULTISAMPLE_NONE, 0, FALSE, &VMSurface, NULL, FALSE ) ;
			if( VMSurface != NULL )
			{
				GraphicsDevice_StretchRect( TargetSurface, NULL, VMSurface, NULL, D_D3DTEXF_NONE ) ;
				GraphicsDevice_GetRenderTargetData(	VMSurface, SMSurface ) ;
				Graphics_ObjectRelease( VMSurface ) ;
				VMSurface = NULL ;
			}
		}

		// システムメモリサーフェスをロック
		GraphicsSurface_LockRect( SMSurface, &LockRect, NULL, D_D3DLOCK_READONLY ) ; 

		// アドレスとピッチのセット
		BaseImage.GraphData = ( BYTE * )LockRect.pBits + LockRect.Pitch * y1 + x1 * BaseImage.ColorData.PixelByte ;
		BaseImage.Pitch = LockRect.Pitch ;
	}
	else
	{
		MEMIMG *Img ;

		// ハードウエアの機能を使用していない場合

		// 描画先によって処理を分岐
		if( Image2 )
		{
			Img = &Image2->Soft.MemImg ;
		}
		else
		{
			Img = &GRS.MainBufferMemImg ;
		}

		BaseImage.ColorData = *Img->Base->ColorDataP ;
		BaseImage.Pitch = Img->Base->Pitch ;
		BaseImage.GraphData = ( char * )Img->UseImage + Img->Base->Pitch * y1 + Img->Base->ColorDataP->PixelByte * x1 ;
	}

	// 保存形式によって処理を変更する
	switch( SaveType )
	{
	case DX_IMAGESAVETYPE_JPEG:
#ifndef DX_NON_JPEGREAD
		NS_SaveBaseImageToJpeg( FileName, &BaseImage, Jpeg_Quality, Jpeg_Sample2x1 );
#endif
		break;

	case DX_IMAGESAVETYPE_PNG:
#ifndef DX_NON_PNGREAD
		NS_SaveBaseImageToPng( FileName, &BaseImage, Png_CompressionLevel );
#endif
		break;

	case DX_IMAGESAVETYPE_BMP:	// Bitmap 
		NS_SaveBaseImageToBmp( FileName, &BaseImage ) ;
		break ;
	}

	// 後始末処理

	// ハードウエア機能を使用しているかどうかで処理を分岐
	if( GRA2.ValidHardWare )
	{
		// ハードウエアの機能を使用している場合

		// システムメモリサーフェスのロックを解除
		GraphicsSurface_UnlockRect( SMSurface ) ;

		// システムメモリサーフェスの解放
		Graphics_ObjectRelease( SMSurface ) ;
	}
	else
	{
		// ハードウエアの機能を使用していない場合
	}

	// 終了
	return 0 ;
}

#endif // DX_NON_SAVEFUNCTION

























// 設定関係设定相关

// 使用中のＤｉｒｅｃｔ３ＤＤｅｖｉｃｅ９オブジェクトを得る
extern	const DX_DIRECT3DDEVICE9* NS_GetUseDirect3DDevice9( void )
{
	return ( DX_DIRECT3DDEVICE9* )GraphicsDevice_GetObject() ;
}

// 使用中のバックバッファのDirect3DSurface9オブジェクトを取得する
extern const DX_DIRECT3DSURFACE9* NS_GetUseDirect3D9BackBufferSurface( void )
{
	return GRH.BackBufferSurface ;
}

// ＤＸライブラリのＤｉｒｅｃｔ３Ｄ設定をしなおす
extern int NS_RefreshDxLibDirect3DSetting( void )
{
	if( GraphicsDevice_IsValid() == 0 ) return -1 ;

	RefreshRenderStateHardware() ;

	// 初期化フラグを立てる
	GRH.InitializeFlag = TRUE ;

	SetDrawBlendModeHardware( GRH.BlendMode, GRH.AlphaTestValidFlag, GRH.AlphaChannelValidFlag ) ;
	DrawPreparation() ;

	// 初期化フラグを倒す
	GRH.InitializeFlag = FALSE ;

	// 終了
	return 0 ;
}


// 頂点バッファに溜まった頂点データを吐き出す
extern int NS_RenderVertex( void )
{
	return RenderVertexHardware() ;
}

// 必要ならグラフィックの分割を行うか、フラグのセット
extern	int		NS_SetUseDivGraphFlag( int Flag ) 
{
	GRH.NotUseDivFlag = !Flag ;

	// 終了
	return 0 ;
}

// 使用するテクスチャーの最大サイズをセット(0でデフォルト)
extern	int		NS_SetUseMaxTextureSize( int Size )
{
	int i ;

	if( Size == 0 )
	{
		GRH.UserMaxTextureSize = 0 ;
		return 0 ;
	}
	
	// 指定のサイズが収まる最小の２のｎ乗のサイズを求める
	for( i = MIN_TEXTURE_SIZE ; i < Size ; i <<= 1 ){}

	// 最大サイズより大きかったら補正
	if( Size > GRH.MaxTextureSize ) Size = GRH.MaxTextureSize ; 
	
	// 値をセット
	GRH.UserMaxTextureSize = i ;
	
	// 終了
	return 0 ;
}

// Direct3DDevice9->DrawIndexedPrimitive のラッピング関数
extern int D_DrawIndexedPrimitive( void *VertexBuffer9, DWORD VertexStride, DWORD FVFFlag, void *IndexBuffer9, int PrimitiveType, int BaseVertexIndex, DWORD MinIndex, DWORD NumVertices, DWORD StartIndex, DWORD PrimitiveCount )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	GraphicsDevice_SetStreamSource( 0, ( DX_DIRECT3DVERTEXBUFFER9 * )VertexBuffer9, 0, VertexStride ) ;
	GraphicsDevice_SetIndices( ( DX_DIRECT3DINDEXBUFFER9 * )IndexBuffer9 ) ;
	SETFVF( FVFFlag )
	GraphicsDevice_DrawIndexedPrimitive( ( D_D3DPRIMITIVETYPE )PrimitiveType, BaseVertexIndex, MinIndex, NumVertices, StartIndex, PrimitiveCount ) ;

	// 終了
	return 0 ;
}

// Direct3DDevice9->DrawIndexedPrimitiveUP のラッピング関数
extern int D_DrawIndexedPrimitiveUP( DWORD FVFFlag, int PrimitiveType, DWORD MinVertexIndex, DWORD NumVertexIndices, DWORD PrimitiveCount, void *pIndexData, D_D3DFORMAT IndexDataFormat, void *pVertexStreamZeroData, DWORD VertexStreamZeroStride )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	SETFVF( FVFFlag )
	GraphicsDevice_DrawIndexedPrimitiveUP( ( D_D3DPRIMITIVETYPE )PrimitiveType, MinVertexIndex, NumVertexIndices, PrimitiveCount, pIndexData, IndexDataFormat, pVertexStreamZeroData, VertexStreamZeroStride ) ;

	// 終了
	return 0 ;
}

// 基本データに設定されている行列をハードウエアに反映する
extern void ApplyLibMatrixToHardware()
{
	if( GBASE.MatchHardwareMatrix == TRUE ) return ;

	if( GBASE.MatchHardwareWorldMatrix == FALSE )
	{
		SetTransformToWorldHardware( &GBASE.WorldMatrix ) ;
		GBASE.MatchHardwareWorldMatrix = TRUE ;
	}

	if( GBASE.MatchHardwareViewMatrix == FALSE )
	{
		SetTransformToViewHardware( &GBASE.ViewMatrix ) ;
		GBASE.MatchHardwareViewMatrix = TRUE ;
	}

	if( GBASE.MatchHardwareProjectionMatrix == FALSE )
	{
		SetTransformToProjectionHardware( &GBASE.ProjectionMatrix ) ;
		GBASE.MatchHardwareProjectionMatrix = TRUE ;
	}

	GBASE.MatchHardwareMatrix = TRUE ;
}

// 基本データに設定されているフォグ情報をハードウエアに反映する
extern void ApplyLigFogToHardware( void )
{
	if( GRH.FogEnable != GBASE.FogEnable ) SetFogEnableHardware( GBASE.FogEnable ) ;
}

// 描画準備を行う( ParamFlag は DRAWPREP_TRANS 等 )
extern	void	_DrawPreparation( int GrHandle, int ParamFlag )
{
	IMAGEDATA2 *Image2 ;

	if( GrHandle == DX_NONE_GRAPH )
	{
		DRAWPREP_NOTEX( ParamFlag );
	}
	else
	{
		if( GRAPHCHK( GrHandle, Image2 ) )
			return;

		// テクスチャではなかったらエラー
		if( Image2->Orig->FormatDesc.TextureFlag == FALSE ) return ;

		// テクスチャをセット
		DRAWPREP_TEX( Image2->Orig, Image2->Hard.Draw[ 0 ].Tex->Texture, ParamFlag )
	}
}


// 以前の DrawModiGraph 関数のコードを使用するかどうかのフラグをセットする
extern int NS_SetUseOldDrawModiGraphCodeFlag( int Flag )
{
	GRH.UseOldDrawModiGraphCodeFlag = Flag ;
	
	// 終了
	return 0 ;
}

// 行列ブレンドの数を設定する( DrawGraph などを呼ぶ前に 0 を引数にして呼び出さないとその後の描画が正常に行われなくなります )
extern int D_SetVertexBlend( int WeightNum )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// バッファにたまった頂点を書き出す
	RenderVertexHardware() ;

	// 設定の変更
	GraphicsDevice_SetRenderState( D_D3DRS_VERTEXBLEND, ( D_D3DVERTEXBLENDFLAGS )WeightNum ) ;

	// 終了
	return 0 ;
}




// ライトを有効にするかどうかをセットする
extern int D_SetLightEnable( int Flag )
{
	return SetUseLightFlagHardware( Flag ) ;
}

// ライトのパラメータをセットする
extern int D_SetLightParam( int No, int EnableFlag, LIGHTPARAM *Param )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;

	// 設定の変更
	if( EnableFlag == TRUE )
	{
		SetLightHardware( No, ( LIGHT * )Param ) ;
	}
	SetLightEnableHardware( No, EnableFlag ) ;

	// 終了
	return 0 ;
}

// アンビエントライトを設定する
extern int D_SetAmbientLight( int r, int g, int b )
{
	return SetAmbientColorHardware( D_RGBA_MAKE( r, g, b, 0 ) ) ;
}

// スペキュラを使用するかどうかを設定する
extern int D_SetUseSpecular( int UseFlag )
{
	return SetUseSpecularHardware( UseFlag ) ;
}

// マテリアルパラメータをセットする
extern int D_SetMaterial( MATERIALPARAM *Param )
{
	return SetMaterialHardware( ( MATERIAL * )Param ) ;
}

// 頂点ディフューズカラーをマテリアルのディフューズカラーとして使用するかどうかを設定する
extern int D_SetMaterialUseVertexDiffuseColor( int UseFlag )
{
	return SetMaterialUseVertexDiffuseColorHardware( UseFlag ) ;
}

// 頂点スペキュラカラーをマテリアルのスペキュラカラーとして使用するかどうかを設定する
extern int D_SetMaterialUseVertexSpecularColor( int UseFlag )
{
	return SetMaterialUseVertexSpecularColorHardware( UseFlag ) ;
}

// シェードモードをセットする
extern int D_SetShadeMode( int ShadeMode )
{
	return SetShadeModeHardware( ShadeMode ) ;
}

// シェードモードを取得する
extern int D_GetShadeMode( void )
{
	return GRH.ShadeMode ;
}

// テクスチャフィルタリングモードを設定する
extern int D_SetSampleFilterMode( int TexStage, int SetTarget, DX_D3DTEXFILTER_TYPE FilterType )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;
	if( TexStage < 0 || TexStage >= USE_TEXTURESTAGE_NUM ) return 0 ;

	GRH.DrawMode = DX_DRAWMODE_OTHER ;
	GRH.DrawPrepAlwaysFlag = TRUE ;
	switch( SetTarget )
	{
	case DX_D3DSAMP_MAGFILTER :
		if( GRH.MagFilter[ TexStage ] != FilterType )
		{
			GraphicsDevice_SetSamplerState( TexStage, D_D3DSAMP_MAGFILTER, FilterType ) ;
			GRH.MagFilter[ TexStage ] = FilterType ;
		}
		break ;

	case DX_D3DSAMP_MINFILTER :
		if( GRH.MinFilter[ TexStage ] != FilterType )
		{
			GraphicsDevice_SetSamplerState( TexStage, D_D3DSAMP_MINFILTER, FilterType ) ;
			GRH.MinFilter[ TexStage ] = FilterType ;
		}
		break ;

	case DX_D3DSAMP_MIPFILTER :
		if( GRH.MipFilter[ TexStage ] != FilterType )
		{
			GraphicsDevice_SetSamplerState( TexStage, D_D3DSAMP_MIPFILTER, FilterType ) ;
			GRH.MipFilter[ TexStage ] = FilterType ;
		}
		break ;
	}

	// 終了
	return 0 ;
}

// 最大異方性をセットする
extern int D_SetMaxAnisotropy( int TexStage, int MaxAnisotropy )
{
	if( GraphicsDevice_IsValid() == 0 ) return 0 ;
	if( TexStage < 0 || TexStage >= USE_TEXTURESTAGE_NUM ) return 0 ;

	if( GRH.MaxAnisotropyDim[ TexStage ] != MaxAnisotropy )
	{
		GraphicsDevice_SetSamplerState( TexStage, D_D3DSAMP_MAXANISOTROPY, MaxAnisotropy ) ;
		GRH.MaxAnisotropyDim[ TexStage ] = MaxAnisotropy ;
	}
	GRH.MaxAnisotropy = -1 ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// テクスチャフィルタリングモードを取得する
extern	DX_D3DTEXFILTER_TYPE D_GetSampleFilterMode( int TexStage, int SetTarget )
{
	if( GraphicsDevice_IsValid() == 0 ) return ( DX_D3DTEXFILTER_TYPE )0 ;
	if( TexStage < 0 || TexStage >= USE_TEXTURESTAGE_NUM ) return ( DX_D3DTEXFILTER_TYPE )0 ;

	switch( SetTarget )
	{
	case DX_D3DSAMP_MAGFILTER : return GRH.MagFilter[ TexStage ] ;
	case DX_D3DSAMP_MINFILTER : return GRH.MinFilter[ TexStage ] ;
	case DX_D3DSAMP_MIPFILTER : return GRH.MipFilter[ TexStage ] ;
	}

	// 終了
	return ( DX_D3DTEXFILTER_TYPE )0 ;
}

// ポリゴンカリングの有効、無効をセットする
extern	int D_SetUseCullingFlag( int Flag )
{
	return SetUseCullingHardware( Flag ) ;
}

// 頂点カラーを使用するかどうかの設定をハードに反映する
extern	int D_SetupUseVertColor( void )
{
	// 頂点カラーをマテリアルのカラーとして使用するかどうかをセットする
	if( ( GBASE.Light.MaterialNotUseVertexDiffuseColor ? FALSE : TRUE ) != GRH.MaterialUseVertexDiffuseColor )
		SetMaterialUseVertexDiffuseColorHardware( GBASE.Light.MaterialNotUseVertexDiffuseColor ? FALSE : TRUE ) ;
	if( ( GBASE.Light.MaterialNotUseVertexSpecularColor ? FALSE : TRUE ) != GRH.MaterialUseVertexSpecularColor )
		SetMaterialUseVertexSpecularColorHardware( GBASE.Light.MaterialNotUseVertexSpecularColor ? FALSE : TRUE ) ;

	// 終了
	return 0 ;
}

// ３Ｄ描画用のＺバッファ設定をハードに反映させる
extern	int D_SetupZBuffer3D( void )
{
	if( GBASE.EnableZBufferFlag3D )
	{
		if( GRH.EnableZBufferFlag != GBASE.EnableZBufferFlag3D ) SetUseZBufferHardware(     GBASE.EnableZBufferFlag3D ) ;
		if( GRH.WriteZBufferFlag  != GBASE.WriteZBufferFlag3D  ) SetWriteZBufferHardware(   GBASE.WriteZBufferFlag3D  ) ;
		if( GRH.ZBufferCmpType    != GBASE.ZBufferCmpType3D    ) SetZBufferCmpTypeHardware( GBASE.ZBufferCmpType3D    ) ;
		if( GRH.ZBias             != GBASE.ZBias3D             ) SetZBiasHardware(          GBASE.ZBias3D             ) ;
	}
	else
	{
		if( GRH.EnableZBufferFlag ) SetUseZBufferHardware( FALSE ) ;
	}

	// 終了
	return 0 ;
}

// Ｚバッファを有効にするか、フラグをセットする
extern	int D_SetUseZBufferFlag( int Flag )
{
	return SetUseZBufferHardware( Flag ) ;
}

// Ｚバッファに書き込みを行うか、フラグをセットする
extern	int D_SetWriteZBufferFlag( int Flag )
{
	return SetWriteZBufferHardware( Flag ) ;
}

// 描画時のアルファテストのモードをセットする
extern	int D_SetDrawAlphaTest( int TestMode, int TestParam )
{
	return SetDrawAlphaTestHardware( TestMode, TestParam ) ;
}

// Ｚ値の比較モードをセットする
extern	int D_SetZBufferCmpType( int CmpType /* DX_CMP_NEVER 等 */ )
{
	return SetZBufferCmpTypeHardware( CmpType ) ;
}

// Ｚバイアスをセットする
extern	int	D_SetZBias( int Bias )
{
	return SetZBiasHardware( Bias ) ;
}

// フィルモードをセットする
extern	int	D_SetFillMode( int FillMode )
{
	return SetFillModeHardware( FillMode ) ;
}

// テクスチャアドレスモードを設定する
extern int D_SetTextureAddressMode( int Mode /* DX_TEXADDRESS_WRAP 等 */, int Stage )
{
	return SetTextureAddressHardware( Mode, Stage ) ;
}

// テクスチャアドレスモードを設定する
extern int D_SetTextureAddressModeUVW( int ModeU, int ModeV, int ModeW, int Stage )
{
	SetTextureAddressUHardware( ModeU, Stage ) ;
	SetTextureAddressVHardware( ModeV, Stage ) ;
	return SetTextureAddressWHardware( ModeW, Stage ) ;
}

// テクスチャ座標変換行列をセットする
extern int D_SetTextureAddressTransformMatrix( int Use, MATRIX *Matrix, int Stage )
{
	GRH.TextureTransformMatrixDirectChange = TRUE ;
	GRH.DrawPrepAlwaysFlag = TRUE ;
	return SetTextureAddressTransformMatrixHardware( Use, Matrix, Stage ) ;
}

// ローカル→ワールド行列を変更する
extern int D_SetTransformToWorld( MATRIX *Matrix )
{
	SetTransformToWorldHardware( Matrix ) ;
	GBASE.MatchHardwareWorldMatrix = FALSE ;
	GBASE.MatchHardwareMatrix = FALSE ;

	// 終了
	return 0 ;
}

// ビュー変換用行列をセットする
extern int D_SetTransformToView( MATRIX *Matrix )
{
	SetTransformToViewHardware( Matrix ) ;
	GBASE.MatchHardwareViewMatrix = FALSE ;
	GBASE.MatchHardwareMatrix = FALSE ;

	// 終了
	return 0 ;
}

// 投影変換用行列をセットする
extern int D_SetTransformToProjection( const MATRIX *Matrix )
{
	SetTransformToProjectionHardware( Matrix ) ;
	GBASE.MatchHardwareProjectionMatrix = FALSE ;
	GBASE.MatchHardwareMatrix = FALSE ;

	// 終了
	return 0 ;
}

// ユーザーのブレンドインフォを適応する
extern int D_SetUserBlendInfo( DIRECT3DBLENDINFO *BlendInfo, int TextureStageIsTextureAndTextureCoordOnlyFlag, int TextureIsGraphHandleFlag )
{
	RenderVertexHardware() ;

	RefreshBlendStateHardware( BlendInfo, TextureStageIsTextureAndTextureCoordOnlyFlag, TextureIsGraphHandleFlag ) ;
	GRH.ChangeBlendParamFlag = TRUE ;
	GRH.ChangeTextureFlag = TRUE ;
	GRH.DrawPrepAlwaysFlag = TRUE ;

	// 終了
	return 0 ;
}

// 各ステージが使用するテクスチャアドレスをステージ番号と同じにする
extern int D_ResetTextureCoord( void )
{
	int i ;
	DIRECT3DTEXTURESTAGEINFO *Stage ;

	Stage = GRH.BlendInfo.TextureStageInfo ;
	for( i = 0 ; i < USE_TEXTURESTAGE_NUM ; i ++, Stage ++ )
	{
		if( Stage->TextureCoordIndex != i || GRH.InitializeFlag )
		{
			GraphicsDevice_SetTextureStageState( i, D_D3DTSS_TEXCOORDINDEX, i ) ;
			Stage->TextureCoordIndex = i ;
		}
	}

	// 終了
	return 0 ;
}


// 其他辅助函数

// カラーデータを得る
extern const COLORDATA * NS_GetTexColorData( int AlphaCh, int AlphaTest, int ColorBitDepth, int DrawValid )
{
	IMAGEFORMATDESC Format ;
	
	Format.DrawValidFlag = ( unsigned char )DrawValid ;
	Format.AlphaChFlag = ( unsigned char )AlphaCh ;
	Format.AlphaTestFlag = ( unsigned char )AlphaTest ;
	Format.ColorBitDepth = ColorBitDepth == TEX_BITDEPTH_16 ? 16 : 32 ;
	Format.ChannelNum = 0 ;
	Format.ChannelBitDepth = 0 ;
	Format.FloatTypeFlag = FALSE ;
	Format.BaseFormat = DX_BASEIMAGE_FORMAT_NORMAL ;
	return NS_GetTexColorData( &Format ) ;
}

// フォーマットに基づいたカラーデータを得る
extern const COLORDATA * NS_GetTexColorData( const IMAGEFORMATDESC *Format )
{
	const COLORDATA * Result ;

	Result = NS_GetTexColorData( NS_GetTexFormatIndex( Format ) ) ;

	return Result ;
}

// 指定のフォーマットインデックスのカラーデータを得る
extern const COLORDATA * NS_GetTexColorData( int FormatIndex )
{
	static int Initialize = FALSE ;
	static COLORDATA ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_NUM ] ;

	// 値が範囲外だったらエラー
	if( FormatIndex >= DX_GRAPHICSIMAGE_FORMAT_3D_NUM ) return NULL ;

	// 最初に来たときに初期化
	if( Initialize == FALSE )
	{
		Initialize = TRUE ;

		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_RGB16                 ],  16, 0x0000f800, 0x000007e0, 0x0000001f, 0x00000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_RGB32                 ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB16           ],  16, 0x00000f00, 0x000000f0, 0x0000000f, 0x0000f000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHA_RGB32           ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB16       ],  16, 0x00007c00, 0x000003e0, 0x0000001f, 0x00008000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_ALPHATEST_RGB32       ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT1                  ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT2                  ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT3                  ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT4                  ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT5                  ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB16       ],  16, 0x0000f800, 0x000007e0, 0x0000001f, 0x00000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_RGB32       ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0x00000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ALPHA_RGB32 ],  32, 0x00ff0000, 0x0000ff00, 0x000000ff, 0xff000000 ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_I16    ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 4, 16, FALSE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F16    ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 4, 16, TRUE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ABGR_F16    ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 4, 32, TRUE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I8      ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 1,  8, FALSE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_I16     ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 1, 16, FALSE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F16     ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 1, 16, TRUE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_ONE_F32     ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 1, 32, TRUE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I8      ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 2,  8, FALSE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_I16     ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 2, 16, FALSE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F16     ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 2, 16, TRUE ) ;
		NS_CreateColorData( &ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DRAWVALID_TWO_F32     ],   0, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 2, 32, TRUE ) ;

		ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT1 ].Format = DX_BASEIMAGE_FORMAT_DXT1 ; ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT1 ].ColorBitDepth = 4 ;
		ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT2 ].Format = DX_BASEIMAGE_FORMAT_DXT2 ; ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT2 ].ColorBitDepth = 8 ;
		ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT3 ].Format = DX_BASEIMAGE_FORMAT_DXT3 ; ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT3 ].ColorBitDepth = 8 ;
		ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT4 ].Format = DX_BASEIMAGE_FORMAT_DXT4 ; ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT4 ].ColorBitDepth = 8 ;
		ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT5 ].Format = DX_BASEIMAGE_FORMAT_DXT5 ; ColorData[ DX_GRAPHICSIMAGE_FORMAT_3D_DXT5 ].ColorBitDepth = 8 ;
	}

	// カラーフォーマットを返す
	return &ColorData[ FormatIndex ] ;
}

#ifndef DX_NON_MOVIE

// MovieGraph相关函数
// 動画ファイルの再生
extern	int		NS_PlayMovie( const TCHAR *FileName, int ExRate, int PlayType )
{
	int MovieHandle ;
	LOADGRAPH_GPARAM GParam ;
	int x1, y1, x2, y2, w, h ;
	int DrawScreen ;
	int DrawScreenSurface ;
#ifndef DX_NON_INPUT
	int KeyOffFlag ;
	int State ;
#endif // DX_NON_INPUT
	int ScreenW, ScreenH ;

	InitLoadGraphGParam( &GParam ) ;

	MovieHandle = LoadBmpToGraph_UseGParam( &GParam, FALSE, -1, FileName, FALSE, FALSE, DX_MOVIESURFACE_NORMAL, FALSE ) ;
	if( MovieHandle < 0 )
		return -1 ;

#ifndef DX_NON_INPUT
	KeyOffFlag = NS_CheckHitKeyAll() ;
#endif // DX_NON_INPUT
	if( MovieHandle != -1 )
	{
		NS_PlayMovieToGraph( MovieHandle ) ;

		NS_GetDrawScreenSize( &ScreenW, &ScreenH ) ;
		NS_GetGraphSize( MovieHandle, &w, &h ) ;
		x1 = ( ScreenW - w * ExRate ) >> 1 ;
		y1 = ( ScreenH - h * ExRate ) >> 1 ;

		x2 = x1 + w * ExRate ;
		y2 = y1 + h * ExRate ;

		DrawScreen = GBASE.TargetScreen[ 0 ] ;
		DrawScreenSurface = GBASE.TargetScreenSurface[ 0 ] ;

		NS_SetDrawScreen( DX_SCREEN_BACK ) ;
		NS_ClearDrawScreen() ;

		while( NS_GetMovieStateToGraph( MovieHandle ) == 1 )
		{
//			NS_DrawBox( 0,0,32,32, GetColor( 255,255,255 ), TRUE ) ;
			NS_DrawExtendGraph( x1, y1, x2, y2, MovieHandle, FALSE ) ;

			NS_ScreenFlip() ;

#ifndef DX_NON_INPUT
			State = NS_CheckHitKeyAll() ;
			if( State == FALSE ) 
			{
				KeyOffFlag = FALSE ;
			}
#endif // DX_NON_INPUT

			if( ProcessMessage() != 0 
#ifndef DX_NON_INPUT
				|| ( PlayType == DX_MOVIEPLAYTYPE_BCANCEL && GetActiveFlag() && State && KeyOffFlag == FALSE )
#endif // DX_NON_INPUT
				) break ;
		}
		NS_DeleteGraph( MovieHandle ) ;

		NS_SetRenderTargetToShader( 0, DrawScreen, DrawScreenSurface ) ;
	}

	// 終了
	return 0;
}

// ムービーを開く
extern	int		NS_OpenMovieToGraph( const TCHAR *FileName, int FullColor )
{
	return NS_LoadBmpToGraph( FileName, FALSE, FALSE, FullColor ? DX_MOVIESURFACE_FULLCOLOR : DX_MOVIESURFACE_NORMAL );
}

// ムービーグラフィックに含まれるムービーの再生を開始する
extern 	int		NS_PlayMovieToGraph( int GraphHandle, int PlayType, int SysPlay  )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return  0 ;

	return PlayMovie_( Image2->MovieHandle, PlayType, SysPlay ) ;
}

// ムービーグラフィックに含まれるムービーの再生をストップする
extern 	int		NS_PauseMovieToGraph( int GraphHandle, int SysPause  )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return  0 ;

	return PauseMovie( Image2->MovieHandle, SysPause ) ;
}

// ムービーのフレームを進める、戻すことは出来ない( ムービーが停止状態で、且つ Ogg Theora のみ有効 )
extern	int		NS_AddMovieFrameToGraph( int GraphHandle, unsigned int FrameNum )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return 0 ;

	return AddMovieFrame( Image2->MovieHandle, FrameNum ) ;
}

// ムービーの再生位置を設定する(ミリ秒単位)
extern	int		NS_SeekMovieToGraph( int GraphHandle, int Time )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return 0 ;

	return SeekMovie( Image2->MovieHandle, Time ) ;
}

// ムービーの再生状態を得る
extern 	int		NS_GetMovieStateToGraph( int GraphHandle )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return 0 ;

	return GetMovieState( Image2->MovieHandle ) ;
}

// ムービーのボリュームをセットする(0～10000)
extern	int		NS_SetMovieVolumeToGraph( int Volume, int GraphHandle )	
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return 0 ;

	return SetMovieVolume( Volume, Image2->MovieHandle ) ;
}

// ムービーのボリュームをセットする(0～255)
extern	int		NS_ChangeMovieVolumeToGraph( int Volume, int GraphHandle )
{
	IMAGEDATA2 *Image2 ;
	int temp ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return 0 ;

	if( Volume < 0 )
	{
		Volume = 0 ;
	}
	else
	if( Volume > 255 )
	{
		Volume = 255 ;
	}

	if( Volume == 0 )
	{
		temp = 0 ;
	}
	else
	{
		if( DX_DirectSoundData.OldVolumeTypeFlag )
		{
			temp = _DTOL( _LOG10( Volume / 255.0f ) * 10.0 * 100.0 ) + 10000;
		}
		else
		{
			temp = _DTOL( _LOG10( Volume / 255.0f ) * 50.0 * 100.0 ) + 10000;
		}
	}

	return SetMovieVolume( temp, Image2->MovieHandle ) ;
}

// ムービーの基本イメージデータを取得する
extern	const BASEIMAGE *NS_GetMovieBaseImageToGraph( int GraphHandle, int *ImageUpdateFlag )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return NULL ;

	if( Image2->MovieHandle < 0 ) return  NULL ;

	return GetMovieBaseImage( Image2->MovieHandle, ImageUpdateFlag ) ;
}

// ムービーの総フレーム数を得る( Ogg Theora でのみ有効 )
extern	int		NS_GetMovieTotalFrameToGraph( int GraphHandle )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return 0 ;

	return GetMovieTotalFrame( Image2->MovieHandle ) ;
}

// ムービーの再生位置を取得する(ミリ秒単位)
extern	int		NS_TellMovieToGraph( int GraphHandle )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return  0 ;

	return TellMovie( Image2->MovieHandle ) ;
}

// ムービーの再生位置を取得する(フレーム単位)
extern	int		NS_TellMovieToGraphToFrame( int GraphHandle )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return  0 ;

	return TellMovieToFrame( Image2->MovieHandle ) ;
}

// ムービーの再生位置を設定する(フレーム単位)
extern	int		NS_SeekMovieToGraphToFrame( int GraphHandle, int Frame )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return  0 ;

	return SeekMovieToFrame( Image2->MovieHandle, Frame ) ;
}

// ムービーの１フレームあたりの時間を得る
extern	LONGLONG NS_GetOneFrameTimeMovieToGraph( int GraphHandle )
{
	IMAGEDATA2 *Image2 ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return  0 ;

	return GetOneFrameTimeMovie( Image2->MovieHandle ) ;
}

// ムービーのイメージを最後に更新した時間を得る(ミリ秒単位)
extern int NS_GetLastUpdateTimeMovieToGraph( int GraphHandle )
{
	IMAGEDATA2 *Image2 ;
	MOVIEGRAPH *Movie ;

	if( GRAPHCHK( GraphHandle, Image2 ) )
		return -1 ;

	if( Image2->MovieHandle < 0 ) return  -1 ;

	Movie = GetMovieData( Image2->MovieHandle ) ;
	if( Movie == NULL ) return -1 ;

	return Movie->RefreshTime ;
}


#endif


}


